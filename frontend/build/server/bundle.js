module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading wasm modules
/******/ 	var installedWasmModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/";
/******/
/******/ 	// object with all compiled WebAssembly.Modules
/******/ 	__webpack_require__.w = {};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../ssr3000/node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../lib/api/controllers/Error.js":
/*!***************************************!*\
  !*** ../lib/api/controllers/Error.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.handleError = function (res, error) {
  console.error('error', error);
  return res.status(500).send(error);
};

/***/ }),

/***/ "../lib/api/controllers/Pages.js":
/*!***************************************!*\
  !*** ../lib/api/controllers/Pages.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _objectWithoutProperties2 = __webpack_require__(/*! babel-runtime/helpers/objectWithoutProperties */ "babel-runtime/helpers/objectWithoutProperties");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _deepDiff = __webpack_require__(/*! deep-diff */ "../node_modules/deep-diff/index.es.js");

var _deepDiff2 = _interopRequireDefault(_deepDiff);

var _Error = __webpack_require__(/*! ./Error */ "../lib/api/controllers/Error.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Page = __webpack_require__(/*! ../models/Page */ "../lib/api/models/Page.js");
var Value = __webpack_require__(/*! ../models/Value */ "../lib/api/models/Value.js");
var normalizeFields = function normalizeFields(original, target) {
  return (0, _keys2.default)(original).reduce(function (acc, key) {
    var value = target[key];
    acc[key] = value;
    return acc;
  }, {});
};

var normalizeDocument = function normalizeDocument(original, target) {
  return (0, _keys2.default)(original).reduce(function (acc, key) {
    var originalValue = original[key];
    var value = target[key];
    if (originalValue instanceof Array) {
      value = target[key].map(function (val) {
        return normalizeFields(originalValue[0], val);
      }).reverse();
    } else if (originalValue instanceof Object) {
      value = normalizeFields(originalValue, value);
    }
    acc[key] = value;
    return acc;
  }, {});
};

exports.create = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(req, res) {
    var _req$body, values, rest, page, tValues, savedPage;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _req$body = req.body, values = _req$body.values, rest = (0, _objectWithoutProperties3.default)(_req$body, ['values']);

            console.log('??', req.body);
            page = new Page(rest);
            tValues = values.map(function (v) {
              return new Value(v);
            });

            page.values = tValues;
            _context.next = 8;
            return page.saveAll({ values: true });

          case 8:
            savedPage = _context.sent;
            return _context.abrupt('return', res.status(200).json({
              savedPage: savedPage
            }));

          case 12:
            _context.prev = 12;
            _context.t0 = _context['catch'](0);

            console.log(_context.t0);

          case 15:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined, [[0, 12]]);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.get = function (req, res) {
  var id = req.params.id;
  Page.get(id).getJoin({ values: true }).run().then(function (value) {
    res.json({
      value: value
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.patch = function (req, res) {
  var _req$body2 = req.body,
      values = _req$body2.values,
      rest = (0, _objectWithoutProperties3.default)(_req$body2, ['values']);

  Page.get(rest.id).getJoin({ values: true }).run().then(function (existingPage) {
    var actions = values.reduce(function (acc, value) {
      var exists = existingPage.values.findIndex(function (v) {
        return v.key === value.key;
      });
      if (exists > -1) {
        console.log(exists);
        acc.update.push(existingPage.values[exists].merge(value));
      } else {
        console.log(value.key);
        acc.create.push(new Value(value));
      }
      return acc;
    }, { update: [], create: [] });
    existingPage.values = [].concat(actions.update, actions.create);
    existingPage.saveAll({ values: true }).then(function (result) {
      res.json(result);
    }).catch(function (err) {
      return (0, _Error.handleError)(err, err);
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.getBy = function (req, res) {
  var _Page$filter;

  var by = req.params.by;
  var value = req.params.value;
  Page.filter((_Page$filter = {}, _Page$filter[by] = value, _Page$filter)).getJoin({ values: true }).run().then(function (page) {
    res.json({
      page: page
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.getAll = function (req, res) {
  Page.getJoin({
    values: true
  }).run().then(function (pages) {
    res.json({
      pages: pages
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.deleteAll = function (req, res) {
  Page.getJoin({ values: true }).run().then(function (pages) {
    var all = pages.map(function (page) {
      return page.deleteAll({ values: true });
    });
    _promise2.default.all(all).then(function () {
      res.json({
        msg: 'all pages deleted'
      });
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.purgeAll = function (req, res) {
  Page.run().then(function (pages) {
    var all = pages.map(function (page) {
      return page.purge();
    });
    _promise2.default.all(all).then(function () {
      res.json({
        msg: 'all pages purged'
      });
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

/***/ }),

/***/ "../lib/api/controllers/Templates.js":
/*!*******************************************!*\
  !*** ../lib/api/controllers/Templates.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _objectWithoutProperties2 = __webpack_require__(/*! babel-runtime/helpers/objectWithoutProperties */ "babel-runtime/helpers/objectWithoutProperties");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _deepDiff = __webpack_require__(/*! deep-diff */ "../node_modules/deep-diff/index.es.js");

var _deepDiff2 = _interopRequireDefault(_deepDiff);

var _Error = __webpack_require__(/*! ./Error */ "../lib/api/controllers/Error.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Template = __webpack_require__(/*! ../models/Template */ "../lib/api/models/Template.js");
var Value = __webpack_require__(/*! ../models/Value */ "../lib/api/models/Value.js");
var normalizeFields = function normalizeFields(original, target) {
  return (0, _keys2.default)(original).reduce(function (acc, key) {
    var value = target[key];
    acc[key] = value;
    return acc;
  }, {});
};

var normalizeDocument = function normalizeDocument(original, target) {
  return (0, _keys2.default)(original).reduce(function (acc, key) {
    var originalValue = original[key];
    var value = target[key];
    if (originalValue instanceof Array) {
      value = target[key].map(function (val) {
        return normalizeFields(originalValue[0], val);
      }).reverse();
    } else if (originalValue instanceof Object) {
      value = normalizeFields(originalValue, value);
    }
    acc[key] = value;
    return acc;
  }, {});
};

exports.create = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(req, res) {
    var _req$body, values, rest, exists, _template, normalizedTemplate, changes, template, tValues, savedTemplate;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _req$body = req.body, values = _req$body.values, rest = (0, _objectWithoutProperties3.default)(_req$body, ['values']);
            _context.prev = 1;
            _context.next = 4;
            return Template.filter({ name: rest.name }).run();

          case 4:
            exists = _context.sent;

            if (!exists.length) {
              _context.next = 12;
              break;
            }

            _context.next = 8;
            return Template.filter({ name: rest.name }).getJoin({ values: true });

          case 8:
            _template = _context.sent;
            normalizedTemplate = normalizeDocument(req.body, _template[0]);
            changes = (0, _deepDiff2.default)(normalizedTemplate, req.body) || false;
            return _context.abrupt('return', res.status(200).json({
              template: _template[0],
              hasChanges: !!changes.length,
              changes: changes || null
            }));

          case 12:
            template = new Template(rest);
            tValues = values.map(function (v) {
              return new Value(v);
            });

            template.values = tValues;
            _context.next = 17;
            return template.saveAll({ values: true });

          case 17:
            savedTemplate = _context.sent;
            return _context.abrupt('return', res.status(200).json({
              savedTemplate: savedTemplate
            }));

          case 21:
            _context.prev = 21;
            _context.t0 = _context['catch'](1);

            console.log(_context.t0);

          case 24:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined, [[1, 21]]);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.get = function (req, res) {
  var id = req.params.id;
  Template.get(id).getJoin({ values: true }).run().then(function (value) {
    res.json({
      value: value
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.patch = function (req, res) {
  var _req$body2 = req.body,
      values = _req$body2.values,
      rest = (0, _objectWithoutProperties3.default)(_req$body2, ['values']);

  Template.get(rest.id).getJoin({ values: true }).run().then(function (existingTemplate) {
    var actions = values.reduce(function (acc, value) {
      var exists = existingTemplate.values.findIndex(function (v) {
        return v.key === value.key;
      });
      if (exists > -1) {
        console.log(exists);
        acc.update.push(existingTemplate.values[exists].merge(value));
      } else {
        console.log(value.key);
        acc.create.push(new Value(value));
      }
      return acc;
    }, { update: [], create: [] });
    existingTemplate.values = [].concat(actions.update, actions.create);
    existingTemplate.saveAll({ values: true }).then(function (result) {
      res.json(result);
    }).catch(function (err) {
      return (0, _Error.handleError)(err, err);
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.getBy = function (req, res) {
  var _Template$filter;

  var by = req.params.by;
  var value = req.params.value;
  Template.filter((_Template$filter = {}, _Template$filter[by] = value, _Template$filter)).getJoin({ values: true }).run().then(function (page) {
    res.json({
      page: page
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.getAll = function (req, res) {
  Template.getJoin({
    values: true
  }).run().then(function (templates) {
    res.json({
      templates: templates
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.deleteAll = function (req, res) {
  Template.getJoin({ values: true }).run().then(function (templates) {
    var all = templates.map(function (template) {
      return template.deleteAll({ values: true });
    });
    _promise2.default.all(all).then(function () {
      res.json({
        msg: 'all templates deleted'
      });
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.purgeAll = function (req, res) {
  Template.run().then(function (templates) {
    var all = templates.map(function (template) {
      return template.purge();
    });
    _promise2.default.all(all).then(function () {
      res.json({
        msg: 'all templates purged'
      });
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

/***/ }),

/***/ "../lib/api/controllers/Values.js":
/*!****************************************!*\
  !*** ../lib/api/controllers/Values.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _Error = __webpack_require__(/*! ./Error */ "../lib/api/controllers/Error.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Value = __webpack_require__(/*! ../models/Value */ "../lib/api/models/Value.js");

exports.get = function (req, res) {
  var id = req.params.id;
  Value.get(id).getJoin({ template: true }).run().then(function (value) {
    res.json({
      value: value
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.getAll = function (req, res) {
  Value.getJoin({ template: true }).run().then(function (values) {
    res.json({
      values: values
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.deleteAll = function (req, res) {
  Value.run().then(function (values) {
    var all = values.map(function (value) {
      return value.delete();
    });
    _promise2.default.all(all).then(function () {
      res.json({
        msg: 'all values purged'
      });
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

exports.purgeAll = function (req, res) {
  Value.run().then(function (values) {
    var all = values.map(function (value) {
      return value.purge();
    });
    _promise2.default.all(all).then(function () {
      res.json({
        msg: 'all values purged'
      });
    });
  }).catch(function (err) {
    return (0, _Error.handleError)(res, err);
  });
};

/***/ }),

/***/ "../lib/api/db.js":
/*!************************!*\
  !*** ../lib/api/db.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! dotenv */ "../node_modules/dotenv/lib/main.js").config();

var thinky = __webpack_require__(/*! thinky */ "../node_modules/thinky/lib/thinky.js")({
  host: process.env.HOST,
  port: process.env.PORT,
  db: process.env.DB
});

module.exports = thinky;

/***/ }),

/***/ "../lib/api/models/Page.js":
/*!*********************************!*\
  !*** ../lib/api/models/Page.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _db = __webpack_require__(/*! ../db */ "../lib/api/db.js");

var _db2 = _interopRequireDefault(_db);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Page = _db2.default.createModel('Page', {
  id: _db2.default.type.string(),
  // title: thinky.type.string(),
  type: _db2.default.type.string(),
  title: _db2.default.type.virtual().default(function () {
    return this.values && this.values.find(function (v) {
      return v.key === 'title';
    }) ? this.values.find(function (v) {
      return v.key === 'title';
    }).value : 'No title found';
  })
}); // import cypher from 'cypher-query';


module.exports = Page;

// const Value = require('./Value');
// Page.hasMany(Value, 'values', 'id', 'pageId');

/***/ }),

/***/ "../lib/api/models/Template.js":
/*!*************************************!*\
  !*** ../lib/api/models/Template.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _db = __webpack_require__(/*! ../db */ "../lib/api/db.js");

var _db2 = _interopRequireDefault(_db);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Template = null; // import cypher from 'cypher-query';


if (!Template) {
  console.log('CREATING TEMPLATE', Template);
  Template = _db2.default.createModel('Template', {
    id: _db2.default.type.string(),
    name: _db2.default.type.string(),
    title: _db2.default.type.virtual().default(function () {
      return this.values ? this.values.find(function (v) {
        return v.key === 'title';
      }).value : 'No title found';
    })
  });
}

module.exports = Template;

var Value = __webpack_require__(/*! ./Value */ "../lib/api/models/Value.js");
Template.hasMany(Value, 'values', 'id', 'templateId');

/***/ }),

/***/ "../lib/api/models/Value.js":
/*!**********************************!*\
  !*** ../lib/api/models/Value.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _db = __webpack_require__(/*! ../db */ "../lib/api/db.js");

var _db2 = _interopRequireDefault(_db);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Value = null; // import cypher from 'cypher-query';

if (!Value) {
  console.log('CREATING Value', Value);
  Value = _db2.default.createModel('Value', {
    id: _db2.default.type.string(),
    templateId: _db2.default.type.string(),
    key: _db2.default.type.string(),
    value: _db2.default.type.string()
  });
}

module.exports = Value;

var Template = __webpack_require__(/*! ./Template */ "../lib/api/models/Template.js");
Value.belongsTo(Template, 'temlate', 'templateId', 'id');

/***/ }),

/***/ "../lib/index.js":
/*!***********************!*\
  !*** ../lib/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _express = __webpack_require__(/*! express */ "express");

var _express2 = _interopRequireDefault(_express);

var _bodyParser = __webpack_require__(/*! body-parser */ "body-parser");

var _bodyParser2 = _interopRequireDefault(_bodyParser);

var _cors = __webpack_require__(/*! cors */ "../node_modules/cors/lib/index.js");

var _cors2 = _interopRequireDefault(_cors);

var _Values = __webpack_require__(/*! ./api/controllers/Values */ "../lib/api/controllers/Values.js");

var _Values2 = _interopRequireDefault(_Values);

var _Pages = __webpack_require__(/*! ./api/controllers/Pages */ "../lib/api/controllers/Pages.js");

var _Pages2 = _interopRequireDefault(_Pages);

var _Templates = __webpack_require__(/*! ./api/controllers/Templates */ "../lib/api/controllers/Templates.js");

var _Templates2 = _interopRequireDefault(_Templates);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = new _express.Router();
// import testPage from './sample-data/draft-js-sample';


router.use((0, _cors2.default)());
// parse application/x-www-form-urlencoded
router.use(_bodyParser2.default.urlencoded({ extended: false }));
// parse application/json
router.use(_bodyParser2.default.json());

/*
 * BLOCKS
 */

router.route('/api/values').get(_Values2.default.getAll);
router.route('/api/values/:id').delete(_Values2.default.get);
router.route('/api/values').delete(_Values2.default.deleteAll);
router.route('/api/values/purge').delete(_Values2.default.purgeAll);

/*
 * Templates
 */

router.route('/api/templates').get(_Templates2.default.getAll);
router.route('/api/templates/:id').delete(_Templates2.default.get);
router.route('/api/templates/:by/:value').get(_Templates2.default.getBy);
router.route('/api/templates').post(_Templates2.default.create);
router.route('/api/templates').patch(_Templates2.default.patch);
router.route('/api/templates').delete(_Templates2.default.deleteAll);
router.route('/api/templates/purge').delete(_Templates2.default.purgeAll);

router.route('/api/pages').get(_Pages2.default.getAll);
router.route('/api/pages/:id').delete(_Pages2.default.get);
router.route('/api/pages/:by/:value').get(_Pages2.default.getBy);
router.route('/api/pages').post(_Pages2.default.create);
router.route('/api/pages').patch(_Pages2.default.patch);
router.route('/api/pages').delete(_Pages2.default.deleteAll);
router.route('/api/pages/purge').delete(_Pages2.default.purgeAll);

// router.route('*').get(routes.index);

// Start server
// app.listen('3000', () => {
//     // console.log('Express server listening on port %d in %s mode',
//     //     config.expressPort, app.settings.env);
// });

// const exitHandler = () => {
//   console.log('closing driver on programm exit');
//   process.exit(0);
// };

// process.on('SIGINT', () => { process.exit(0); });
// process.on('exit', exitHandler);

// process.once('SIGUSR2', () => {
//   console.log('[nodemon] cleanup');
// });
// 

exports.default = function () {
  return router;
};

/***/ }),

/***/ "../node_modules/cors/lib/index.js":
/*!*****************************************!*\
  !*** ../node_modules/cors/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function () {

  'use strict';

  var assign = __webpack_require__(/*! object-assign */ "object-assign");
  var vary = __webpack_require__(/*! vary */ "vary");

  var defaults = {
      origin: '*',
      methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
      preflightContinue: false,
      optionsSuccessStatus: 204
    };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
      headers = [],
      isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin);
      // reflect origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;
    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }
    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }
    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }
    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }
    return null;
  }

  function configureMaxAge(options) {
    var maxAge = options.maxAge && options.maxAge.toString();
    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }
    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureMethods(options, req));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);

      if (options.preflightContinue ) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus || defaults.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;
    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function (req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function (origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }

  // can pass either an options hash, an options delegate, or nothing
  module.exports = middlewareWrapper;

}());


/***/ }),

/***/ "../node_modules/deep-diff/index.es.js":
/*!*********************************************!*\
  !*** ../node_modules/deep-diff/index.es.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

var $scope, conflict, conflictResolution = [];
if (typeof global === 'object' && global) {
  $scope = global;
} else if (typeof window !== 'undefined') {
  $scope = window;
} else {
  $scope = {};
}
conflict = $scope.DeepDiff;
if (conflict) {
  conflictResolution.push(
    function() {
      if ('undefined' !== typeof conflict && $scope.DeepDiff === accumulateDiff) {
        $scope.DeepDiff = conflict;
        conflict = undefined;
      }
    });
}

// nodejs compatible on server side and in the browser.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}

function Diff(kind, path) {
  Object.defineProperty(this, 'kind', {
    value: kind,
    enumerable: true
  });
  if (path && path.length) {
    Object.defineProperty(this, 'path', {
      value: path,
      enumerable: true
    });
  }
}

function DiffEdit(path, origin, value) {
  DiffEdit.super_.call(this, 'E', path);
  Object.defineProperty(this, 'lhs', {
    value: origin,
    enumerable: true
  });
  Object.defineProperty(this, 'rhs', {
    value: value,
    enumerable: true
  });
}
inherits(DiffEdit, Diff);

function DiffNew(path, value) {
  DiffNew.super_.call(this, 'N', path);
  Object.defineProperty(this, 'rhs', {
    value: value,
    enumerable: true
  });
}
inherits(DiffNew, Diff);

function DiffDeleted(path, value) {
  DiffDeleted.super_.call(this, 'D', path);
  Object.defineProperty(this, 'lhs', {
    value: value,
    enumerable: true
  });
}
inherits(DiffDeleted, Diff);

function DiffArray(path, index, item) {
  DiffArray.super_.call(this, 'A', path);
  Object.defineProperty(this, 'index', {
    value: index,
    enumerable: true
  });
  Object.defineProperty(this, 'item', {
    value: item,
    enumerable: true
  });
}
inherits(DiffArray, Diff);

function arrayRemove(arr, from, to) {
  var rest = arr.slice((to || from) + 1 || arr.length);
  arr.length = from < 0 ? arr.length + from : from;
  arr.push.apply(arr, rest);
  return arr;
}

function realTypeOf(subject) {
  var type = typeof subject;
  if (type !== 'object') {
    return type;
  }

  if (subject === Math) {
    return 'math';
  } else if (subject === null) {
    return 'null';
  } else if (Array.isArray(subject)) {
    return 'array';
  } else if (Object.prototype.toString.call(subject) === '[object Date]') {
    return 'date';
  } else if (typeof subject.toString === 'function' && /^\/.*\//.test(subject.toString())) {
    return 'regexp';
  }
  return 'object';
}

function deepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
  path = path || [];
  stack = stack || [];
  var currentPath = path.slice(0);
  if (typeof key !== 'undefined') {
    if (prefilter) {
      if (typeof(prefilter) === 'function' && prefilter(currentPath, key)) {
        return; } else if (typeof(prefilter) === 'object') {
        if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {
          return; }
        if (prefilter.normalize) {
          var alt = prefilter.normalize(currentPath, key, lhs, rhs);
          if (alt) {
            lhs = alt[0];
            rhs = alt[1];
          }
        }
      }
    }
    currentPath.push(key);
  }

  // Use string comparison for regexes
  if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
    lhs = lhs.toString();
    rhs = rhs.toString();
  }

  var ltype = typeof lhs;
  var rtype = typeof rhs;

  var ldefined = ltype !== 'undefined' || (stack && stack[stack.length - 1].lhs && stack[stack.length - 1].lhs.hasOwnProperty(key));
  var rdefined = rtype !== 'undefined' || (stack && stack[stack.length - 1].rhs && stack[stack.length - 1].rhs.hasOwnProperty(key));

  if (!ldefined && rdefined) {
    changes(new DiffNew(currentPath, rhs));
  } else if (!rdefined && ldefined) {
    changes(new DiffDeleted(currentPath, lhs));
  } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
    changes(new DiffEdit(currentPath, lhs, rhs));
  } else if (realTypeOf(lhs) === 'date' && (lhs - rhs) !== 0) {
    changes(new DiffEdit(currentPath, lhs, rhs));
  } else if (ltype === 'object' && lhs !== null && rhs !== null) {
    if (!stack.filter(function(x) {
        return x.lhs === lhs; }).length) {
      stack.push({ lhs: lhs, rhs: rhs });
      if (Array.isArray(lhs)) {
        var i, len = lhs.length;
        for (i = 0; i < lhs.length; i++) {
          if (i >= rhs.length) {
            changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
          } else {
            deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack);
          }
        }
        while (i < rhs.length) {
          changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
        }
      } else {
        var akeys = Object.keys(lhs);
        var pkeys = Object.keys(rhs);
        akeys.forEach(function(k, i) {
          var other = pkeys.indexOf(k);
          if (other >= 0) {
            deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack);
            pkeys = arrayRemove(pkeys, other);
          } else {
            deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack);
          }
        });
        pkeys.forEach(function(k) {
          deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack);
        });
      }
      stack.length = stack.length - 1;
    } else if (lhs !== rhs) {
      // lhs is contains a cycle at this element and it differs from rhs
      changes(new DiffEdit(currentPath, lhs, rhs));
    }
  } else if (lhs !== rhs) {
    if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
      changes(new DiffEdit(currentPath, lhs, rhs));
    }
  }
}

function accumulateDiff(lhs, rhs, prefilter, accum) {
  accum = accum || [];
  deepDiff(lhs, rhs,
    function(diff) {
      if (diff) {
        accum.push(diff);
      }
    },
    prefilter);
  return (accum.length) ? accum : undefined;
}

function applyArrayChange(arr, index, change) {
  if (change.path && change.path.length) {
    var it = arr[index],
      i, u = change.path.length - 1;
    for (i = 0; i < u; i++) {
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        applyArrayChange(it[change.path[i]], change.index, change.item);
        break;
      case 'D':
        delete it[change.path[i]];
        break;
      case 'E':
      case 'N':
        it[change.path[i]] = change.rhs;
        break;
    }
  } else {
    switch (change.kind) {
      case 'A':
        applyArrayChange(arr[index], change.index, change.item);
        break;
      case 'D':
        arr = arrayRemove(arr, index);
        break;
      case 'E':
      case 'N':
        arr[index] = change.rhs;
        break;
    }
  }
  return arr;
}

function applyChange(target, source, change) {
  if (target && source && change && change.kind) {
    var it = target,
      i = -1,
      last = change.path ? change.path.length - 1 : 0;
    while (++i < last) {
      if (typeof it[change.path[i]] === 'undefined') {
        it[change.path[i]] = (typeof change.path[i] === 'number') ? [] : {};
      }
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
        break;
      case 'D':
        delete it[change.path[i]];
        break;
      case 'E':
      case 'N':
        it[change.path[i]] = change.rhs;
        break;
    }
  }
}

function revertArrayChange(arr, index, change) {
  if (change.path && change.path.length) {
    // the structure of the object at the index has changed...
    var it = arr[index],
      i, u = change.path.length - 1;
    for (i = 0; i < u; i++) {
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        revertArrayChange(it[change.path[i]], change.index, change.item);
        break;
      case 'D':
        it[change.path[i]] = change.lhs;
        break;
      case 'E':
        it[change.path[i]] = change.lhs;
        break;
      case 'N':
        delete it[change.path[i]];
        break;
    }
  } else {
    // the array item is different...
    switch (change.kind) {
      case 'A':
        revertArrayChange(arr[index], change.index, change.item);
        break;
      case 'D':
        arr[index] = change.lhs;
        break;
      case 'E':
        arr[index] = change.lhs;
        break;
      case 'N':
        arr = arrayRemove(arr, index);
        break;
    }
  }
  return arr;
}

function revertChange(target, source, change) {
  if (target && source && change && change.kind) {
    var it = target,
      i, u;
    u = change.path.length - 1;
    for (i = 0; i < u; i++) {
      if (typeof it[change.path[i]] === 'undefined') {
        it[change.path[i]] = {};
      }
      it = it[change.path[i]];
    }
    switch (change.kind) {
      case 'A':
        // Array was modified...
        // it will be an array...
        revertArrayChange(it[change.path[i]], change.index, change.item);
        break;
      case 'D':
        // Item was deleted...
        it[change.path[i]] = change.lhs;
        break;
      case 'E':
        // Item was edited...
        it[change.path[i]] = change.lhs;
        break;
      case 'N':
        // Item is new...
        delete it[change.path[i]];
        break;
    }
  }
}

function applyDiff(target, source, filter) {
  if (target && source) {
    var onChange = function(change) {
      if (!filter || filter(target, source, change)) {
        applyChange(target, source, change);
      }
    };
    deepDiff(target, source, onChange);
  }
}

Object.defineProperties(accumulateDiff, {

  diff: {
    value: accumulateDiff,
    enumerable: true
  },
  observableDiff: {
    value: deepDiff,
    enumerable: true
  },
  applyDiff: {
    value: applyDiff,
    enumerable: true
  },
  applyChange: {
    value: applyChange,
    enumerable: true
  },
  revertChange: {
    value: revertChange,
    enumerable: true
  },
  isConflict: {
    value: function() {
      return 'undefined' !== typeof conflict;
    },
    enumerable: true
  },
  noConflict: {
    value: function() {
      if (conflictResolution) {
        conflictResolution.forEach(function(it) {
          it();
        });
        conflictResolution = null;
      }
      return accumulateDiff;
    },
    enumerable: true
  }
});

/* harmony default export */ __webpack_exports__["default"] = (accumulateDiff);


/***/ }),

/***/ "../node_modules/dotenv/lib/main.js":
/*!******************************************!*\
  !*** ../node_modules/dotenv/lib/main.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs")

/*
 * Parses a string or buffer into an object
 * @param {String|Buffer} src - source to be parsed
 * @returns {Object}
*/
function parse (src) {
  var obj = {}

  // convert Buffers before splitting into lines and processing
  src.toString().split('\n').forEach(function (line) {
    // matching "KEY' and 'VAL' in 'KEY=VAL'
    var keyValueArr = line.match(/^\s*([\w\.\-]+)\s*=\s*(.*)?\s*$/)
    // matched?
    if (keyValueArr != null) {
      var key = keyValueArr[1]

      // default undefined or missing values to empty string
      var value = keyValueArr[2] ? keyValueArr[2] : ''

      // expand newlines in quoted values
      var len = value ? value.length : 0
      if (len > 0 && value.charAt(0) === '"' && value.charAt(len - 1) === '"') {
        value = value.replace(/\\n/gm, '\n')
      }

      // remove any surrounding quotes and extra spaces
      value = value.replace(/(^['"]|['"]$)/g, '').trim()

      obj[key] = value
    }
  })

  return obj
}

/*
 * Main entry point into dotenv. Allows configuration before loading .env
 * @param {Object} options - valid options: path ('.env'), encoding ('utf8')
 * @returns {Boolean}
*/
function config (options) {
  var path = '.env'
  var encoding = 'utf8'

  if (options) {
    if (options.path) {
      path = options.path
    }
    if (options.encoding) {
      encoding = options.encoding
    }
  }

  try {
    // specifying an encoding returns a string instead of a buffer
    var parsedObj = parse(fs.readFileSync(path, { encoding: encoding }))

    Object.keys(parsedObj).forEach(function (key) {
      process.env[key] = process.env[key] || parsedObj[key]
    })

    return { parsed: parsedObj }
  } catch (e) {
    return { error: e }
  }
}

module.exports.config = config
module.exports.load = config
module.exports.parse = parse


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/connection.js":
/*!*******************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/connection.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var net = __webpack_require__(/*! net */ "net");
var tls = __webpack_require__(/*! tls */ "tls");
var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var events = __webpack_require__(/*! events */ "events");
var util = __webpack_require__(/*! util */ "util");
var crypto = __webpack_require__(/*! crypto */ "crypto");

var helper = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/helper.js */ "../node_modules/rethinkdbdash/lib/helper.js");
var Err = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/error.js */ "../node_modules/rethinkdbdash/lib/error.js");
var Cursor = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/cursor.js */ "../node_modules/rethinkdbdash/lib/cursor.js");
var ReadableStream = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/stream.js */ "../node_modules/rethinkdbdash/lib/stream.js");
var Metadata = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/metadata.js */ "../node_modules/rethinkdbdash/lib/metadata.js");

var protodef = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/protodef.js */ "../node_modules/rethinkdbdash/lib/protodef.js");
var responseTypes = protodef.Response.ResponseType;

// We'll ping a connection using this special value.
var PING_VALUE = "__rethinkdbdash_ping__";

var PROTOCOL_VERSION = 0;
var AUTHENTIFICATION_METHOD = "SCRAM-SHA-256";
var KEY_LENGTH = 32; // Because we are currently using SHA 256
var NULL_BUFFER = new Buffer('\0', "binary");
var CACHE_PBKDF2 = {};

function Connection(r, options, resolve, reject) {
  var self = this;
  this.r = r;
  this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.

  // Set default options - We have to save them in case the user tries to reconnect
  if (!helper.isPlainObject(options)) options = {};
  this.host = options.host || r._host;
  this.port = options.port || r._port;
  if (options.authKey != null) {
    if (options.user != null || options.password != null) {
      throw new Err.ReqlDriverError('Cannot use both authKey and password');
    }
    this.user = r._user;
    this.password = options.authKey;
  } else {
    if (options.user === undefined) {
      this.user = r._user;
    } else {
      this.user = options.user;
    }
    if (options.password === undefined) {
      this.password = r._password;
    } else {
      this.password = options.password;
    }
  }

  this.authKey = options.authKey || r._authKey;
  // period in *seconds* for the connection to be opened
  this.timeoutConnect = options.timeout || r._timeoutConnect;
  // The connection will be pinged every <pingInterval> seconds
  this.pingInterval = options.pingInterval || r._pingInterval;

  if (options.db) this.db = options.db; // Pass to each query

  this.token = 1;
  this.buffer = new Buffer(0);

  this.metadata = {}

  this.open = false; // true only if the user can write on the socket
  this.timeout = null;

  if (options.connection) {
    this.connection = options.connection;
  }
  else {
    var family = 'IPv4';
    if (net.isIPv6(self.host)) {
      family = 'IPv6';
    }

    var connectionArgs = {
      host: self.host,
      port: self.port,
      family: family
    }

    var tlsOptions = options.ssl || false;
    if (tlsOptions === false) {
      self.connection = net.connect(connectionArgs);
    } else {
      if (helper.isPlainObject(tlsOptions)) {
        // Copy the TLS options in connectionArgs
        helper.loopKeys(tlsOptions, function(tlsOptions, key) {
          connectionArgs[key] = tlsOptions[key];
        });
      }
      self.connection = tls.connect(connectionArgs);
    }
  }

  self.connection.setKeepAlive(true);

  self.timeoutOpen = setTimeout(function() {
    self.connection.end(); // Send a FIN packet
    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+self.timeoutConnect+'s').setOperational());
  }, self.timeoutConnect*1000);

  self.connection.on('end', function() {
    self.open = false;
    self.emit('end');
    // We got a FIN packet, so we'll just flush
    self._flush();
  });
  self.connection.on('close', function() {
    // We emit end or close just once
    clearTimeout(self.timeoutOpen)
    clearInterval(self.pingIntervalId);
    self.connection.removeAllListeners();
    self.open = false;
    self.emit('closed');
    // The connection is fully closed, flush (in case 'end' was not triggered)
    self._flush();
  });
  self.connection.setNoDelay();
  self.connection.once('error', function(error) {
    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+'\nFull error:\n'+JSON.stringify(error)).setOperational());
  });
  self.connection.on('connect', function() {
    self.connection.removeAllListeners('error');
    self.connection.on('error', function(error) {
      self.emit('error', error);
    });

    var versionBuffer = new Buffer(4)
    versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)

    self.randomString = new Buffer(crypto.randomBytes(18)).toString('base64')
    var authBuffer = new Buffer(JSON.stringify({
      protocol_version: PROTOCOL_VERSION,
      authentication_method: AUTHENTIFICATION_METHOD,
      authentication: "n,,n=" + self.user + ",r=" + self.randomString
    }));

    helper.tryCatch(function() {
      self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn't established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());
    });
  });
  self.connection.once('end', function() {
    self.open = false;
  });

  self.connection.on('data', function(buffer) {
    if (self.state === -1) {
      // This is an error state
      return;
    }
    self.buffer = Buffer.concat([self.buffer, buffer]);

    if (self.open == false) {
      for(var i=0; i<self.buffer.length; i++) {
        if (self.buffer[i] === 0) {
          var messageServerStr = self.buffer.slice(0, i).toString();
          self.buffer = self.buffer.slice(i+1); // +1 to remove the null byte
          try {
            var messageServer = JSON.parse(messageServerStr);
          } catch(error) {
            self._abort();
            reject(new Err.ReqlDriverError('Could not parse the message sent by the server : \''+messageServerStr+'\'').setOperational());
            return;
          }
          if (messageServer.success !== true) {
            self._abort();
            reject(new Err.ReqlDriverError('Error '+messageServer.error_code+':'+messageServer.error).setOperational());
            return;
          }

          if (self.state === 0) {
            self._checkProtocolVersion(messageServer, reject);
          } else if (self.state === 1) {
            // Compute salt and send the proof
            self._computeSaltedPassword(messageServer, reject);
          } else if (self.state === 2) {
            self._compareDigest(messageServer, resolve, reject);
          }
        }
      }
    }
    else {
      while(self.buffer.length >= 12) {
        var token = self.buffer.readUInt32LE(0) + 0x100000000 * self.buffer.readUInt32LE(4);
        var responseLength = self.buffer.readUInt32LE(8);

        if (self.buffer.length < 12+responseLength) break;

        var responseBuffer = self.buffer.slice(12, 12+responseLength);
        var response = JSON.parse(responseBuffer);

        self._processResponse(response, token);

        self.buffer = self.buffer.slice(12+responseLength);
      }
    }
  });

  self.connection.on('timeout', function(buffer) {
    self.connection.open = false;
    self.emit('timeout');
  })
  self.connection.toJSON = function() { // We want people to be able to jsonify a cursor
    return '"A socket object cannot be converted to JSON due to circular references."'
  }
}

util.inherits(Connection, events.EventEmitter);

Connection.prototype._checkProtocolVersion = function(messageServer, reject) {
  // Expect max_protocol_version, min_protocol_version, server_version, success
  var minVersion = messageServer.min_protocol_version
  var maxVersion = messageServer.max_protocol_version

  if (minVersion > PROTOCOL_VERSION || maxVersion < PROTOCOL_VERSION) {
    this._abort();
    reject(new Err.ReqlDriverError('Unsupported protocol version: '+PROTOCOL_VERSION+', expected between '+minVersion+' and '+ maxVersion).setOperational());
  }
  this.state = 1;
};

Connection.prototype._computeSaltedPassword = function(messageServer, reject) {
  var self = this;
  var authentication = helper.splitCommaEqual(messageServer.authentication);

  var randomNonce = authentication.r
  var salt = new Buffer(authentication.s, 'base64')
  var iterations = parseInt(authentication.i)

  if (randomNonce.substr(0, self.randomString.length) !== self.randomString) {
    self._abort();
    reject(new Err.ReqlDriverError('Invalid nonce from server').setOperational());
  }

  // The salt is constant, so we can cache the salted password.
  var cacheKey = self.password.toString("base64")+','+salt.toString("base64")+','+iterations;
  if (CACHE_PBKDF2.hasOwnProperty(cacheKey)) {
    helper.tryCatch(function() {
      self._sendProof(messageServer.authentication, randomNonce, CACHE_PBKDF2[cacheKey]);
    }, function(err) {
      // The TCP connection is open, but the ReQL connection wasn't established.
      // We can just abort the whole thing
      self.open = false;
      reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());
    });
  } else {
    crypto.pbkdf2(self.password, salt, iterations, KEY_LENGTH, "sha256", function(error, saltedPassword) {
      if (error != null) {
        self._abort();
        reject(new Err.ReqlDriverError('Could not derive the key. Error:' + error.toString()).setOperational());
      }
      CACHE_PBKDF2[cacheKey] = saltedPassword;
      helper.tryCatch(function() {
        self._sendProof(messageServer.authentication, randomNonce, saltedPassword);
      }, function(err) {
        // The TCP connection is open, but the ReQL connection wasn't established.
        // We can just abort the whole thing
        self.open = false;
        reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());
      });
    })
  }
}

Connection.prototype._sendProof = function(authentication, randomNonce, saltedPassword) {
  var clientFinalMessageWithoutProof = "c=biws,r=" + randomNonce;
  var clientKey = crypto.createHmac("sha256", saltedPassword).update("Client Key").digest()
  var storedKey = crypto.createHash("sha256").update(clientKey).digest()

  var authMessage =
      "n=" + this.user + ",r=" + this.randomString + "," +
      authentication + "," +
      clientFinalMessageWithoutProof

  var clientSignature = crypto.createHmac("sha256", storedKey).update(authMessage).digest()
  var clientProof = helper.xorBuffer(clientKey, clientSignature)

  var serverKey = crypto.createHmac("sha256", saltedPassword).update("Server Key").digest()
  this.serverSignature = crypto.createHmac("sha256", serverKey).update(authMessage).digest()

  this.state = 2
  var message = JSON.stringify({
    authentication: clientFinalMessageWithoutProof + ",p=" + clientProof.toString("base64")
  })
  this.connection.write(Buffer.concat([new Buffer(message.toString()), NULL_BUFFER]))
}

Connection.prototype._compareDigest = function(messageServer, resolve, reject) {
  var self = this;
  var firstEquals = messageServer.authentication.indexOf('=')
  var serverSignatureValue = messageServer.authentication.slice(firstEquals+1)

  if (!helper.compareDigest(serverSignatureValue, self.serverSignature.toString("base64"))) {
    reject(new Err.ReqlDriverError('Invalid server signature').setOperational());
  }

  self.state = 4
  self.connection.removeAllListeners('error');
  self.open = true;
  self.connection.on('error', function(e) {
    self.open = false;
  });
  clearTimeout(self.timeoutOpen)
  resolve(self);
  if (self.pingInterval > 0) {
    self.pingIntervalId = setInterval(function() {
      self.pendingPing = true;
      self.r.error(PING_VALUE).run(self).error(function(error) {
        self.pendingPing = false;
        if (error.message !== PING_VALUE) {
          self.emit('error', new Err.ReqlDriverError(
                'Could not ping the connection').setOperational());
          self.open = false;
          self.connection.end();
        } else {
        }
      });
    }, self.pingInterval*1000);
  }
}

Connection.prototype._abort = function() {
  this.state = -1;
  this.removeAllListeners();
  this.close();
}

Connection.prototype._processResponse = function(response, token) {
  //console.log('Connection.prototype._processResponse: '+token);
  //console.log(JSON.stringify(response, null, 2));
  var self = this;

  var type = response.t;
  var result;
  var cursor;
  var stream;
  var currentResolve, currentReject;
  var datum;
  var options;

  if (type === responseTypes.COMPILE_ERROR) {
    self.emit('release');
    if (typeof self.metadata[token].reject === 'function') {
      self.metadata[token].reject(new Err.ReqlCompileError(helper.makeAtom(response), self.metadata[token].query, response));
    }

    delete self.metadata[token]
  }
  else if (type === responseTypes.CLIENT_ERROR) {
    self.emit('release');

    if (typeof self.metadata[token].reject === 'function') {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
      self.metadata[token].removeCallbacks();
      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
      if (typeof self.metadata[token].endReject !== 'function') {
        // No pending STOP query, we can delete
        delete self.metadata[token]
      }
    }
    else if (typeof self.metadata[token].endResolve === 'function') {
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      self.metadata[token].removeEndCallbacks();
      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));
      delete self.metadata[token]
    }
    else if (token === -1) { // This should not happen now since 1.13 took the token out of the query
      var error = new Err.ReqlClientError(helper.makeAtom(response)+'\nClosing all outstanding queries...');
      self.emit('error', error);
      // We don't want a function to yield forever, so we just reject everything
      helper.loopKeys(self.rejectMap, function(rejectMap, key) {
        rejectMap[key](error);
      });
      self.close();
      delete self.metadata[token]
    }
  }
  else if (type === responseTypes.RUNTIME_ERROR) {
    var errorValue = helper.makeAtom(response);
    var error;
    // We don't want to release a connection if we just pinged it.
    if (self.pendingPing === false || (errorValue !== PING_VALUE)) {
      self.emit('release');
      error = new Err.ReqlRuntimeError(errorValue, self.metadata[token].query, response);
    } else {
      error = new Err.ReqlRuntimeError(errorValue);
    }

    if (typeof self.metadata[token].reject === 'function') {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
      self.metadata[token].removeCallbacks();
      error.setName(response.e);
      currentReject(error);
      if (typeof self.metadata[token].endReject !== 'function') {
        // No pending STOP query, we can delete
        delete self.metadata[token]
      }
    }
    else if (typeof self.metadata[token].endResolve === 'function') {
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      self.metadata[token].removeEndCallbacks();
      delete self.metadata[token]
    }
  }
  else if (type === responseTypes.SUCCESS_ATOM) {
    self.emit('release');
    // self.metadata[token].resolve is always a function
    datum = helper.makeAtom(response, self.metadata[token].options);

    if ((Array.isArray(datum)) &&
        ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true)))) {
      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');
      if (self.metadata[token].options.profile === true) {
        self.metadata[token].resolve({
          profile: response.p,
          result: cursor
        });
      }
      else {
        self.metadata[token].resolve(cursor);
      }

      cursor._push({done: true, response: { r: datum }});
    }
    else if ((Array.isArray(datum)) &&
        ((self.metadata[token].options.stream === true || self.r._options.stream === true))) {
      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');
      stream = new ReadableStream({}, cursor);
      if (self.metadata[token].options.profile === true) {
        self.metadata[token].resolve({
          profile: response.p,
          result: stream 
        });
      }
      else {
        self.metadata[token].resolve(stream);
      }
      cursor._push({done: true, response: { r: datum }});
    }
    else {
      if (self.metadata[token].options.profile === true) {
        result = {
          profile: response.p,
          result: cursor || datum
        }
      }
      else {
        result = datum;
      }
      self.metadata[token].resolve(result);
    }

    delete self.metadata[token];
  }
  else if (type === responseTypes.SUCCESS_PARTIAL) {
    // We save the current resolve function because we are going to call cursor._fetch before resuming the user's yield
    var done = false;
    if (typeof self.metadata[token].resolve !== 'function') {
      // According to issues/190, we can get a SUCESS_COMPLETE followed by a
      // SUCCESS_PARTIAL when closing an feed. So resolve/reject will be undefined
      // in this case.
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      if (typeof currentResolve === 'function') {
        done = true;
      }
    }
    else {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
    }

    // We need to delete before calling cursor._push
    self.metadata[token].removeCallbacks();

    if (!self.metadata[token].cursor) { //No cursor, let's create one
      self.metadata[token].cursor = true;

      var typeResult = 'Cursor';
      var includesStates = false;;
      if (Array.isArray(response.n)) {
        for(var i=0; i<response.n.length; i++) {
          if (response.n[i] === protodef.Response.ResponseNote.SEQUENCE_FEED) {
            typeResult = 'Feed';
          }
          else if (response.n[i] === protodef.Response.ResponseNote.ATOM_FEED) {
            typeResult = 'AtomFeed';
          }
          else if (response.n[i] === protodef.Response.ResponseNote.ORDER_BY_LIMIT_FEED) {
            typeResult = 'OrderByLimitFeed';
          }
          else if (response.n[i] === protodef.Response.ResponseNote.UNIONED_FEED) {
            typeResult = 'UnionedFeed';
          }
          else if (response.n[i] === protodef.Response.ResponseNote.INCLUDES_STATES) {
            includesStates = true;
          }
          else {
            currentReject(new Err.ReqlDriverError('Unknown ResponseNote '+response.n[i]+', the driver is probably out of date.').setOperational());
            return;
          }
        }
      }
      cursor = new Cursor(self, token, self.metadata[token].options, typeResult);
      if (includesStates === true) {
        cursor.setIncludesStates();
      }
      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {
        // Return a cursor
        if (self.metadata[token].options.profile === true) {
          currentResolve({
            profile: response.p,
            result: cursor
          });
        }
        else {
          currentResolve(cursor);
        }
      }
      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {
        stream = new ReadableStream({}, cursor);
        if (self.metadata[token].options.profile === true) {
          currentResolve({
            profile: response.p,
            result: stream 
          });
        }
        else {
          currentResolve(stream);
        }
      }
      else if (typeResult !== 'Cursor') {
        // Return a feed
        if (self.metadata[token].options.profile === true) {
          currentResolve({
            profile: response.p,
            result: cursor
          });
        }
        else {
          currentResolve(cursor);
        }
      }
      else {
        // When we get SUCCESS_SEQUENCE, we will delete self.metadata[token].options
        // So we keep a reference of it here
        options = self.metadata[token].options;

        // Fetch everything and return an array
        cursor.toArray().then(function(result) {
          if (options.profile === true) {
            currentResolve({
              profile: response.p,
              result: result
            });
          }
          else {
            currentResolve(result);
          }
        }).error(currentReject)
      }
      cursor._push({done: false, response: response});
    }
    else { // That was a continue query
      currentResolve({done: done, response: response});
    }
  }
  else if (type === responseTypes.SUCCESS_SEQUENCE) {
    self.emit('release');

    if (typeof self.metadata[token].resolve === 'function') {
      currentResolve = self.metadata[token].resolve;
      currentReject = self.metadata[token].reject;
      self.metadata[token].removeCallbacks();
    }
    else if (typeof self.metadata[token].endResolve === 'function') {
      currentResolve = self.metadata[token].endResolve;
      currentReject = self.metadata[token].endReject;
      self.metadata[token].removeEndCallbacks();
    }

    if (!self.metadata[token].cursor) { // No cursor, let's create one
      cursor = new Cursor(self, token, self.metadata[token].options, 'Cursor');

      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {
        if (self.metadata[token].options.profile === true) {
          currentResolve({
            profile: response.p,
            result: cursor
          });
        }
        else {
          currentResolve(cursor);
        }

        // We need to keep the options in the else statement, so we clean it inside the if/else blocks
        if (typeof self.metadata[token].endResolve !== 'function') {
          delete self.metadata[token];
        }
      }
      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {
        stream = new ReadableStream({}, cursor);
        if (self.metadata[token].options.profile === true) {
          currentResolve({
            profile: response.p,
            result: stream
          });
        }
        else {
          currentResolve(stream);
        }

        // We need to keep the options in the else statement,
        // so we clean it inside the if/else blocks (the one looking 
        // if a cursor was already created)
        if (typeof self.metadata[token].endResolve !== 'function') {
          // We do not want to delete the metadata if there is an END query waiting
          delete self.metadata[token];
        }

      }
      else {
        cursor.toArray().then(function(result) {
          if (self.metadata[token].options.profile === true) {
            currentResolve({
              profile: response.p,
              result: result
            });
          }
          else {
            currentResolve(result);
          }
          if (typeof self.metadata[token].endResolve !== 'function') {
            delete self.metadata[token];
          }

        }).error(currentReject)
      }
      done = true;
      cursor._push({done: true, response: response});
    }
    else { // That was a continue query
      // If there is a pending STOP query we do not want to close the cursor yet
      done = true;
      if (typeof self.metadata[token].endResolve === 'function') {
        done = false;
      }
      currentResolve({done: done, response: response});
    }
  }
  else if (type === responseTypes.WAIT_COMPLETE) {
    self.emit('release');
    self.metadata[token].resolve();

    delete self.metadata[token];
  }
  else if (type === responseTypes.SERVER_INFO) {
    self.emit('release');
    datum = helper.makeAtom(response, self.metadata[token].options);
    self.metadata[token].resolve(datum);
    delete self.metadata[token];
  }
}

Connection.prototype.reconnect = function(options, callback) {
  var self = this;

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  if (!helper.isPlainObject(options)) options = {};

  if (options.noreplyWait === true) {
    var p = new Promise(function(resolve, reject) {
      self.close(options).then(function() {
        self.r.connect({
          host: self.host,
          port: self.port,
          authKey: self.authKey,
          db: self.db
        }).then(function(c) {
          resolve(c);
        }).error(function(e) {
          reject(e);
        });
      }).error(function(e) {
        reject(e)
      })
    }).nodeify(callback);
  }
  else {
    return self.r.connect({
      host: self.host,
      port: self.port,
      authKey: self.authKey,
      db: self.db
    }, callback);
  }

  return p;
}

Connection.prototype._send = function(query, token, resolve, reject, originalQuery, options, end) {
  //console.log('Connection.prototype._send: '+token);
  //console.log(JSON.stringify(query, null, 2));

  var self = this;
  if (self.open === false) {
    var err = new Err.ReqlDriverError('The connection was closed by the other party');
    err.setOperational();
    reject(err);
    return;
  }

  var queryStr = JSON.stringify(query);
  var querySize = Buffer.byteLength(queryStr);

  var buffer = new Buffer(8+4+querySize);
  buffer.writeUInt32LE(token & 0xFFFFFFFF, 0)
  buffer.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)

  buffer.writeUInt32LE(querySize, 8);

  buffer.write(queryStr, 12);

  // noreply instead of noReply because the otpions are translated for the server
  if ((!helper.isPlainObject(options)) || (options.noreply != true)) {
    if (!self.metadata[token]) {
      self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);
    }
    else if (end === true) {
      self.metadata[token].setEnd(resolve, reject);
    }
    else {
      self.metadata[token].setCallbacks(resolve, reject);
    }
  }
  else {
    if (typeof resolve === 'function') resolve();
    this.emit('release');
  }

  // This will emit an error if the connection is closed
  helper.tryCatch(function() {
    self.connection.write(buffer);
  }, function(err) {
    self.metadata[token].reject(err);
    delete self.metadata[token]
  });

};

Connection.prototype._continue = function(token, resolve, reject) {
  var query = [protodef.Query.QueryType.CONTINUE];
  this._send(query, token, resolve, reject);
}
Connection.prototype._end = function(token, resolve, reject) {
  var query = [protodef.Query.QueryType.STOP];
  this._send(query, token, resolve, reject, undefined, undefined, true);
}


Connection.prototype.use = function(db) {
  if (typeof db !== 'string') throw new Err.ReqlDriverError('First argument of `use` must be a string')
  this.db = db;
}

Connection.prototype.server = function(callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.SERVER_INFO];
    self._send(query, self._getToken(), resolve, reject, undefined, undefined, true);
  }).nodeify(callback);
}

// Return the next token and update it.
Connection.prototype._getToken = function() {
  return this.token++;
}

Connection.prototype.close = function(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  var self = this;

  var p = new Promise(function(resolve, reject) {
    if (!helper.isPlainObject(options)) options = {};
    if (options.noreplyWait === true) {
      self.noreplyWait().then(function(r) {
        self.open = false;
        self.connection.end()
        resolve(r);
      }).error(function(e) {
        reject(e)
      });
    }
    else{
      self.open = false;
      self.connection.end();
      resolve();
    }
  }).nodeify(callback);
  return p;
};


Connection.prototype.noReplyWait = function() {
  throw new Err.ReqlDriverError('Did you mean to use `noreplyWait` instead of `noReplyWait`?')
}
Connection.prototype.noreplyWait = function(callback) {
  var self = this;
  var token = self._getToken();

  var p = new Promise(function(resolve, reject) {
    var query = [protodef.Query.QueryType.NOREPLY_WAIT];

    self._send(query, token, resolve, reject);
  }).nodeify(callback);
  return p;
}
Connection.prototype._isConnection = function() {
  return true;
}
Connection.prototype._isOpen = function() {
  return this.open;
}

Connection.prototype._flush = function() {
  helper.loopKeys(this.metadata, function(metadata, key) {
    if (typeof metadata[key].reject === 'function') {
      metadata[key].reject(new Err.ReqlServerError(
            'The connection was closed before the query could be completed.',
            metadata[key].query));
    }
    if (typeof metadata[key].endReject === 'function') {
      metadata[key].endReject(new Err.ReqlServerError(
            'The connection was closed before the query could be completed.',
            metadata[key].query));
    }
  });
  this.metadata = {};
}

module.exports = Connection


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/cursor.js":
/*!***************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/cursor.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var Err = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/error.js */ "../node_modules/rethinkdbdash/lib/error.js");
var helper = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/helper.js */ "../node_modules/rethinkdbdash/lib/helper.js");
var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;

var MAX_CALL_STACK = 1000;

function Cursor(connection, token, options, type) {
  this.connection = connection;
  this.token = token;

  this._stackSize = 0; // Estimation of our call stack.
  this._index = 0; // Position in this._data[0]
  this._data = []; // Array of non empty arrays
  this._fetching = false; // Are we fetching data
  this._canFetch = true; // Can we fetch more data?
  this._pendingPromises = []; // Pending promises' resolve/reject
  this.options = options || {};
  this._closed = false;
  this._closingPromise = null; // Promise returned by close
  this._type = type;
  this._setIncludesStates = false;
  if ((type === 'feed') || (type === 'atomFeed')) {
    this.toArray = _unsupportedToArray;
  }
  this._emittedEnd = false;
}

Cursor.prototype.toString = function() {
  return '[object '+this._type+']';
}
Cursor.prototype.setIncludesStates = function() {
  this._setIncludesStates = true;
}
Cursor.prototype.includesStates = function() {
  return this._setIncludesStates;
}
Cursor.prototype.getType = function() {
  return this._type;
}

Cursor.prototype.toJSON = function() {
  if (this._type === 'Cursor') {
    throw new Err.ReqlDriverError('You cannot serialize a Cursor to JSON. Retrieve data from the cursor with `toArray` or `next`');
  }
  else {
    throw new Err.ReqlDriverError('You cannot serialize a '+this._type+' to JSON. Retrieve data from the cursor with `each` or `next`');
  }
}

Cursor.prototype._next = function(callback) {
  var self = this;
  if (self._closed === true) {
    return Promise.reject(new Err.ReqlDriverError(
      'You cannot call `next` on a closed '+self._type).setOperational()
    ).nodeify(callback);
  }
  else if ((self._data.length === 0) && (self._canFetch === false)) {
    return Promise.reject(new Err.ReqlDriverError(
      'No more rows in the '+self._type.toLowerCase()).setOperational()
    ).nodeify(callback);
  }
  else {
    if ((self._data.length > 0) && (self._data[0].length > self._index)) {
      var result = self._data[0][self._index++];
      if (result instanceof Error) {
        return Promise.reject(result).nodeify(callback);
      }
      else {
        // This could be possible if we get back batch with just one document?
        if (self._data[0].length === self._index) {
          self._index = 0;
          self._data.shift();
          if ((self._data.length === 1)
            && (self._canFetch === true)
            && (self._closed === false)
            && (self._fetching === false)) {
              self._fetch();
          }
        }
        return Promise.resolve(result).nodeify(callback);
      }
    }
    else {
      return new Promise(function(resolve, reject) {
        self._pendingPromises.push({resolve: resolve, reject: reject});
      }).nodeify(callback);
    }
  }
}
Cursor.prototype.hasNext = function() {
  throw new Error('The `hasNext` command has been removed in 1.13, please use `next`.')
}
Cursor.prototype.toArray = function(callback) {
  var self = this;
  var p = new Promise(function(resolve, reject) {
    var result = [];
    var i =0;
    self._each(function(err, data) {
      if (err) {
        reject(err);
      }
      else {
        result.push(data);
      }
    }, function() {
      resolve(result);
    });
  }).nodeify(callback);
  return p;
}

Cursor.prototype._fetch = function() {
  var self = this;
  this._fetching = true;

  var p = new Promise(function(resolve, reject) {
    self.connection._continue(self.token, resolve, reject);
  }).then(function(response) {
    self._push(response);
    return null;
  }).error(function(error) {
    self._fetching = false;
    self._canFetch = false;
    self._pushError(error);
  })
}

Cursor.prototype._push = function(data) {
  var couldfetch = this._canFetch;
  if (data.done) this._done();
  var response = data.response;
  this._fetching = false;
  // If the cursor was closed, we ignore all following response
  if ((response.r.length > 0) && (couldfetch === true)) {
    this._data.push(helper.makeSequence(response, this.options));
  }
  // this._fetching = false
  if ((this._closed === false) && (this._canFetch) && (this._data.length <= 1)) this._fetch();
  this._flush();
}
// Try to solve as many pending promises as possible
Cursor.prototype._flush = function() {
  while ((this._pendingPromises.length > 0) && ((this._data.length > 0) || ((this._fetching === false) && (this._canFetch === false)))) {
    var fullfiller = this._pendingPromises.shift();
    var resolve = fullfiller.resolve;
    var reject = fullfiller.reject;

    if (this._data.length > 0) {
      var result = this._data[0][this._index++];
      if (result instanceof Error) {
        reject(result);
      }
      else {
        resolve(result);
      }

      if (this._data[0].length === this._index) {
        this._index = 0;
        this._data.shift();
        if ((this._data.length <= 1)
          && (this._canFetch === true)
          && (this._closed === false)
          && (this._fetching === false)) {
            this._fetch();
        }
      }
    }
    else {
      reject(new Err.ReqlDriverError('No more rows in the '+this._type.toLowerCase()).setOperational())
    }
  }
}
Cursor.prototype._pushError = function(error) {
  this._data.push([error]);
  this._flush();
}

Cursor.prototype._done = function() {
  this._canFetch = false;
  if (this._eventEmitter) {
    this._eventEmitter.emit('end');
  }
}

Cursor.prototype._set = function(ar) {
  this._fetching = false;
  this._canFetch = false;
  if (ar.length > 0) {
    this._data.push(ar);
  }
  this._flush();
}

Cursor.prototype.close = function(callback) {
  var self = this;
  if (self._closed === true) {
    return self._closingPromise.nodeify(callback);
  }
  self._closed = true;

  self._closingPromise = new Promise(function(resolve, reject) {
    if ((self._canFetch === false) && (self._fetching === false)) {
      resolve()
    }
    else { // since v0_4 (RethinkDB 2.0) we can (must) force a STOP request even if a CONTINUE query is pending
      var endCallback = function() {
        if (self._eventEmitter && (self._emittedEnd === false)) {
          self._emittedEnd = true;
          self._eventEmitter.emit('end');
        }
        resolve();
      }
      self.connection._end(self.token, endCallback, reject);
    }
  }).nodeify(callback);
  return self._closingPromise;
}
Cursor.prototype._each = function(callback, onFinish) {
  if (this._closed === true) {
    return callback(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());
  }
  var self = this;

  var reject = function(err) {
    if (err.message === 'No more rows in the '+self._type.toLowerCase()+'.') {
      if (typeof onFinish === 'function') {
        onFinish();
      }
    }
    else {
      callback(err);
    }
    return null;
  }
  var resolve = function(data) {
    self._stackSize++;
    var keepGoing = callback(null, data);
    if (keepGoing === false) {
      if (typeof onFinish === 'function') {
        onFinish();
      }
    }
    else {
      if (self._closed === false) {
        if (self._stackSize <= MAX_CALL_STACK) {
          self._next().then(resolve).error(function(error) {
            if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&
                (error.message.match(/You cannot call `next` on a closed/) === null)) {
              reject(error);
            }
          });
        }
        else {
          setTimeout(function() {
            self._stackSize = 0;
            self._next().then(resolve).error(function(error) {
              if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&
                  (error.message.match(/You cannot call `next` on a closed/) === null)) {
                reject(error);
              }
            });
          }, 0);
        }
      }
    }
    return null;
  }

  self._next().then(resolve).error(function(error) {
    // We can silence error when the cursor is closed as this
    if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&
        (error.message.match(/You cannot call `next` on a closed/) === null)) {
      reject(error);
    }
  });
  return null;
}
Cursor.prototype._eachAsync = function(callback) {
  var self = this;
  return new Promise(function(resolve, reject) {
    self._eachAsyncInternal(callback, resolve, reject)
  });
}
Cursor.prototype._eachAsyncInternal = function(callback, finalResolve, finalReject) {
  if (this._closed === true) {
    finalReject(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());
    return;
  }
  var self = this;

  var nextCb = function() {
    self._stackSize++;
    self._next().then(function(row) {
      if (self._stackSize <= MAX_CALL_STACK) {
        if (callback.length <= 1) {
          Promise.resolve(callback(row)).then(nextCb)
          return null;
        }
        else {
          new Promise(function(resolve, reject) {
            return callback(row, resolve)
          }).then(nextCb);
          return null;
        }
      }
      else {
        new Promise(function(resolve, reject) {
          setTimeout(function() {
            self._stackSize = 0;
            if (callback.length <= 1) {
              Promise.resolve(callback(row)).then(resolve).catch(reject);
            }
            else {
              new Promise(function(resolve, reject) {
                return callback(row, resolve)
              }).then(resolve).catch(reject);
              return null;
            }
          }, 0)
        }).then(nextCb);
        return null;
      }
    }).error(function(error) {
      if ((error.message === 'No more rows in the '+self._type.toLowerCase()+'.') ||
          (error.message === 'You cannot retrieve data from a cursor that is closed.') ||
          (error.message.match(/You cannot call `next` on a closed/) !== null)) {
        return finalResolve();
      }
      return finalReject(Err.setOperational(error));
    });
  }
  nextCb();
}
Cursor.prototype.eachAsync = Cursor.prototype._eachAsync;
Cursor.prototype.next = Cursor.prototype._next;
Cursor.prototype.each = Cursor.prototype._each;
Cursor.prototype._unsupportedToArray = function() {
  throw new Error('The `toArray` method is not available on feeds.')
}

Cursor.prototype._makeEmitter = function() {
  this.next = function() {
    throw new Err.ReqlDriverError('You cannot call `next` once you have bound listeners on the '+this._type)
  }
  this.each = function() {
    throw new Err.ReqlDriverError('You cannot call `each` once you have bound listeners on the '+this._type)
  }
  this.eachAsync = function() {
    throw new Err.ReqlDriverError('You cannot call `eachAsync` once you have bound listeners on the '+this._type)
  }
  this.toArray = function() {
    throw new Err.ReqlDriverError('You cannot call `toArray` once you have bound listeners on the '+this._type)
  }
  this._eventEmitter = new EventEmitter();
}
Cursor.prototype._eachCb = function(err, data) {
  // We should silent things if the cursor/feed is closed
  if (this._closed === false) {
    if (err) {
      this._eventEmitter.emit('error', err);
    }
    else {
      this._eventEmitter.emit('data', data);
    }
  }
}

var methods = [
  'addListener',
  'on',
  'once',
  'removeListener',
  'removeAllListeners',
  'setMaxListeners',
  'listeners',
  'emit'
];

for(var i=0; i<methods.length; i++) {
  (function(n) {
    var method = methods[n];
    Cursor.prototype[method] = function() {
      var self = this;
      if (self._eventEmitter == null) {
        self._makeEmitter();
        setImmediate(function() {
          self._each(self._eachCb.bind(self), function() {
            if (self._emittedEnd === false) {
              self._emittedEnd = true;
              self._eventEmitter.emit('end');
            }
          });
        });
      }
      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
      self._eventEmitter[method].apply(self._eventEmitter, _args);
    };
  })(i);
}

module.exports = Cursor;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/dequeue.js":
/*!****************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/dequeue.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Implement a dequeue with a circular buffer
// The buffer can expand but currently doesn't automatically shrink
// as it is not a desired behavior. We may want to explicitly resize it though.
function Dequeue(size) {
  this.start = 0;
  this.end = 0;

  size = size || 50;
  this.buffer = new Array(size);
}
Dequeue.prototype.get = function(index) {
  if (this.start+index > this.buffer.length) {
    return this.buffer[this.start+index-this.buffer.length]
  }
  else {
    return this.buffer[this.start+index]
  }
}

Dequeue.prototype.toArray = function(index) {
  var result = [];
  for(var i=0; i<this.getLength(); i++) {
    result.push(this.get(i));
  }
  return result;
}

Dequeue.prototype.delete = function(index) {
  var current, next;
  if (this.start+index >= this.buffer.length) {
    current = this.start+index-this.buffer.length;
    next = this.start+index-this.buffer.length+1;
  }
  else {
    current = this.start+index;
    next = this.start+index+1;
  }

  for(var i=index; i<(this.buffer.length-index); i++) {
    if (next === this.buffer.length) next = 0;
    if (current === this.buffer.length) current = 0;

    this.buffer[current] = this.buffer[next];
    current++;
    next++;
  }

  this.end--;
  if (this.end < 0) this.end = this.buffer.length-1
}

Dequeue.prototype.push = function(element) {
  // push on this.end and then increase this.end
  // this.end should NEVER be equal to this.buffer.length
  this.buffer[this.end] = element;
  this.end++;
  if (this.end === this.buffer.length) this.end = 0;

  if (this.start === this.end) {
    // Resize
    var previousBuffer = this.buffer;

    this.buffer = new Array(previousBuffer.length*2);

    var i, k = 0;
    for(i=this.start; i<previousBuffer.length; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    for(i=0; i<this.start; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    this.start = 0;
    this.end = previousBuffer.length;
  }
}

Dequeue.prototype.pop = function(element) {
  //TODO: Decrease size when possible/needed? This may not be
  //something we really need/want
  // Return the element in this.end-1
  if (this.getLength() > 0) {
    var pos = this.end-1;
    if (pos < 0) pos = this.buffer.length-1;
    this.end = pos;
    var result = this.buffer[pos];
    this.buffer[pos] = undefined;
    return result;
  }
  else {
    return undefined
  }
}

Dequeue.prototype.unshift = function(element) {
  // push on this.start-1 and then decrease this.start.
  // this.end should NEVER be equal to this.buffer.length

  var pos = this.start-1;
  if (pos < 0) pos = this.buffer.length-1;

  this.buffer[pos] = element;
  this.start = pos;

  if (this.start === this.end) {
    //Resize
    var previousBuffer = this.buffer;

    this.buffer = new Array(previousBuffer.length*2);

    var i, k = 0;
    for(i=this.start; i<previousBuffer.length; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    for(i=0; i<this.start; i++) {
      this.buffer[k++] = previousBuffer[i];
    }
    this.start = 0;
    this.end = previousBuffer.length;
  }
}

Dequeue.prototype.shift = function() {
  // Return the element in this.start

  if (this.getLength() > 0) {
    var result = this.buffer[this.start];
    this.buffer[this.start] = undefined;
    this.start++;
    if (this.start === this.buffer.length) this.start = 0;
    return result;
  }
}

Dequeue.prototype.getLength = function() {
  if (this.start <= this.end) {
    return this.end-this.start;
  }
  else {
    return this.buffer.length-(this.start-this.end);
  }
}

module.exports = Dequeue;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/error.js":
/*!**************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/error.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var helper = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/helper.js */ "../node_modules/rethinkdbdash/lib/helper.js");
var INDENT = 4;
var LIMIT = 80;
var IS_OPERATIONAL = 'isOperational';

var protodef = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/protodef.js */ "../node_modules/rethinkdbdash/lib/protodef.js");
var responseTypes = protodef.Response.ResponseType;
var protoErrorType = protodef.Response.ErrorType;
var termTypes = protodef.Term.TermType;
var datumTypes = protodef.Datum.DatumType;
var frameTypes = protodef.Frame.FrameType;


function ReqlDriverError(message, query, secondMessage) {
  this.message = this.msg = message;
  Error.captureStackTrace(this, ReqlDriverError);

  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {
    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }
    
    this.message += ' after:\n';

    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

    this.message += backtrace.str;
  }
  else {
    if (this.message[this.message.length-1] !== '?') this.message += '.';
  }
  if (secondMessage) this.message += '\n'+secondMessage;
};
ReqlDriverError.prototype = new Error();
ReqlDriverError.prototype.name = 'ReqlDriverError';
ReqlDriverError.prototype.setOperational = function() {
  this[IS_OPERATIONAL] = true;
  return this;
};

module.exports.ReqlDriverError = ReqlDriverError;


function ReqlServerError(message, query) {
  this.message = this.msg = message;
  Error.captureStackTrace(this, ReqlServerError);

  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {
    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }
    
    this.message += ' for:\n';

    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});

    this.message += backtrace.str;
  }
  else {
    if (this.message[this.message.length-1] !== '?') this.message += '.';
  }
};
ReqlServerError.prototype = new Error();
ReqlServerError.prototype.name = 'ReqlServerError';
ReqlServerError.prototype[IS_OPERATIONAL] = true;

module.exports.ReqlServerError = ReqlServerError;


function ReqlRuntimeError(message, query, frames) {
  this.message = this.msg = message;
  Error.captureStackTrace(this, ReqlRuntimeError);

  if ((query != null) && (frames)) {
    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }
    
    this.message += ' in:\n';

    frames = frames.b;
    if (frames) this.frames = frames.slice(0);
    //this.frames = JSON.stringify(frames, null, 2);

    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

    var queryLines = backtrace.str.split('\n');
    var carrotLines = backtrace.car.split('\n');

    for(var i=0; i<queryLines.length; i++) {
      this.message += queryLines[i]+'\n';
      if (carrotLines[i].match(/\^/)) {
        var pos = queryLines[i].match(/[^\s]/);
        if ((pos) && (pos.index)) {
          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\n';
        }
        else {
          this.message += carrotLines[i]+'\n';
        }
      }
    }
  }
  //this.query = JSON.stringify(query, null, 2);
};
ReqlRuntimeError.prototype = new Error();
ReqlRuntimeError.prototype.name = 'ReqlRuntimeError';
ReqlRuntimeError.prototype.setName = function(type) {
  switch(type) {
    case protoErrorType.INTERNAL:
      this.name = 'ReqlInternalError';
      break;
    case protoErrorType.RESOURCE_LIMIT:
      this.name = 'ReqlResourceError';
      break;
    case protoErrorType.QUERY_LOGIC:
      this.name = 'ReqlLogicError';
      break;
    case protoErrorType.OP_FAILED:
      this.name = 'ReqlOpFailedError';
      break;
    case protoErrorType.OP_INDETERMINATE:
      this.name = 'ReqlOpIndeterminateError';
      break;
    case protoErrorType.USER:
      this.name = 'ReqlUserError';
      break;
    //default: // Do nothing
  }
}
ReqlRuntimeError.prototype[IS_OPERATIONAL] = true;

module.exports.ReqlRuntimeError = ReqlRuntimeError;


function ReqlCompileError(message, query, frames) {
  this.message = message;
  Error.captureStackTrace(this, ReqlCompileError);

  if ((query != null) && (frames)) {
    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {
      this.message = this.message.slice(0, this.message.length-1);
    }

    this.message += ' in:\n';

    frames = frames.b;
    if (frames) this.frames = frames.slice(0);
    //this.frames = JSON.stringify(frames, null, 2);

    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});

    var queryLines = backtrace.str.split('\n');
    var carrotLines = backtrace.car.split('\n');

    for(var i=0; i<queryLines.length; i++) {
      this.message += queryLines[i]+'\n';
      if (carrotLines[i].match(/\^/)) {
        var pos = queryLines[i].match(/[^\s]/);
        if ((pos) && (pos.index)) {
          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\n';
        }
        else {
          this.message += carrotLines[i]+'\n';
        }
      }
    }
  }
};
ReqlCompileError.prototype = new Error();
ReqlCompileError.prototype.name = 'ReqlCompileError';
ReqlCompileError.prototype[IS_OPERATIONAL] = true;

module.exports.ReqlCompileError = ReqlCompileError;


function ReqlClientError(message) {
  this.message = message;
  Error.captureStackTrace(this, ReqlClientError);
};
ReqlClientError.prototype = new Error();
ReqlClientError.prototype.name = 'ReqlClientError';
ReqlClientError.prototype[IS_OPERATIONAL] = true;

module.exports.ReqlClientError = ReqlClientError;



var _constants = {
  MONDAY: true,
  TUESDAY: true,
  WEDNESDAY: true,
  THURSDAY: true,
  FRIDAY: true,
  SATURDAY: true,
  SUNDAY: true,
  JANUARY: true,
  FEBRUARY: true,
  MARCH: true,
  APRIL: true,
  MAY: true,
  JUNE: true,
  JULY: true,
  AUGUST: true,
  SEPTEMBER: true,
  OCTOBER: true,
  NOVEMBER: true,
  DECEMBER: true,
  MINVAL: true,
  MAXVAL: true,
}
var constants = {};
for(var key in _constants) {
  constants[termTypes[key]] = true;
}


var _nonPrefix = {
  DB: true,
  DB_CREATE: true,
  DB_LIST: true,
  DB_DROP: true,
  JS: true,
  NOW: true,
  TIME: true,
  EPOCH_TIME: true,
  ISO8601: true,
  BRANCH: true,
  JAVASCRIPT: true,
  ERROR: true,
  MAKE_ARRAY: true,
  JSON: true,
  ARGS: true,
  HTTP: true,
  RANDOM: true,
  BINARY: true,
  OBJECT: true,
  CIRCLE: true,
  GEOJSON: true,
  POINT: true,
  LINE: true,
  POLYGON: true,
  UUID: true,
  DESC: true,
  ASC: true,
  RANGE: true,
  LITERAL: 'true'
}
var nonPrefix = {};
for(var key in _nonPrefix) {
  nonPrefix[termTypes[key]] = true;
}
// Constants are also in nonPrefix
for(var key in _constants) {
  nonPrefix[termTypes[key]] = true;
}


var _typeToString = {
  DB: 'db',
  DB_CREATE: 'dbCreate',
  DB_LIST: 'dbList',
  DB_DROP: 'dbDrop',
  TABLE_CREATE: 'tableCreate',
  TABLE_LIST: 'tableList',
  TABLE_DROP: 'tableDrop',
  TABLE: 'table',
  INDEX_CREATE: 'indexCreate',
  INDEX_DROP: 'indexDrop',
  INDEX_LIST: 'indexList',
  INDEX_WAIT: 'indexWait',
  INDEX_STATUS: 'indexStatus',
  INSERT: 'insert',
  UPDATE: 'update',
  REPLACE: 'replace',
  DELETE: 'delete',
  SYNC: 'sync',
  GET: 'get',
  GET_ALL: 'getAll',
  BETWEEN: 'between',
  FILTER: 'filter',
  INNER_JOIN: 'innerJoin',
  OUTER_JOIN: 'outerJoin',
  EQ_JOIN: 'eqJoin',
  ZIP: 'zip',
  MAP: 'map',
  WITH_FIELDS: 'withFields',
  CONCAT_MAP: 'concatMap',
  ORDER_BY: 'orderBy',
  DESC: 'desc',
  ASC: 'asc',
  SKIP: 'skip',
  LIMIT: 'limit',
  SLICE: 'slice',
  NTH: 'nth',
  OFFSETS_OF: 'offsetsOf',
  IS_EMPTY: 'isEmpty',
  UNION: 'union',
  SAMPLE: 'sample',
  REDUCE: 'reduce',
  COUNT: 'count',
  SUM: 'sum',
  AVG: 'avg',
  MIN: 'min',
  MAX: 'max',
  FOLD: 'fold',
  OBJECT: 'object',
  DISTINCT: 'distinct',
  GROUP: 'group',
  UNGROUP: 'ungroup',
  CONTAINS: 'contains',
  IMPLICIT_VAR: 'row',
  PLUCK: 'pluck',
  WITHOUT: 'without',
  MERGE: 'merge',
  APPEND: 'append',
  PREPEND: 'prepend',
  DIFFERENCE: 'difference',
  SET_INSERT: 'setInsert',
  SET_UNION: 'setUnion',
  SET_INTERSECTION: 'setIntersection',
  SET_DIFFERENCE: 'setDifference',
  HAS_FIELDS: 'hasFields',
  INSERT_AT: 'insertAt',
  SPLICE_AT: 'spliceAt',
  DELETE_AT: 'deleteAt',
  CHANGE_AT: 'changeAt',
  KEYS: 'keys',
  VALUES: 'values',
  MATCH: 'match',
  UPCASE: 'upcase',
  DOWNCASE: 'downcase',
  ADD: 'add',
  SUB: 'sub',
  MUL: 'mul',
  DIV: 'div',
  MOD: 'mod',
  AND: 'and',
  OR: 'or',
  EQ: 'eq',
  NE: 'ne',
  GT: 'gt',
  GE: 'ge',
  LT: 'lt',
  LE: 'le',
  NOT: 'not',
  FLOOR: 'floor',
  CEIL: 'ceil',
  ROUND: 'round',
  NOW: 'now',
  TIME: 'time',
  EPOCH_TIME: 'epochTime',
  ISO8601: 'ISO8601',
  IN_TIMEZONE: 'inTimezone',
  TIMEZONE: 'timezone',
  DURING: 'during',
  DATE: 'date',
  TIME_OF_DAY: 'timeOfDay',
  YEAR: 'year',
  MONTH: 'month',
  DAY: 'day',
  DAY_OF_WEEK: 'dayOfWeek',
  DAY_OF_YEAR: 'dayOfYear',
  HOURS: 'hours',
  MINUTES: 'minutes',
  SECONDS: 'seconds',
  TO_ISO8601: 'toISO8601',
  TO_EPOCH_TIME: 'toEpochTime',
  FUNCALL: 'do',
  BRANCH: 'branch',
  FOR_EACH: 'forEach',
  ERROR: 'error',
  DEFAULT: 'default',
  JAVASCRIPT: 'js',
  COERCE_TO: 'coerceTo',
  TYPE_OF: 'typeOf',
  INFO: 'info',
  JSON: 'json',
  ARGS: 'args',
  HTTP: 'http',
  RANDOM: 'random',
  CHANGES: 'changes',
  BINARY: 'binary',
  INDEX_RENAME: 'indexRename',
  CIRCLE: 'circle',
  DISTANCE: 'distance',
  FILL: 'fill',
  GEOJSON: 'geojson',
  TO_GEOJSON: 'toGeojson',
  GET_INTERSECTING: 'getIntersecting',
  GET_NEAREST: 'getNearest',
  INCLUDES: 'includes',
  INTERSECTS: 'intersects',
  LINE: 'line',
  POINT: 'point',
  POLYGON: 'polygon',
  POLYGON_SUB: 'polygonSub',
  UUID: 'uuid',
  RANGE: 'range',
  TO_JSON_STRING: 'toJSON',
  CONFIG: 'config',
  STATUS: 'status',
  WAIT: 'wait',
  RECONFIGURE: 'reconfigure',
  REBALANCE: 'rebalance',
  GRANT: 'grant',
  SPLIT: 'split',
  LITERAL: 'literal',
  MONDAY: 'monday',
  TUESDAY: 'tuesday',
  WEDNESDAY: 'wednesday',
  THURSDAY: 'thursday',
  FRIDAY: 'friday',
  SATURDAY: 'saturday',
  SUNDAY: 'sunday',
  JANUARY: 'january',
  FEBRUARY: 'february',
  MARCH: 'march',
  APRIL: 'april',
  MAY: 'may',
  JUNE: 'june',
  JULY: 'july',
  AUGUST: 'august',
  SEPTEMBER: 'september',
  OCTOBER: 'october',
  NOVEMBER: 'november',
  DECEMBER: 'december' ,
  MINVAL: 'minval',
  MAXVAL: 'maxval',
}
var typeToString = {};
for(var key in _typeToString) {
  typeToString[termTypes[key]] = _typeToString[key];
}

var _noPrefixOptargs = {
  ISO8601: true,
}
var noPrefixOptargs = {};
for(var key in _noPrefixOptargs) {
  noPrefixOptargs[termTypes[key]] = true;
}

var _specialType = {
  DATUM: function(term, index, father, frames, options, optarg) {
    optarg = optarg || false;

    var underline = Array.isArray(frames) && (frames.length === 0);
    var currentFrame, backtrace;
    if (Array.isArray(frames)) currentFrame = frames.shift();

    var result = {
      str: '',
      car: ''
    }

    if ((helper.isPlainObject(term)) && (term.$reql_type$ === 'BINARY')) {
      carify(result, 'r.binary(<Buffer>)', underline);
      return result;
    }

    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)

    if (typeof term === 'string' ) {
      carify(result, '"'+term+'"', underline);
    }
    else if (helper.isPlainObject(term)) {
      var totalKeys = Object.keys(term).length;
      if (totalKeys === 0) {
        carify(result, '{}', underline);
      }
      else {
        carify(result, '{\n', underline);
        var countKeys = 0;
        var extraToRemove = options.extra;
        options.indent += INDENT+options.extra;
        options.extra = 0;
        for(var key in term) {
          countKeys++;
          //if (!((father) && (Array.isArray(father[2])) && (Object.keys(father[2]).length > 0))) options.extra = 0;

          if (optarg) {
            carify(result, space(options.indent)+camelCase(key)+': ', underline);
          }
          else {
            carify(result, space(options.indent)+key+': ', underline);
          }
          if ((currentFrame != null) && (currentFrame === key)) {
            backtrace = generateBacktrace(term[key], i, term, frames, options);
          }
          else {
            backtrace = generateBacktrace(term[key], i, term, null, options);
          }
          result.str += backtrace.str;
          result.car += backtrace.car;
          
          if (countKeys !== totalKeys) { 
            carify(result, ',\n', underline);
          }

        }
        options.indent -= INDENT+extraToRemove;
        carify(result, '\n'+space(options.indent+extraToRemove)+'}', underline);
      }
    }
    else if (Array.isArray(term)) {
      carify(result, '[', underline);
      for(var i=0; i<term.length; i++) {
        if ((currentFrame != null) && (currentFrame === i)) {
          backtrace = generateBacktrace(term[i], i, term, frames, options);
        }
        else {
          backtrace = generateBacktrace(term[i], i, term, null, options);
        }
        result.str += backtrace.str;
        result.car += backtrace.car;
      }
      carify(result, ']', underline);
    }
    else {
      carify(result, ''+term, underline);
    }

    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, ')', underline);

    if (underline) result.car = result.str.replace(/./g, '^');

    return result;
  },
  TABLE: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    }
    var backtrace, underline, currentFrame;


    if ((term.length === 1) || (term[1].length === 0) || (term[1][0][0] !== termTypes.DB)) {
      var underline = Array.isArray(frames) && (frames.length === 0);
      if (Array.isArray(frames)) currentFrame = frames.shift();

      carify(result, 'r.'+typeToString[term[0]]+'(', underline);
      if (Array.isArray(term[1])) {
        for(var i=0; i<term[1].length; i++) {
          if (i !==0) result.str += ', ';


          if ((currentFrame != null) && (currentFrame === 1)) {
            // +1 for index because it's like if there was a r.db(...) before .table(...)
            backtrace = generateBacktrace(term[1][i], i+1, term, frames, options)
          }
          else {
            backtrace = generateBacktrace(term[1][i], i+1, term, null, options)
          }
          result.str += backtrace.str;
          result.car += backtrace.car
        }
      }

      backtrace = makeOptargs(term, i, term, frames, options, currentFrame)
      result.str += backtrace.str;
      result.car += backtrace.car;

      carify(result, ')', underline);

      if (underline) result.car = result.str.replace(/./g, '^');
    }
    else {
      backtrace = generateNormalBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }

    return result;
  },
  GET_FIELD: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    }
    var backtrace, underline, currentFrame;

    var underline = Array.isArray(frames) && (frames.length === 0);
    if (Array.isArray(frames)) currentFrame = frames.shift();

    if ((currentFrame != null) && (currentFrame === 0)) {
      backtrace = generateBacktrace(term[1][0], 0, term, frames, options)
    }
    else {
      backtrace = generateBacktrace(term[1][0], 0, term, null, options)
    }
    result.str = backtrace.str;
    result.car = backtrace.car;

    carify(result, '(', underline);

    if ((currentFrame != null) && (currentFrame === 1)) {
      backtrace = generateBacktrace(term[1][1], 1, term, frames, options)
    }
    else {
      backtrace = generateBacktrace(term[1][1], 1, term, null, options)
    }
    result.str += backtrace.str;
    result.car += backtrace.car;

    carify(result, ')', underline);

    if (underline) result.car = result.str.replace(/./g, '^');

    return result;
  },
  MAKE_ARRAY: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    };
    var backtrace, underline, currentFrame;

    var underline = Array.isArray(frames) && (frames.length === 0);
    if (Array.isArray(frames)) currentFrame = frames.shift();

    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)

    if (!((options) && (options.noBracket))) {
      carify(result, '[', underline);
    }
    for(var i=0; i<term[1].length; i++) {
      if (i !== 0) {
        carify(result, ', ', underline);
      }

      if ((currentFrame != null) && (currentFrame  === i)) {
        backtrace = generateBacktrace(term[1][i], i, term, frames, options);
      }
      else {
        backtrace = generateBacktrace(term[1][i], i, term, null, options);
      }
      result.str += backtrace.str;
      result.car += backtrace.car;

    }

    if (!((options) && (options.noBracket))) {
      carify(result, ']', underline);
    }

    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) {
      carify(result, ')', underline);
    }

    if (underline) result.car = result.str.replace(/./g, '^');

    return result;
  },
  FUNC: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    };
    var backtrace, underline, currentFrame;

    var underline = Array.isArray(frames) && (frames.length === 0);
    if (Array.isArray(frames)) currentFrame = frames.shift();

    if ((term[1][0][1].length === 1) && (helper.hasImplicit(term[1][1]))) {
      if ((currentFrame != null) && (currentFrame === 1)) {
        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);
      }
      else {
        backtrace = generateBacktrace(term[1][1], 1, term, null, options);
      }
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else {
      carify(result, 'function(', underline);

      for(var i=0; i<term[1][0][1].length; i++) {
        if (i !== 0) {
          carify(result, ', ', underline);
        }
        carify(result, 'var_'+term[1][0][1][i], underline);
      }

      options.indent += INDENT+options.extra;
      var extraToRemove = options.extra;
      options.extra = 0;
      //if (!((Array.isArray(term[2])) && (term[2].length > 0))) options.extra = 0;

      carify(result, ') {\n'+space(options.indent)+'return ', underline);

      if ((currentFrame != null) && (currentFrame === 1)) {
        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);
      }
      else {
        backtrace = generateBacktrace(term[1][1], 1, term, null, options);
      }

      result.str += backtrace.str;
      result.car += backtrace.car;

      options.indent -= INDENT+extraToRemove;
      options.extra = extraToRemove;

      carify(result, '\n'+space(options.indent+extraToRemove)+'}', underline);

    }

    if (underline) result.car = result.str.replace(/./g, '^');

    return result;
  },
  VAR: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    }
    var backtrace, underline, currentFrame;

    var underline = Array.isArray(frames) && (frames.length === 0);
    if (Array.isArray(frames)) currentFrame = frames.shift();

    carify(result, 'var_'+term[1][0], underline);

    if (underline) result.car = result.str.replace(/./g, '^');
    return result;
  },
  FUNCALL: function(term, index, father, frames, options) {
    // The syntax is args[1].do(args[0])
    var result = {
      str: '',
      car: ''
    };
    var backtrace, underline, currentFrame;

    var underline = Array.isArray(frames) && (frames.length === 0);
    if (Array.isArray(frames)) currentFrame = frames.shift();

    if (term[1].length === 2) {
      if ((currentFrame != null) && (currentFrame === 1)) {
        backtrace = generateBacktrace(term[1][1], 0, term, frames, options);
      }
      else {
        backtrace = generateBacktrace(term[1][1], 0, term, null, options);
      }
      result.str = backtrace.str;
      result.car = backtrace.car;

      carify(result, '.do(', underline);
    }
    else {
      carify(result, 'r.do(', underline);

      for(var i=1; i<term[1].length; i++) {
        if ((currentFrame != null) && (currentFrame === i)) {
          backtrace = generateBacktrace(term[1][i], i, term, frames, options);
        }
        else {
          backtrace = generateBacktrace(term[1][i], i, term, null, options);
        }
        result.str += backtrace.str;
        result.car += backtrace.car;

        if (i !== term[1].length) {
          carify(result, ', ' , underline);
        }
      }
    }

    if ((currentFrame != null) && (currentFrame === 0)) {
      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);
    }
    else {
      backtrace = generateBacktrace(term[1][0], 0, term, null, options);
    }
    result.str += backtrace.str;
    result.car += backtrace.car;

    carify(result, ')', underline);

    if (underline) result.car = result.str.replace(/./g, '^');

    return result;
  },
  IMPLICIT_VAR: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    }
    var backtrace, underline, currentFrame;

    var underline = Array.isArray(frames) && (frames.length === 0);
    if (Array.isArray(frames)) currentFrame = frames.shift();

    carify(result, 'r.row', underline);

    if (underline) result.car = result.str.replace(/./g, '^');
    return result;
  },
  WAIT: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    }
    var backtrace, underline, currentFrame;

    if (term.length === 1 || term[1].length === 0) {
      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else {
      backtrace = generateNormalBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    return result;
  },
  MAP: function(term, index, father, frames, options) {
    var result = {
      str: '',
      car: ''
    }
    var backtrace, underline, currentFrame;

    if (term.length > 1 && term[1].length > 2) {
      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else {
      backtrace = generateNormalBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    return result;
  },
}
_specialType.TABLE_CREATE = _specialType.TABLE;
_specialType.TABLE_DROP = _specialType.TABLE;
_specialType.TABLE_LIST = _specialType.TABLE;
_specialType.RECONFIGURE = _specialType.WAIT;
_specialType.REBALANCE = _specialType.WAIT;
_specialType.BRACKET = _specialType.GET_FIELD;

var specialType = {};
for(var key in _specialType) {
  specialType[termTypes[key]] = _specialType[key];
}


function space(n) {
  return new Array(n+1).join(' ');
}
function carify(result, str, underline) {
  if (underline === true) {
    result.str += str;
    result.car += str.replace(/[^\n]/g, '^');
  }
  else {
    result.str += str;
    result.car += str.replace(/[^\n]/g, ' ');
  }
}
function makeOptargs(term, index, father, frames, options, currentFrame) {
  var result = {
    str: '',
    car: ''
  }
  var backtrace, currentFrame, underline;

  if (helper.isPlainObject(term[2])) {
    //if ((currentFrame != null) && (frames != null)) frames.unshift(currentFrame);

    //underline = Array.isArray(frames) && (frames.length === 0);
    var underline = false;
    //if (Array.isArray(frames)) currentFrame = frames.shift();

    // This works before there is no prefix term than can be called with no normal argument but with an optarg
    if (Array.isArray(term[1]) && (term[1].length > 1)) {
      carify(result, ', ' , underline);
    }
    else if (Array.isArray(term[1]) && (term[1].length > 0) && (noPrefixOptargs[term[0]])) {
      carify(result, ', ' , underline);
    }

    backtrace = specialType[termTypes.DATUM](term[2], index, term[2], frames, options, true);

    result.str += backtrace.str;
    result.car += backtrace.car;

    if (underline) result.car = result.str.replace(/./g, '^');
  }

  return result;
}
function generateNormalBacktrace(term, index, father, frames, options) {
  var result = {
    str: '',
    car: ''
  }
  var backtrace, currentFrame, underline;

  //if (term[1]) {
    var underline = Array.isArray(frames) && (frames.length === 0);
    if (Array.isArray(frames)) currentFrame = frames.shift();

    if ((currentFrame != null) && (currentFrame === 0)) {
      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);
    }
    else {
      backtrace = generateBacktrace(term[1][0], 0, term, null, options);
    }
    result.str = backtrace.str;
    result.car = backtrace.car;

    var lines = backtrace.str.split('\n');
    var line = lines[lines.length-1];
    var pos = line.match(/[^\s]/);
    pos = (pos) ? pos.index : 0;

    if (line.length-pos > LIMIT) {
      if (options.extra === 0) options.extra += INDENT;
      carify(result, '\n'+space(options.indent+options.extra) , underline);
    }

    carify(result, '.'+typeToString[term[0]]+'(' , underline);
    options.indent += options.extra;
    var extraToRemove = options.extra;
    options.extra = 0;

    for(var i=1; i<term[1].length; i++) {
      if (i !== 1) {
        carify(result, ', ' , underline);
      }
      if ((currentFrame != null) && (currentFrame === i)) {
        backtrace = generateBacktrace(term[1][i], i, term, frames, options);
      }
      else {
        backtrace = generateBacktrace(term[1][i], i, term, null, options);
      }
      result.str += backtrace.str;
      result.car += backtrace.car;
    }

    backtrace = makeOptargs(term, i, term, frames, options, currentFrame)
    result.str += backtrace.str;
    result.car += backtrace.car;

    options.indent -= extraToRemove;
    options.extra = extraToRemove;

    carify(result, ')' , underline);

    if (underline) result.car = result.str.replace(/./g, '^');
  /*
  }
  else {
    throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 1 --\n'+JSON.stringify(term, null, 2))
  }
  */


  return result;
}

function generateWithoutPrefixBacktrace(term, index, father, frames, options) {
  var result = {
    str: '',
    car: ''
  }

  var backtrace, currentFrame, underline;

  var underline = Array.isArray(frames) && (frames.length === 0);
  if (Array.isArray(frames)) currentFrame = frames.shift();

  if (constants[term[0]]) {
    carify(result, 'r.'+typeToString[term[0]], underline); 
    return result;
  }

  carify(result, 'r.'+typeToString[term[0]]+'(', underline); 

  if (Array.isArray(term[1])) {
    for(var i=0; i<term[1].length; i++) {
      if (i !== 0) carify(result, ', ', underline)

      if ((currentFrame != null) && (currentFrame === i)) {
        backtrace = generateBacktrace(term[1][i], i, term, frames, options)
      }
      else {
        backtrace = generateBacktrace(term[1][i], i, term, null, options)
      }
      result.str += backtrace.str;
      result.car += backtrace.car;
    }
  }

  backtrace = makeOptargs(term, i, term, frames, options, currentFrame)
  result.str += backtrace.str;
  result.car += backtrace.car;

  carify(result, ')', underline);

  if (underline) result.car = result.str.replace(/./g, '^');

  return result;
}

function generateBacktrace(term, index, father, frames, options) {
  var result = {
    str: '',
    car: ''
  }
  var backtrace, currentFrame, underline;

  // frames = null -> do not underline
  // frames = [] -> underline

  if (Array.isArray(term)) {
    if (term.length === 0) {
      var underline = Array.isArray(frames) && (frames.length === 0);
      carify(result, 'undefined', underline);
    }
    else if (specialType[term[0]]) {
      backtrace = specialType[term[0]](term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else if (nonPrefix[term[0]]) {
      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
    else { // normal type -- this.<method>( this.args... )
      backtrace = generateNormalBacktrace(term, index, father, frames, options);
      result.str = backtrace.str;
      result.car = backtrace.car;
    }
  }
  else if (term !== undefined) {
    backtrace = specialType[termTypes.DATUM](term, index, father, frames, options);

    result.str = backtrace.str;
    result.car = backtrace.car;
  }
  else {
    //throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 2')
  }
  return result;
}

function camelCase(str) {
  return str.replace(/_(.)/g, function (m, char) { return char.toUpperCase() });
}
module.exports.generateBacktrace = generateBacktrace;

module.exports.setOperational = function(error) {
  error[IS_OPERATIONAL] = true;
  return error;
};



/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/helper.js":
/*!***************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/helper.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var protodef = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/protodef.js */ "../node_modules/rethinkdbdash/lib/protodef.js");
var termTypes = protodef.Term.TermType;
var datumTypes = protodef.Datum.DatumType;
var net = __webpack_require__(/*! net */ "net");


function createLogger(poolMaster, silent) {
  return function(message) {
    if (silent !== true) {
      console.error(message);
    }
    poolMaster.emit('log', message);
  }
}
module.exports.createLogger = createLogger;

function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
module.exports.isPlainObject = isPlainObject;

function toArray(args) {
  return Array.prototype.slice.call(args);
}
module.exports.toArray = toArray;

function hasImplicit(arg) {
  if (Array.isArray(arg)) {
    if (arg[0] === termTypes.IMPLICIT_VAR) return true;

    if (Array.isArray(arg[1])) {
      for(var i=0; i<arg[1].length; i++) {
        if (hasImplicit(arg[1][i])) return true;
      }
    }
    if (isPlainObject(arg[2])) {
      for(var key in arg[2]) {
        if (hasImplicit(arg[2][key])) return true;
      }
    }
  }
  else if (isPlainObject(arg)) {
    for(var key in arg) {
      if (hasImplicit(arg[key])) return true;
    }
  }
  return false;
}
module.exports.hasImplicit = hasImplicit;

function loopKeys(obj, fn) {
  var keys = Object.keys(obj);
  var result;
  var keysLength = keys.length;
  for(var i=0; i<keysLength; i++) {
    result = fn(obj, keys[i]);
    if (result === false) return;
  }
}
module.exports.loopKeys = loopKeys;

function convertPseudotype(obj, options) {
  var reqlType = obj['$reql_type$'];
  if (reqlType === 'TIME' && options['timeFormat'] !== 'raw') {
    return new Date(obj['epoch_time'] * 1000);
  }
  else if (reqlType === 'GROUPED_DATA' && options['groupFormat'] !== 'raw') {
    var result = [];
    for (var i = 0, len = obj['data'].length, ref; i < len; i++) {
      ref = obj.data[i];
      result.push({
        group: ref[0],
        reduction: ref[1]
      });
    }
    return result;
  }
  else if (reqlType === 'BINARY' && options['binaryFormat'] !== 'raw') {
    return new Buffer(obj['data'], 'base64');
  }
  return obj;
}
function recursivelyConvertPseudotype(obj, options) {
  var i, value, len, key;
  if (Array.isArray(obj)) {
    for (i = 0, len = obj.length; i < len; i++) {
      value = obj[i];
      obj[i] = recursivelyConvertPseudotype(value, options);
    }
  }
  else if (obj && typeof obj === 'object') {
    for (key in obj) {
      value = obj[key];
      obj[key] = recursivelyConvertPseudotype(value, options);
    }
    obj = convertPseudotype(obj, options);
  }
  return obj;
}
function makeAtom(response, options) {
  options = options || {};
  return recursivelyConvertPseudotype(response.r[0], options);
}
module.exports.makeAtom = makeAtom;

function makeSequence(response, options) {
  options = options || {};
  return recursivelyConvertPseudotype(response.r, options);
}

module.exports.makeSequence = makeSequence;

function changeProto(object, other) {
  object.__proto__ = other.__proto__;
}
module.exports.changeProto = changeProto;

// Try to extract the most global address
// Note: Mutate the input
function getCanonicalAddress(addresses) {
  // We suppose that the addresses are all valid, and therefore use loose regex
  for(var i=0; i<addresses.length; i++) {
    var addresse = addresses[i];
    if ((/^127(\.\d{1,3}){3}$/.test(addresse.host)) || (/0?:?0?:?0?:?0?:?0?:?0?:0?:1/.test(addresse.host))) {
      addresse.value = 0;
    }
    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[eE]80:.*\:.*\:/.test(addresse.host))) {
      addresse.value = 1;
    }
    else if (/^169\.254\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 2;
    }
    else if (/^192\.168\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 3;
    }
    else if (/^172\.(1\d|2\d|30|31)\.\d{1,3}\.\d{1,3}$/.test(addresse.host)) {
      addresse.value = 4;
    }
    else if (/^10(\.\d{1,3}){3}$/.test(addresse.host)) {
      addresse.value = 5;
    }
    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[cCdD].*\:.*\:/.test('addresse.host'))) {
      addresse.value = 6;
    }
    else {
      addresse.value = 7;
    }
  }
  var result = addresses[0];
  var max = addresses[0].value;
  for(var i=0; i<addresses.length; i++) {
    if (addresses[i].value > max) {
      result = addresses[i];
      max = addresses[i].value;
    }
  }
  return result;
}
module.exports.getCanonicalAddress = getCanonicalAddress;


module.exports.localhostAliases = {
  'localhost': true,
  '127.0.0.1': true,
  '::1': true
}

module.exports.tryCatch = function tryCatch(toTry, handleError) {
  try{
  toTry()
  }
  catch(err) {
  handleError(err)
  }
}

function splitCommaEqual(message) {
  var result = {};
  var messageParts = message.split(',');
  for(var i=0; i<messageParts.length; i++) {
    var equalPosition = messageParts[i].indexOf("=")
    result[messageParts[i].slice(0, equalPosition)] = messageParts[i].slice(equalPosition+1);
  }
  return result;
}
module.exports.splitCommaEqual = splitCommaEqual;

function xorBuffer(a, b) {
  var result = [];
  var len = Math.min(a.length, b.length)
  for(var i=0; i<len; i++) {
    result.push(a[i] ^ b[i]);
  }
  return new Buffer(result);
}
module.exports.xorBuffer = xorBuffer;

function compareDigest(a, b) {
  var left = undefined
  var right = b
  var result = undefined
  if (a.length === b.length) {
    left = a
    result = 0
  } else {
    left = b
    result = 1
  }
  var len = Math.min(a.length, b.length);
  for(var i=0; i<len; i++) {
    result |= a[i] ^b[i]
  }
  return result === 0
}
module.exports.compareDigest = compareDigest;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/index.js":
/*!**************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(/*! bluebird */ "bluebird");

var helper = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/helper.js */ "../node_modules/rethinkdbdash/lib/helper.js");
var Connection = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/connection.js */ "../node_modules/rethinkdbdash/lib/connection.js");
var Term = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/term.js */ "../node_modules/rethinkdbdash/lib/term.js");
var Error = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/error.js */ "../node_modules/rethinkdbdash/lib/error.js");
var PoolMaster = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/pool_master.js */ "../node_modules/rethinkdbdash/lib/pool_master.js");
var termTypes = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/protodef.js */ "../node_modules/rethinkdbdash/lib/protodef.js").Term.TermType;

function r() {
  var self = this;
  var _r = function(x) {
    return new Term(_r).expr(x);
  }
  helper.changeProto(_r, self);

  Term.prototype._setNestingLevel(r.prototype.nestingLevel);
  Term.prototype._setArrayLimit(r.prototype.arrayLimit);

  _r.row = new Term(_r).row();

  _r.monday = new Term(_r).monday();
  _r.tuesday = new Term(_r).tuesday();
  _r.wednesday = new Term(_r).wednesday();
  _r.thursday = new Term(_r).thursday();
  _r.friday = new Term(_r).friday();
  _r.saturday = new Term(_r).saturday();
  _r.sunday =  new Term(_r).sunday();

  _r.january = new Term(_r).january();
  _r.february = new Term(_r).february();
  _r.march = new Term(_r).march();
  _r.april = new Term(_r).april();
  _r.may = new Term(_r).may();
  _r.june = new Term(_r).june();
  _r.july = new Term(_r).july();
  _r.august = new Term(_r).august();
  _r.september = new Term(_r).september();
  _r.october = new Term(_r).october();
  _r.november = new Term(_r).november();
  _r.december = new Term(_r).december();
  _r.minval = new Term(_r).minval();
  _r.maxval = new Term(_r).maxval();

  _r.nextVarId = 1;
  _r._Term = Term;
  return _r;
};
r.prototype._host = 'localhost';
r.prototype._port = 28015;
r.prototype._authKey = '';
r.prototype._user = 'admin';
r.prototype._password = '';
r.prototype._timeoutConnect = 20; // seconds
r.prototype._pingInterval = -1; // seconds

r.prototype._nestingLevel = 100;
r.prototype._arrayLimit = 100000;
r.prototype._db = 'test';
r.prototype._useOutdated = false;
r.prototype._timeFormat = 'native';
r.prototype._profile = false;


r.prototype.setNestingLevel = function(nestingLevel) {
  if (typeof nestingLevel !== 'number') throw new Error.ReqlDriverError('The first argument of `setNestingLevel` must be a number.')
  this.nestingLevel = nestingLevel;
}
r.prototype.setArrayLimit = function(arrayLimit) {
  if (typeof arrayLimit !== 'number') throw new Error.ReqlDriverError('The first argument of `setArrayLimit` must be a number.')
  this.arrayLimit = arrayLimit;
}

r.prototype.connect = function(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  var self = this;

  var p = new Promise(function(resolve, reject) {
    new Connection(self, options, resolve, reject);
  }).nodeify(callback);
  return p;
};

r.prototype.createPools = function(options) {
  this._poolMaster = new PoolMaster(this, options);
  return this;
}

r.prototype.getPoolMaster = function() {
  return this._poolMaster;
}
r.prototype.getPool = function(i) {
  if (i === undefined) {
    if (this.getPoolMaster().getPools().length === 1) {
      return this.getPoolMaster().getPools()[0];
    }
    else {
      throw new Error('You have multiple pools. Use `getPool(index)` or `getPools()`');
    }
  }
  else {
    return this.getPoolMaster().getPools()[i];
  }
}

r.prototype.expr = function(expression, nestingLevel) {
  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 1, 2, 'expr', this);
  }
  var _nestingLevel = nestingLevel || this.nestingLevel;
  return new Term(this).expr(expression, _nestingLevel);
};
r.prototype.db = function(db) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.db', this);
  }
  return new Term(this).db(db);
};
r.prototype.table = function(table, options) {
  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 1, 2, 'table', this);
  }
  return new Term(this).table(table, options);
};
r.prototype.js = function(jsString, options) {
  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 1, 2, 'r.js', this);
  }
  return new Term(this).js(jsString, options);
};
r.prototype.tableCreate = function(table, options) {
  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 1, 2, 'r.tableCreate', this);
  }
  return new Term(this).tableCreate(table, options);
};
r.prototype.tableDrop = function(db) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.tableDrop', this);
  }
  return new Term(this).tableDrop(db);
};
r.prototype.tableList = function() {
  if (Term.prototype._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 0, 'r.tableList', this);
  }
  return new Term(this).tableList();
};
r.prototype.dbCreate = function(db) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'dbCreate', this);
  }
  return new Term(this).dbCreate(db);
};
r.prototype.dbDrop = function(db) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'dbDrop', this);
  }
  return new Term(this).dbDrop(db);
};
r.prototype.dbList = function() {
  if (Term.prototype._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 0, 'dbList', this);
  }
  return new Term(this).dbList();
};
r.prototype.literal = function(obj) {
  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 1, 2, 'r.literal', this);
  }
  if (obj === undefined) {
    return new Term(this).literal();
  }
  else {
    return new Term(this).literal(obj);
  }
};
r.prototype.desc = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.desc', this);
  }
  return new Term(this).desc(field);
};
r.prototype.asc = function(field) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.asc', this);
  }
  return new Term(this).asc(field);
};
r.prototype.union = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this).expr(_args[0]);
  return term.union.apply(term, _args.slice(1));
};
r.prototype.add = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.add', this);

  var term = new Term(this).expr(_args[0]);
  return term.add.apply(term, _args.slice(1));
};
r.prototype.sub = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.sub', this);

  var term = new Term(this).expr(_args[0]);
  return term.sub.apply(term, _args.slice(1));
};
r.prototype.div = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.div', this);

  var term = new Term(this).expr(_args[0]);
  return term.div.apply(term, _args.slice(1));
};
r.prototype.mul = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.mul', this);

  var term = new Term(this).expr(_args[0]);
  return term.mul.apply(term, _args.slice(1));
};
r.prototype.mod = function(a, b) {
  if (Term.prototype._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 2, 'r.mod', this);
  }

  return new Term(this).expr(a).mod(b);
};
r.prototype.and = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this);
  return term.and.apply(term, _args);
};
r.prototype.or = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this);
  return term.or.apply(term, _args);
};
r.prototype.eq = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.eq', this);

  var term = new Term(this).expr(_args[0]);
  return term.eq.apply(term, _args.slice(1));
};
r.prototype.ne = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.ne', this);

  var term = new Term(this).expr(_args[0]);
  return term.ne.apply(term, _args.slice(1));
};
r.prototype.gt = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.gt', this);

  var term = new Term(this).expr(_args[0]);
  return term.gt.apply(term, _args.slice(1));
};
r.prototype.ge = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.ge', this);

  var term = new Term(this).expr(_args[0]);
  return term.ge.apply(term, _args.slice(1));
};
r.prototype.lt = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.lt', this);

  var term = new Term(this).expr(_args[0]);
  return term.lt.apply(term, _args.slice(1));
};
r.prototype.le = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.le', this);

  var term = new Term(this).expr(_args[0]);
  return term.le.apply(term, _args.slice(1));
};
r.prototype.not = function(bool) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.not', this);
  }
  return new Term(this).expr(bool).not();
}
r.prototype.floor = function(num) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.floor', this);
  }
  return new Term(this).expr(num).floor();
}
r.prototype.ceil = function(num) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.ceil', this);
  }
  return new Term(this).expr(num).ceil();
}
r.prototype.round = function(num) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.round', this);
  }
  return new Term(this).expr(num).round();
}


r.prototype.now = function() {
  if (Term.prototype._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 0, 'now', this);
  }
  return new Term(this).now();
}
r.prototype.time = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this);
  return term.time.apply(term, _args);
}
r.prototype.epochTime = function(epochTime) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.epochTime', this);
  }
  return new Term(this).epochTime(epochTime);
}
r.prototype.ISO8601 = function(isoTime, options) {
  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 1, 2, 'r.ISO8601', this);
  }
  return new Term(this).ISO8601(isoTime, options);
}
r.prototype.branch = function(predicate, trueBranch, falseBranch) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 3, Infinity, 'r.branch', this);

  var term = new Term(this).expr(predicate);
  return term.branch.apply(term, _args.slice(1));
}
r.prototype.error = function(errorStr) {
  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 0, 1, 'r.error', this);
  }
  var term = new Term(this);
  term._query.push(termTypes.ERROR);
  if (errorStr !== undefined) {
    term._query.push([new Term(this).expr(errorStr)._query]);
  }
  return term;

}
r.prototype.json = function(json) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.json', this);
  }
  return new Term(this).json(json);
}

r.prototype.object = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this);
  return term.object.apply(term, _args);
}
r.prototype.args = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this);
  return term.args.apply(term, _args);
}
r.prototype.random = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this);
  return term.random.apply(term, _args);
}
r.prototype.http = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this);
  return term.http.apply(term, _args);
}
r.prototype.do = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, Infinity, 'r.do', this);

  var term = new Term(this).expr(_args[0]);
  return term.do.apply(term, _args.slice(1));
}
r.prototype.binary = function(bin) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.binary', this);
  }
  var term = new Term(this);
  return term.binary(bin);
}
r.prototype.uuid = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 0, 1, 'r.uuid', this);
  var term = new Term(this);
  return term.uuid(_args[0]);
}

r.prototype.line = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, Infinity, 'r.line', this);

  var term = new Term(this);
  return term.line.apply(term, _args);
}
r.prototype.point = function(longitude, latitude) {
  if (Term.prototype._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 2, 'r.point', this);
  }
  return new Term(this).point(longitude, latitude);
}
r.prototype.polygon = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 3, Infinity, 'r.polygon', this);

  var term = new Term(this);
  return term.polygon.apply(term, _args);
}
r.prototype.circle = function(center, radius, options) {
  if (Term.prototype._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arityRange(_args, 2, 3, 'r.circle', this);
  }
  var term = new Term(this);
  if (options !== undefined) {
    return term.circle(center, radius, options);
  }
  else {
    return term.circle(center, radius);
  }
}
r.prototype.geojson = function(value) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.geojson', this);
  }
  var term = new Term(this);
  return term.geojson(value);
}
r.prototype.distance = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 2, 3, 'r.add', this);

  var term = new Term(this).expr(_args[0]);
  return term.distance.apply(term, _args.slice(1));
};

r.prototype.range = function(start, end) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, 2, 'r.range', this);

  var term = new Term(this);
  if (end !== undefined) {
    return term.range(start, end);
  }
  else {
    return term.range(start);
  }
}
r.prototype.wait = function() {
  // `wait` on the top level has been removed in 2.3.
  throw new Error.ReqlDriverError('`wait` can only be called on a table or a database since 2.3');
}
r.prototype.reconfigure = function(config) {
  // `reconfigure` on the top level has been removed in 2.3.
  throw new Error.ReqlDriverError('`reconfigure` can only be called on a table or a database since 2.3');
}
r.prototype.rebalance = function(config) {
  // `rebalance` on the top level has been removed in 2.3.
  throw new Error.ReqlDriverError('`rebalance` can only be called on a table or a database since 2.3');
}
r.prototype.map = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, Infinity, 'r.map', this);

  var term = new Term(this);
  return term.map.apply(term, _args);
};
r.prototype.typeOf = function(value) {
  if (Term.prototype._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    Term.prototype._arity(_args, 1, 'r.typeOf', this);
  }
  var term = new Term(this);
  return term.expr(value).typeOf();
}
r.prototype.min = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, Infinity, 'r.min', this);
  var term = new Term(this).expr(_args[0]);
  return term.min.apply(term, _args.slice(1));
}
r.prototype.max = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, Infinity, 'r.max', this);
  var term = new Term(this).expr(_args[0]);
  return term.max.apply(term, _args.slice(1));
}
r.prototype.sum = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, Infinity, 'r.sum', this);
  var term = new Term(this).expr(_args[0]);
  return term.sum.apply(term, _args.slice(1));
}
r.prototype.avg = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, Infinity, 'r.avg', this);
  var term = new Term(this).expr(_args[0]);
  return term.avg.apply(term, _args.slice(1));
}
r.prototype.distinct = function(value) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  Term.prototype._arityRange(_args, 1, Infinity, 'r.distinct', this);
  var term = new Term(this).expr(_args[0]);
  return term.distinct.apply(term, _args.slice(1));
}


r.prototype.Error = Error;


function main(options) {
  var _r = new r();

  if (!helper.isPlainObject(options)) options = {};
  if (options.pool !== false) _r.createPools(options);
  _r._options = {};
  if (options.cursor === true) _r._options.cursor = true;
  if (options.stream === true) _r._options.stream = true;
  if (options.optionalRun === false) {
    delete _r._Term.prototype.then
    delete _r._Term.prototype.error
    delete _r._Term.prototype.catch
    delete _r._Term.prototype.finally
  }
  return _r;
}
module.exports = main;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/metadata.js":
/*!*****************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/metadata.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Metadata we keep per query
function Metadata(resolve, reject, query, options) {
  this.resolve = resolve;
  this.reject = reject;
  this.query = query; // The query in case we have to build a backtrace
  this.options = options || {};
  this.cursor = false;
}

Metadata.prototype.setCursor = function() {
  this.cursor = true;
}

Metadata.prototype.setEnd = function(resolve, reject) {
  this.endResolve = resolve;
  this.endReject = reject;
}

Metadata.prototype.setCallbacks = function(resolve, reject) {
  this.resolve = resolve;
  this.reject = reject;
}
Metadata.prototype.removeCallbacks = function() {
  this.resolve = null;
  this.reject = null;
}
Metadata.prototype.removeEndCallbacks = function() {
  this.endResolve = null;
  this.endReject = null;
}

module.exports = Metadata;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/pool.js":
/*!*************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/pool.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var Dequeue = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/dequeue.js */ "../node_modules/rethinkdbdash/lib/dequeue.js");
var helper = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/helper.js */ "../node_modules/rethinkdbdash/lib/helper.js");
var Err = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/error.js */ "../node_modules/rethinkdbdash/lib/error.js");
var events = __webpack_require__(/*! events */ "events");
var util = __webpack_require__(/*! util */ "util");

function Pool(r, options) {
  this._r = r;

  if (!helper.isPlainObject(options)) options = {};
  this.options = {};
  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take
  var buffer = (typeof options.buffer === 'number') ? options.buffer : 50;
  this.options.buffer = (buffer < this.options.max) ? buffer : this.options.max;
  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out after one hour.
  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  this.options.silent = options.silent || false;

  this.options.connection = {
    host: options.host || this._r._host,
    port: options.port || this._r._port,
    db: options.db || this._r._db,
    timeout: options.timeout || this._r._timeoutConnect,
    authKey: options.authKey,
    user: options.user,
    password: options.password,
    cursor: options.cursor || false,
    stream: options.stream || false,
    ssl: options.ssl || false,
    pingInterval: options.pingInterval || this._r._pingInterval
  }
  this._log = options._log;

  this._pool = new Dequeue(this.options.buffer+1);
  this._draining = false;
  this._drainingHandlers = null; // Store the resolve/reject methods once draining is called
  this._localhostToDrain = 0; // number of connections to "localhost" to remove
  this._connectionToReplace = 0; // number of connections to "localhost" to remove

  this._numConnections = 0;
  this._openingConnections = 0; // Number of connections being opened
  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection
  this._slowGrowth = false;     // Opening one connection at a time
  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode
  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close

  this._empty = true;

  var self = this;
  // So we can let the pool master bind listeners
  setTimeout(function() {
    if (self._draining === false) {
      for(var i=0; i<self.options.buffer; i++) {
        if (self.getLength() < self.options.max) {
          self.createConnection();
        }
      }
    }
  }, 0);
  this.id = Math.floor(Math.random()*100000);
  this._log('Creating a pool connected to '+this.getAddress());
}

util.inherits(Pool, events.EventEmitter);
/*
 * Events:
 *  - draining // when `drain` is called
 *  - queueing(size of the queue) // the number of queries being beffered changed
 *  - size(number of connections) // the size of the pool changed
 *  - available-size(available size) // the number of AVAILABLE conncetions of the pool changed
 */

Pool.prototype.getConnection = function() {
  var self = this;
  var p = new Promise(function(resolve, reject) {
    if (self._draining === true) {
      return reject(new Err.ReqlDriverError('The pool is being drained').setOperational());
    }

    var connection = self._pool.pop();
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', -1);

    if (connection) {
      clearTimeout(connection.timeout);
      resolve(connection);
    }
    else {
      if ((self._numConnections === 0) && (self._slowGrowth === true)) {
        // If the server is down we do not want to buffer the queries
        return reject(new Err.ReqlDriverError('The pool does not have any opened connections and failed to open a new one').setOperational());
      }
    }

    if (self._slowGrowth === false) {
      self._expandBuffer();
    }

  });
  return p;
};

Pool.prototype._decreaseNumConnections = function() {
  this._numConnections--;
  this.emit('size', this._numConnections)
  this.emit('size-diff', -1)
  if ((this._drainingHandlers !== null) && (this._numConnections === 0)) {
    this._drainingHandlers.resolve();
  }
  // We do not check for this._empty === false because we want to emit empty if the pool
  // tries to connect to an unavailable server (such that the master can remove it from the
  // healthy pool
  if (this._numConnections === 0) {
    this._empty = true;
    this.emit('empty');
  }
}
Pool.prototype._increaseNumConnections = function() {
  this._numConnections++;
  this.emit('size', this._numConnections)
  this.emit('size-diff', 1)
}


Pool.prototype.putConnection = function(connection) {
  var self = this;
  if (connection.end === false) {
    // Temporary attempt to fix #192 - this should not happen.
    return;
  }
  if (self._empty === true) {
    self._empty = false;
    // We emit not-empty only we have at least one opened connection
    self.emit('not-empty');
  }
  if ((self._localhostToDrain > 0) && (helper.localhostAliases.hasOwnProperty(connection.host))) {
    self._localhostToDrain--;
    connection.close();
    clearTimeout(connection.timeout);
    self.createConnection();
  }
  else if (self._drainingHandlers !== null) {
    connection.close();
    clearTimeout(connection.timeout);
    if (self.getLength() === 0) {
      self._drainingHandlers.resolve();
    }
  }
  else if (self._extraConnections > 0) {
    self._extraConnections--;
    connection.close().error(function(error) {
      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));
    });
    clearTimeout(connection.timeout);
  }
  /*
  // We let the pool garbage collect these connections
  else if (self.getAvailableLength()+1 > self.options.buffer) { // +1 for the connection we may put back
    // Note that because we have available connections here, the pool master has no pending
    // queries.
    connection.close().error(function(error) {
      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));
    });
    clearTimeout(connection.timeout);
  }
  */
  else {
    self._pool.push(connection);
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', 1);
    self.emit('new-connection', connection);

    clearTimeout(connection.timeout);
    var timeoutCb = function() {
      if (self._pool.get(0) === connection) {
        if (self._pool.getLength() > self.options.buffer) {
          self._pool.shift().close();
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
        }
        else {
          connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
        }
      }
      else {
        // This should technically never happens
        connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
      }
    }
    connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);
  }
};

Pool.prototype.createConnection = function() {
  var self = this;
  self._increaseNumConnections();
  self._openingConnections++;

  self.emit('creating-connection', self);
  if (self._draining === true) {
    return; // Do not create a new connection if we are draining the pool.
  }

  return self._r.connect(self.options.connection).then(function(connection) {
    self.emit('created-connection', self);

    self._openingConnections--;

    if ((self._slowlyGrowing === false) && (self._slowGrowth === true) && (self._openingConnections === 0)) {
      self._consecutiveFails++;
      self._slowlyGrowing = true;
      self.timeoutReconnect = setTimeout(function() {
        self.createConnection();
        //self._expandBuffer();
      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
    }
    // Need another flag
    else if ((self._slowlyGrowing === true) && (self._slowGrowth === true) && (self._consecutiveFails > 0)) {
      self._log('Exiting slow growth mode');
      self._consecutiveFails = 0;
      self._slowGrowth = false;
      self._slowlyGrowing = false;
      self._aggressivelyExpandBuffer();
    }



    connection.on('error', function(error) {
      // We are going to close connection, but we don't want another process to use it before
      // So we remove it from the pool now (if it's inside)
      self._log('Error emitted by a connection: '+JSON.stringify(error));
      for(var i=0; i<self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
          break;
        }
      }
      // We want to make sure that it's not going to try to reconnect
      clearTimeout(connection.timeout);

      // Not sure what happened here, so let's be safe and close this connection.
      connection.close().then(function() {
        return self._expandBuffer();
      }).error(function(e) {
        // We failed to close this connection, but we removed it from the pool... so err, let's just ignore that.
        self._expandBuffer();
      });
    });
    connection.on('end', function(e) {
      // The connection was closed by the server, let's clean...
      for(var i=0; i<self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
          break;
        }
      }

      clearTimeout(connection.timeout);
      self._decreaseNumConnections();
      self._expandBuffer();
    });
    connection.on('timeout', function() {
      for(var i=0; i<self.getAvailableLength(); i++) {
        if (self._pool.get(i) === this) {
          self._pool.delete(i);
          self.emit('available-size', self._pool.getLength());
          self.emit('available-size-diff', -1);
          break;
        }
      }

      clearTimeout(connection.timeout);
      self._decreaseNumConnections();
      self._expandBuffer();
    });
    connection.on('release', function() {
      if (this._isOpen()) self.putConnection(this);
    });
    self.putConnection(connection);
    return null;
  }).error(function(error) {
    // We failed to create a connection, we are now going to create connections one by one
    self._openingConnections--;
    self._decreaseNumConnections();

    self._slowGrowth = true;
    if (self._slowlyGrowing === false) {
      self._log('Entering slow growth mode');
    }
    self._slowlyGrowing = true;

    // Log an error
    self._log('Fail to create a new connection for the connection pool. Error:'+JSON.stringify(error));

    if (self._openingConnections === 0) {
      self._consecutiveFails++;
      self.timeoutReconnect = setTimeout(function() {
        //self._expandBuffer();
        self.createConnection();
      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);
    }
  })
};

Pool.prototype._aggressivelyExpandBuffer = function() {
  for(var i=0; i<this.options.buffer; i++) {
    this._expandBuffer();
  }
}
Pool.prototype._expandBuffer = function() {
  if ((this._draining === false) &&
      (this._pool.getLength() < this.options.buffer+this._localhostToDrain) &&
      (this._numConnections < this.options.max+this._localhostToDrain)) {
    this.createConnection();
  }
}

Pool.prototype.getLength = function() {
  return this._numConnections;
}
Pool.prototype.getAvailableLength = function() {
  return this._pool.getLength();
}

Pool.prototype.setOptions = function(options) {
  if (helper.isPlainObject(options)) {
    for(var key in options) {
      this.options[key] = options[key];
    }
  }
  return this.options;
}
Pool.prototype.drainLocalhost = function() {
  var self = this;
  // All the connections are to localhost, let's create new ones (not to localhost)
  self._connectionToReplace = self._numConnections;
  ;
  for(var i=0, numConnections=self._numConnections; i<numConnections; i++) {
    self.createConnection().finally(function() {
      self._localhostToDrain++;
      self._connectionToReplace--;
      if ((self._connectionToReplace === 0) && (self._localhostToDrain > 0)) {
        var len = self._pool.getLength();
        for(var j=0; j<len; j++) {
          if (self._localhostToDrain === 0) {
            break;
          }
          var _connection = self._pool.shift();
          if (helper.localhostAliases.hasOwnProperty(_connection.host)) {
            self._localhostToDrain--;
            _connection.close();
            clearTimeout(_connection.timeout);
          }
          else {
            self._pool.push(_connection);
          }
        }
      }

    });
  }
}

Pool.prototype.drain = function() {
  var self = this;
  self._draining = true;
  self._log('Draining the pool connected to '+this.getAddress());
  self.emit('draining');
  var p = new Promise(function(resolve, reject) {
    var connection = self._pool.pop();
    self.emit('available-size', self._pool.getLength());
    self.emit('available-size-diff', -1);
    while(connection) {
      connection.close();
      clearTimeout(connection.timeout);
      connection = self._pool.pop();
    }
    if (self.timeoutReconnect !== undefined) {
      clearTimeout(self.timeoutReconnect);
      self.timeoutReconnect = null;
    }
    if (self.getLength() === 0) {
      resolve();
    }
    else {
      self._drainingHandlers = {
        resolve: resolve,
        reject: reject
      }
    }
  });
  return p;
}


Pool.prototype.getAddress = function() {
  return this.options.connection.host+':'+this.options.connection.port;
}
module.exports = Pool;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/pool_master.js":
/*!********************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/pool_master.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! util */ "util");
var events = __webpack_require__(/*! events */ "events");
var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var Dequeue = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/dequeue.js */ "../node_modules/rethinkdbdash/lib/dequeue.js");
var Pool = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/pool.js */ "../node_modules/rethinkdbdash/lib/pool.js");
var helper = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/helper.js */ "../node_modules/rethinkdbdash/lib/helper.js");
var Err = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/error.js */ "../node_modules/rethinkdbdash/lib/error.js");
var UNKNOWN_POOLS = 'unknownPools';
var SEPARATOR = 'feedSeparator';
function PoolMaster(r, options) {
  var self = this;
  var options = options || {};
  var lineLength = options.buffer || 50;

  self._r = r;
  self._line = new Dequeue(lineLength);
  self._pools = {};
  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server'id
  self._healthyPools = [];
  self._healthy = false;
  self._init = false;
  self._index = 0; // next pool to used
  self._indexUnknown =  0 // next unknown pool to used
  self._discovery = (typeof options.discovery === 'boolean') ? options.discovery: false; // Whether the pool master is in discovery mode or not
  //self._refresh = (typeof options.refresh === 'number') ? options.refresh: 1000*60*60; // Refresh rate for the list of servers
  self._options = options;
  self._options.buffer = options.buffer || 50;
  self._options.max = options.max || 1000;
  self._log = helper.createLogger(self, options.silent || false);
  if (typeof options.log == 'function') {
    self.on('log', options.log);
  }
  self._draining = false;
  self._numConnections = 0;
  self._numAvailableConnections = 0;
  self._hasPrintWarningLocalhost = false;
  self._feed = null;
  self._consecutiveFails = -1;
  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?
  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError

  //TODO
  //self._usingPool = true; // If we have used the pool
  self._seed = 0;

  var pool;
  if (Array.isArray(options.servers)) {
    if (options.servers.length > 0) {
      self._servers = options.servers;
      for(var i=0; i<options.servers.length; i++) {
        var settings = self.createPoolSettings(options, options.servers[i], self._log);
        pool = new Pool(self._r, settings);
        self._pools[UNKNOWN_POOLS].push(pool);
        // A pool is considered healthy by default such that people can do
        // var = require(...)(); query.run();
        self._healthyPools.push(pool);
        self.emitStatus()
      }
    }
    else {
      throw new Err.ReqlDriverError("If `servers` is an array, it must contain at least one server")
    }
  }
  else {
    self._servers = [{
      host: options.host || 'localhost',
      port: options.port || 28015
    }]
    var settings = self.createPoolSettings(options, {}, self._log);
    pool = new Pool(self._r, settings);
    self._pools[UNKNOWN_POOLS].push(pool);
    self._healthyPools.push(pool);
    self.emitStatus()
  }

  // Initialize all the pools - bind listeners
  for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {
    self.initPool(self._pools[UNKNOWN_POOLS][i]);
  }
  if ((self._discovery === true)) {
    self._timeout = setTimeout(function() { self.fetchServers() }, 0);
  }
}
util.inherits(PoolMaster, events.EventEmitter);

PoolMaster.prototype.getPools = function() {
  var result = [];
  helper.loopKeys(this._pools, function(pools, key) {
    if (key === UNKNOWN_POOLS) {
      for(var i=0;i<pools[key].length; i++) {
        result.push(pools[key][i]);
      }
    }
    else {
      result.push(pools[key]);
    }
  });
  return result;
}

// Reject all promises in this._line
PoolMaster.prototype._flushErrors = function() {
  while(this._line.getLength() > 0) {
    this._line.shift().reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').setOperational());
    this.emit('queueing', this._line.getLength())
  }
}

PoolMaster.prototype.getConnection = function() {
  var self = this;
  // Find a pool with available connections
  var result;
  for(var i=0; i<self._healthyPools.length; i++) {
    if (self._index >= self._healthyPools.length) {
      self._index = 0;
    }
    if (self._healthyPools[self._index].getAvailableLength() > 0) {
      result = self._healthyPools[self._index].getConnection();
    }
    self._index++;
    if (self._index === self._healthyPools.length) {
      self._index = 0;
    }
    if (result) {
      return result;
    }
  }
  if (self._healthyPools.length === 0) {
    return new Promise(function(resolve, reject) {
      reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').setOperational());
    });
  }
  else {
    // All pool are busy, buffer the request
    return new Promise(function(resolve, reject) {
      self._line.push({
        resolve: resolve,
        reject: reject
      });

      self.emit('queueing', self._line.getLength())
      // We could add a condition to be less greedy (for early start)
      self._expandAll();
    });

  }
}
PoolMaster.prototype._expandAll = function() {
  for(var i=0; i<this._healthyPools.length; i++) {
    this._healthyPools[i]._expandBuffer();
  }
}

// Fetch all the servers once
PoolMaster.prototype.handleAllServersResponse = function(servers) {
  var self = this;
  if (self._draining === true) {
    return;
  }
  // Fill all the known server from RethinkDB
  var knownServer = {};
  for(var i=0; i<servers.length; i++) {
    var server = servers[i];
    knownServer[server.id] = {count: 0, server: server};
    if (self._pools[server.id] === undefined) {
      // We potentially have a new server in the cluster, or we already have a pool for this server
      // in one of the UNKNOWN_POOLS
      var found = false;
      for(var j=0; j<self._pools[UNKNOWN_POOLS].length; j++) {
        if (found) break;
        var pool = self._pools[UNKNOWN_POOLS][j]; 
        // If a pool is created with localhost, it will probably match the first server even though it may not the the one
        // So it gets an id
        for(var k=0; k<server.network.canonical_addresses.length; k++) {
          // Check for the same host (or if they are both localhost) and port
          if (((server.network.canonical_addresses[k].host === pool.options.connection.host) ||
               (server.network.hostname === pool.options.connection.host) ||
            (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &&
            helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &&
            (server.network.reql_port === pool.options.connection.port)) {

            self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];
            // We may assign the wrong pool to this server if it's maching on localhost
            if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {
              self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host;
              self._pools[server.id].drainLocalhost();
            }
            found = true;
            break;
          }
        }
      }
      if (found === false) {
        // We just found a new server, let's extract the canonical address and connect to it
        self.createPool(server);
      }
    }
  } // Each server know has a pool

  // Check if we need to remove pools
  helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id
    if (key !== UNKNOWN_POOLS) {
      if (knownServer.hasOwnProperty(key) === false) {
        self.deletePool(key); // We just found a pool that doesn't map to any known RethinkDB server
      }
      else {
        knownServer[key].count++;
      }
    }
  });
  for(var i=0;i<self._pools[UNKNOWN_POOLS].length; i++) {
    // These pools does not match any server returned by RethinkDB.
    var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
    self._log('Removing pool connected to: '+pool.getAddress())
    pool.drain().then(function() {
      pool.removeAllListeners();
    }).error(function(error) {
      self._log('Pool connected to: '+self._pools[UNKNOWN_POOLS][i].getAddress()+' could not be properly drained.')
      self._log(error.message);
      self._log(error.stack);
    });
  }
}

// Create the settings for a given pool. Merge the global options + the servers's one.
PoolMaster.prototype.createPoolSettings = function(globalOptions, serverOptions, log) {
  var settings = {};
  var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;
  helper.loopKeys(globalOptions, function(options, key) {
    if ((key === 'buffer') || (key === 'max')) {
      settings[key] = Math.ceil(options[key]/numServers);
      settings[key] = Math.ceil(options[key]/numServers);
    }
    else if (key !== 'servers') {
      settings[key] = options[key];
    }
  });
  if (serverOptions) {
    helper.loopKeys(serverOptions, function(options, key) {
      settings[key] = options[key];
    });
  }
  settings._log = log;
  return settings;
}

// Create a new pool
PoolMaster.prototype.createPool = function(server) {
  var self = this;
  var address = helper.getCanonicalAddress(server.network.canonical_addresses);
  var settings = self.createPoolSettings(self._options, {
    port: server.network.reql_port,
    host: address.host
  }, self._log);
  var pool = new Pool(self._r, settings);
  self._pools[server.id] = pool
  self.initPool(pool);
  self._healthyPools.push(pool);
  self.emitStatus()
  self.resetBufferParameters();
}

// Delete a known pool
PoolMaster.prototype.deletePool = function(key) {
  var self = this;
  var pool = self._pools[key];
  self._log('Removing pool connected to: '+pool.getAddress())
  pool.drain().then(function() {
    pool.removeAllListeners();
  }).error(function(error) {
    self._log('Pool connected to: '+self._pools[key].getAddress()+' could not be properly drained.')
    self._log(error.message);
    self._log(error.stack);
  });
  delete self._pools[key];
  self.resetBufferParameters();
}

//  Create the feed on server_status and bind the listener to the feed
PoolMaster.prototype.fetchServers = function(useSeeds) {
  var self = this;
  var query = self._r.db('rethinkdb').table('server_status')
      .union([SEPARATOR])
      .union(self._r.db('rethinkdb').table('server_status').changes())
  // In case useSeeds is true, we rotate through all the seeds + the pool master
  if (!useSeeds || self._seed === self._servers.length) {
    if (useSeeds && self._seed === self._servers.length) {
      // We increase the back off only when we went through all the seeds
      self._consecutiveFails++;
    }

    self._seed = 0;
    var promise = query.run({cursor: true})
  }
  else {
    var settings = self._servers[self._seed];
    self._seed++;
    var promise = self._r.connect(settings).then(function(connection) {
      return query.run(connection, {cursor: true})
    });
  }
  promise.then(function(feed) {
    if (self._draining === true) {
      // There is no need to close the feed here as we'll close the connections
      return feed.close();
    }
    self._feed = feed;
    var initializing = true;
    var servers = [];
    feed.each(function(err, change) {
      if (err) {
        self._log('The changefeed on server_status returned an error: '+err.toString());
        // We have to refetch everything as the server that was serving the feed may
        // have died.
        if (!self._draining) {
          setTimeout(function() {
            self.fetchServers();
          }, 0); // Give a timeout to let the driver clean the pools
        }
        return;
      }
      if (initializing === true) {
        if (change === SEPARATOR) {
          initializing = false;
          self.handleAllServersResponse(servers);
          // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long
          // as RethinkDB does not provide initial results
          setTimeout(function() {
            self._r.db('rethinkdb').table('server_status').run({cursor: false}).then(function(servers) {
              self.handleAllServersResponse(servers);
            }).error(function(error) {
              self._log('Fail to retrieve a second copy of server_status');
              //TODO Retry
            });
          }, 1000);
        }
        else {
          servers.push(change);
        }
        return;
      }

      if (change.new_val !== null && change.old_val === null) {
        // New server
        self.createPool(change.new_val);
      }
      else if (change.new_val === null && change.old_val !== null) {
        // A server was removed
        var server = change.old_val;
        if (self._pools[server.id] != null) {
          self.deletePool(server.id);
        }
        else {
          var found = false;
          for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {
            if (((server.network.canonical_addresses[k].host === self._pools[UNKNOWN_POOLS][i].options.connection.host) ||
              (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) && (helper.localhostAliases.hasOwnProperty(self._pools[UNKNOWN_POOLS][i].options.connection.host)))) &&
              (server.network.reql_port === self._pools[UNKNOWN_POOLS][i].options.connection.port)) {
              found = true;

              (function (pool) {
                self._log('Removing pool connected to: '+pool.getAddress())
                var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];
                pool.drain().then(function() {
                  pool.removeAllListeners();
                }).error(function(error) {
                  if (self._options.silent !== true) {
                    self._log('Pool connected to: '+pool.getAddress()+' could not be properly drained.')
                    self._log(error.message);
                    self._log(error.stack);
                  }
                });
              })(self._pools[UNKNOWN_POOLS][i]);
              break;
            }
          }
        }
        if (found === false) {
          self._log('A server was removed but no pool for this server exists...')
        }
      }
      // We ignore this change since this it doesn't affect whether the server
      // is available or not.
      // else if (change.new_val !== null && change.old_val !== null) {}
    });
    return null;
  }).error(function(error) {
    self._log('Could not retrieve the data from server_status: '+JSON.stringify(error));
    
    var timeout;
    if (self._consecutiveFails === -1) {
      timeout = 0;
    }
    else {
      timeout = (1<<Math.min(self._maxExponent, self._consecutiveFails))*self._timeoutError;
    }
    setTimeout(function() {
      self.fetchServers(true);
    }, timeout);
  });
}

// Bind listeners on the pools
PoolMaster.prototype.initPool = function(pool) {
  var self = this;

  pool.on('size-diff', function(diff) {
    self._numConnections += diff;
    self.emit('size', self._numConnections)
  });
  pool.on('available-size-diff', function(diff) {
    self._numAvailableConnections += diff;
    self.emit('available-size', self._numAvailableConnections)
  });

  pool.on('new-connection', function() {
    if (self._line.getLength() > 0) {
      var p = self._line.shift();
      this.getConnection().then(p.resolve).error(p.reject);
      self.emit('queueing', self._line.getLength())
    }
  });
  pool.on('not-empty', function() {
    if (self._draining === false) {
      var found = false;
      for(var i=0; i<self._healthyPools.length; i++) {
        if (self._healthyPools[i] === this) {
          self._healthyPools.length;
          found = true;
          break;
        }
      }
      if (found === false) {
        self._healthyPools.push(this);
        self.emitStatus()
        self.resetBufferParameters();
      }
    }
  });
  pool.on('empty', function() {
    // A pool that become empty is considered unhealthy
    for(var i=0; i<self._healthyPools.length; i++) {
      if (self._healthyPools[i] === this) {
        self._healthyPools.splice(i, 1);
        self.emitStatus()
        break;
      }
    }
    if (self._healthyPools.length === 0) {
      self._flushErrors();
    }

    self.resetBufferParameters();
  });
  pool.on('draining', function() {
    for(var i=0; i<self._healthyPools.length; i++) {
      if (self._healthyPools[i] === this) {
        self._healthyPools.splice(i, 1);
        self.emitStatus()
        break;
      }
    }

    if (self._healthyPools === 0) {
      self._flushErrors();
    }
  });
}

PoolMaster.prototype.getNumConnections = function() {
  var sum = 0;
  for(var i=0; i<this._healthyPools.length; i++) {
    sum += this._healthyPools[i].getLength();
  }
  return sum;
}
PoolMaster.prototype.getNumAvailableConnections = function() {
  var sum = 0;
  for(var i=0; i<this._healthyPools.length; i++) {
    sum += this._healthyPools[i].getAvailableLength();
  }
  return sum;
}

// Reset buffer and max for each pool
PoolMaster.prototype.resetBufferParameters = function() {
  var max = Math.floor(this._options.max/this._healthyPools.length)
  var buffer = Math.floor(this._options.buffer/this._healthyPools.length)
  for(var i=0; i<this._healthyPools.length; i++) {
    if (this._healthyPools[i].getLength() > max) {
      this._healthyPools[i]._extraConnections = this._healthyPools[i].getLength()-max;
    }
    else {
      this._healthyPools[i]._extraConnections = 0;
    }
    this._healthyPools[i].options.max = max
    this._healthyPools[i].options.buffer = buffer;
  }
}

PoolMaster.prototype.getLength = function() {
  return this._numConnections;
}
PoolMaster.prototype.getAvailableLength = function() {
  return this._numAvailableConnections;
}

PoolMaster.prototype.drain = function() {
  this.emit('draining');
  if (this._discovery === true) {
    this._discovery = false;
    if (this._feed != null) {
      this._feed.close();
    }
  }
  this._draining = true;
  var promises = [];
  var pools = this.getPools();
  for(var i=0; i<pools.length; i++) {
    promises.push(pools[i].drain());
  }
  this._healthyPools = [];
  var self = this;
  return Promise.all(promises).then(function() {
    for(var i=0; i<pools.length; i++) {
      pools[i].removeAllListeners();
    }
  }).error(function(error) {
    if (self._options.silent !== true) {
      self._log('Failed to drain all the pools:');
      self._log(error.message);
      self._log(error.stack);
    }
  });
}

// Emit the healthy event with a boolean indicating whether the pool master
// is healthy or not
PoolMaster.prototype.emitStatus = function() {
  var healthy = this._healthyPools.length !== 0;
  if (this._healthy !== healthy) {
    this._healthy = healthy;
    this.emit('healthy', healthy)
  }
}

module.exports = PoolMaster;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/protodef.js":
/*!*****************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/protodef.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// DO NOT EDIT
// Autogenerated by convert_protofile

module.exports = {
	VersionDummy: {
		Version: {
			V0_1: 1063369270,
			V0_2: 1915781601,
			V0_3: 1601562686,
			V0_4: 1074539808,
			V1_0: 885177795
		},
		
		Protocol: {
			PROTOBUF: 656407617,
			JSON: 2120839367
		}
	},
	
	Query: {
		QueryType: {
			START: 1,
			CONTINUE: 2,
			STOP: 3,
			NOREPLY_WAIT: 4,
			SERVER_INFO: 5
		},
		
		AssocPair: {}
	},
	
	Frame: {
		FrameType: {
			POS: 1,
			OPT: 2
		}
	},
	
	Backtrace: {},
	
	Response: {
		ResponseType: {
			SUCCESS_ATOM: 1,
			SUCCESS_SEQUENCE: 2,
			SUCCESS_PARTIAL: 3,
			WAIT_COMPLETE: 4,
			SERVER_INFO: 5,
			CLIENT_ERROR: 16,
			COMPILE_ERROR: 17,
			RUNTIME_ERROR: 18
		},
		
		ErrorType: {
			INTERNAL: 1000000,
			RESOURCE_LIMIT: 2000000,
			QUERY_LOGIC: 3000000,
			NON_EXISTENCE: 3100000,
			OP_FAILED: 4100000,
			OP_INDETERMINATE: 4200000,
			USER: 5000000,
			PERMISSION_ERROR: 6000000
		},
		
		ResponseNote: {
			SEQUENCE_FEED: 1,
			ATOM_FEED: 2,
			ORDER_BY_LIMIT_FEED: 3,
			UNIONED_FEED: 4,
			INCLUDES_STATES: 5
		}
	},
	
	Datum: {
		DatumType: {
			R_NULL: 1,
			R_BOOL: 2,
			R_NUM: 3,
			R_STR: 4,
			R_ARRAY: 5,
			R_OBJECT: 6,
			R_JSON: 7
		},
		
		AssocPair: {}
	},
	
	Term: {
		TermType: {
			DATUM: 1,
			MAKE_ARRAY: 2,
			MAKE_OBJ: 3,
			VAR: 10,
			JAVASCRIPT: 11,
			UUID: 169,
			HTTP: 153,
			ERROR: 12,
			IMPLICIT_VAR: 13,
			DB: 14,
			TABLE: 15,
			GET: 16,
			GET_ALL: 78,
			EQ: 17,
			NE: 18,
			LT: 19,
			LE: 20,
			GT: 21,
			GE: 22,
			NOT: 23,
			ADD: 24,
			SUB: 25,
			MUL: 26,
			DIV: 27,
			MOD: 28,
			FLOOR: 183,
			CEIL: 184,
			ROUND: 185,
			APPEND: 29,
			PREPEND: 80,
			DIFFERENCE: 95,
			SET_INSERT: 88,
			SET_INTERSECTION: 89,
			SET_UNION: 90,
			SET_DIFFERENCE: 91,
			SLICE: 30,
			SKIP: 70,
			LIMIT: 71,
			OFFSETS_OF: 87,
			CONTAINS: 93,
			GET_FIELD: 31,
			KEYS: 94,
			VALUES: 186,
			OBJECT: 143,
			HAS_FIELDS: 32,
			WITH_FIELDS: 96,
			PLUCK: 33,
			WITHOUT: 34,
			MERGE: 35,
			BETWEEN_DEPRECATED: 36,
			BETWEEN: 182,
			REDUCE: 37,
			MAP: 38,
			FOLD: 187,
			FILTER: 39,
			CONCAT_MAP: 40,
			ORDER_BY: 41,
			DISTINCT: 42,
			COUNT: 43,
			IS_EMPTY: 86,
			UNION: 44,
			NTH: 45,
			BRACKET: 170,
			INNER_JOIN: 48,
			OUTER_JOIN: 49,
			EQ_JOIN: 50,
			ZIP: 72,
			RANGE: 173,
			INSERT_AT: 82,
			DELETE_AT: 83,
			CHANGE_AT: 84,
			SPLICE_AT: 85,
			COERCE_TO: 51,
			TYPE_OF: 52,
			UPDATE: 53,
			DELETE: 54,
			REPLACE: 55,
			INSERT: 56,
			DB_CREATE: 57,
			DB_DROP: 58,
			DB_LIST: 59,
			TABLE_CREATE: 60,
			TABLE_DROP: 61,
			TABLE_LIST: 62,
			CONFIG: 174,
			STATUS: 175,
			WAIT: 177,
			RECONFIGURE: 176,
			REBALANCE: 179,
			SYNC: 138,
			GRANT: 188,
			INDEX_CREATE: 75,
			INDEX_DROP: 76,
			INDEX_LIST: 77,
			INDEX_STATUS: 139,
			INDEX_WAIT: 140,
			INDEX_RENAME: 156,
			FUNCALL: 64,
			BRANCH: 65,
			OR: 66,
			AND: 67,
			FOR_EACH: 68,
			FUNC: 69,
			ASC: 73,
			DESC: 74,
			INFO: 79,
			MATCH: 97,
			UPCASE: 141,
			DOWNCASE: 142,
			SAMPLE: 81,
			DEFAULT: 92,
			JSON: 98,
			TO_JSON_STRING: 172,
			ISO8601: 99,
			TO_ISO8601: 100,
			EPOCH_TIME: 101,
			TO_EPOCH_TIME: 102,
			NOW: 103,
			IN_TIMEZONE: 104,
			DURING: 105,
			DATE: 106,
			TIME_OF_DAY: 126,
			TIMEZONE: 127,
			YEAR: 128,
			MONTH: 129,
			DAY: 130,
			DAY_OF_WEEK: 131,
			DAY_OF_YEAR: 132,
			HOURS: 133,
			MINUTES: 134,
			SECONDS: 135,
			TIME: 136,
			MONDAY: 107,
			TUESDAY: 108,
			WEDNESDAY: 109,
			THURSDAY: 110,
			FRIDAY: 111,
			SATURDAY: 112,
			SUNDAY: 113,
			JANUARY: 114,
			FEBRUARY: 115,
			MARCH: 116,
			APRIL: 117,
			MAY: 118,
			JUNE: 119,
			JULY: 120,
			AUGUST: 121,
			SEPTEMBER: 122,
			OCTOBER: 123,
			NOVEMBER: 124,
			DECEMBER: 125,
			LITERAL: 137,
			GROUP: 144,
			SUM: 145,
			AVG: 146,
			MIN: 147,
			MAX: 148,
			SPLIT: 149,
			UNGROUP: 150,
			RANDOM: 151,
			CHANGES: 152,
			ARGS: 154,
			BINARY: 155,
			GEOJSON: 157,
			TO_GEOJSON: 158,
			POINT: 159,
			LINE: 160,
			POLYGON: 161,
			DISTANCE: 162,
			INTERSECTS: 163,
			INCLUDES: 164,
			CIRCLE: 165,
			GET_INTERSECTING: 166,
			FILL: 167,
			GET_NEAREST: 168,
			POLYGON_SUB: 171,
			MINVAL: 180,
			MAXVAL: 181
		},
		
		AssocPair: {}
	}
}


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/stream.js":
/*!***************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/stream.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Readable = __webpack_require__(/*! stream */ "stream").Readable;
var Cursor = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/cursor.js */ "../node_modules/rethinkdbdash/lib/cursor.js");
var util = __webpack_require__(/*! util */ "util");

// Experimental, but should work fine.
function ReadableStream(options, cursor) {
  if (cursor) this._cursor = cursor;
  this._pending = 0; // How many time we called _read while no cursor was available
  this._index = 0;
  this._maxRecursion = 1000; // Hardcoded
  this._highWaterMark = options.highWaterMark;
  this._closed = false;

  Readable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
};
util.inherits(ReadableStream, Readable);


ReadableStream.prototype._setCursor = function(cursor) {
  if (cursor instanceof Cursor === false) {
    this.emit('error', new Error('Cannot create a stream on a single value.'));
    this.push(null);
    return this;
  }
  this._cursor = cursor;
  this._fetchAndDecrement();
}
ReadableStream.prototype._read = function(size) {
  this._count++;
  if (this._cursor === undefined) {
    this._pending++;
    return;
  }

  this._recursion = 0;
  this._fetch();
}

//TODO: Refactor with _fetch?
ReadableStream.prototype._fetchAndDecrement = function() {
  var self = this;
  self._pending--;
  if (self._pending < 0 || self._closed === true) {
    return;
  }

  if (self._cursor._closed === true) {
    self.push(null);
  }
  else {
    self._cursor._next().then(function(data) {
      // Silently drop null values for now
      if (data === null) {
        if (self._recursion++ === self._maxRecursion) {
          //Avoid maximum call stack errors
          process.nextTick(function() {
            self._fetchAndDecrement();
          });
        }
        else {
          self._fetchAndDecrement();
        }
      }
      else {
        if (self.push(data) !== false) {
          if (self._recursion++ === self._maxRecursion) {
            process.nextTick(function() {
              self._fetchAndDecrement();
            });
          }
          else {
            self._fetchAndDecrement();
          }
        }
      }
      return null;
    }).error(function(error) {
      if (error.message.match(/No more rows in the/)) {
        self.push(null);
      }
      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {
        // if the user call `close`, the cursor may reject pending requests. We just
        // ignore them here.
      }
      else {
        self.emit('error', error);
        self.push(null);
      }
    });
  }
}

ReadableStream.prototype._fetch = function() {
  var self = this;
  if (self._closed === true) {
    return;
  }
  if (self._cursor._closed === true) {
    self.push(null);
  }
  else {
    self._cursor._next().then(function(data) {
      if (self._closed === true) {
        return;
      }
      // Silently drop null values for now
      if (data === null) {
        if (self._recursion++ === self._maxRecursion) {
          process.nextTick(function() {
            self._fetch();
          });
        }
        else {
          self._fetch();
        }
      }
      else {
        if (self.push(data) !== false) {
          if (self._recursion++ === self._maxRecursion) {
            process.nextTick(function() {
              self._fetch();
            });
          }
          else {
            self._fetch();
          }
        }
      }
      return null;
    }).error(function(error) {
      if (error.message.match(/No more rows in the/)) {
        self.push(null);
      }
      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {
        // if the user call `close`, the cursor may reject pending requests. We just
        // ignore them here.
      }
      else {
        self.emit('error', error);
        self.push(null);
      }
    });
  }
}


ReadableStream.prototype.close = function() {
  this._closed = true;
  this.push(null);
  return this._cursor.close();
}

module.exports = ReadableStream;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/term.js":
/*!*************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/term.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var protodef = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/protodef.js */ "../node_modules/rethinkdbdash/lib/protodef.js");
var termTypes = protodef.Term.TermType;

var Error = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/error.js */ "../node_modules/rethinkdbdash/lib/error.js");
var helper = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/helper.js */ "../node_modules/rethinkdbdash/lib/helper.js");
var ReadableStream = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/stream.js */ "../node_modules/rethinkdbdash/lib/stream.js");
var WritableStream = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/writable_stream.js */ "../node_modules/rethinkdbdash/lib/writable_stream.js");
var TransformStream = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/transform_stream.js */ "../node_modules/rethinkdbdash/lib/transform_stream.js");

function Term(r, value, error) {
  var self = this;
  var term = function(field) {
    if (Term.prototype._fastArity(arguments.length, 1) === false) {
      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
      Term.prototype._arity(_args, 1, '(...)', self);
    }
    return term.bracket(field);
  }
  helper.changeProto(term, self);

  if (value === undefined) {
    term._query = [];
  }
  else {
    term._query = value;
  }
  term._r = r; // Keep a reference to r for global settings

  if (error !== undefined) {
    term._error = error;
    term._frames = [];
  }

  return term;
}

// run([connection][, options][, callback])
Term.prototype.run = function(connection, options, callback) {
  var self = this;

  if (self._error != null) {
    var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});
    return Promise.reject(error);
  }

  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    else {
      if (!helper.isPlainObject(options)) options = {};
    }

    if (connection._isOpen() !== true) {
      return new Promise(function(resolve, reject) {
        reject(new Error.ReqlDriverError('`run` was called with a closed connection', self._query).setOperational());
      });
    }
    var p = new Promise(function(resolve, reject) {
      var token = connection._getToken();

      var query = [protodef.Query.QueryType.START];
      query.push(self._query);

      var _options = {};
      var sendOptions = false;
      if (connection.db != null) {
        sendOptions = true;
        _options.db = self._r.db(connection.db)._query;
      }

      if (self._r.arrayLimit != null) {
        sendOptions = true;
        _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;
      };


      var keepGoing = true; // we need it just to avoir calling resolve/reject multiple times
      helper.loopKeys(options, function(options, key) {
        if (keepGoing === true) {
          if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||
            (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile') ||
            (key === 'minBatchRows') || (key === 'maxBatchRows') || (key === 'maxBatchBytes') ||
            (key === 'maxBatchSeconds') || (key === 'firstBatchScaledownFactor')) {

            sendOptions = true;
            if (key === 'db') {
              _options[key] = self._r.db(options[key])._query;
            }
            else if (self._translateArgs.hasOwnProperty(key)) {
              _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query;
            }
            else {
              _options[key] = new Term(self._r).expr(options[key])._query;
            }
          }
          else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&
              (key !== 'binaryFormat') && (key !== 'cursor') &&
              (key !== 'readable') && (key !== 'writable') &&
              (key !== 'transform') && (key !== 'stream') &&
              (key !== 'highWaterMark')) {
            reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <bool>, cursor <bool>, stream <bool>'));
            keepGoing = false;
          }
        }
      });

      if (keepGoing === false) {
        connection.emit('release');
        return // The promise was rejected in the loopKeys
      }

      if (sendOptions === true) {
        query.push(_options);
      }
      connection._send(query, token, resolve, reject, self._query, options);
    }).nodeify(callback);
  }
  else {
    var poolMaster = self._r.getPoolMaster(); // if self._r is defined, so is self._r.getPool()
    if (!poolMaster) {
      throw new Error.ReqlDriverError('`run` was called without a connection and no pool has been created', self._query);
    }
    else {
      if (typeof connection === 'function') {
        // run(callback);
        callback = connection;
        options = {};
      }
      else if (helper.isPlainObject(connection)) {
        // run(options[, callback])
        callback = options;
        options = connection;
      }
      else {
        options = {};
      }


      var p = new Promise(function(resolve, reject) {
        poolMaster.getConnection().then(function(connection) {
          var token = connection._getToken();
          var query = [protodef.Query.QueryType.START];
          query.push(self._query);

          var _options = {};
          var sendOptions = false;
          if (connection.db != null) {
            sendOptions = true;
            _options.db = self._r.db(connection.db)._query;
          }
          if (self._r.arrayLimit != null) {
            sendOptions = true;
            _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;
          };

          var keepGoing = true;
          helper.loopKeys(options, function(options, key) {
            if (keepGoing === true) {
              if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||
                  (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile') ||
                  (key === 'minBatchRows') || (key === 'maxBatchRows') || (key === 'maxBatchBytes') ||
                  (key === 'maxBatchSeconds') || (key === 'firstBatchScaledownFactor')) {


                sendOptions = true;
                if (key === 'db') {
                  _options[key] = self._r.db(options[key])._query;
                }
                else if (self._translateArgs.hasOwnProperty(key)) {
                  _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query
                }
                else {
                  _options[key] = new Term(self._r).expr(options[key])._query
                }
              }
              else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&
                  (key !== 'binaryFormat') && (key !== 'cursor') &&
                  (key !== 'readable') && (key !== 'writable') &&
                  (key !== 'transform') && (key !== 'stream') &&
                  (key !== 'highWaterMark')) {

                setTimeout( function() {
                  reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <string>, cursor <bool>, stream <bool>'));
                }, 0);
                keepGoing = false;
                return false;
              }
            }
          });

          if (keepGoing === false) {
            connection.emit('release');
            return // The promise was rejected in the loopKeys
          }

          if (sendOptions === true) {
            query.push(_options);
          }
          connection._send(query, token, resolve, reject, self._query, options);
        }).error(function(error) {
          reject(error);
        });
      }).nodeify(callback);
    }
  }

  //if (options.noreply) return self; // Do not return a promise if the user ask for no reply.

  return p;
}

Term.prototype.toStream = function(connection, options) {
  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
    if (helper.isPlainObject(options) === false) {
      options = {};
    }
    if (options.readable === true) {
      return this._toReadableStream(connection, options);
    }
    else if (options.writable === true) {
      return this._toWritableStream(connection, options);
    }
    else if (options.transform === true) {
      return this._toTransformStream(connection, options);
    }
    else {
      return this._toReadableStream(connection, options);
    }
  }
  else {
    options = connection;
    if (helper.isPlainObject(options) === false) {
      options = {};
    }
    if (options.readable === true) {
      return this._toReadableStream(options);
    }
    else if (options.writable === true) {
      return this._toWritableStream(options);
    }
    else if (options.transform === true) {
      return this._toTransformStream(options);
    }
    else {
      return this._toReadableStream(options);
    }
  }
}

Term.prototype._toReadableStream = function(connection, options) {
  var stream;

  var _options = {};
  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
    //toStream make sure that options is an object
    helper.loopKeys(options, function(obj, key) {
      _options[key] = obj[key];
    });
    _options.cursor = true;
    stream = new ReadableStream(_options);
    this.run(connection, _options).then(function(cursor) {
      stream._setCursor(cursor);
      return null;
    }).error(function(error) {
      stream.emit('error', error);
    });
  }
  else {
    helper.loopKeys(connection, function(obj, key) {
      _options[key] = obj[key];
    });
    _options.cursor = true;
    stream = new ReadableStream(_options);
    this.run(_options).then(function(cursor) {
      stream._setCursor(cursor);
      return null;
    }).error(function(error) {
      stream.emit('error', error);
    });
  }
  return stream;
}

Term.prototype._toWritableStream = function(connection, options) {
  if (this._query[0] !== termTypes.TABLE) {
    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');
  }

  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
    return new WritableStream(this, options, connection);
  }
  else {
    return new WritableStream(this, connection);
  }
}
Term.prototype._toTransformStream = function(connection, options) {
  if (this._query[0] !== termTypes.TABLE) {
    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');
  }

  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {
    return new TransformStream(this, options, connection);
  }
  else {
    return new TransformStream(this, connection);
  }
}


// Manipulating databases
Term.prototype.dbCreate = function(db) {
  // Check for arity is done in r.prototype.dbCreate
  this._noPrefix(this, 'dbCreate');

  var term = new Term(this._r);
  term._query.push(termTypes.DB_CREATE);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}
Term.prototype.dbDrop = function(db) {
  this._noPrefix(this, 'dbDrop');

  var term = new Term(this._r);
  term._query.push(termTypes.DB_DROP);
  var args = [new Term(this._r).expr(db)._query]
  term._fillArgs(args);
  return term;
}
Term.prototype.dbList = function() {
  this._noPrefix(this, 'dbList');

  var term = new Term(this._r);
  term._query.push(termTypes.DB_LIST)
  return term;
}

// Manipulating Tables
Term.prototype.tableCreate = function(table, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'tableCreate', self);
  }


  var term = new Term(self._r);
  term._query.push(termTypes.TABLE_CREATE)

  var args = [];
  if (Array.isArray(self._query) && (self._query.length > 0)) {
    args.push(self); // Push db
  }
  args.push(new Term(self._r).expr(table))
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // Check for non valid key
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'primaryKey')
          && (key !== 'durability')
          && (key !== 'shards')
          && (key !== 'replicas')
          && (key !== 'primaryReplicaTag')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `tableCreate`', self._query, 'Available options are primaryKey <string>, durability <string>, shards <number>, replicas <number/object>, primaryReplicaTag <object>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}

Term.prototype.tableDrop = function(table) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'tableDrop', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TABLE_DROP)

  var args = [];
  if (!Array.isArray(this._query) || (this._query.length > 0)) {
    args.push(this); // push db
  }
  args.push(new Term(this._r).expr(table))
  term._fillArgs(args);
  return term;
}
Term.prototype.tableList = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'tableList', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TABLE_LIST);

  var args = [];
  if (!Array.isArray(this._query) || (this._query.length > 0)) {
    args.push(this);
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.indexList = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'indexList', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_LIST);
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.indexCreate = function(name, fn, options) {
  if (this._fastArityRange(arguments.length, 1, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 3, 'indexCreate', this);
  }

  if ((options == null) && (helper.isPlainObject(fn))) {
    options = fn;
    fn = undefined;
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_CREATE);
  var args = [this];
  args.push(new Term(this._r).expr(name));
  if (typeof fn !== 'undefined') args.push(new Term(this._r).expr(fn)._wrap());
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // There is no need to translate here
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'multi') && (key !== 'geo')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexCreate`', self._query, 'Available option is multi <bool> and geo <bool>');
      }
    });
    term._query.push(new Term(this._r).expr(options)._query);
  }
  return term;
}
Term.prototype.indexDrop = function(name) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'indexDrop', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_DROP);
  var args = [this, new Term(this._r).expr(name)];
  term._fillArgs(args);
  return term;
}

Term.prototype.indexStatus = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_STATUS);
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.indexWait = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_WAIT);
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.indexRename = function(oldName, newName, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, 'indexRename', self);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INDEX_RENAME);
  var args = [this, new Term(this._r).expr(oldName), new Term(this._r).expr(newName)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'overwrite') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexRename`', self._query, 'Available options are overwrite <bool>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }


  return term;
}
Term.prototype.changes = function(options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'changes', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.CHANGES);
  var args = [self];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'squash') && (key !== 'includeStates') && (key !== 'includeTypes')
          && (key !== 'includeInitial') && (key !== 'includeOffsets')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `changes`', self._query,
            'Available options are squash <bool>, includeInitial <bool>, includeStates <bool>, includeOffsets <bool>, includeTypes <bool>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}

// Writing data
Term.prototype.insert = function(documents, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'insert', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.INSERT);
  var args = [self, new Term(self._r).expr(documents)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'conflict')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `insert`', self._query, 'Available options are returnChanges <bool>, durability <string>, conflict <string>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.update = function(newValue, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'update', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.UPDATE);
  var args = [self, new Term(self._r).expr(newValue)._wrap()];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `update`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.replace = function(newValue, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'replace', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.REPLACE);
  var args = [self, new Term(self._r).expr(newValue)._wrap()];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `replace`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.delete = function(options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'delete', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.DELETE);
  var args = [self];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'returnChanges') && (key !== 'durability')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `delete`', self._query, 'Available options are returnChanges <bool>, durability <string>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.sync = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'sync', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SYNC)
  var args = [this._query];
  term._fillArgs(args);
  return term;
}

// Selecting data
Term.prototype.db = function(db) {
  this._noPrefix(this, 'db');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'db', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DB)
  var args = [new Term(this._r).expr(db)];
  term._fillArgs(args);
  return term;
}
Term.prototype.table = function(table, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'table', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.TABLE)

  var args = [];
  if (Array.isArray(self._query) && (self._query.length > 0)) {
    args.push(self);
  }
  args.push(new Term(self._r).expr(table))
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'readMode') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `table`', self._query, 'Available option is readMode <string>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.get = function(primaryKey) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'get', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GET);
  var args = [this, new Term(this._r).expr(primaryKey)]
  term._fillArgs(args);
  return term;
}
Term.prototype.getAll = function() {
  // We explicitly _args here, so fastArityRange is not useful
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.GET_ALL);

  var args = [];
  args.push(this);
  for(var i=0; i<_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  if ((_args.length > 0) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else if (_args.length > 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1]))
    term._fillArgs(args);
  } else {
    term._fillArgs(args);
  }
  return term;
}
Term.prototype.between = function(start, end, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, 'between', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.BETWEEN);
  var args = [self, new Term(self._r).expr(start), new Term(self._r).expr(end)]
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'index') && (key !== 'leftBound') && (key !== 'rightBound')){
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `between`', self._query, 'Available options are index <string>, leftBound <string>, rightBound <string>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.minval = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.MINVAL);
  return term;
}
Term.prototype.maxval = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.MAXVAL);
  return term;
}

Term.prototype.filter = function(filter, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'filter', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.FILTER);
  var args = [self, new Term(self._r).expr(filter)._wrap()]
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'default') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `filter`', self._query, 'Available option is filter');
      }
    })
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}

// Joins
Term.prototype.innerJoin = function(sequence, predicate) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'innerJoin', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INNER_JOIN);
  var args = [this._query];
  args.push(new Term(this._r).expr(sequence)._query);
  args.push(new Term(this._r).expr(predicate)._wrap()._query);
  term._fillArgs(args);

  return term;
}
Term.prototype.outerJoin = function(sequence, predicate) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'outerJoin', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OUTER_JOIN);
  var args = [this];
  args.push(new Term(this._r).expr(sequence));
  args.push(new Term(this._r).expr(predicate)._wrap());
  term._fillArgs(args);

  return term;
}
Term.prototype.eqJoin = function(rightKey, sequence, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 2, 3, 'eqJoin', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.EQ_JOIN);
  var args = [self];
  args.push(new Term(self._r).expr(rightKey)._wrap());
  args.push(new Term(self._r).expr(sequence));
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'index') && (key !== 'ordered')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `eqJoin`', self._query, 'Available options are index <string>, ordered <boolean>');
      }
    })
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.zip = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'zip', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ZIP);
  var args = [this];
  term._fillArgs(args);
  return term;
}



// Transformation
Term.prototype.map = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'map', this);

  var term = new Term(this._r);
  term._query.push(termTypes.MAP);
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length > 0)) {
    args.push(this);
  }
  for(var i=0; i<_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  // Make sure that we don't push undefined if no argument is passed to map,
  // in which case the server will handle the case and return an error.
  if (_args.length> 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
  }
  term._fillArgs(args);

  return term;
}
Term.prototype.withFields = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'withFields', this);

  var term = new Term(this._r);
  term._query.push(termTypes.WITH_FIELDS);
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);

  return term;
}
Term.prototype.concatMap = function(transformation) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'concatMap', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CONCAT_MAP);
  var args = [this];
  args.push(new Term(this._r).expr(transformation)._wrap())
  term._fillArgs(args);

  return term;
}
Term.prototype.orderBy = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'orderBy', this);

  var term = new Term(this._r);
  term._query.push(termTypes.ORDER_BY);

  var args = [this];
  for(var i=0; i<_args.length-1; i++) {
    if ((_args[i] instanceof Term) &&
        ((_args[i]._query[0] === termTypes.DESC) || (_args[i]._query[0] === termTypes.ASC))) {
      args.push(new Term(this._r).expr(_args[i]))
    }
    else {
      args.push(new Term(this._r).expr(_args[i])._wrap())
    }
  }
  // We actually don't need to make the difference here, but...
  if ((_args.length > 0) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else {
    if ((_args[_args.length-1] instanceof Term) &&
      ((_args[_args.length-1]._query[0] === termTypes.DESC) || (_args[_args.length-1]._query[0] === termTypes.ASC))) {
      args.push(new Term(this._r).expr(_args[_args.length-1]))
    }
    else {
      args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())
    }
    term._fillArgs(args);
  }
  return term;

}
Term.prototype.desc = function(field) {
  this._noPrefix(this, 'desc');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'desc', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DESC)
  var args = [new Term(this._r).expr(field)._wrap()];
  term._fillArgs(args);
  return term;
}
Term.prototype.asc = function(field) {
  this._noPrefix(this, 'asc');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'asc', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ASC)
  var args = [new Term(this._r).expr(field)._wrap()];
  term._fillArgs(args);
  return term;
}
Term.prototype.skip = function(value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'skip', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SKIP)
  var args = [this, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}
Term.prototype.limit = function(value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'limit', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.LIMIT)
  var args = [this, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}
Term.prototype.slice = function(start, end, options) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 3, 'slice', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SLICE);

  var args = [];
  args.push(this);
  args.push(new Term(this._r).expr(start));

  if ((end !== undefined) && (options !== undefined)) {
    args.push(new Term(this._r).expr(end));
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  else if ((end !== undefined) && (options === undefined)) {
    if (helper.isPlainObject(end) === false) {
      args.push(new Term(this._r).expr(end));
      term._fillArgs(args);
    }
    else {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(end))._query);
    }
  }
  else { // end and options are both undefined
    term._fillArgs(args);
  }
  return term;
}
Term.prototype.nth = function(value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'nth', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.NTH)
  var args = [this._query, new Term(this._r).expr(value)]
  term._fillArgs(args);
  return term;
}
Term.prototype.offsetsOf = function(predicate) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'indexesOf', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.OFFSETS_OF)
  var args = [this, new Term(this._r).expr(predicate)._wrap()];
  term._fillArgs(args);
  return term;
}
Term.prototype.indexesOf = Term.prototype.offsetsOf;

Term.prototype.isEmpty = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'isEmpty', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IS_EMPTY)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.union = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.UNION)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length > 0)) {
    args.push(this);
  }
  for(var i=0; i<_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  if ((_args.length > 1) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].interleave !== undefined)) {
    term._fillArgs(args);
    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);
  }
  else if (_args.length > 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1]))
    term._fillArgs(args);
  }
  return term;
}
Term.prototype.sample = function(size) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'sample', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SAMPLE)
  var args = [this, new Term(this._r).expr(size)];
  term._fillArgs(args);
  return term;
}

// Aggregations
Term.prototype.reduce = function(func) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'reduce', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.REDUCE)
  var args = [this, new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  return term;
}
Term.prototype.count = function(filter) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'count', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.COUNT);
  var args = [];
  args.push(this);
  if (filter !== undefined) {
    args.push(new Term(this._r).expr(filter)._wrap())
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.distinct = function(options) {
  var self= this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'distinct', self);
  }

  var term = new Term(self._r);
  term._query.push(termTypes.DISTINCT)
  var args = [self];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    var keepGoing = true;
    helper.loopKeys(options, function(obj, key) {
      if ((keepGoing === true) && (key !== 'index')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distinct`', self._query, 'Available option is index: <string>');
        keepGoing = false;
      }
    });
    if (keepGoing === true) {
      term._query.push(new Term(self._r).expr(translateOptions(options))._query);
    }
  }

  return term;
}
Term.prototype.group = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var self = this;
  self._arityRange(_args, 1, Infinity, 'group', self);

  var term = new Term(self._r);
  term._query.push(termTypes.GROUP);
  var args = [self];
  for(var i=0; i<_args.length-1; i++) {
    args.push(new Term(self._r).expr(_args[i])._wrap())
  }
  if (_args.length > 0) {
    if (helper.isPlainObject(_args[_args.length-1])) {
      helper.loopKeys(_args[_args.length-1], function(obj, key) {
         if ((key !== 'index')
        && (key !==  'multi')) {
          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `group`', self._query, 'Available options are index: <string>, multi <boolean>');
        }
      });
      term._fillArgs(args);
      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
    }
    else {
      args.push(new Term(self._r).expr(_args[_args.length-1])._wrap())
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }

  return term;
}
Term.prototype.split = function(separator, max) {
  if (this._fastArityRange(arguments.length, 0, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 2, 'split', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SPLIT)
  var args = [this];
  if (separator !== undefined) {
    args.push(new Term(this._r).expr(separator))
    if (max !== undefined) {
      args.push(new Term(this._r).expr(max))
    }
  }
  term._fillArgs(args);

  return term;
}

Term.prototype.ungroup = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'ungroup', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.UNGROUP)
  var args = [this._query];
  term._fillArgs(args);
  return term;
}
Term.prototype.contains = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'contains', this);

  var term = new Term(this._r);
  term._query.push(termTypes.CONTAINS)
  var args = [this._query];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i])._wrap())
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.sum = function(field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'sum', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SUM);
  var args = [this];
  if (field !== undefined) {
    args.push(new Term(this._r).expr(field)._wrap())
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.avg = function(field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'avg', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.AVG)
  var args = [this];
  if (field !== undefined) {
    args.push(new Term(this._r).expr(field)._wrap())
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.min = function(field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'min', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MIN)
  var args = [this];
  if (field !== undefined) {
    if (helper.isPlainObject(field)) {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(field))._query);
    }
    else {
      args.push(new Term(this._r).expr(field)._wrap());
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}
Term.prototype.max = function(field) {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'max', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MAX)
  var args = [this];
  if (field !== undefined) {
    if (helper.isPlainObject(field)) {
      term._fillArgs(args);
      term._query.push(new Term(this._r).expr(translateOptions(field))._query);
    }
    else {
      args.push(new Term(this._r).expr(field)._wrap())
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}
Term.prototype.fold = function(base, func, options) {
  if (this._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 2, 3, 'range', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FOLD)
  var args = [this, new Term(this._r).expr(base), new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'emit') && (key !== 'finalEmit')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `fold`. Available options are emit <function>, finalEmit <function>');
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}



// Document manipulation
Term.prototype.row = function() {
  this._noPrefix(this, 'row');
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'r.row', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IMPLICIT_VAR)
  return term;
}
Term.prototype.pluck = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'pluck', this);

  var term = new Term(this._r);
  term._query.push(termTypes.PLUCK)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.without = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'without', this);

  var term = new Term(this._r);
  term._query.push(termTypes.WITHOUT)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.merge = function(arg) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'merge', this);

  var term = new Term(this._r);
  term._query.push(termTypes.MERGE)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i])._wrap())
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.literal = function(obj) {
  this._noPrefix(this, 'literal');
  // The test for arity is performed in r.literal

  var term = new Term(this._r);
  term._query.push(termTypes.LITERAL);
  if (arguments.length > 0) {
    var args = [new Term(this._r).expr(obj)];
    term._fillArgs(args);
  }
  return term;
}
Term.prototype.append = function(value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'append', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.APPEND)
  var args = [this, new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}
Term.prototype.prepend = function(value) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'prepend', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.PREPEND)
  var args = [this, new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}
Term.prototype.difference = function(other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'difference', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DIFFERENCE)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}
Term.prototype.setInsert = function(other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setInsert', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_INSERT)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}
Term.prototype.setUnion = function(other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setUnion', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_UNION)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}
Term.prototype.setIntersection = function(other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setIntersection', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_INTERSECTION)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}
Term.prototype.setDifference = function(other) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'setDifference', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SET_DIFFERENCE)
  var args = [this, new Term(this._r).expr(other)];
  term._fillArgs(args);
  return term;
}
Term.prototype.getField = function(field) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, '(...)', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GET_FIELD)
  var args = [this, new Term(this._r).expr(field)];
  term._fillArgs(args);
  return term;
}
Term.prototype.bracket = function(field) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, '(...)', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.BRACKET)
  var args = [this, new Term(this._r).expr(field)];
  term._fillArgs(args);
  return term;
}

Term.prototype.hasFields = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'hasFields', this);

  var term = new Term(this._r);
  term._query.push(termTypes.HAS_FIELDS)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;

}
Term.prototype.insertAt = function(index, value) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'insertAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INSERT_AT)
  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(value)];
  term._fillArgs(args);
  return term;
}
Term.prototype.spliceAt = function(index, array) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'spliceAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SPLICE_AT)
  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(array)];
  term._fillArgs(args);
  return term;
}
Term.prototype.deleteAt = function(start, end) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'deleteAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DELETE_AT);
  var args = [this, new Term(this._r).expr(start)];
  if (end !== undefined) {
    args.push(new Term(this._r).expr(end))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.changeAt = function(index, value) {
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'changeAt', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CHANGE_AT);
  var args = [this];
  args.push(new Term(this._r).expr(index))
  args.push(new Term(this._r).expr(value))
  term._fillArgs(args);
  return term;
}
Term.prototype.keys = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'keys', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.KEYS)
  var args = [this];
  term._fillArgs(args);
  return term;
}

Term.prototype.values = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'keys', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.VALUES)
  var args = [this];
  term._fillArgs(args);
  return term;
}

Term.prototype.object = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, 'object');
  this._arityRange(_args, 0, Infinity, 'object', this);

  var term = new Term(this._r);
  term._query.push(termTypes.OBJECT)
  var args = [];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}



// String
Term.prototype.match = function(regex) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'match', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MATCH)
  var args = [this, new Term(this._r).expr(regex)];
  term._fillArgs(args);
  return term;
}
Term.prototype.upcase = function(regex) {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'upcase', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.UPCASE)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.downcase = function(regex) {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'upcase', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DOWNCASE)
  var args = [this];
  term._fillArgs(args);
  return term;
}




// Math and Logic
Term.prototype.add = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'add', this);

  var term = new Term(this._r);
  term._query.push(termTypes.ADD)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.sub = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'sub', this);

  var term = new Term(this._r);
  term._query.push(termTypes.SUB)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.mul = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'mul', this);

  var term = new Term(this._r);
  term._query.push(termTypes.MUL)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.div = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'div', this);

  var term = new Term(this._r);
  term._query.push(termTypes.DIV)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.mod = function(b) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'mod', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MOD)
  var args = [this, new Term(this._r).expr(b)];
  term._fillArgs(args);
  return term;
}
Term.prototype.and = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.AND)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length > 0)) {
    args.push(this);
  }
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.or = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.OR)
  var args = [];
  if (!Array.isArray(this._query) || (this._query.length > 0)) {
    args.push(this);
  }
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.eq = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'eq', this);

  var term = new Term(this._r);
  term._query.push(termTypes.EQ)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.ne = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'ne', this);

  var term = new Term(this._r);
  term._query.push(termTypes.NE)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.gt = function(other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'gt', this);

  var term = new Term(this._r);
  term._query.push(termTypes.GT)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.ge = function(other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'ge', this);

  var term = new Term(this._r);
  term._query.push(termTypes.GE)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.lt = function(other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'lt', this);

  var term = new Term(this._r);
  term._query.push(termTypes.LT)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.le = function(other) {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 1, Infinity, 'le', this);

  var term = new Term(this._r);
  term._query.push(termTypes.LE)
  var args = [this];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.not = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'not', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.NOT)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.random = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  var self = this;
  self._noPrefix(this, 'random');
  self._arityRange(_args, 0, 3, 'random', self);

  var term = new Term(self._r);
  term._query.push(termTypes.RANDOM);

  var args = [];
  for(var i=0; i<_args.length-1; i++) {
    args.push(new Term(self._r).expr(_args[i]))
  }
  if (_args.length > 0) {
    if (helper.isPlainObject(_args[_args.length-1])) {
      helper.loopKeys(_args[_args.length-1], function(obj, key) {
        if (key !== 'float') {
          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `random`', self._query, 'Available option is float: <boolean>');
        }
      });
      term._fillArgs(args);
      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);
    }
    else {
      args.push(new Term(self._r).expr(_args[_args.length-1]))
      term._fillArgs(args);
    }
  }
  else {
    term._fillArgs(args);
  }
  return term;
}
Term.prototype.floor = function() {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'floor', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FLOOR)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.ceil = function() {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'ceil', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.CEIL)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.round = function() {
  if (this._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 0, 1, 'round', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ROUND)
  var args = [this];
  term._fillArgs(args);
  return term;
}

// Dates and times
Term.prototype.now = function() {
  this._noPrefix(this, 'now');

  var term = new Term(this._r);
  term._query.push(termTypes.NOW)
  return term;
}
Term.prototype.time = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, 'time');
  // Special check for arity
  var foundArgs = false;
  for(var i=0; i<_args.length; i++) {
    if ((_args[i] instanceof Term) && (_args[i]._query[0] === termTypes.ARGS)) {
      foundArgs = true;
      break;
    }
  }
  if (foundArgs === false) {
    if ((_args.length !== 4) && (_args.length !== 7)) {
      throw new Error.ReqlDriverError('`r.time` called with '+_args.length+' argument'+((_args.length>1)?'s':''), null, '`r.time` takes 4 or 7 arguments');
    }
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIME)
  var args = [];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.epochTime = function(epochTime) {
  this._noPrefix(this, 'epochTime');

  var term = new Term(this._r);
  term._query.push(termTypes.EPOCH_TIME)
  var args = [new Term(this._r).expr(epochTime)];
  term._fillArgs(args);
  return term;
}
Term.prototype.ISO8601 = function(isoTime, options) {
  this._noPrefix(this, 'ISO8601');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'ISO8601', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.ISO8601)
  var args = [new Term(this._r).expr(isoTime)._query];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'defaultTimezone') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `ISO8601`. Available options are primaryKey <string>, durability <string>, datancenter <string>');
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }

  return term;
}
Term.prototype.inTimezone = function(timezone) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'inTimezone', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.IN_TIMEZONE)
  var args = [this, new Term(this._r).expr(timezone)];
  term._fillArgs(args);
  return term;
}
Term.prototype.timezone = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'timezone', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIMEZONE)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.during = function(left, right, options) {
  if (this._fastArityRange(arguments.length, 2, 3) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 2, 3, 'during', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DURING);
  var args = [];
  args.push(this);
  args.push(new Term(this._r).expr(left));
  args.push(new Term(this._r).expr(right));

  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.date = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'date', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DATE)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.timeOfDay = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'timeOfDay', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TIME_OF_DAY)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.year = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'year', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.YEAR)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.month = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'month', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MONTH)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.day = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'day', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.dayOfYear = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'dayOfYear', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY_OF_YEAR)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.dayOfWeek = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'dayOfWeek', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DAY_OF_WEEK)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.hours = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'hours', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.HOURS)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.minutes = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'minutes', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.MINUTES)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.seconds = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'seconds', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.SECONDS)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.toISO8601 = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toISO8601', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TO_ISO8601)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.toEpochTime = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toEpochTime', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TO_EPOCH_TIME)
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.monday = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.MONDAY);
  return term;
}
Term.prototype.tuesday = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.TUESDAY);
  return term;
}
Term.prototype.wednesday = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.WEDNESDAY);
  return term;
}
Term.prototype.thursday = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.THURSDAY);
  return term;
}
Term.prototype.friday = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.FRIDAY);
  return term;
}
Term.prototype.saturday = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.SATURDAY);
  return term;
}
Term.prototype.sunday = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.SUNDAY);
  return term;
}

Term.prototype.january = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.JANUARY);
  return term;
}
Term.prototype.february = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.FEBRUARY);
  return term;
}
Term.prototype.march = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.MARCH);
  return term;
}
Term.prototype.april = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.APRIL);
  return term;
}
Term.prototype.may = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.MAY);
  return term;
}
Term.prototype.june = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.JUNE);
  return term;
}
Term.prototype.july = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.JULY);
  return term;
}
Term.prototype.august = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.AUGUST);
  return term;
}
Term.prototype.september = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.SEPTEMBER);
  return term;
}
Term.prototype.october = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.OCTOBER);
  return term;
}
Term.prototype.november = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.NOVEMBER);
  return term;
}
Term.prototype.december = function() {
  var term = new Term(this._r);
  term._query.push(termTypes.DECEMBER);
  return term;
}


Term.prototype.args = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._noPrefix(this, 'args');

  var term = new Term(this._r);
  term._query.push(termTypes.ARGS);
  var args = [];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.do = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}

  var term = new Term(this._r);
  term._query.push(termTypes.FUNCALL);
  var args = [];
  if (_args.length > 0) {
    args.push(new Term(this._r).expr(_args[_args.length-1])._wrap()._query);
  }
  args.push(this);
  for(var i=0; i<_args.length-1; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}


Term.prototype.branch = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  this._arityRange(_args, 2, Infinity, '', this);

  var term = new Term(this._r);
  term._query.push(termTypes.BRANCH)
  var args = [];
  args.push(this);
  for(var i=0; i<_len; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.forEach = function(func) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'forEach', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.FOR_EACH);
  var args = [this, new Term(this._r).expr(func)._wrap()];
  term._fillArgs(args);
  return term;
}
Term.prototype.default = function(expression) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'default', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.DEFAULT);
  var args = [this, new Term(this._r).expr(expression)];
  term._fillArgs(args);
  return term;
}
Term.prototype.expr = function(expression, nestingLevel) {
  var self = this;
  self._noPrefix(self, 'expr');
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'expr', self);
  }

  // undefined will be caught in the last else
  var ar, obj;

  if (expression === undefined) {
    var error = 'Cannot convert `undefined` with r.expr()';
    return new Term(self._r, expression, error);
  }

  var _nestingLevel = nestingLevel;
  if (_nestingLevel == null) {
    _nestingLevel = self._r.nestingLevel;
  }
  //if (nestingLevel == null) nestingLevel = self._r.nestingLevel;
  if (_nestingLevel < 0) throw new Error.ReqlDriverError('Nesting depth limit exceeded.\nYou probably have a circular reference somewhere')

  if (expression instanceof Term) {
    return expression;
  }
  else if (expression instanceof Function) {
    return new Func(self._r, expression);
  }
  else if (expression instanceof Date) {
    return new Term(self._r).ISO8601(expression.toISOString())
  }
  else if (Array.isArray(expression)) {
    var term = new Term(self._r);
    term._query.push(termTypes.MAKE_ARRAY);

    var args = [];
    for(var i=0; i<expression.length; i++) {
      args.push(new Term(self._r).expr(expression[i], _nestingLevel-1))
    }
    term._fillArgs(args);
    return term;
  }
  else if (expression instanceof Buffer) {
    return self._r.binary(expression);
  }
  else if (helper.isPlainObject(expression)) {
    var term = new Term(self._r);
    var optArgs = {};
    var foundError = false;
    helper.loopKeys(expression, function(expression, key) {
      if (expression[key] !== undefined) {
        var optArg = new Term(self._r).expr(expression[key], _nestingLevel-1);
        if (optArg instanceof Term && !foundError && optArg._error != null) {
          foundError = true;
          term._error = optArg._error;
          term._frames = [key].concat(optArg._frames);
        }
        optArgs[key] = optArg._query;
      }
    });
    term._query = optArgs;
    return term;
  }
  else { // Primitive
    if (expression === null) {
      return new Term(self._r, null, expression);
    }
    else if (typeof expression === 'string') {
      return new Term(self._r, expression);
    }
    else if (typeof expression === 'number') {
      if (expression !== expression) {
        var error = 'Cannot convert `NaN` to JSON';
        return new Term(self._r, expression, error);
      }
      else if (!isFinite(expression)) {
        var error = 'Cannot convert `Infinity` to JSON';
        return new Term(self._r, expression, error);
      }
      return new Term(self._r, expression);
    }
    else if (typeof expression === 'boolean') {
      return new Term(self._r, expression);
    }
    else {
      self._error = new Error.ReqlDriverError('Cannot convert `'+expression+'` to datum.');
      self._frames = [];
    }
  }
  return self;
}

Term.prototype.binary = function(bin) {
  this._noPrefix(this, 'binary');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'binary', this);
  }

  var term;
  if (bin instanceof Buffer) {
    // We could use BINARY, and coerce `bin` to an ASCII string, but that
    // will break if there is a null char
    term = new Term(this._r, {
      $reql_type$: 'BINARY',
      data: bin.toString('base64')
    });
  }
  else {
    term = new Term(this._r);
    term._query.push(termTypes.BINARY)
    var args = [new Term(this._r).expr(bin)];
    term._fillArgs(args);
  }
  return term;
}

Term.prototype.js = function(arg, options) {
  this._noPrefix(this, 'js');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'js', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.JAVASCRIPT)
  var args = [new Term(this._r).expr(arg)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.coerceTo = function(type) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'coerceTo', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.COERCE_TO)
  var args = [this, new Term(this._r).expr(type)];
  term._fillArgs(args);
  return term;
}
Term.prototype.typeOf = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'typeOf', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.TYPE_OF);
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.info = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'info', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.INFO);
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.json = function(json) {
  this._noPrefix(this, 'json');
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'info', this);
  }
  /*
  if ((/\\u0000/.test(json)) || (/\0/.test(json))) {
    this._error = new Error.ReqlDriverError('The null character is currently not supported by RethinkDB');
  }
  */
  var term = new Term(this._r);
  term._query.push(termTypes.JSON);

  var args = [new Term(this._r).expr(json)];
  term._fillArgs(args);
  return term;
}
Term.prototype.http = function(url, options) {
  this._noPrefix(this, 'http');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'http', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.HTTP);
  var args = [new Term(this._r).expr(url)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'timeout')
        && (key !==  'attempts')
        && (key !==  'redirects')
        && (key !==  'verify')
        && (key !==  'resultFormat')
        && (key !==  'method')
        && (key !==  'auth')
        && (key !==  'params')
        && (key !==  'header')
        && (key !==  'data')
        && (key !==  'page')
        && (key !==  'pageLimit')
        && (key !==  '')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `http`. Available options are attempts <number>, redirects <number>, verify <boolean>, resultFormat: <string>, method: <string>, auth: <object>, params: <object>, header: <string>, data: <string>, page: <string/function>, pageLimit: <number>');
      }
    });

    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.uuid = function(str) {
  this._noPrefix(this, 'uuid');

  var term = new Term(this._r);
  term._query.push(termTypes.UUID)

  if (str !== undefined) {
    var args = [new Term(this._r).expr(str)];
    term._fillArgs(args);
  }
  return term;
}


Term.prototype.circle = function(center, radius, options) {
  var self = this;

  // Arity check is done by r.circle
  self._noPrefix(self, 'circle');
  var term = new Term(self._r);
  term._query.push(termTypes.CIRCLE);
  var args = [new Term(self._r).expr(center), new Term(self._r).expr(radius)];
  term._fillArgs(args);

  if (helper.isPlainObject(options)) {
    // There is no need to translate here
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'numVertices') && (key !== 'geoSystem') && (key !== 'unit') && (key !== 'fill')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `circle`', self._query, 'Available options are numVertices <number>, geoSsystem <string>, unit <string> and fill <bool>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }

  return term;
}
Term.prototype.distance = function(geometry, options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 1, 2, 'distance', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.DISTANCE);
  var args = [self, new Term(self._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'geoSystem') && (key !== 'unit')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are geoSystem <string>, unit <string>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;
}
Term.prototype.fill = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'fill', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.FILL);
  var args = [this];
  term._fillArgs(args);
  return term;
}

Term.prototype.geojson = function(geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'geojson', this);
  }
  this._noPrefix(this, 'geojson');
  var term = new Term(this._r);
  term._query.push(termTypes.GEOJSON);
  var args = [new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}

Term.prototype.toGeojson = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toGeojson', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_GEOJSON);
  var args = [this];
  term._fillArgs(args);
  return term;
}

Term.prototype.getIntersecting = function(geometry, options) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'getIntersecting', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.GET_INTERSECTING);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if (key !== 'index') {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are index <string>');
      }
    });
    term._query.push(new Term(this._r).expr(translateOptions(options))._query);
  }
  return term;
}

Term.prototype.getNearest = function(geometry, options) {
  var self = this;
  if (self._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arity(_args, 2, 'getNearest', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.GET_NEAREST);
  var args = [self, new Term(self._r).expr(geometry)];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'index') && (key !== 'maxResults') && (key !== 'maxDist') && (key !== 'unit') && (key !== 'geoSystem')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `getNearest`', self._query, 'Available options are index <string>, maxResults <number>, maxDist <number>, unit <string>, geoSystem <string>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }
  return term;

}

Term.prototype.includes = function(geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'includes', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.INCLUDES);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}

Term.prototype.intersects = function(geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'intersects', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.INTERSECTS);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}

Term.prototype.line = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  // Arity check is done by r.line
  this._noPrefix(this, 'line');

  var term = new Term(this._r);
  term._query.push(termTypes.LINE);

  var args = [];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);
  return term;
}

Term.prototype.point = function(longitude, latitude) {
  // Arity check is done by r.point
  this._noPrefix(this, 'point');

  var term = new Term(this._r);
  term._query.push(termTypes.POINT);
  var args = [new Term(this._r).expr(longitude), new Term(this._r).expr(latitude)];
  term._fillArgs(args);
  return term;
}

Term.prototype.polygon = function() {
  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
  // Arity check is done by r.polygon
  this._noPrefix(this, 'polygon');

  var term = new Term(this._r);
  term._query.push(termTypes.POLYGON);

  var args = [];
  for(var i=0; i<_args.length; i++) {
    args.push(new Term(this._r).expr(_args[i]))
  }
  term._fillArgs(args);

  return term;
}

Term.prototype.polygonSub = function(geometry) {
  if (this._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 1, 'polygonSub', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.POLYGON_SUB);
  var args = [this, new Term(this._r).expr(geometry)];
  term._fillArgs(args);
  return term;
}

Term.prototype.range = function(start, end) {
  this._noPrefix(this, 'range');
  if (this._fastArityRange(arguments.length, 1, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arityRange(_args, 1, 2, 'r.range', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.RANGE);
  var args = [];
  args.push(new Term(this._r).expr(start));
  if (end !== undefined) {
    args.push(new Term(this._r).expr(end));
  }
  term._fillArgs(args);
  return term;
}
Term.prototype.toJsonString = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'toJSON', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.TO_JSON_STRING);
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.toJSON = Term.prototype.toJsonString;

Term.prototype.config = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'config', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.CONFIG);
  var args = [this];
  term._fillArgs(args);
  return term;
}

Term.prototype.status = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'status', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.STATUS);
  var args = [this];
  term._fillArgs(args);
  return term;
}

Term.prototype.wait = function(options) {
  var self = this;
  if (self._fastArityRange(arguments.length, 0, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arityRange(_args, 0, 1, 'wait', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.WAIT);
  var args = [self];
  term._fillArgs(args);
  if (helper.isPlainObject(options)) {
    helper.loopKeys(options, function(obj, key) {
      if ((key !== 'waitFor') && (key !== 'timeout')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `wait`', self._query, 'Available options are waitFor: <string>, timeout: <number>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(options))._query);
  }

  return term;
}

Term.prototype.reconfigure = function(config) {
  var self = this;
  if (self._fastArity(arguments.length, 1) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    self._arity(_args, 1, 'reconfigure', self);
  }
  var term = new Term(self._r);
  term._query.push(termTypes.RECONFIGURE);

  var args = [this];
  term._fillArgs(args);
  if (helper.isPlainObject(config)) {
    helper.loopKeys(config, function(obj, key) {
      if ((key !== 'shards') && (key !== 'replicas') &&
        (key !== 'dryRun') && (key !== 'primaryReplicaTag') &&
        (key !== 'nonvotingReplicaTags') && (key !== 'emergencyRepair')) {
        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `reconfigure`', self._query, 'Available options are shards: <number>, replicas: <number>, primaryReplicaTag: <object>, dryRun <boolean>, emergencyRepair: <string>, nonvotingReplicaTags: <array<string>>');
      }
    });
    term._query.push(new Term(self._r).expr(translateOptions(config))._query);
  }
  else {
    throw new Error.ReqlDriverError('First argument of `reconfigure` must be an object');
  }
  return term;
}

Term.prototype.rebalance = function() {
  if (this._fastArity(arguments.length, 0) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 0, 'rebalance', this);
  }
  var term = new Term(this._r);
  term._query.push(termTypes.REBALANCE);
  var args = [this];
  term._fillArgs(args);
  return term;
}
Term.prototype.grant = function(name, access) {
  if (this._fastArity(arguments.length, 2) === false) {
    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}
    this._arity(_args, 2, 'grant', this);
  }

  var term = new Term(this._r);
  term._query.push(termTypes.GRANT)
  var args = [this, new Term(this._r).expr(name), new Term(this._r).expr(access)];
  term._fillArgs(args);
  return term;
}


Term.prototype.then = function(resolve, reject) {
  return this.run().then(resolve, reject);
}
Term.prototype.error = function(reject) {
  return this.run().error(reject);
}
Term.prototype.catch = function(reject) {
  return this.run().catch(reject);
}
Term.prototype.finally = function(handler) {
  return this.run().finally(handler);
}
Term.prototype.delay = function(msecs) {
  return this.run().delay(msecs);
}

Term.prototype.toString = function() {
  return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;
}

Term.prototype._wrap = function() {
  var self = this;
  if (helper.hasImplicit(this._query)) {
    if (this._query[0] === termTypes.ARGS) {
      throw new Error.ReqlDriverError('Implicit variable `r.row` cannot be used inside `r.args`')
    }
    //Must pass at least one variable to the function or it won't accept r.row
    return new Term(this._r).expr(function(doc) { return self; })
  }
  else {
    return self;
  }
}

Term.prototype._fillArgs = function(args) {
  var foundError = false;
  var internalArgs = [];
  for(var i=0; i<args.length; i++) {
  if (args[i] instanceof Term) {
    internalArgs.push(args[i]._query);
    if (!foundError && (args[i]._error != null)) {
    this._error = args[i]._error;
    this._frames = args[i]._frames;
    this._frames.unshift(i);
    foundError = true;
    }
  }
  else {
    internalArgs.push(args[i]);
  }
  }
  this._query.push(internalArgs);
  return this;
}

Term.prototype._translateArgs = {
  returnChanges: 'return_changes',
  includeInitial: 'include_initial',
  primaryKey: 'primary_key',
  readMode: 'read_mode',
  nonAtomic: 'non_atomic',
  leftBound: 'left_bound',
  rightBound: 'right_bound',
  defaultTimezone: 'default_timezone',
  noReply: 'noreply',
  resultFormat: 'result_format',
  pageLimit: 'page_limit',
  arrayLimit: 'array_limit',
  numVertices: 'num_vertices',
  geoSystem: 'geo_system',
  maxResults: 'max_results',
  maxDist: 'max_dist',
  dryRun: 'dry_run',
  waitFor: 'wait_for',
  includeStates: 'include_states',
  primaryReplicaTag: 'primary_replica_tag',
  emergencyRepair: 'emergency_repair',
  minBatchRows: 'min_batch_rows',
  maxBatchRows: 'max_batch_rows',
  maxBatchBytes: 'max_batch_bytes',
  maxBatchSeconds: 'max_batch_seconds',
  firstBatchScaledownFactor: 'first_batch_scaledown_factor',
  includeOffsets: 'include_offsets',
  includeTypes: 'include_types',
  finalEmit: 'final_emit'
}
function translateOptions(options) {
  var translatedOpt = {};
  helper.loopKeys(options, function(options, key) {
    var keyServer = Term.prototype._translateArgs[key] || key;
    translatedOpt[keyServer] = options[key];
  });
  return translatedOpt;
}
Term.prototype._setNestingLevel = function(nestingLevel) {
  Term.prototype._nestingLevel = nestingLevel;
}
Term.prototype._setArrayLimit = function(arrayLimit) {
  Term.prototype._arrayLimit = arrayLimit;
}


Term.prototype._noPrefix = function(term, method) {
  if ((!Array.isArray(term._query)) || (term._query.length > 0)) {
    throw new Error.ReqlDriverError('`'+method+'` is not defined', term._query);
  }
}
Term.prototype._arityRange = function(args, min, max, method, term) {
  var foundArgs = false;
  if (args.length < min) {
    for(var i=0; i<args.length; i++) {
      if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {
        foundArgs = true;
        break;
      }
    }
    if (foundArgs === false) {
      throw new Error.ReqlDriverError('`'+method+'` takes at least '+min+' argument'+((min>1)?'s':'')+', '+args.length+' provided', term._query);
    }
  }
  else if (args.length > max) {
    for(var i=0; i<args.length; i++) {
      if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {
        foundArgs = true;
        break;
      }
    }
    if (foundArgs === false) {
      throw new Error.ReqlDriverError('`'+method+'` takes at most '+max+' argument'+((max>1)?'s':'')+', '+args.length+' provided', term._query);
    }
  }
}
Term.prototype._arity = function(args, num, method, term) {
  var foundArgs = false;
  for(var i=0; i<args.length; i++) {
    if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {
      foundArgs = true;
      break;
    }
  }
  if (foundArgs === false) {
    throw new Error.ReqlDriverError('`'+method+'` takes '+num+' argument'+((num>1)?'s':'')+', '+args.length+' provided', term._query);
  }
}
// Cheap arity check. If it fails, return false, and then we are expected to call _arity/_arityRange
Term.prototype._fastArity = function(len, num) {
  return (len === num);
}
Term.prototype._fastArityRange = function(len, min, max) {
  return ((len >= min) && (len <= max));
}


// Datums
function Func(r, func) {
  // We can retrieve the names of the arguments with
  // func.toString().match(/\(([^\)]*)\)/)[1].split(/\s*,\s*/)

  var term = new Term(r);
  term._query.push(termTypes.FUNC);
  var args = [];
  var argVars = [];
  var argNums = [];

  for(var i=0; i<func.length; i++) {
    argVars.push(new Var(r, r.nextVarId));
    argNums.push(r.nextVarId);

    if (r.nextVarId === 9007199254740992) { // That seems like overdoing it... but well maybe...
      r.nextVarId = 0;
    }
    else {
      r.nextVarId++;
    }
  }

  var body = func.apply(func, argVars)
  if (body === undefined) throw new Error.ReqlDriverError('Anonymous function returned `undefined`. Did you forget a `return`? In:\n'+func.toString(), this._query);
  body = new Term(r).expr(body);
  args.push(new Term(r).expr(argNums));
  args.push(body);

  term._fillArgs(args);

  return term;
}
Func.prototype.nextVarId = 1;

function Var(r, id) {
  var term = new Term(r);
  term._query.push(termTypes.VAR)
  term._query.push([new Term(r).expr(id)._query])
  return term;
}

module.exports = Term;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/transform_stream.js":
/*!*************************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/transform_stream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(/*! stream */ "stream").Transform;
var Cursor = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/cursor.js */ "../node_modules/rethinkdbdash/lib/cursor.js");
var util = __webpack_require__(/*! util */ "util");

// Experimental, but should work fine.
function TransformStream(table, options, connection) {
  this._table = table;
  this._r = table._r;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._ended = false;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;
  this._insertOptions = {};
  this._insertOptions.durability = options.durability || 'hard';
  this._insertOptions.conflict = options.conflict || 'error';
  this._insertOptions.returnChanges = options.returnChanges || true;

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Transform.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
};
util.inherits(TransformStream, Transform);

TransformStream.prototype._transform = function(value, encoding, done) {
  this._cache.push(value);
  this._next(value, encoding, done);
}

// Everytime we want to insert but do not have a full buffer,
// we recurse with setImmediate to give a chance to the input
// stream to push a few more elements
TransformStream.prototype._next = function(value, encoding, done) {
  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {
    // There's more data to buffer
    if (this._cache.length < this._highWaterMark) {
      this._delayed = false;
      // Call done now, and more data will be put in the cache
      done();
    }
    else {
      if (this._inserting === false) {
        if (this._delayed === true) {
          // We have to flush
          this._delayed = false;
          this._insert();
          // Fill the buffer while we are inserting data
          done();
        }
        else {
          var self = this;
          this._delayed = true;
          setImmediate(function() {
            self._next(value, encoding, done);
          })
        }

      }
      else {
        // to call when we are dong inserting to keep buffering
        this._pendingCallback = done;
      }
    }
  }
  else { // We just pushed the last element in the internal buffer
    if (this._inserting === false) {
      if (this._delayed === true) {
        this._delayed = false;
        // to call when we are dong inserting to maybe flag the end
        this._insert();
        // We can call done now, because we have _flush to close the stream
        done();
      }
      else {
        var self = this;
        this._delayed = true;
        setImmediate(function() {
          self._next(value, encoding, done);
        })
      }
    }
    else {
      this._delayed = false;
      // There is nothing left in the internal buffer
      // But something is already inserting stuff.
      if (this._cache.length < this._highWaterMark-1) {
        // Call done, to attempt to buffer more
        // This may trigger _flush
        //this._pendingCallback = done;
        done();
      }
      else {
        this._pendingCallback = done;
      }
    }
  }
}

TransformStream.prototype._insert = function() {
  var self = this;
  self._inserting = true;

  var cache = self._cache;
  self._cache = [];

  if (Array.isArray(self._sequence)) {
    self._sequence.push(cache.length);
  }

  var pendingCallback = self._pendingCallback;
  self._pendingCallback = null;
  if (typeof pendingCallback === 'function') {
    pendingCallback();
  }

  var query = self._table.insert(cache, self._insertOptions);
  if (self._options.format === 'primaryKey') {
    query = query.do(function(result) {
      return self._r.branch(
        result('errors').eq(0),
        self._table.config()('primary_key').do(function(primaryKey) {
          return result('changes')('new_val')(primaryKey)
        }),
        result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\n').add(result('first_error'))))
      )
    })
  }

  query.run(self._connection).then(function(result) {
    self._inserting = false;
    if (self._options.format === 'primaryKey') {
      for(var i=0; i<result.length; i++) {
        self.push(result[i]);
      }
    }
    else {
      if (result.errors > 0) {
        self._inserting = false;
        self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));
      }
      else {
        if (self._insertOptions.returnChanges === true) {
          for(var i=0; i<result.changes.length; i++) {
            self.push(result.changes[i].new_val);
          }
        }
      }
    }

    pendingCallback = self._pendingCallback
    self._pendingCallback = null;
    if (typeof pendingCallback === 'function') {
      // Mean that we can buffer more
      pendingCallback();
    }
    else if (self._ended !== true) {
      if (((((self._writableState.lastBufferedRequest === null) ||
          self._writableState.lastBufferedRequest.chunk === self._cache[self._cache.length-1])))
        && (self._cache.length > 0)) {
          self._insert();
      }
    }
    else if (self._ended === true) {
      if (self._cache.length > 0) {
        self._insert();
      }
      else {
        if (typeof self._flushCallback === 'function') {
          self._flushCallback();
        }
        self.push(null);
      }
    }
  }).error(function(error) {
    self._inserting = false;
    self.emit('error', error);
  });
}

TransformStream.prototype._flush = function(done) {
  this._ended = true;
  if ((this._cache.length === 0) && (this._inserting === false)) {
    done();
  }
  else { // this._inserting === true
    if (this._inserting === false) {
      this._flushCallback = done;
      this._insert();
    }
    else {
      this._flushCallback = done;
    }
  }
}


module.exports = TransformStream;


/***/ }),

/***/ "../node_modules/rethinkdbdash/lib/writable_stream.js":
/*!************************************************************!*\
  !*** ../node_modules/rethinkdbdash/lib/writable_stream.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Writable = __webpack_require__(/*! stream */ "stream").Writable;
var Cursor = __webpack_require__(/*! ../node_modules/rethinkdbdash/lib/cursor.js */ "../node_modules/rethinkdbdash/lib/cursor.js");
var util = __webpack_require__(/*! util */ "util");

// Experimental, but should work fine.
function WritableStream(table, options, connection) {
  this._table = table;
  this._options = options;
  this._cache = [];
  this._pendingCallback = null;
  this._inserting = false;
  this._delayed = false;
  this._connection = connection;
  this._highWaterMark = options.highWaterMark || 100;

  this._insertOptions = {};
  this._insertOptions.durability = options.durability || 'hard';
  this._insertOptions.conflict = options.conflict || 'error';

  // Internal option to run some tests
  if (options.debug === true) {
    this._sequence = [];
  }

  Writable.call(this, {
    objectMode: true,
    highWaterMark: this._highWaterMark
  });
  this._i = 0;
};
util.inherits(WritableStream, Writable);

WritableStream.prototype._write = function(value, encoding, done) {
  this._i++;
  this._cache.push(value);
  this._next(value, encoding, done);
}

// Everytime we want to insert but do not have a full buffer,
// we recurse with setImmediate to give a chance to the input
// stream to push a few more elements
WritableStream.prototype._next = function(value, encoding, done) {
  var self = this;
  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {
    // There's more data to buffer
    if (this._cache.length < this._highWaterMark) {
      this._delayed = false;
      // Call done now, and more data will be put in the cache
      done();
    }
    else {
      if (this._inserting === false) {
        if (this._delayed === true) {
          this._delayed = false;
          // We have to flush
          this._insert();
          // Fill the buffer while we are inserting data
          done();
        }
        else {
          var self = this;
          this._delayed = true;
          setImmediate(function() {
            self._next(value, encoding, done);
          })
        }

      }
      else {
        this._delayed = false;
        // to call when we are dong inserting to keep buffering
        this._pendingCallback = done;
      }
    }
  }
  else { // We just pushed the last element in the internal buffer
    if (this._inserting === false) {
      if (this._delayed === true) {
        this._delayed = false;
        // to call when we are dong inserting to maybe flag the end
        // We cannot call done here as we may be inserting the last batch
        this._pendingCallback = done;
        this._insert();
      }
      else {
        var self = this;
        this._delayed = true;
        setImmediate(function() {
          self._next(value, encoding, done);
        })
      }
    }
    else {
      this._delayed = false;
      // We cannot call done here as we may be inserting the last batch
      //this._pendingCallback = done;
      this._pendingCallback = function() {
        self._next(value, encoding, done);
      };
    }
  }
}

WritableStream.prototype._insert = function() {
  var self = this;
  self._inserting = true;

  var cache = self._cache;
  self._cache = [];

  if (Array.isArray(self._sequence)) {
    self._sequence.push(cache.length);
  }

  self._table.insert(cache, self._insertOptions).run(self._connection).then(function(result) {
    self._inserting = false;
    if (result.errors > 0) {
      self._inserting = false;
      self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));
    }
    if (typeof self._pendingCallback === 'function') {
      var pendingCallback = self._pendingCallback;
      self._pendingCallback = null;
      pendingCallback();
    }
    return null;
  }).error(function(error) {
    self._inserting = false;
    self.emit('error', error);
  });
}


module.exports = WritableStream;


/***/ }),

/***/ "../node_modules/thinky/lib/document.js":
/*!**********************************************!*\
  !*** ../node_modules/thinky/lib/document.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var schemaUtil =    __webpack_require__(/*! ../node_modules/thinky/lib/schema.js */ "../node_modules/thinky/lib/schema.js");
var type =          __webpack_require__(/*! ../node_modules/thinky/lib/type/index.js */ "../node_modules/thinky/lib/type/index.js");
var util =          __webpack_require__(/*! ../node_modules/thinky/lib/util.js */ "../node_modules/thinky/lib/util.js");
var Promise =       __webpack_require__(/*! bluebird */ "bluebird");
var EventEmitter =  __webpack_require__(/*! events */ "events").EventEmitter;
var Errors =        __webpack_require__(/*! ../node_modules/thinky/lib/errors.js */ "../node_modules/thinky/lib/errors.js");


/**
 * Create a document of a model (returned by `thinky.createModel`).
 * @param {function} model The model of this document
 * @param {object=} options Options that can overwrite the ones of the model
 */
function Document(model, options) {
  var self = this;  // Keep a reference to itself.

  this.constructor = model;  // The constructor for this model
  this._model = model._getModel(); // The instance of Model

  // We don't want to store options if they are different
  // than the one provided by the model
  if (util.isPlainObject(options)) {
    this._schemaOptions = {};
    this._schemaOptions.enforce_missing =
        (options.enforce_missing != null) ? options.enforce_missing : model.getOptions().enforce_missing;
    this._schemaOptions.enforce_extra =
        (options.enforce_extra != null) ? options.enforce_extra : model.getOptions().enforce_extra;
    this._schemaOptions.enforce_type =
        (options.enforce_type != null) ? options.enforce_type : model.getOptions().enforce_type;
  }

  //TODO: We do not need to make a deep copy. We can do the same as for this._schemaOptions.
  options = options || {};
  this._options = {};
  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : model.getOptions().timeFormat;
  this._options.validate = (options.validate != null) ? options.validate : model.getOptions().validate;

  this._saved = options.saved || false;  // Whether the document is saved or not

  util.bindEmitter(self);  // Copy methods from eventEmitter

  // links to hasOne/hasMany documents
  // We use it to know if some links have been removed/added before saving.
  // Example: { key: doc } or { key: [docs] }
  this._belongsTo = {};
  this._hasOne = {};
  this._hasMany = {};
  // Example: { <linkTableName>: { <valueOfRightKey>: true, ... }, ... }
  this._links = {}

  // Keep reference of any doc having a link pointing to this
  // So we can clean when users do doc.belongsToDoc.delete()
  this._parents = {
    _hasOne: {},      // <tableName>: [{doc, key}]
    _hasMany: {},     // <tableName>: [{doc, key}]
    _belongsTo: {},   // <tableName>: [{doc, key, foreignKey}]
    _belongsLinks: {} // <tableName>: [{doc, key}]
  }

  // Bind listeners of the model to this documents.
  util.loopKeys(model._listeners, function(listeners, eventKey) {
    for(var j=0; j<listeners[eventKey].length; j++) {
      if (listeners[eventKey][j].once === false) {
        self.addListener(eventKey, listeners[eventKey][j].listener);
      }
      else if (listeners[eventKey][j].once === true) {
        self.once(eventKey, listeners[eventKey][j].listener);
      }
    }
  });


  // Atom feed
  this._active = false;
  this._feed = null;

  // Add customized methods of the model on this document.
  util.loopKeys(model._methods, function(methods, key) {
    if (self[key] === undefined) {
      self[key] = methods[key];
    }
    else {
      //TODO: Should we warn the users? Throw an error?
      console.log(self[key]);
      console.log("A property "+key+" is already defined in the prototype chain. Skipping.");
    }
  });
}


/**
 * Return the options of the document, not the instance of Document.
 * @return {Object=}
 */
Document.prototype._getOptions = function() {
  return this.__proto__._options;
}


/**
 * Return the options for the schema of the document, not the instance of Document.
 * @return {Object=}
 */
Document.prototype._getSchemaOptions = function() {
  return this.__proto__._schemaOptions;
}


/**
 * Return the constructor of the document, not the instance of Document.
 * @return {function}
 */
Document.prototype.getModel = function() {
  return this.__proto__.constructor;
}


/**
 * Return the model, the instance of Model
 * @return {function}
 */
Document.prototype._getModel = function() {
  return this.__proto__._model;
}


/**
 * Save the virtual fields of the document to be re-injected later.
 */
Document.prototype._saveVirtual = function() {
  var copy = {};
  var model = this._getModel(); // instance of Model

  // TODO We could do better and copy less things, but things get a bit tricky
  // when virtual fields are nested in arrays.
  // This implementation still allows no overhead if no virtual fields exist,
  // which should be the most common case
  for(var i=0; i<this._getModel().virtualFields.length; i++) {
    var key = this._getModel().virtualFields[i].path[0];
    copy[key] = this[key];
  }
  this.__proto__.virtualValue = util.deepCopy(copy);
}


/**
 * Get the virtual fields saved by `_saveVirtual`.
 * @return {Object=}
 */
Document.prototype._getVirtual = function() {
  return this.__proto__.virtualValue;
}

/**
 * Generate the virtual values for the document, or re-inject the ones
 * previously saved.
 * This should be called **after** `_generateDefault`.
 */
Document.prototype.generateVirtualValues = function() {
  for(var i=0; i<this._getModel().virtualFields.length; i++) {
    schemaUtil.generateVirtual(this, this._getModel().virtualFields[i], this, this._getVirtual());
  }
}


/**
 * Generate the default values for the document, first the non virtual fields, and then
 * the virtual fields.
 */
Document.prototype._generateDefault = function() {
  for(var i=0; i<this._getModel().defaultFields.length; i++) {
    schemaUtil.generateDefault(this, this._getModel().defaultFields[i], this);
  }
  if (this._getModel().virtualFields.length > 0) {
    this.generateVirtualValues();
  }
}


/*
 * Validate this document against the schema of its model and triggers all the hooks.
 * @param {Object=} options Options to overwrite the ones of the document.
 * @param {Object=} modelToValidate Internal parameter, model to validate
 * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.
 * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.
 * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).
 * @return {Promise=} return a promise if the validation is asynchrone, else undefined.
 */
Document.prototype.validate = function(options, modelToValidate, validateAll, validatedModel, prefix) {
  modelToValidate = modelToValidate || {};
  validateAll = validateAll || false;
  validatedModel = validatedModel || {};
  prefix = prefix || '';

  var self = this;
  var validatedModelCopy = util.deepCopy(validatedModel);

  //TODO: Can we not always call this?
  var async = self._validateIsAsync(modelToValidate, validateAll, validatedModelCopy);

  return util.hook({
    preHooks: self._getModel()._pre.validate,
    postHooks: self._getModel()._post.validate,
    doc: self,
    async: async,
    fn: self._validateHook,
    fnArgs: [options, modelToValidate, validateAll, validatedModel, prefix]
  })
}


/*
 * Validate this document against the schema of its model and all its joined documents and triggers all the hooks
 * @param {Object=} options Options to overwrite the ones of the document.
 * @param {Object=} modelToValidate Internal parameter, model to validate
 * @return {Promise=} return a promise if the validation is asynchrone, else undefined.
 */
Document.prototype.validateAll = function(options, modelToValidate) {
  var validateAll = modelToValidate === undefined;
  modelToValidate = modelToValidate || {};

  return this.validate(options, modelToValidate, validateAll, {}, '', true);
}


/*
 * Internal methods that will validate the document (but that will not execute the hooks).
 * @param {Object=} options Options to overwrite the ones of the document.
 * @param {Object=} modelToValidate Internal parameter, model to validate
 * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.
 * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.
 * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).
 * @return {Promise=} return a promise if the validation is asynchrone, else undefined.
 */
Document.prototype._validateHook = function(options, modelToValidate, validateAll, validatedModel, prefix) {
  var self = this;
  var promises = [];
  var error;

  var schemaOptions = self._getSchemaOptions();
  if (util.isPlainObject(schemaOptions)) {
    schemaOptions = util.mergeOptions(schemaOptions, options);
  }
  else {
    schemaOptions = options;
  }


  if (typeof self._getModel()._validator === 'function') {
    if (self._getModel()._validator.call(self, self) === false) {
      throw new Errors.ValidationError("Document's validator returned `false`.");
    }
  }

  // Validate this document
  self._getModel()._schema.validate(self, prefix, schemaOptions)

  if (util.isPlainObject(modelToValidate) === false) {
    modelToValidate = {};
  }

  var constructor = self.__proto__.constructor;
  validatedModel[constructor.getTableName()] = true;

  // Validate joined documents
  util.loopKeys(self._getModel()._joins, function(joins, key) {
    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {
      switch (joins[key].type) {
        case 'hasOne':
        case 'belongsTo':
          if (util.isPlainObject(self[key])) {
            if (self[key] instanceof Document === false) {
              self[key] = new self._getModel()._joins[key].model(self[key]);
            }
            // We do not propagate the options of this document, but only those given to validate
            var promise = self[key].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']');
            if (promise instanceof Promise) {
              promises.push(promise);
              promise = null;
            }
          }
          else if (self[key] != null) {
            throw new Errors.ValidationError("Joined field "+prefix+"["+key+"] should be `undefined`, `null` or an `Object`")
          }
          break;

        case 'hasMany':
        case 'hasAndBelongsToMany':
          if (Array.isArray(self[key])) {
            for(var i=0; i<self[key].length; i++) {
              if (util.isPlainObject(self[key][i])) {
                if (self[key][i] instanceof Document === false) {
                  self[key][i] = new self._getModel()._joins[key].model(self[key][i]);
                }
                promise = self[key][i].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']['+i+']');
                if (promise instanceof Promise) {
                  promises.push(promise);
                  promise = null;
                }
              }
              else {
                throw new Errors.ValidationError("Joined field "+prefix+"["+key+"]["+i+"] should be `undefined`, `null` or an `Array`")
              }
            }
          }
          else if (self[key] != null) {
            throw new Errors.ValidationError("Joined field "+prefix+"["+key+"] should be `undefined`, `null` or an `Array`")
          }
          break;
      }
    }
  });
  if (promises.length > 0) {
    return Promise.all(promises);
  }
}


/*
 * Return whether the validation run with the same options will be asynchronous or not.
 * @param {Object=} modelToValidate Internal parameter, model to validate
 * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.
 * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.
 * @return {boolean}
 */
Document.prototype._validateIsAsync = function(modelToValidate, validateAll, validatedModel) {
  var self = this;

  if (self._getModel()._async.validate) {
    return true;
  }
  var async = false;
  util.loopKeys(self._getModel()._joins, function(joins, key) {
    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {
      if (((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo'))) {
        if (util.isPlainObject(self[key])) {
          if (self[key] instanceof Document === false) {
            self[key] = new self._getModel()._joins[key].model(self[key]);
          }
          // We do not propagate the options of this document, but only those given to validate
          if (self[key]._getModel()._async.validate || self[key]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {
            async = true;
            return false;
          }
        }
      }
      else  if (((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany'))) {
        if (Array.isArray(self[key])) {
          for(var i=0; i<self[key].length; i++) {
            if (util.isPlainObject(self[key][i])) {
              if (self[key][i] instanceof Document === false) {
                self[key][i] = new self._getModel()._joins[key].model(self[key][i]);
              }
              if (self[key][i]._getModel()._async.validate || self[key][i]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {
                async = true;
                return false;
              }
            }
          }
        }
      }
    }
    return false;
  });
  return async;
}


/**
 * Save the document and execute the hooks. Return a promise if the callback
 * is not provided.
 * @param {function=} callback to execute
 * @return {Promise=}
 */
Document.prototype.save = function(callback) {
  return this._save({}, false, {}, callback);
}


/**
 * Save the document and its joined documents. It will also execute the hooks.
 * Return a promise if the callback is not provided.
 * It will save joined documents as long as a document of the same model has not
 * been saved.
 * @param {function=} callback to execute
 * @return {Promise=}
 */
Document.prototype.saveAll = function(docToSave, callback) {
  var saveAll;
  if (typeof docToSave === 'function') {
    callback = docToSave;
    saveAll = true;
    docToSave = {};
  }
  else {
    saveAll = docToSave === undefined;
    docToSave = docToSave || {};
  }

  return this._save(docToSave, saveAll,{}, callback);
}


/**
 * Return a savable copy of the document by removing the extra fields,
 * generating the default and virtual fields.
 * @return {object}
 */
Document.prototype._makeSavableCopy = function() {
  var model = this._getModel(); // instance of Model
  var schema = this._getModel()._schema;

  var r = this._getModel()._thinky.r;

  if (this._getModel().needToGenerateFields === true){
    this._generateDefault();
  }

  return this.__makeSavableCopy(this, schema, this._getOptions(), model, r)
}


/**
 * Internal helper for _makeSavableCopy.
 * generating the dfault and virtual fields.
 * @return {any} the copy of the field/object.
 */
Document.prototype.__makeSavableCopy = function(doc, schema, options, model, r) {
  var localOptions; // can be undefined
  if (schema !== undefined) {
    localOptions = schema._options;
  }

  // model is an instance of a Model (for the top level fields), or undefined
  var result, key, keys, nextSchema, copyFlag;
  if (type.isDate(schema) && (typeof doc === 'string' || typeof doc === 'number')) {
    if (typeof doc === 'number') {
      var numericDate = parseInt(doc, 10);
      if(!isNaN(numericDate)) {
        doc = numericDate;
      }
    }
    return new Date(doc); // Use r.ISO8601 and not `new Date()` to keep timezone
  }
  else if (type.isPoint(schema)) {
    if (util.isPlainObject(doc) && (doc['$reql_type$'] !== "GEOMETRY")) {
      var keys = Object.keys(doc).sort();
      if ((keys.length === 2) && (keys[0] === 'latitude') && (keys[1] === 'longitude') && (typeof doc.latitude === "number") && (typeof doc.longitude === "number")) {
        return r.point(doc.longitude, doc.latitude)
      }
      else if ((doc.type === "Point") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson
        return r.geojson(doc)
      }
    }
    else if (Array.isArray(doc)) {
      if ((doc.length === 2) && (typeof doc[0] === "number") && (typeof doc[1] === "number")) {
        return r.point(doc[0], doc[1])
      }
    }
    else { // no transformation are required here, return doc
      return doc;
    }
  }
  else if (type.isNumber(schema) && (typeof doc === 'string')) {
    var numericString = parseFloat(doc);
    if(!isNaN(numericString)){
      return numericString;
    }else{
      return doc;
    }
  }

  if (util.isPlainObject(doc) && (doc instanceof Buffer === false)) {
    result = {};
    util.loopKeys(doc, function(doc, key) {
      copyFlag = true;
      if ((util.isPlainObject(model) === false) || (model._joins[key] === undefined)) { // We do not copy joined documents
        if ((schema !== undefined) && (schema._schema !== undefined) && (type.isVirtual(schema._schema[key]) === true)) {
          // We do not copy virtual
        }
        else if (((schema === undefined) || (schema._schema === undefined) || (schema._schema[key] === undefined)) &&
            (localOptions !== undefined) && (localOptions.enforce_extra === "remove")) {
          // We do not copy fields if enfroce_extra is "remove"
        }
        else {
          if ((schema !== undefined) && (schema._schema !== undefined)) {
            nextSchema = schema._schema[key];
          }
          else {
            nextSchema = undefined;
          }
          result[key] = Document.prototype.__makeSavableCopy(doc[key], nextSchema, localOptions, undefined, r);
        }
      }
    });

    // Copy the fields that are used as foreign keys
    if (util.isPlainObject(model) === true) {
      util.loopKeys(model._localKeys, function(localKeys, localKey) {
        if (doc[localKey] !== undefined) {
          if (schema !== undefined) {
            nextSchema = schema._schema[key];
          }
          else {
            nextSchema = undefined;
          }
          //TODO: Do we want to copy the foreign key value? If yes, there's no need for this loop
          //Do we want to copy the key from the joined document? If yes we need to replace doc[localKey]
          result[localKey] = Document.prototype.__makeSavableCopy(doc[localKey], nextSchema, localOptions, undefined, r);
        }
      });
    }
    return result;
  }
  else if (Array.isArray(doc)) {
    result = [];
    copyFlag = true;

    // Next schema
    if (type.isArray(schema)) {
      nextSchema = schema._schema;
    }
    else if ((util.isPlainObject(schema)) && (schema._type !== undefined) && (schema._schema !== undefined)) {
      nextSchema = schema._schema
      if (schema._type === "virtual") {
        copyFlag = false;
      }
    }
    else {
      nextSchema = undefined;
    }
    if (copyFlag === true) {
      for(var i=0; i<doc.length; i++) {
        result.push(Document.prototype.__makeSavableCopy(doc[i], nextSchema, localOptions, undefined, r));
      }
    }
    return result;
  }
  // else, doc is a primitive (or a buffer)
  return doc;
}


/**
 * Save the document, its joined documents and execute the hooks. Return a
 * promise if the callback is undefined.
 * @param {Object=} docToSave Documents to save represented by an object field->true
 * @param {boolean} saveAll Whether _save should recurse by default or not
 * @param {Object=} savedModel Models saved in this call
 * @param {Object=} callback to execute
 * @return {Promise=}
 */
Document.prototype._save = function(docToSave, saveAll, savedModel, callback) {
  //TOIMPROVE? How should we handle circular references outsides of joined fields? Now we throw with a maximum call stack size exceed
  var self = this;
  self.emit('saving', self);

  return util.hook({
    preHooks: self._getModel()._pre.save,
    postHooks: self._getModel()._post.save,
    doc: self,
    async: true,
    fn: self._saveHook,
    fnArgs: [docToSave, saveAll, savedModel]
  }).nodeify(callback);
}


/**
 * Save the document and execute the hooks. This is an internal method used with
 * Model.save. This let us use a similar code path for `document.save` and `Model.save`.
 * @param {Function} executeInsert the method that will execute the batch insert
 * @return {Promise}
 */
Document.prototype._batchSave = function(executeInsert) {
  // Keep in sync with _save
  var self = this;
  self.emit('saving', self);

  return util.hook({
    preHooks: self._getModel()._pre.save,
    postHooks: self._getModel()._post.save,
    doc: self,
    async: true,
    fn: self._batchSaveSelf,
    fnArgs: [executeInsert]
  });
}


/**
 * Call executeInsert when the model is ready
 * @param {Function} executeInsert the method that will execute the batch insert
 * @return {Promise}
 */
Document.prototype._batchSaveSelf = function(executeInsert) {
  var self = this;

  return new Promise(function(resolve, reject) {
    self.getModel().ready().then(function() {
      executeInsert(resolve, reject)
    });
  })
}


/**
 * Save the document and maybe its joined documents. Hooks have been dealt with
 * in _save.
 * @param {!Object} copy The savable copy of the original documents.
 * @param {Object=} docToSave Documents to save represented by an object field->true
 * @param {Object=} belongsToKeysSaved The keys that may contains a document to save
 * @param {boolean} saveAll Whether _save should recurse by default or not
 * @param {Object=} savedModel Models saved in this call
 * @param {Function} resolve The function to call when everything has been saved
 * @param {Function} reject The function to call if an error happened
 */
Document.prototype._saveHook = function(docToSave, saveAll, savedModel) {
  var self = this;
  var model = self._getModel(); // instance of Model
  var constructor = self.getModel();
  var r = model._thinky.r;

  if (util.isPlainObject(docToSave) === false) {
    docToSave = {};
  }

  savedModel[constructor.getTableName()] = true;


  var p = new Promise(function(resolve, reject) {
    // Steps:
    // - Save belongsTo
    // - Save this
    // - Save hasOne, hasMany and hasAndBelongsToMany docs
    // - Save links

    // We'll use it to know which `belongsTo` docs were saved
    var belongsToKeysSaved = {};

    var copy = self._makeSavableCopy();
    self._saveVirtual();

    // Save the joined documents via belongsTo first
    var promises = [];
    util.loopKeys(model._joins, function(joins, key) {
      if ((docToSave.hasOwnProperty(key) || (saveAll === true)) &&
          (joins[key].type === 'belongsTo') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {

        belongsToKeysSaved[key] = true;
        if (self[key] != null) {
          savedModel[joins[key].model.getTableName()] = true;
          if (saveAll === true) {
            promises.push(self[key]._save({}, true, savedModel))
          }
          else {
            promises.push(self[key]._save(docToSave[joins[key].model.getTableName()], false, savedModel))
          }
        }
      }
    });

    //TODO Remove once
    self.getModel().ready().then(function() {
      Promise.all(promises).then(function() {
        self._onSavedBelongsTo(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject);
      }).error(reject);
    });
  });
  return p;
}


/**
 * Save the joined documents linked with a BelongsTo relation. This should be
 * called before _saveSelf as we will have to copy the foreign keys in `self`.
 * @param {!Object} copy The savable copy of the original documents.
 * @param {Object=} docToSave Documents to save represented by an object field->true
 * @param {Object=} belongsToKeysSaved The keys that may contains a document to save
 * @param {boolean} saveAll Whether _save should recurse by default or not
 * @param {Object=} savedModel Models saved in this call
 * @param {Function} resolve The function to call when everything has been saved
 * @param {Function} reject The function to call if an error happened
 */
Document.prototype._onSavedBelongsTo = function(
    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {
  var self = this;
  var model = self._getModel();
  var constructor = self.__proto__.constructor;
  var r = this._getModel()._thinky.r;

  util.loopKeys(belongsToKeysSaved, function(joins, key) {
    var joins = model._joins;
    if (self[key] != null) {

      self.__proto__._belongsTo[key] = true;

      // Copy foreign key
      if (self[key][joins[key].rightKey] == null) {
        if (self.hasOwnProperty(joins[key].leftKey)) {
          delete self[joins[key][joins[key].leftKey]];
        }
        if (copy.hasOwnProperty(joins[key].leftKey)) {
          delete copy[joins[key][joins[key].leftKey]];
        }
      }
      else {
        self[joins[key].leftKey] = self[key][joins[key].rightKey];
        copy[joins[key].leftKey] = self[key][joins[key].rightKey]; // We need to put it in copy before saving it
      }

      // Save the document that belongs to self[key]
      if (self[key].__proto__._parents._belongsTo[constructor.getTableName()] == null) {
        self[key].__proto__._parents._belongsTo[constructor.getTableName()] = [];
      }
      self[key].__proto__._parents._belongsTo[constructor.getTableName()].push({
        doc: self,
        foreignKey: joins[key].leftKey,
        key: key // foreignDoc
      });
    }
  });
  self._saveSelf(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject)
}


/**
 * Save the document on which `save` was called.
 * @param {!Object} copy The savable copy of the original documents.
 * @param {Object=} docToSave Documents to save represented by an object field->true
 * @param {Object=} belongsToKeysSaved The keys that may contains a document to save
 * @param {boolean} saveAll Whether _save should recurse by default or not
 * @param {Object=} savedModel Models saved in this call
 * @param {Function} resolve The function to call when everything has been saved
 * @param {Function} reject The function to call if an error happened
 */
Document.prototype._saveSelf = function(
    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {
  var self = this;
  var model = self._getModel();
  var constructor = self.__proto__.constructor;
  var r = this._getModel()._thinky.r;

  // BelongsTo documents were saved before. We just need to copy the foreign
  // keys.
  util.loopKeys(model._joins, function(joins, key) {
    if ((joins[key].type === 'belongsTo') && (belongsToKeysSaved[key] === true)) {
      if (self[key] != null) {
        self[joins[key].leftKey] = self[key][joins[key].rightKey]
      }
      else if (self.__proto__._belongsTo[key]) {
        delete self[joins[key].leftKey];
        delete copy[joins[key].leftKey];
      }
    }
  });

  var querySaveSelf; // The query to save the document on which `save`/`saveAll` was called.
  // We haven't validated the document yet, so building the query with `copy`
  // may throw an error (for example if a Date has not a valid time).
  var buildQuery = function () {
    if (self.__proto__._saved === false) {
      return querySaveSelf = r.table(constructor.getTableName())
        .insert(copy, {returnChanges: 'always'})
    }
    else {
      if (copy[model._pk] === undefined) {
        throw new Error("The document was previously saved, but its primary key is undefined.");
      }
      return querySaveSelf = r.table(constructor.getTableName())
        .get(copy[model._pk]).replace(copy, {returnChanges: 'always'})
    }
  }

  self.getModel().ready().then(function() {
    util.tryCatch(function() {
      // Validate the document before saving it
      var promise = self.validate();
      if (promise instanceof Promise) {
        promise.then(function() {
          querySaveSelf = buildQuery();
          querySaveSelf.run().then(function(result) {
            self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)
          }).error(reject)
        }).error(reject);
      }
      else {
        querySaveSelf = buildQuery();
        querySaveSelf.run().then(function(result) {
          self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)
        }).error(reject)
      }
    }, reject);
  });
}


/**
 * Callback for the insert query.
 * @param {Object} result The result from the insert query
 * @param {Object=} docToSave Documents to save represented by an object field->true
 * @param {boolean} saveAll Whether _save should recurse by default or not
 * @param {Object=} savedModel Models saved in this call
 * @param {Function} resolve The function to call when everything has been saved
 * @param {Function} reject The function to call if an error happened
 */
Document.prototype._onSaved = function(result, docToSave, saveAll, savedModel, resolve, reject) {
  // Keep in sync with Model.save
  var self = this;

  if (result.first_error != null) {
    return reject(Errors.create(result.first_error));
  }

  util.tryCatch(function() { // Validate the doc, replace it, and tag it as saved
    if (Array.isArray(result.changes) && result.changes.length > 0) {
      self._merge(result.changes[0].new_val);
      self._setOldValue(util.deepCopy(result.changes[0].old_val));
    }

    if (self._getModel().needToGenerateFields === true) {
      self._generateDefault();
    }
    self.setSaved();
    self.emit('saved', self);

    var promise = self.validate();
    if (promise instanceof Promise) {
      promise.then(function() {
        self._saveMany(docToSave, saveAll, savedModel, resolve, reject)
      }).error(reject);
    }
    else {
      self._saveMany(docToSave, saveAll, savedModel, resolve, reject)
    }
  }, reject);
}


/**
 * Save the joined documents linked with a hasOne or hasMany or
 * hasAndBelongsToMany relation. This should be called after `_saveSelf` as we
 * will have to copy the foreign keys in the joined documents.
 * @param {Object} result The result from the insert query
 * @param {Object=} docToSave Documents to save represented by an object field->true
 * @param {boolean} saveAll Whether _save should recurse by default or not
 * @param {Object=} savedModel Models saved in this call
 * @param {Function} resolve The function to call when everything has been saved
 * @param {Function} reject The function to call if an error happened
 */
Document.prototype._saveMany = function(docToSave, saveAll, savedModel, resolve, reject) {
  var self = this;
  var model = self._getModel();

  var promisesMany = [];
  util.loopKeys(model._joins, function(joins, key) {
    if (((key in docToSave) || (saveAll === true)) &&
        (joins[key].type === 'hasOne') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {
      savedModel[joins[key].model.getTableName()] = true;

      if (self[key] != null) {
        self[key][joins[key].rightKey] = self[joins[key].leftKey];
        (function(_key) {
          promisesMany.push(new Promise(function(resolve, reject) {
            self[_key]._save(docToSave[_key], saveAll, savedModel).then(function() {
              self.__proto__._hasOne[_key] = {
                doc: self[_key],
                foreignKey: self._getModel()._joins[_key].rightKey
              };
              if (self[_key].__proto__._parents._hasOne[self._getModel()._name] == null) {
                self[_key].__proto__._parents._hasOne[self._getModel()._name] = [];
              }
              self[_key].__proto__._parents._hasOne[self._getModel()._name].push({
                doc: self,
                key: key
              });
              resolve();
            }).error(reject);
          }))
        })(key)
      }
      else if ((self[key] == null) && (self.__proto__._hasOne[key] != null)) {
        var doc = self.__proto__._hasOne[key].doc;
        delete doc[self.__proto__._hasOne[key].foreignKey];
        promisesMany.push(doc._save(docToSave[key], saveAll, savedModel))
        self.__proto__._hasOne[key] = null;
      }
    }
  });
  util.loopKeys(model._joins, function(joins, key) {
    if (((key in docToSave) || (saveAll === true)) &&
        (joins[key].type === 'hasMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))
        && (Array.isArray(self[key]))) {

      savedModel[joins[key].model.getTableName()] = true;

      //Go through _hasMany and find element that were removed
      var pkMap = {};
      if (Array.isArray(self[key])) {
        for(var i=0; i<self[key].length; i++) {
          if (self[key][i][joins[key].model._pk] != null) {
            pkMap[self[key][i][joins[key].model._pk]] = true;
          }
        }
      }

      if (self.__proto__._hasMany[key] != null) {
        for(var i=0; i<self.__proto__._hasMany[key].length; i++) {
          if (pkMap[self.__proto__._hasMany[key][i].doc[[joins[key].model._pk]]] == null) {
            delete self.__proto__._hasMany[key][i].doc[self.__proto__._hasMany[key][i].foreignKey];
            promisesMany.push(self.__proto__._hasMany[key][i].doc._save(docToSave[key], saveAll, savedModel));
          }
        }
      }
      self.__proto__._hasMany[key] = [];

      for(var i=0; i<self[key].length; i++) {
        self[key][i][joins[key].rightKey] = self[joins[key].leftKey];
        (function(key, i) {
          promisesMany.push(new Promise(function(resolve, reject) {
            if (!(self[key][i] instanceof Document)) {
              self[key][i] = new joins[key].model(self[key][i]);
            }

            var callback = function() {
              self[key][i]._save(docToSave[key], saveAll, savedModel).then(function(doc) {
                if (!Array.isArray(self.__proto__._hasMany[key])) {
                  self.__proto__._hasMany[key] = [];
                }
                self.__proto__._hasMany[key].push({
                  doc: doc,
                  foreignKey: self._getModel()._joins[key].rightKey
                });

                if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {
                  self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];
                }
                self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({
                  doc: self,
                  key: key
                });

                resolve();
              }).error(reject);
            }

            if (self[key][i] instanceof Promise) {
              self[key][i].then(callback).error(reject);
            }
            else {
              callback();
            }

          }))
        })(key, i);
      }
    }
  });
  util.loopKeys(model._joins, function(joins, key) {
    // Compare to null
    if (((key in docToSave) || (saveAll === true)) &&
        (joins[key].type === 'hasAndBelongsToMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {

      savedModel[joins[key].model.getTableName()] = true;

      if (Array.isArray(self[key])) {
        for(var i=0; i<self[key].length; i++) {
          if (util.isPlainObject(self[key][i])) { // Save only if we have a full object, and not just a key
            (function(key, i) {
              promisesMany.push(new Promise(function(resolve, reject) {
                if (!(self[key][i] instanceof Document)) {
                  self[key][i] = new joins[key].model(self[key][i]);
                }
                var callback = function() {
                  self[key][i]._save(docToSave[key], saveAll, savedModel).then(function() {
                    // self.__proto__._links will be saved in saveLinks
                    if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {
                      self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];
                    }
                    self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({
                      doc: self,
                      key: key
                    });
                    resolve();
                  }).error(reject);
                }

                if (self[key][i] instanceof Promise) {
                  self[key][i].then(callback).error(reject);
                }
                else {
                  callback();
                }
              }))
            })(key, i)
          }
        }
      }
    }
  });

  if (promisesMany.length > 0) {
    Promise.all(promisesMany).then(function() {
      self._saveLinks(docToSave, saveAll, resolve, reject)
    }).error(reject);
  }
  else {
    self._saveLinks(docToSave, saveAll, resolve, reject)
  }
}


/**
 * Save the links for hasAndBelongsToMany joined documents.
 * called before _saveSelf as we will have to copy the foreign keys in `self`.
 * @param {Object=} docToSave Documents to save represented by an object field->true
 * @param {boolean} saveAll Whether _save should recurse by default or not
 * @param {Function} resolve The function to call when everything has been saved
 * @param {Function} reject The function to call if an error happened
 */
Document.prototype._saveLinks = function(docToSave, saveAll, resolve, reject) {
  var self = this;
  var model = self._getModel();
  var constructor = self.getModel();
  var r = model._thinky.r;

  var promisesLink = [];

  util.loopKeys(model._joins, function(joins, key) {
    // Write tests about that!
    if (((key in docToSave) || (saveAll === true)) &&
        (joins[key].type === 'hasAndBelongsToMany')) {

      if (Array.isArray(self[key])) {
        var newKeys = {}
        for(var i=0; i<self[key].length; i++) {
          if (util.isPlainObject(self[key][i])) {
            if (self[key][i].isSaved() === true) {
              newKeys[self[key][i][joins[key].rightKey]] = true;
            }
          }
          else { // self[key][i] is just the key
            newKeys[self[key][i]] = true;
          }
        }

        if (self.__proto__._links[joins[key].link] === undefined) {
          self.__proto__._links[joins[key].link] = {}
        }
        var oldKeys = self.__proto__._links[joins[key].link];

        util.loopKeys(newKeys, function(newKeys, link) {
          if (oldKeys[link] !== true) {
            var newLink = {};

            if ((constructor.getTableName() === joins[key].model.getTableName())
              && (joins[key].leftKey === joins[key].rightKey)) {

              // We link on the same model and same key
              // We don't want to save redundant field
              if (link < self[joins[key].leftKey]) {
                newLink.id = link+"_"+self[joins[key].leftKey];
              }
              else {
                newLink.id = self[joins[key].leftKey]+"_"+link;
              }
              newLink[joins[key].leftKey+"_"+joins[key].leftKey] = [link, self[joins[key].leftKey]];
            }
            else {
              newLink[constructor.getTableName()+"_"+joins[key].leftKey] = self[joins[key].leftKey];
              newLink[joins[key].model.getTableName()+"_"+joins[key].rightKey] = link;

              // Create the primary key
              if (constructor.getTableName() < joins[key].model.getTableName()) {
                newLink.id = self[joins[key].leftKey]+"_"+link;
              }
              else if (constructor.getTableName() > joins[key].model.getTableName()) {
                newLink.id = link+"_"+self[joins[key].leftKey];
              }
              else {
                if (link < self[joins[key].leftKey]) {
                  newLink.id = link+"_"+self[joins[key].leftKey];
                }
                else {
                  newLink.id = self[joins[key].leftKey]+"_"+link;
                }
              }
            }

            (function(key, link) {
              promisesLink.push(new Promise(function(resolve, reject) {
                r.table(self._getModel()._joins[key].link).insert(newLink, {conflict: "replace", returnChanges: 'always'}).run().then(function(result) {
                  if (Array.isArray(result.changes) && result.changes.length > 0) {
                    self.__proto__._links[joins[key].link][result.changes[0].new_val[joins[key].model.getTableName()+"_"+joins[key].rightKey]] = true;
                  }
                  else {
                    self.__proto__._links[joins[key].link][newLink[joins[key].model.getTableName()+"_"+joins[key].rightKey]] = true;
                  }
                  resolve();
                }).error(reject);
              }))
            })(key, link);
          }
        });

        var keysToDelete = []
        util.loopKeys(oldKeys, function(oldKeys, link) {
          if (newKeys[link] === undefined) {
            if (constructor.getTableName() < joins[key].model.getTableName()) {
              keysToDelete.push(self[joins[key].leftKey]+"_"+link);
            }
            else {
              keysToDelete.push(link+"_"+self[joins[key].leftKey]);
            }
          }
        });
        if (keysToDelete.length > 0) {
          var table = r.table(joins[key].link);
          promisesLink.push(table.getAll.apply(table, keysToDelete).delete().run().then(function() {
            for(var i=0; i<keysToDelete.length; i++) {
              self.__proto__._links[joins[key].link][keysToDelete[i]] = false;
            }
          }));
        }
      }
    }
  });

  if (promisesLink.length > 0) {
    Promise.all(promisesLink).then(function() {
      resolve(self);
    }).error(reject);
  }
  else {
    resolve(self);
  }
}


/**
 * Return the value saved in __proto__.oldValue
 */
Document.prototype.getOldValue = function() {
  return this.__proto__.oldValue;
}


/**
 * Save a reference of `value` that will be later accessible with `getOldValue`.
 * @param {Object} value The value to save
 */
Document.prototype._setOldValue = function(value) {
  return this.__proto__.oldValue = value;
}


/**
 * Return whether this document was saved or not.
 * @return {boolean}
 */
Document.prototype.isSaved = function() {
  return this.__proto__._saved;
}


/**
 * Set the document (and maybe its joined documents) as saved.
 * @param {boolean=} all Recursively set all the joined documents as saved
 */
Document.prototype.setSaved = function(all) {
  var self = this;
  self.__proto__._saved = true;
  if (all !== true) return;
    util.loopKeys(self._getModel()._joins, function(joins, key) {
      switch (joins[key].type) {
        case 'hasOne':
          if (self[key] instanceof Document) {
            self[key].setSaved(true);
          }
          break;

        case 'belongsTo':
          if (self[key] instanceof Document) {
            self[key].setSaved(true);
          }
          break;

        case 'hasMany':
          if (Array.isArray(self[key])) {
            for(var i=0; i<self[key].length; i++) {
              if (self[key][i] instanceof Document) {
                self[key][i].setSaved(true);
              }
            }
          }
          break;

        case 'hasAndBelongsToMany':
          if (Array.isArray(self[key])) {
            for(var i=0; i<self[key].length; i++) {
              if (self[key][i] instanceof Document) {
                self[key][i].setSaved(true);
              }
            }
          }
          break;
      }
    });

    // Make joins, we should keep references only of the saved documents
    util.loopKeys(self._getModel()._joins, function(joins, key) {
      if (self[key] == null) return;
      switch (joins[key].type) {
        case 'hasOne':
          if (self[key].isSaved()) {
            self.__proto__._hasOne[key] = {
              doc: self[key],
              foreignKey: self._getModel()._joins[key].rightKey
            }
          }

          if (self[key].__proto__._parents._hasOne[self._getModel()._name] == null) {
            self[key].__proto__._parents._hasOne[self._getModel()._name] = [];
          }
          self[key].__proto__._parents._hasOne[self._getModel()._name].push({
            doc: self,
            key: key
          });
          break;

        case 'belongsTo':
          if (self[key].__proto__._parents._belongsTo[self._getModel()._name] == null) {
            self[key].__proto__._parents._belongsTo[self._getModel()._name] = [];
          }
          self[key].__proto__._parents._belongsTo[self._getModel()._name].push({
            doc: self,
            foreignKey: self._getModel()._joins[key].leftKey,
            key: key
          });
          self.__proto__._belongsTo[key] = true;
          break;

        case 'hasMany':
          self.__proto__._hasMany[key] = []

          for(var i=0; i<self[key].length; i++) {
            if (self[key][i].isSaved()) {
              self.__proto__._hasMany[key].push({
                doc: self[key][i],
                foreignKey: self._getModel()._joins[key].rightKey
              })
            }

            if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {
              self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];
            }
            self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({
              doc: self,
              key: key
            });

          }
          break;

        case 'hasAndBelongsToMany':
          if (self.__proto__._links[self._getModel()._joins[key].link] === undefined) {
            self.__proto__._links[self._getModel()._joins[key].link] = {}
          }

          for(var i=0; i<self[key].length; i++) {
            if (self[key][i].isSaved()) {
              self.__proto__._links[self._getModel()._joins[key].link][self[key][i][self._getModel()._joins[key].rightKey]] = true;
            }

            if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {
              self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];
            }
            self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({
              doc: self,
              key: key
            });

          }
          break;
      }
    });

}


/**
 * Set the document as unsaved
 */
Document.prototype._setUnSaved = function() {
  this.__proto__._saved = false;
}


/**
 * Delete the document from the database. Update the joined documents by
 * removing the foreign key for hasOne/hasMany joined documents, and remove the
 * links for hasAndBelongsToMany joined documents if the link is built on the
 * primary key.
 * @param {Function=} callback
 * @return {Promise=} Return a promise if no callback is provided
 */
Document.prototype.delete = function(callback) {
  return this._delete({}, false, [], true, true, callback)
}


/**
 * Delete the document from the database and the joined documents. If
 * `docToDelete` is undefined, it will delete all the joined documents, else it
 * will limits itself to the one stored in the keys defined in `docToDelete`.
 * It will also update the joined documents by removing the foreign key for
 * `hasOne`/`hasMany` joined documents, and remove the links for
 * `hasAndBelongsToMany` joined documents if the link is built on the primary
 * key.
 * @param {Object=} docToDelete An object where a field maps to `true` if the
 * document stored in this field should be deleted.
 * @param {Function=} callback
 * @return {Promise=} Return a promise if no callback is provided
 */
Document.prototype.deleteAll = function(docToDelete, callback) {
  var deleteAll;
  if (typeof docToDelete === 'function') {
    callback = docToDelete;
    deleteAll = true;
    docToDelete = {};
  }
  else {
    deleteAll = docToDelete === undefined;
    docToDelete = docToDelete || {};
  }
  return this._delete(docToDelete, deleteAll, [], true, true, callback)
}


/**
 * Delete the document from the database and the joined documents. If
 * `docToDelete` is `undefined` and `deleteAll` is `true`, it will delete all
 * the joined documents, else it will limits itself to the one stored in the
 * keys defined in `docToDelete`. It will also update the joined documents by
 * removing the foreign key for `hasOne`/`hasMany` joined documents, and
 * remove the links for `hasAndBelongsToMany` joined documents if the link is
 * built on the primary key.
 * Hooks will also be executed.
 * @param {Object=} docToDelete Explicit maps of the documents to delete
 * @param {boolean} deleteAll Recursively delete all the documents if
 *     `docToDelete` is undefined
 * @param {Array} deletedDocs Array of docs already deleted, used to make sure
 *     that we do not try to delete multiple times the same documents
 * @param {boolean} deleteSelf Whether it should delete self
 * @param {boolean} updateParents Whether it should update the keys for the
 *     parents
 * @param {Function=} callback
 * @return {Promise=} Return a promise if no callback is provided
 */
Document.prototype._delete = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {
  //TODO Set a (string) id per document and use it to perform faster lookup
  var self = this;

  if (util.isPlainObject(docToDelete) === false) {
    docToDelete = {};
  }

  deleteSelf = (deleteSelf === undefined) ? true: deleteSelf;

  return util.hook({
    preHooks: self._getModel()._pre.delete,
    postHooks: self._getModel()._post.delete,
    doc: self,
    async: true,
    fn: self._deleteHook,
    fnArgs: [docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback]
  });
}


/**
 * Internal methods used in `_delete`. Does the same as `_delete` but without
 * the hooks.
 * @param {Object=} docToDelete Explicit maps of the documents to delete
 * @param {boolean} deleteAll Recursively delete all the documents if
 *     `docToDelete` is undefined
 * @param {Array} deletedDocs Array of docs already deleted, used to make sure
 *     that we do not try to delete multiple times the same documents
 * @param {boolean} deleteSelf Whether it should delete self
 * @param {boolean} updateParents Whether it should update the keys for the
 *     parents
 * @return {Promise=} Return a promise if no callback is provided
 */
Document.prototype._deleteHook = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {
  var self = this;
  var model = self._getModel(); // instance of Model
  var constructor = self.getModel();
  var r = model._thinky.r;

  var promises = [];

  deletedDocs.push(self);
  util.loopKeys(self._getModel()._joins, function(joins, key) {
    if ((joins[key].type === 'hasOne') && (self[key] instanceof Document)) {
      if ((self[key].isSaved() === true) &&
        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {

        (function(key) {
          promises.push(new Promise(function(resolve, reject) {
            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {
              delete self[key];
              resolve();
            }).error(reject);
          }))
        })(key);
      }
      else if ((deleteSelf === true) && (deletedDocs.indexOf(self[key]) === -1)) {
        delete self[key][joins[key].rightKey];
        if (self[key].isSaved() === true) {
          promises.push(self[key].save({}, false, {}, true, false));
        }
      }
    }
    if ((joins[key].type === 'belongsTo') && (self[key] instanceof Document)) {
      if ((self[key].isSaved() === true) &&
        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {

        (function(key) {
          promises.push(new Promise(function(resolve, reject) {
            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {
              delete self[key];
              resolve();
            }).error(reject);
          }));
        })(key);
      }
    }

    if ((joins[key].type === 'hasMany') && (Array.isArray(self[key]))) {
      var manyPromises = [];
      for(var i=0; i<self[key].length; i++) {
        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))
          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {

          manyPromises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))
        }
        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {
          delete self[key][i][joins[key].rightKey];
          if (self[key][i].isSaved() === true) {
            promises.push(self[key][i].save({}, false, {}, true, false))
          }
        }
      }
      (function(key) {
        promises.push(new Promise(function(resolve, reject) {
          Promise.all(manyPromises).then(function() {
            delete self[key];
            resolve()
          })
        }));
      })(key)
    }
    if ((joins[key].type === 'hasAndBelongsToMany') && (Array.isArray(self[key]))) {
      // Delete links + docs
      var pks = []; // primary keys of the documents
      var linksPks = []; // primary keys of the links

      // Store the element we are going to delete.
      // If the user force the deletion of the same element multiple times, we can't naively loop
      // over the elements in the array...
      var docsToDelete = [];


      for(var i=0; i<self[key].length; i++) {
        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))
          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {

          //pks.push(self[key][i][joins[key].model._getModel()._pk]);
          docsToDelete.push(self[key][i]);
          // We are going to do a range delete, but we still have to recurse
          promises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))

          if (self.getModel()._getModel()._pk === joins[key].leftKey) {
            // The table is created since we are deleting an element from it
            if (self._getModel()._name === joins[key].model._getModel()._name) {
              if (self[joins[key].leftKey] < self[key][i][joins[key].rightKey]) {
                //TODO Add test for this
                linksPks.push(self[joins[key].leftKey]+"_"+self[key][i][joins[key].rightKey]);
              }
              else {
                linksPks.push(self[key][i][joins[key].rightKey]+"_"+self[joins[key].leftKey]);
              }
            }
            else if (self._getModel()._name < joins[key].model._getModel()._name) {
              linksPks.push(self[joins[key].leftKey]+"_"+self[key][i][joins[key].rightKey]);
            }
            else {
              linksPks.push(self[key][i][joins[key].rightKey]+"_"+self[joins[key].leftKey]);
            }
          }
        }
        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {
          // It's safe to destroy links only if it's a primary key
          if (self.getModel()._getModel()._pk === joins[key].leftKey) {
            if (self._getModel()._name < joins[key].model._getModel()._name) {
              linksPks.push(self[joins[key].leftKey]+"_"+self[key][i][joins[key].rightKey]);
            }
            else {
              linksPks.push(self[key][i][joins[key].rightKey]+"_"+self[joins[key].leftKey]);
            }
          }
        }
      }
      if (linksPks.length > 0) {
        var query = r.table(joins[key].link);
        query = query.getAll.apply(query, linksPks).delete();
        promises.push(query.run());
      }
    }
  });
  if (updateParents !== false) {
    // Clean links that we are aware of
    util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {
      var parents = hasOne[key];
      for(var i=0; i<parents.length; i++) {
        delete parents[i].doc[parents[i].key];
        util.loopKeys(parents[i].doc.__proto__._hasOne, function(joined, joinKey) {
          if (joined[joinKey].doc === self) {
            delete parents[i].doc.__proto__._hasOne[joinKey];
          }
        })
      }
    });
    util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {
      var parents = belongsTo[key];
      for(var i=0; i<parents.length; i++) {
        delete parents[i].doc[parents[i].key];
        delete parents[i].doc[parents[i].foreignKey];
        if (deletedDocs.indexOf(parents[i]) === -1) {
          promises.push(parents[i].doc.save());
        }
      }
    });
    util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {
      var parents = hasMany[key];
      for(var i=0; i<parents.length; i++) {
        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {
          if (parents[i].doc[parents[i].key][j] === self) {
            util.loopKeys(parents[i].doc.__proto__._hasMany, function(joined, joinKey) {
              for(var k=0; k<joined[joinKey].length; k++) {
                if (joined[joinKey][k].doc === self) {
                  joined[joinKey].splice(k, 1);
                  return false;
                }
              }
            });
            parents[i].doc[parents[i].key].splice(j, 1);
            break;
          }
        }
      }
    });
    util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {
      var parents = belongsLinks[key];
      for(var i=0; i<parents.length; i++) {
        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {
          if (parents[i].doc[parents[i].key][j] === self) {
            parents[i].doc[parents[i].key].splice(j, 1);
            break;
          }
        }
      }
    });
  }

  if (deleteSelf !== false) {
    if (self.isSaved() === true) {
      promises.push(new Promise(function(resolve, reject) {
        r.table(model._name).get(self[model._pk]).delete().run().then(function(result) {
          self._setUnSaved();
          self.emit('deleted', self);
          resolve(self);
        }).error(reject);
      }))
    }
    // else we don't throw an error, should we?
  }

  var p = new Promise(function(resolve, reject) {
    Promise.all(promises).then(function(result) {
      resolve(self);
    }).error(function(error) {
      reject(error)
    });
  })
  return p.nodeify(callback);
}

/*
 * Delete this document and purge the database by doing range update to clean
 * the foreign keys.
 * @param {Function=} callback
 * @return {Promise=} Return a promise if no callback is provided
 */
Document.prototype.purge = function(callback) {
  var self = this;

  var model = self._getModel(); // instance of Model
  var r = model._thinky.r;

  // Clean parent for hasOne
  // doc.otherDoc.delete()
  util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {
    for(var i=0; i<hasOne[key].length; i++) {
      var parentDoc = hasOne[key][i].doc; // A doc that belongs to otherDoc (aka this)
      delete parentDoc[hasOne[key][i].key] // Delete reference to otherDoc (aka this)
    }
  });

  // Clean parent for belongsTo
  // doc.otherDoc.delete()
  util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {
    for(var i=0; i<belongsTo[key].length; i++) {
      var parentDoc = belongsTo[key][i].doc;
      delete parentDoc[belongsTo[key][i].key];
      delete parentDoc[belongsTo[key][i].foreignKey];
    }
  });

  // Clean parent for hasMany
  util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {
    for(var i=0; i<hasMany[key].length; i++) {
      var parentDoc = hasMany[key][i].doc;
      var field = hasMany[key][i].key;
      for(var j=0; j<parentDoc[field].length; j++) {
        if (parentDoc[field][j] === this) {
          parentDoc[field].splice(j, 1);
          break;
        }
      }
    }
  });


  // Clean parent for hasAndBelongsToMany
  util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {
    for(var i=0; i<belongsLinks[key].length; i++) {
      var parentDoc = belongsLinks[key][i].doc;
      var field = belongsLinks[key][i].key;
      for(var j=0; j<parentDoc[field].length; j++) {
        if (parentDoc[field][j] === this) {
          parentDoc[field].splice(j, 1);
          break;
        }
      }
    }
  });

  // Purge the database
  var promises = [];
  util.loopKeys(self._getModel()._joins, function(joins, field) {
    var join = joins[field];
    var joinedModel = join.model;

    if ((join.type === 'hasOne') || (join.type === 'hasMany')) {
      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.leftKey], {index: join.rightKey}).replace(function(doc) {
        return doc.without(join.rightKey)
      }).run())
    }
    // nothing to do for "belongsTo"
    else if (join.type === 'hasAndBelongsToMany') {
      if (self.getModel()._getModel()._pk === join.leftKey) {
        // [1]
        promises.push(r.table(join.link).getAll(self[join.leftKey], {index: self.getModel().getTableName()+"_"+join.leftKey}).delete().run())
      }
    }
  });

  util.loopKeys(self._getModel()._reverseJoins, function(reverseJoins, field) {
    var join = reverseJoins[field];
    var joinedModel = join.model; // model where belongsTo/hasAndBelongsToMany was called

    if (join.type === 'belongsTo') {
      // What was called is joinedModel.belongsTo(self, fieldDoc, leftKey, rightKey)
      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.rightKey], {index: join.leftKey}).replace(function(doc) {
        return doc.without(join.leftKey)
      }).run())
    }
    // nothing to do for "belongsTo"
    else if (join.type === 'hasAndBelongsToMany') {
      // Purge only if the key is a primary key
      // What was called is joinedModel.hasAndBelongsToMany(self, fieldDoc, leftKey, rightKey)
      if (self.getModel()._getModel()._pk === join.leftKey) {
        promises.push(r.table(join.link).getAll(self[join.rightKey], {index: self.getModel().getTableName()+"_"+join.rightKey}).delete().run())
      }
    }
  });

  // Delete itself
  promises.push(self.delete())

  return new Promise(function(resolve, reject) {
    Promise.all(promises).then(function() {
      resolve(self);
    }).error(reject);
  }).nodeify(callback);
}

Document.prototype.addRelation = function() {
  var self = this;
  var pk = self._getModel()._pk;

  var query = self.getModel().get(this[pk])
  return query.addRelation.apply(query, arguments);
}

Document.prototype.removeRelation = function() {
  var self = this;
  var pk = self._getModel()._pk;

  var query = self.getModel().get(this[pk])
  return query.removeRelation.apply(query, arguments);
}

/**
 * Perform a `merge` of `obj` in this document. Extra keys will be removed.
 */
Document.prototype._merge = function(obj) {
  var self = this;
  util.loopKeys(self, function(self, key) {
    if ((obj[key] === undefined) && (self._getModel()._joins[key] === undefined)) {
      delete self[key];
    }
  });
  util.loopKeys(obj, function(obj, key) {
    self[key] = obj[key];
  });
  return self;
}


/**
 * Perform a `merge` of `obj` in this document. Extra keys will not be removed.
 */
Document.prototype.merge = function(obj) {
  var self = this;
  util.loopKeys(obj, function(obj, key) {
    // Recursively merge only if both fields are objects, else we'll overwrite the field
    if (util.isPlainObject(obj[key]) && util.isPlainObject(self[key])) {
      Document.prototype.merge.call(self[key], obj[key])
    }
    else {
      self[key] = obj[key];
    }
  });
  return self;
}

/**
 * Set the atom feed and update the document for each change
 */
Document.prototype._setFeed = function(feed) {
  var self = this;

  self.__proto__._feed = feed;
  self.__proto__._active = true;
  feed.each(function(err, change) {
    if (err) {
      self.__proto__._active = false;
      self.emit('error', err);
    }
    else {
      if (change.new_val === null) {
        // Delete all the fields
        self._merge({});
        self._setOldValue(change.old_val);
        self._setUnSaved();
        self.emit('change', self);
      }
      else {
        self._merge(change.new_val);
        self._setOldValue(change.old_val);
        self.setSaved();
        self.emit('change', self);
      }
    }

  });
};

Document.prototype.getFeed = function() {
  return this.__proto__._feed;
}

Document.prototype.closeFeed = function() {
  return this.__proto__._feed.close();
}

/**
 * Have the model emit 'retrieved' with the current document and
 * recurse to have all joined models do the same.
 */
Document.prototype._emitRetrieve = function() {
  var self = this;
  self.getModel().emit('retrieved', self);
  util.loopKeys(self._getModel()._joins, function(joins, key) {
    var join = joins[key];
    if ((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo')) {
      if ((self[key] != null) && (typeof self[key]._emitRetrieve === 'function')) {
        self[key]._emitRetrieve();
      }
    }
    else if ((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany')) {
      if (Array.isArray(self[key])) {
        for(var i=0; i<self[key].length; i++) {
          if (typeof self[key][i]._emitRetrieve === 'function') {
            self[key][i]._emitRetrieve();
          }
        }
      }
    }
  })
}

module.exports = Document;


/***/ }),

/***/ "../node_modules/thinky/lib/errors.js":
/*!********************************************!*\
  !*** ../node_modules/thinky/lib/errors.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! util */ "util");
var errors = module.exports = {};

/**
 * The base error that all thinky related errors derive from
 *
 * @constructor
 * @alias Error
 */
errors.ThinkyError = function() {
  var tmp = Error.apply(this, arguments);
  tmp.name = this.name = 'ThinkyError';

  this.message = tmp.message;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, this.constructor);
};
util.inherits(errors.ThinkyError, Error);

/**
 * Thrown or returned when `get` returns `null`.
 * @extends ThinkyError
 */
errors.DocumentNotFound = function(message) {
  var errorMessage = message || "The query did not find a document and returned null.";
  errors.ThinkyError.call(this, errorMessage);
  this.name = 'DocumentNotFoundError';
};
util.inherits(errors.DocumentNotFound, errors.ThinkyError);

/**
 * Thrown or returned when an in place update/replace returns an invalid document.
 * @extends ThinkyError
 */
errors.InvalidWrite = function(message, raw) {
  errors.ThinkyError.call(this, message);
  this.name = 'InvalidWriteError';
  this.raw = raw;
};
util.inherits(errors.InvalidWrite, errors.ThinkyError);

/**
 * Thrown or returned when validation of a document fails.
 * @extends ThinkyError
 */
errors.ValidationError = function(message) {
  errors.ThinkyError.call(this, message);
  this.name = 'ValidationError';
};
util.inherits(errors.ValidationError, errors.ThinkyError);

/**
 * Thrown or returned when the primary key unique document constraint fails.
 * @extends ThinkyError
 */
errors.DuplicatePrimaryKey = function(message, primaryKey) {
  errors.ThinkyError.call(this, message);
  this.name = 'DuplicatePrimaryKeyError';
  if (primaryKey !== undefined) {
    this.primaryKey = primaryKey;
  }
};
util.inherits(errors.DuplicatePrimaryKey, errors.ThinkyError);

/**
 * regular expressions used to determine which errors should be thrown
 */
errors.DOCUMENT_NOT_FOUND_REGEX = new RegExp('^The query did not find a document and returned null.*');
errors.DUPLICATE_PRIMARY_KEY_REGEX = new RegExp('^Duplicate primary key `(.*)`.*');

/**
 * Creates an appropriate error given either an instance of Error or a message
 * from the RethinkDB driver
 */
errors.create = function(errorOrMessage) {
  var message = (errorOrMessage instanceof Error) ? errorOrMessage.message : errorOrMessage;
  if (message.match(errors.DOCUMENT_NOT_FOUND_REGEX)) {
    return new errors.DocumentNotFound(message);
  } else if (message.match(errors.DUPLICATE_PRIMARY_KEY_REGEX)) {
    var primaryKey = message.match(errors.DUPLICATE_PRIMARY_KEY_REGEX)[1];
    return new errors.DuplicatePrimaryKey(message, primaryKey);
  } else if (errorOrMessage instanceof Error) {
    return errorOrMessage;
  }

  return new errors.ThinkyError(errorOrMessage);
};


/***/ }),

/***/ "../node_modules/thinky/lib/feed.js":
/*!******************************************!*\
  !*** ../node_modules/thinky/lib/feed.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
var util = __webpack_require__(/*! ../node_modules/thinky/lib/util.js */ "../node_modules/thinky/lib/util.js");

function Feed(feed, model) {
  this.feed = feed;
  this.model = model;
  this._closed = false;

  this.each = this._each;
  this.next = this._next;
}

Feed.prototype.toString = function() {
  return '[object Feed]'
}


Feed.prototype._next = function() {
  var self = this;
  return new Promise(function(resolve, reject) {
    self.feed.next().then(function(data) {
      util.tryCatch(function() {
        if (data.new_val != null) {
          self.model._parse(data.new_val).then(function(doc) {
            doc._setOldValue(data.old_val);
            resolve(doc);
          }).error(reject);
        }
        else if (data.old_val != null) { // new_val is null
          self.model._parse(data.old_val).then(function(doc) {
            doc._setUnSaved();
            resolve(doc);
          }).error(reject);
        }
        //else we just drop the change as it's a state/initializing object
      }, function(err) {
        reject(err);
      })
    }).error(reject);
  });
}

Feed.prototype.toArray = function() {
  throw new Error("The `toArray` method is not available on feeds.");
}

Feed.prototype.close = function(callback) {
  this._closed = true;
  return this.feed.close(callback);
}

Feed.prototype._each = function(callback, onFinish) {
  var self = this;
  self.feed.each(function(err, data) {
    if (err) {
      if (self._closed === true) {
        return;
      }
      return callback(err);
    }
    util.tryCatch(function() {
      if (data.new_val != null) {
        self.model._parse(data.new_val).then(function(doc) {
          doc._setOldValue(data.old_val);
          callback(null, doc);
        }).error(function(err) {
          callback(err);
        });
      }
      else if (data.old_val != null) { // new_val is null
        self.model._parse(data.old_val).then(function(doc) {
          doc._setUnSaved();
          callback(null, doc);
        }).error(function(err) {
          callback(err);
        });
      }
      //else we just drop the change as it's a state/initializing object
    }, function(err) {
      callback(err);
    })
  }, onFinish);
};

Feed.prototype._makeEmitter = function() {
  this.next = function() {
    throw new Error("You cannot called `next` once you have bound listeners on the feed")
  }
  this.each = function() {
    throw new Error("You cannot called `each` once you have bound listeners on the feed")
  }
  this.toArray = function() {
    throw new Error("You cannot called `toArray` once you have bound listeners on the feed")
  }
  this._eventEmitter = new EventEmitter();
}

Feed.prototype._eachCb = function(err, data) {
  var self = this;
  if (err != null) {
    if ((this._closed !== false) || (err.message !== "You cannot retrieve data from a cursor that is closed")) {
      self._eventEmitter.emit('error', err);
    }
    return;
  }

  util.tryCatch(function() {
    if (data.new_val !== null) {
      self.model._parse(data.new_val).then(function(doc) {
        doc._setOldValue(data.old_val);
        self._eventEmitter.emit('data', doc);
      }).error(function(err) {
        self._eventEmitter.emit('error', err);
      });
    }
    else if (data.old_val !== null) { // new_val is null
      self.model._parse(data.old_val).then(function(doc) {
        doc._setUnSaved();
        self._eventEmitter.emit('data', doc);
      }).error(function(err) {
        self._eventEmitter.emit('error', err);
      });
    }
  }, function(err) {
    self._eventEmitter.emit('error', err);
  })
}

var methods = [
    'addListener',
    'on',
    'once',
    'removeListener',
    'removeAllListeners',
    'setMaxListeners',
    'listeners',
    'emit'
];

for(var i=0; i<methods.length; i++) {
  (function(n) {
    var method = methods[n];
    Feed.prototype[method] = function() {
      var self = this;
      if (self._eventEmitter == null) {
        self._makeEmitter();
        setImmediate(function() {
          self.feed._each(self._eachCb.bind(self), function() {
            self._eventEmitter.emit('end');
          });
        });
      }
      self._eventEmitter[method].apply(self._eventEmitter, util.toArray(arguments));
    };
  })(i);
}

module.exports = Feed;


/***/ }),

/***/ "../node_modules/thinky/lib/model.js":
/*!*******************************************!*\
  !*** ../node_modules/thinky/lib/model.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/util.js */ "../node_modules/thinky/lib/util.js");
var _util = __webpack_require__(/*! util */ "util");
var schemaUtil = __webpack_require__(/*! ../node_modules/thinky/lib/schema.js */ "../node_modules/thinky/lib/schema.js");
var Document = __webpack_require__(/*! ../node_modules/thinky/lib/document.js */ "../node_modules/thinky/lib/document.js");
var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
var Query = __webpack_require__(/*! ../node_modules/thinky/lib/query.js */ "../node_modules/thinky/lib/query.js");
var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/errors.js */ "../node_modules/thinky/lib/errors.js");

/*
 * Constructor for a Model. Note that this is not what `thinky.createModel`
 * returns. It is the prototype of what `thinky.createModel` returns.
 * The whole chain being:
 * document.__proto__ = new Document(...)
 * document.__proto__.constructor = model (returned by thinky.createModel
 * document.__proto__._model = instance of Model
 * document.__proto__.constructor.__proto__ = document.__proto__._model
 */
function Model(name, schema, options, thinky) {
  /**
   * Name of the table used
   * @type {string}
   */
  this._name = name;

  // We want a deep copy
  options = options || {};
  this._options = {};
  this._options.enforce_missing = (options.enforce_missing != null) ? options.enforce_missing : thinky._options.enforce_missing;
  this._options.enforce_extra = (options.enforce_extra != null) ? options.enforce_extra : thinky._options.enforce_extra;
  this._options.enforce_type = (options.enforce_type != null) ? options.enforce_type : thinky._options.enforce_type;
  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : thinky._options.timeFormat;
  this._options.validate = (options.validate != null) ? options.validate : thinky._options.validate;

  this._schema = schemaUtil.parse(schema, '', this._options, this);
  //console.log(JSON.stringify(this._schema, null, 2));

  this.virtualFields = [];
  this.defaultFields = [];
  this._schema._getDefaultFields([], this.defaultFields, this.virtualFields)

  this.needToGenerateFields = (this.defaultFields.length+this.virtualFields.length) !== 0;

  this._pk = (options.pk != null) ? options.pk : 'id';

  this._table = (options.table != null) ? options.table : {};
  this._table.primaryKey = this._pk;

  this._thinky = thinky;

  this._validator = options.validator;

  this._indexes = {}; // indexName -> true
  this._pendingPromises = [];

  this._error = null; // If an error occured, we won't let people save things

  this._listeners = {};
  this._maxListeners = 10;
  this._joins = {};
  this._localKeys = {}; // key used as a foreign key by another model

  // This is to track joins that were not directly called by this model but that we still need
  // to purge the database
  this._reverseJoins = {};

  this._methods = {};
  this._staticMethods = {};
  this._async = {
    init: false,
    retrieve: false,
    save: false,
    validate: false
  };

  this._pre = {
    save: [],
    delete: [],
    validate: []
  };
  this._post = {
    init: [],
    retrieve: [],
    save: [],
    delete: [],
    validate: []
  };
}
_util.inherits(Model, EventEmitter);

Model.new = function(name, schema, options, thinky) {

  var proto = new Model(name, schema, options, thinky);
  proto._initModel = options.init  !== undefined ? !!options.init : true;

  var model = function model(doc, options) {
    if (!util.isPlainObject(doc)) {
      throw new Error("Cannot build a new instance of `"+proto._name+"` without an object")
    }
    // We create a deepcopy only if doc was already used to create a document
    if (doc instanceof Document) {
      doc = util.deepCopy(doc);
    }

    util.changeProto(doc, new Document(model, options));

    // Create joins document. We do it here because `options` are easily available
    util.loopKeys(proto._joins, function(joins, key) {
      if (doc[key] != null) {
        if ((joins[key].type === 'hasOne') && (doc[key] instanceof Document === false)) {
          doc[key] = new joins[key].model(doc[key], options);
        }
        else if ((joins[key].type === 'belongsTo') && (doc[key] instanceof Document === false)) {
          doc[key] = new joins[key].model(doc[key], options);
        }
        else if (joins[key].type === 'hasMany') {
          doc.__proto__._hasMany[key] = []

          for(var i=0; i<doc[key].length; i++) {
            if (doc[key][i] instanceof Document === false) {
              doc[key][i] = new joins[key].model(doc[key][i], options);
            }
          }
        }
        else if (joins[key].type === 'hasAndBelongsToMany') {
          for(var i=0; i<doc[key].length; i++) {
            if (doc[key][i] instanceof Document === false) {
              doc[key][i] = new joins[key].model(doc[key][i], options);
            }
          }
        }
      }
    });
    doc._getModel()._schema._setModel(doc._getModel());
    if (proto.needToGenerateFields === true) {
      doc._generateDefault();
    }

    var promises = [];
    var promise;
    if (proto._options.validate === 'oncreate') {
      promise = doc.validate(options);
      if (promise instanceof Promise) promises.push(promise);
    }

    if (proto._post.init.length > 0) {
      promise = util.hook({
        postHooks: doc._getModel()._post.init,
        doc: doc,
        async: doc._getModel()._async.init,
        fn: function() {
          return doc;
        }
      })
      if (promise instanceof Promise) promises.push(promise);
    }

    if (promises.length > 0) {
      return Promise.all(promises).then(function(docs) {
        return docs[0];
      });
    }
    return doc;
  }

  model.__proto__ = proto;

  if (options.init !== false) {
    // Setup the model's table.
    model.tableReady().then();
  }
  else {
    // We do not initialize the table and suppose that it already exists and
    // is ready.
    model.emit('created');
    model.emit('ready');
  }

  // So people can directly call the EventEmitter from the constructor
  // TOIMPROVE: We should emit everything from the constructor instead of emitting things from
  // the constructor and the instance of Model
  util.loopKeys(EventEmitter.prototype, function(emitter, key) {
    (function(_key) {
      model[_key] = function() {
        model._getModel()[_key].apply(model._getModel(), arguments);
      }
    })(key)
  });


  return model
}

/**
 * Create the model's table.
 * @return {Promise=} Returns a promise which will resolve when the table is ready.
 */
Model.prototype.tableReady = function() {
  var self = this;
  var model = this._getModel();
  if (!this._initModel) return Promise.resolve();
  if (this._tableReadyPromise) return this._tableReadyPromise;

  // Create the table, or push the table name in the queue.
  var r = model._thinky.r;
  this._tableReadyPromise = model._thinky.dbReady()
  .then(function() {
    return r.tableCreate(model._name, model._table).run();
  })
  .error(function(error) {
    if (error.message.match(/Table `.*` already exists/)) {
      return;
    }
    model._error = error;
    // Should we throw here?
  });

  return this._tableReadyPromise.then(function() {
    self.emit('created');
    if (!self._pendingPromises.length) {
      self.emit('ready');
    }
  });
};

/**
 * Get a promise which resolves when the Model's table and
 * all indices have been created.
 */
Model.prototype.ready = function() {
  var requirements = [];

  // Ensure the Model's table is ready
  requirements.push(this.tableReady());

  // Ensure all other pending promises have been resolved
  requirements.push(this._promisesReady());

  return Promise.all(requirements);
};

Model.prototype._promisesReady = function() {
  var self = this;
  if (this._promisesReadyPromise) return this._promisesReadyPromise;

  var verifyAll = function() {
    return Promise.all(self._pendingPromises)
    .then(function() {
      var i, allFullfilled = true;
      for (i=0; i<self._pendingPromises.length; i++) {
         if (!self._pendingPromises[i].isFulfilled()) {
          allFullfilled = false;
          break;
         }
      }
      return allFullfilled ? Promise.resolve() : verifyAll();
    });
  };

  this._promisesReadyPromise = verifyAll();
  return this._promisesReadyPromise;
};

Model.prototype._waitFor = function(promise) {
  var self = this;
  this._pendingPromises.push(promise);

  // Emit 'ready' when all pending promises have resolved
  if (!this._pendingReady) {
    this._pendingReady = this._promisesReady().then(function() {
      delete self._pendingReady;
      self.emit('ready', self);
    });
  }
};


Model.prototype._setError = function(error) {
  this._getModel()._error = error;
  this.emit('error', error);
}


/*
 * Return the options of the model -- call from an instance of Model
 */
Model.prototype.getOptions = function() {
  return this._options;
}


/*
 * Return the instance of Model **when called on the function**
 */
Model.prototype._getModel = function() {
  return this.__proto__;
}

/*
 * Return the instance of Model
 */
Model.prototype.getTableName = function() {
  return this._getModel()._name;
}


Model.prototype.ensureIndex = function(name, fn, opts) {
  var self = this;

  if ((opts === undefined) && (util.isPlainObject(fn))) {
    opts = fn;
    fn = undefined;
  }

  return self._createIndex(name, fn, opts)
  .catch(function(error) {
    self._getModel()._setError(error);
    throw error;
  });
}

Model.prototype._createIndex = function(name, fn, opts) {
  var model = this._getModel();
  var tableName = this.getTableName();
  var r = model._thinky.r;

  if (opts === undefined && util.isPlainObject(fn)) {
    opts = fn;
    fn = undefined;
  }

  var promise = this.tableReady().then(function() {
    return new Promise(function(resolve, reject) {
      return r.branch(
        r.table(tableName).indexList().contains(name),
        r.table(tableName).indexWait(name),
        r.branch(
          r.table(tableName).info()('primary_key').eq(name),
          r.table(tableName).indexWait(name),
          r.table(tableName).indexCreate(name, fn, opts).do(function() {
            return r.table(tableName).indexWait(name);
          })
        )
      )
      .run()
      .then(resolve)
      .error(function(error) {
        if (error.message.match(/^Index/)) {
          // TODO: This regex seems a bit too generous since messages such
          // as "Index `id` was not found on table..." will be accepted.
          // Figure out if this is OK or not.
          return resolve();
        }
        reject(error);
      });
    });
  })
  .then(function() {
    model._indexes[name] = true;
  });

  this._waitFor(promise);
  return promise;
};

/*
 * joinedModel: the joined model
 * fieldDoc: the field where the joined document will be kept
 * leftKey: the key in the model used for the join
 * rightKey: the key in the joined model used for the join
 *
 * The foreign key is stores in the joinedModel
 *
 * Post.hasOne(Author, "author", "id", "postId"
 *                ^- post.id
 *
 * options can be:
 * - init: Boolean (create an index or not)
 * - timeFormat: 'raw'/'native'
 * - enforce_extra: 'strict'/'remove'/'none'
 * - enforce_missing: Boolean
 * - enforce_type: 'strict'/'loose'/'none'
 * - validate: 'oncreate'/'onsave'
 */
Model.prototype.hasOne = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
  var self  = this;

  if ((joinedModel instanceof Model) === false) {
    throw new Error("First argument of `hasOne` must be a Model")
  }
  if (fieldDoc in self._getModel()._joins) {
    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
  }
  if (fieldDoc === "_apply") {
    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
  }
  self._getModel()._joins[fieldDoc] = {
    model: joinedModel,
    leftKey: leftKey,
    rightKey: rightKey,
    type: 'hasOne'
  }
  joinedModel._getModel()._localKeys[rightKey] = true;

  options = options || {};
  if (options.init !== false) {
    var newIndex = joinedModel._createIndex(rightKey)
    .catch(function(error) {
      joinedModel._getModel()._setError(error);
      self._getModel()._setError(error);
    });
    self._waitFor(newIndex);
  }
}

/*
 * joinedModel: the joined model
 * fieldDoc: the field where the joined document will be kept
 * leftKey: the key in the model used for the join
 * rightKey: the key in the joined model used for the join
 *
 * The foreign key is store in the model calling belongsTo
 *
 * Post.belongsTo(Author, "author", "authorId", "id"
 *                        ^- author.id
 */
Model.prototype.belongsTo = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
  var self  = this;

  if ((joinedModel instanceof Model) === false) {
    throw new Error("First argument of `belongsTo` must be a Model")
  }
  if (fieldDoc in self._getModel()._joins) {
    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
  }
  if (fieldDoc === "_apply") {
    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
  }

  self._getModel()._joins[fieldDoc] = {
    model: joinedModel,
    leftKey: leftKey,
    rightKey: rightKey,
    type: 'belongsTo'
  };
  self._getModel()._localKeys[leftKey] = true;

  joinedModel._getModel()._reverseJoins[fieldDoc] = {
    model: self,
    leftKey: leftKey,
    rightKey: rightKey,
    type: 'belongsTo',
  }

  options = options || {};
  if (options.init !== false) {
    /*
    var newIndex = self._createIndex(leftKey)
    .catch(function(error) {
      joinedModel._getModel()._setError(error);
      self._getModel()._setError(error);
    });
    joinedModel._waitFor(newIndex);
    */
    var newIndex = joinedModel._createIndex(rightKey)
    .catch(function(error) {
      joinedModel._getModel()._setError(error);
      self._getModel()._setError(error);
    });
    self._waitFor(newIndex);

  }
}


/*
 * joinedModel: the joined model
 * fieldDoc: the field where the joined document will be kept
 * leftKey: the key in the model used for the join
 * rightKey: the key in the joined model used for the join
 *
 * A post has one author, and an author can write multiple posts
 * Author.hasMany(Post, "posts", "id", "authorId"
 *                 ^- author.id
 */
Model.prototype.hasMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
  var self  = this;

  if ((joinedModel instanceof Model) === false) {
    throw new Error("First argument of `hasMany` must be a Model")
  }
  if (fieldDoc in self._getModel()._joins) {
    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
  }
  if (fieldDoc === "_apply") {
    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
  }

  this._getModel()._joins[fieldDoc] = {
    model: joinedModel,
    leftKey: leftKey,
    rightKey: rightKey,
    type: 'hasMany'
  };
  joinedModel._getModel()._localKeys[rightKey] = true;

  options = options || {};
  if (options.init !== false) {
    var newIndex = joinedModel._createIndex(rightKey)
    .catch(function(error) {
      self._getModel()._setError(error);
      joinedModel._getModel()._setError(error);
    });
    self._waitFor(newIndex);
  }
}


/*
 * joinedModel: the joined model
 * fieldDoc: the field where the joined document will be kept
 * leftKey: the key in the model used for the join
 * rightKey: the key in the joined model used for the join
 *
 * Patient.hasAndBelongsToMany(Doctor, "doctors", "id", "id"
 *                     patient.id-^  ^-doctor.id
 *
 * It automatically creates a table <modelName>_<joinedModel> or <joinedModel>_<modelName> (alphabetic order)
 */
Model.prototype.hasAndBelongsToMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {
  var self = this;
  var link, query;
  var thinky = this._getModel()._thinky;
  options = options || {};

  if ((joinedModel instanceof Model) === false) {
    throw new Error("First argument of `hasAndBelongsToMany` must be a Model")
  }
  if (fieldDoc in self._getModel()._joins) {
    throw new Error("The field `"+fieldDoc+"` is already used by another relation.");
  }
  if (fieldDoc === "_apply") {
    throw new Error("The field `_apply` is reserved by thinky. Please use another one.");
  }

  if (this._getModel()._name < joinedModel._getModel()._name) {
    link = this._getModel()._name+"_"+joinedModel._getModel()._name;
  }
  else {
    link = joinedModel._getModel()._name+"_"+this._getModel()._name;
  }
  if (typeof options.type === 'string') {
    link = link+"_"+options.type;
  }
  else if (typeof options.type !== 'undefined') {
    throw new Error('options.type should be a string or undefined.')
  }

  var linkModel;
  if (thinky.models[link] === undefined) {
    // Create a model, claim the namespace and create the table
    // passes table options to the underlying model (e.g. replicas, shards)
    linkModel = thinky.createModel(link, {}, { table: options.table });
  }
  else {
    linkModel = thinky.models[link];
  }


  this._getModel()._joins[fieldDoc] = {
    model: joinedModel,
    leftKey: leftKey,
    rightKey: rightKey,
    type: 'hasAndBelongsToMany',
    link: link,
    linkModel: linkModel
  }

  joinedModel._getModel()._reverseJoins[self.getTableName()] = {
    leftKey: leftKey,
    rightKey: rightKey,
    type: 'hasAndBelongsToMany',
    link: link,
    linkModel: linkModel
  }

  if (options.init !== false) {
    var r = self._getModel()._thinky.r;

    var query;
    if ((this.getTableName() === joinedModel.getTableName())
      && (leftKey === rightKey)) {
      // The relation is built for the same model, using the same key
      // Create a multi index
      query = r.branch(
        r.table(link).indexList().contains(leftKey+"_"+rightKey),
        r.table(link).indexWait(leftKey+"_"+rightKey),
        r.table(link).indexCreate(leftKey+"_"+rightKey, function(doc) {
          return doc(leftKey+"_"+rightKey)
        }, {multi: true}).do(function() {
          return r.table(link).indexWait(leftKey+"_"+rightKey)
        })
      )
    }
    else {
      query = r.branch(
        r.table(link).indexList().contains(self.getTableName()+'_'+leftKey),
        r.table(link).indexWait(self.getTableName()+'_'+leftKey),
        r.table(link).indexCreate(self.getTableName()+'_'+leftKey).do(function() {
          return r.table(link).indexWait(self.getTableName()+'_'+leftKey)
        })
      ).do(function() {
        return r.branch(
          r.table(link).indexList().contains(joinedModel.getTableName()+'_'+rightKey),
          r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey),
          r.table(link).indexCreate(joinedModel.getTableName()+'_'+rightKey).do(function() {
            return r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey)
          })
        )
      })

    }

    var linkPromise = linkModel.ready().then(function() {
      return query.run()
      .then(function() {
        self._getModel()._indexes[leftKey] = true;
        joinedModel._getModel()._indexes[rightKey] = true;
      })
      .error(function(error) {
        if (error.message.match(/^Index `/)) {
          return;
        }
        if (error.message.match(/^Table `.*` already exists/)) {
          return;
        }
        self._getModel()._setError(error);
        joinedModel._getModel()._setError(error);
        throw error;
      });
    })
    .then(function() {
      self._createIndex(leftKey)
      .catch(function(error) {
        self._getModel()._setError(error);
        joinedModel._getModel()._setError(error);
      });

      joinedModel._createIndex(rightKey)
      .catch(function(error) {
        self._getModel()._setError(error);
        joinedModel._getModel()._setError(error);
      });
    });

    joinedModel._waitFor(linkPromise);
    self._waitFor(linkPromise);

    return Promise.all([self.ready(), joinedModel.ready()]);
  }
};

(function() {
  // Import rethinkdbdash methods
  var Term = __webpack_require__(/*! rethinkdbdash */ "../node_modules/rethinkdbdash/lib/index.js")({pool: false}).expr(1).__proto__;
  util.loopKeys(Term, function(Term, key) {
    if (!Term.hasOwnProperty(key)) return;
    if (key === 'run' || key[0] === '_') return;

    (function(key) {
      switch (key) {
        case 'orderBy':
          Model.prototype[key] = function() {
            var query = new Query(this);
            if ((arguments.length === 1)
              && (typeof arguments[0] === 'string')
              && (this._getModel()._indexes[arguments[0]] === true)) {

                query = query[key]({index: arguments[0]});
                return query;
            }
            else {
              query = query[key].apply(query, arguments);
              return query;
            }
          }
          break;
        case 'filter':
          Model.prototype[key] = function() {
            var query = new Query(this);
            if ((arguments.length === 1)
              && (util.isPlainObject(arguments[0]))) {

              // Optimize a filter with an object
              // We replace the first key that match an index name
              var filter = arguments[0];

              var keys = Object.keys(filter).sort(); // Lexicographical order
              for(var i=0 ; i<keys.length; i++) {
                var index = keys[i];

                if (this._getModel()._indexes[index] === true) { // Index found
                  query = query.getAll(filter[index], {index: index});
                  delete filter[index];
                  break;
                }
              }
            }

            query = query[key].apply(query, arguments);
            return query;
          }
          break;
        case 'get':
          // Make a copy of `get` into `_get`
          Model.prototype['_get'] = function() {
            var query = new Query(this);
            query = query['_get'].apply(query, arguments);
            return query;
          }
        default:
          Model.prototype[key] = function() {
            var query = new Query(this);
            query = query[key].apply(query, arguments);
            return query;
          }
      }

    })(key);
  });
})();

Model.prototype.getJoin = function() {
  var query = new Query(this);
  return query.getJoin.apply(query, arguments)
}

Model.prototype.removeRelations = function(relationsToRemove) {
  var query = new Query(this);
  return query.removeRelations(relationsToRemove);
}


Model.prototype.run = function(options) {
  var query = new Query(this);
  return query.run(options);
}
Model.prototype.execute = function(options) {
  var query = new Query(this);
  return query.execute(options);
}

Model.prototype.save = function(docs, options) {
  var self = this;
  var r = self._getModel()._thinky.r;
  var isArray = Array.isArray(docs);

  if (!isArray) {
    docs = [docs];
  }

  var p = new Promise(function(mainResolve, mainReject) {
    var toSave = docs.length;

    var resolves = [];
    var rejects = [];
    var executeInsert = function (resolve, reject) {
      toSave--;
      resolves.push(resolve);
      rejects.push(reject);

      if (toSave === 0) {
        var copies = [];
        for(var i=0; i<docs.length; i++) {
          copies.push(docs[i]._makeSavableCopy());
        }
        var _options;
        if (util.isPlainObject(options)) {
          _options = util.deepCopy(options);
        }
        else {
          _options = {};
        }
        _options.returnChanges = 'always';
        r.table(self.getTableName()).insert(copies, _options).run().then(function(results) {
          if (results.errors === 0) {
            // results.changes currently does not enforce the same order as docs
            if (Array.isArray(results.changes)) {
              for(var i=0; i<results.changes.length; i++) {
                docs[i]._merge(results.changes[i].new_val);
                if (docs[i]._getModel().needToGenerateFields === true) {
                  docs[i]._generateDefault();
                }
                docs[i]._setOldValue(util.deepCopy(results.changes[i].old_val));
                docs[i].setSaved();
                docs[i].emit('saved', docs[i]);
              }
            }
            for(i=0; i<resolves.length; i++) {
              resolves[i]();
            }
          }
          else {
            //TODO Expand error with more information
            for(var i=0; i<rejects.length; i++) {
              rejects[i](new Error("An error occurred during the batch insert. Original results:\n"+JSON.stringify(results, null, 2)));
            }
          }
        }).error(reject);
      }
    };

    var promises = [];
    var foundNonValidDoc = false;
    for(var i=0; i<docs.length; i++) {
      if (foundNonValidDoc === true) {
        return;
      }
      if (docs[i] instanceof Document === false) {
        docs[i] = new self(docs[i]);
      }
      var promise;
      util.tryCatch(function() {
        promise = docs[i].validate();
        if (promise instanceof Promise) {
          promises.push(promise)
        }
      }, function(error) {
        foundNonValidDoc = true;
        mainReject(new Errors.ValidationError("One of the documents is not valid. Original error:\n"+error.message))
      });
    }

    if (foundNonValidDoc === false) {
      Promise.all(promises).then(function() {
        var promises = [];
        for(var i=0; i<docs.length; i++) {
          promises.push(docs[i]._batchSave(executeInsert));
        }
        Promise.all(promises).then(function() {
          mainResolve(docs);
        }).error(function(error) {
          mainReject(error)
        });
      }).error(function(error) {
        mainReject(new Errors.ValidationError("One of the documents is not valid. Original error:\n"+error.message))
      });
    }
  })

  if (!isArray) {
    return p.get(0);
  }

  return p;
}


Model.prototype.define = function(key, fn) {
  this._methods[key] = fn;
}
Model.prototype.defineStatic = function(key, fn) {
  this._staticMethods[key] = fn;

  this[key] = function() {
    return fn.apply(this, arguments);
  };
}



Model.prototype._parse = function(data, ungroup) {
  var self = this;
  var promises = [];
  var promise;

  var p = new Promise(function(resolve, reject) {
    if (ungroup) {
      for(var i=0; i<data.length; i++) {
        for(var j=0; j<data[i].reduction.length; j++) {
          util.tryCatch(function() {
            var newDoc = new self(data[i].reduction[j]);
            newDoc.setSaved(true);
            newDoc._emitRetrieve();
            data[i].reduction[j] = newDoc;
          }, reject)
        }
      }
      return resolve(data);
    }
    else if (Array.isArray(data)) {
      util.tryCatch(function() {
        for(var i=0; i<data.length; i++) {
          data[i] = new self(data[i])
          data[i].setSaved(true);

          self.emit('retrieved', data[i]);

          (function(i) {
            // Order matters here, we want the hooks to be executed *before* calling validate
            promise = util.hook({
              postHooks: data[i]._getModel()._post.retrieve,
              doc: data[i],
              async: data[i]._getModel()._async.retrieve,
              fn: function() {}
            })
            if (promise instanceof Promise) {
              promise.then(function() {
                var promise = data[i].validate();
                if (promise instanceof Promise) {
                  promise.then(function() {
                    resolve(data)
                  }).error(reject);
                }
                else {
                  resolve(data);
                }
              }).error(reject);
              promises.push(promise);
            }
            else {
              promise = data[i].validate();
              if (promise instanceof Promise) promises.push(promise);
            }
          })(i);
        }
      }, function(error) {
        var newError = new Error("The results could not be converted to instances of `"+self.getTableName()+"`\nDetailed error: "+error.message);

        return reject(newError);
      });

      if (promises.length > 0) {
        Promise.all(promises).then(function() {
          resolve(data);
        }).error(reject);
      }
      else {
        resolve(data);
      }
    }
    else {
      // If we get a GROUPED_DATA, we convert documents in each group
      if (util.isPlainObject(data) && (data.$reql_type$ === "GROUPED_DATA")) {
        var result = [];
        util.tryCatch(function() {
          var reduction, newDoc;
          for(var i=0; i<data.data.length; i++) {
            (function(i) {
              reduction = [];
              if (Array.isArray(data.data[i][1])) {
                for(var j=0; j<data.data[i][1].length; j++) {
                  (function(j) {
                    newDoc = new self(data.data[i][1][j]);
                    newDoc.setSaved(true);

                    newDoc._emitRetrieve();

                    promise = util.hook({
                      postHooks: newDoc._getModel()._post.retrieve,
                      doc: newDoc,
                      async: newDoc._getModel()._async.retrieve,
                      fn: function() {}
                    })
                    if (promise instanceof Promise) {
                      promise.then(function() {
                        var promise = newDoc.validate();
                        if (promise instanceof Promise) {
                          promise.then(function() {
                            resolve(data)
                          }).error(reject);
                        }
                        else {
                          resolve(data);
                        }
                      }).error(reject);
                      promises.push(promise);
                    }
                    else {
                      promise = newDoc.validate();
                      if (promise instanceof Promise) promises.push(promise);
                    }

                    reduction.push(newDoc)
                  })(j);
                }
                result.push({
                  group: data.data[i][0],
                  reduction: reduction
                })
              }
              else {
                newDoc = new self(data.data[i][1]);
                newDoc.setSaved(true);

                newDoc._emitRetrieve();

                promise = util.hook({
                  postHooks: newDoc._getModel()._post.retrieve,
                  doc: newDoc,
                  async: newDoc._getModel()._async.retrieve,
                  fn: function() {}
                })
                if (promise instanceof Promise) {
                  promise.then(function() {
                    var promise = newDoc.validate();
                    if (promise instanceof Promise) {
                      promise.then(function() {
                        resolve(result)
                      }).error(reject);
                    }
                    else {
                      resolve(result);
                    }
                  }).error(reject);
                  promises.push(promise);
                }
                else {
                  promise = newDoc.validate();
                  if (promise instanceof Promise) promises.push(promise);
                }

                result.push({
                  group: data.data[i][0],
                  reduction: newDoc
                })
              }
            })(i);
          }
        }, reject);
        if (promises.length > 0) {
          Promise.all(promises).then(function() {
            resolve(result)
          }).error(reject);
        }
        else {
          resolve(result);
        }
      }
      else {
        if (data === null) { // makeDocument is true, but we got `null`
          reject(new Error("Cannot build a new instance of `"+self.getTableName()+"` with `null`."))
        }
        else {
          util.tryCatch(function() {
            var newDoc = new self(data);
            newDoc.setSaved(true);

            newDoc._emitRetrieve();

            promise = util.hook({
              postHooks: newDoc._getModel()._post.retrieve,
              doc: newDoc,
              async: newDoc._getModel()._async.retrieve,
              fn: function() {}
            })
            if (promise instanceof Promise) {
              promise.then(function() {
                var promise = newDoc.validate();
                if (promise instanceof Promise) {
                  promise.then(function() {
                    resolve(newDoc);
                  }).error(reject);
                }
                else {
                  resolve(newDoc);
                }
              }).error(reject);
            }
            else {
              promise = newDoc.validate();
            }

            if (promise instanceof Promise) {
              promise.then(function() {
                resolve(newDoc)
              }).error(function(err) {
                reject(err)
              });
            }
            else {
              resolve(newDoc);
            }
          }, reject);
        }
      }
    }
  })
  return p;
}

/*
 * Implement an interface similar to events.EventEmitter
 */
Model.prototype.docAddListener = function(eventKey, listener) {
  var listeners = this._getModel()._listeners;
  if (listeners[eventKey] == null) {
    listeners[eventKey] = [];
  }
  listeners[eventKey].push({
    once: false,
    listener: listener
  });
}
Model.prototype.docOn = Model.prototype.docAddListener;

Model.prototype.docOnce = function(eventKey, listener) {
  var listeners = this._getModel()._listeners;
  if (listeners[eventKey] == null) {
    listeners[eventKey] = [];
  }
  listeners[eventKey].push({
    once: true,
    listener: listener
  });
}

Model.prototype.docListeners = function(eventKey, raw) {
  if (eventKey == null) {
    return this._getModel()._listeners
  }

  raw = raw || true;
  if (raw === true) {
    return this._getModel()._listeners[eventKey];
  }
  else {
    return this._getModel()._listeners[eventKey].map(function(fn) {
      return fn.listener;
    });
  }
}

Model.prototype.docSetMaxListeners = function(n) {
  this._getModel()._maxListeners = n;
}

Model.prototype.docRemoveListener = function(ev, listener) {
  if (Array.isArray(this._getModel()._listeners[ev])) {
    for(var i=0; i<this._getModel()._listeners[ev].length; i++) {
      if (this._getModel()._listeners[ev][i] === listener) {
        this._getModel()._listeners[ev].splice(i, 1);
        break;
      }
    }
  }
}

Model.prototype.docRemoveAllListeners = function(ev) {
  if (ev === undefined) {
    delete this._getModel()._listeners[ev]
  }
  else {
    this._getModel()._listeners = {};
  }
}

Model.prototype.pre = function(ev, fn) {
  if (typeof fn !== "function") {
    throw new Error("Second argument to `pre` must be a function");
  }
  if (fn.length > 1) {
    throw new Error("Second argument to `pre` must be a function with at most one argument.");
  }
  if (Array.isArray(this._pre[ev]) === false) {
    throw new Error("No pre-hook available for the event `"+ev+"`.")
  }
  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)
  this._getModel()._pre[ev].push(fn);
}

Model.prototype.post = function(ev, fn) {
  if (typeof fn !== "function") {
    throw new Error("Second argument to `pre` must be a function");
  }
  if (fn.length > 1) {
    throw new Error("Second argument to `pre` must be a function with at most one argument.");
  }
  if (Array.isArray(this._post[ev]) === false) {
    throw new Error("No post-hook available for the event `"+ev+"`.")
  }
  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)
  this._getModel()._post[ev].push(fn);
}

module.exports = Model;


/***/ }),

/***/ "../node_modules/thinky/lib/query.js":
/*!*******************************************!*\
  !*** ../node_modules/thinky/lib/query.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var util = __webpack_require__(/*! ../node_modules/thinky/lib/util.js */ "../node_modules/thinky/lib/util.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/errors.js */ "../node_modules/thinky/lib/errors.js");
var schemaUtil = __webpack_require__(/*! ../node_modules/thinky/lib/schema.js */ "../node_modules/thinky/lib/schema.js");
var Feed = __webpack_require__(/*! ../node_modules/thinky/lib/feed.js */ "../node_modules/thinky/lib/feed.js");


/**
 * Constructor for a Query. A Query basically wraps a ReQL queries to keep track
 * of the model returned and if a post-query validation is required.
 * @param {Function=} model Model of the documents returned
 * @param {ReQLQuery=} current ReQL query (rethinkdbdash)
 * @param {boolean=} postValidation whether post query validation should be performed
 */
function Query(model, query, options, error) {
  var self = this;

  this._model = model; // constructor of the model we should use for the results.
  if (model !== undefined) {
    this._r = model._getModel()._thinky.r;
    util.loopKeys(model._getModel()._staticMethods, function(staticMethods, key) {
      (function(_key) {
        self[_key] = function() {
          return staticMethods[_key].apply(self, arguments);
        };
      })(key);
    });
  }

  if (query !== undefined) {
    this._query = query;
   }
  else if (model !== undefined) {
    // By default, we initialize the query to `r.table(<tableName>)`.
    this._query = this._r.table(model.getTableName());
  }

  if (util.isPlainObject(options)) {
    if (options.postValidation) {
      this._postValidation = options.postValidation === true;
    }
    if (options.ungroup) {
      this._ungroup = options.ungroup === true;
    }
    else {
      this._ungroup = false;
    }
  }
  else { // let the user rework the result after ungroup
    this._ungroup = false;
  }
  if (error) {
    // Note `Query.prototype.error` is defined because of `r.error`, so we shouldn't
    // defined this.error.
    this._error = error;
  }
  this._pointWrite = false;
}

Query.prototype.setPostValidation = function() {
  this._postValidation = true;
}

Query.prototype.setPointWrite = function() {
  this._pointWrite = true;
}

/**
 * Execute a Query and expect the results to be object(s) that can be converted
 * to instances of the model.
 * @param {Object=} options The options passed to the driver's method `run`
 * @param {Function=} callback
 * @return {Promise} return a promise that will be resolved when the query and
 * the instances of the models will be created (include the potential
 * asynchronous hooks).
 */
Query.prototype.run = function(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  return this._execute(options, true).nodeify(callback);
}


/**
 * Execute a Query
 * @param {Object=} options The options passed to the driver's method `run`
 * @param {Function=} callback
 * @return {Promise} return a promise that will be resolved with the results
 * of the query.
 */
Query.prototype.execute = function(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  return this._execute(options, false).nodeify(callback);
}

/**
* Bind Query.prototype.run() for later use
* @param {Object=} options The options passed to the driver's method `run`
* @param {Function=} callback
* @return {Function} return a `this` bound Query.prototype.run()
*/

Query.prototype.bindRun = function () {
  var curriedArgs = Array.prototype.slice.call(arguments);
  return Function.prototype.bind.apply( Query.prototype.run, [ this ].concat( curriedArgs ) );
}

/**
 * Bind Query.prototype.execute() for later use
 * @param {Object=} options The options passed to the driver's method `run`
 * @param {Function=} callback
 * @return {Function} return a `this` bound Query.prototype.execute()
 */

Query.prototype.bindExecute = function () {
  var curriedArgs = Array.prototype.slice.call(arguments);
  return Function.prototype.bind.apply( Query.prototype.execute, [ this ].concat( curriedArgs ) );
}

/**
 * Internal method to execute a query. Called by `run` and `execute`.
 * @param {Object} options The options passed to the driver's method `run`
 * @param {boolean} parse Whether the results should be converted as instance(s) of the model
 * @param {Function=} callback
 * @return {Promise} return a promise that will be resolved with the results
 * of the query.
 * @private
 */
Query.prototype._execute = function(options, parse) {
  var self = this;
  options = options || {};
  var fullOptions = {groupFormat: 'raw'}
  util.loopKeys(options, function(options, key) {
    fullOptions[key] = options[key]
  });
  if (parse === true) {
    fullOptions.cursor = false;
  }

  if (self._model._error !== null) {
    return Promise.reject(self._model._error);
  }
  return self._model.ready().then(function() {
    return self._executeCallback(fullOptions, parse, options.groupFormat);
  });
}

Query.prototype._executeCallback = function(fullOptions, parse, groupFormat) {
  var self = this;
  if (self._error !== undefined) {
    return Promise.reject(new Error("The partial value is not valid, so the write was not executed. The original error was:\n"+self._error.message));
  }

  return self._query.run(fullOptions).then(function(result) {
    if (result === null && parse) {
      throw new Errors.DocumentNotFound();
    }

    // Expect a write result from RethinkDB
    if (self._postValidation === true) {
      return self._validateQueryResult(result);
    }

    if (result != null && typeof result.getType === 'function') {
      var resultType = result.getType();
      if (resultType === 'Feed' ||
        resultType === 'OrderByLimitFeed' ||
        resultType === 'UnionedFeed'
      ) {
        var feed = new Feed(result, self._model);
        return feed;
      }

      if (resultType === 'AtomFeed') {
        return result.next().then(function(initial) {
          var value = initial.new_val || {};
          return self._model._parse(value).then(function(doc) {
            doc._setFeed(result);
            return doc;
          });
        });
      }
    }

    if (parse === true) {
      return self._model._parse(result, self._ungroup);
    }

    if (groupFormat !== 'raw') {
      return Query.prototype._convertGroupedData(result);
    }

    return result;
  }).catch(function(err) {
    return Promise.reject(Errors.create(err));
  })
};

Query.prototype._validateUngroupResult = function(result) {
}

Query.prototype._validateQueryResult = function(result) {
  var self = this;
  if (result.errors > 0) {
    console.log(result);
    return Promise.reject(new Errors.InvalidWrite("An error occured during the write", result));
  }
  if (!Array.isArray(result.changes)) {
    if (self._isPointWrite()) {
      return Promise.resolve();
    }
    return Promise.resolve([]);
  }

  var promises = [];
  for(var i=0; i<result.changes.length; i++) {
    (function(i) {
      if (result.changes[i].new_val !== null) {
        promises.push(self._model._parse(result.changes[i].new_val));
      }
    })(i)
  }
  return Promise.all(promises).then(function(result) {
    if (self._isPointWrite()) {
      if (result.length > 1) {
        throw new Error('A point write returned multiple values')
      }
      return result[0];
    }
    return result;
  }).catch(function(error) {
    if (error instanceof Errors.DocumentNotFound) {
      // Should we send back null?
    }
    else {
      var revertPromises = [];
      var primaryKeys = [];
      var keysToValues = {};
      var r = self._model._thinky.r;
      for(var p=0; p<result.changes.length; p++) {
        // Extract the primary key of the document saved in the database
        var primaryKey = util.extractPrimaryKey(
            result.changes[p].old_val,
            result.changes[p].new_val,
            self._model._pk)
        if (primaryKey === undefined) {
          continue;
        }

        if (typeof primaryKey === "string") {
          keysToValues[primaryKey] = result.changes[p].old_val;
          primaryKeys.push(primaryKey);
        }
        else {
          // Replace documents with non-string type primary keys
          // one by one.
          revertPromises.push(r.table(self._model.getTableName())
            .get(primaryKey)
            .replace(result.changes[p].old_val)
            .run());
        }
      }

      // Replace all documents with string-type primary keys
      // in a single replace() operation.
      if (primaryKeys.length) {
        revertPromises.push(
          r.table(self._model.getTableName()).getAll(r.args(primaryKeys)).replace(function(doc) {
            return r.expr(keysToValues)(doc(self._model._pk));
          }).run()
        );
      }

      return Promise.all(revertPromises).then(function(result) {
        throw new Error("The write failed, and the changes were reverted.");
      }).error(function(error) {
        throw new Error("The write failed, and the attempt to revert the changes failed with the error:\n"+error.message);
      });
    }
  })
};


/**
 * Convert GROUPED_DATA results to [group: <group>, reduction: <reduction>]
 * This does the same as the driver. The reduction is not converted to
 * instances of the model.
 */
Query.prototype._convertGroupedData = function(data) {
  if (util.isPlainObject(data) && (data.$reql_type$ === "GROUPED_DATA")) {
    var result = [];
    var reduction;
    for(var i=0; i<data.data.length; i++) {
      result.push({
        group: data.data[i][0],
        reduction: data.data[i][1]
      });
    }
    return result;
  }
  else {
    return data;
  }
}


/**
 * Perform a join given the relations on this._model
 * @param {Object=} modelToGet explicit joined documents to retrieve
 * @param {boolean} getAll Internal argument, if `modelToGet` is undefined, `getAll` will
 * be set to `true` and `getJoin` will be greedy and keep recursing as long as it does not
 * hit a circular reference
 * @param {Object=} gotModel Internal argument, the model we are already fetching.
 * @return {Query}
 */
Query.prototype.getJoin = function(modelToGet, getAll, gotModel) {
  var self = this;
  var r = self._model._getModel()._thinky.r;

  var model = this._model;
  var joins = this._model._getModel()._joins;

  var getAll = modelToGet === undefined;
  if (util.isPlainObject(modelToGet) === false) {
    modelToGet = {};
  }
  var innerQuery;

  gotModel = gotModel || {};
  gotModel[model.getTableName()] = true;

  util.loopKeys(joins, function(joins, key) {
    if (util.recurse(key, joins, modelToGet, getAll, gotModel)) {
      switch (joins[key].type) {
        case 'hasOne':
        case 'belongsTo':
          self._query = self._query.merge(function(doc) {
            return r.branch(
              doc.hasFields(joins[key].leftKey),
              r.table(joins[key].model.getTableName()).getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}).coerceTo("ARRAY").do(function(result) {
                innerQuery = new Query(joins[key].model, result.nth(0));

                if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
                  innerQuery = modelToGet[key]._apply(innerQuery);
                }
                innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel)._query;
                return r.branch(
                  result.count().eq(1),
                  r.object(key, innerQuery),
                  r.branch(
                    result.count().eq(0),
                    {},
                    r.error(r.expr("More than one element found for ").add(doc.coerceTo("STRING")).add(r.expr("for the field ").add(key)))
                  )
                )
              }),
              {}
            )
          });
          break;

        case 'hasMany':
          self._query = self._query.merge(function(doc) {
            innerQuery = new Query(joins[key].model,
                       r.table(joins[key].model.getTableName())
                      .getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}))

            if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
              innerQuery = modelToGet[key]._apply(innerQuery);
            }
            innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel);
            if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {
              innerQuery = innerQuery.coerceTo("ARRAY");
            }
            innerQuery = innerQuery._query;

            return r.branch(
              doc.hasFields(joins[key].leftKey),
              r.object(key, innerQuery),
              {}
            )
          });
          break;

        case 'hasAndBelongsToMany':
          self._query = self._query.merge(function(doc) {
            if ((model.getTableName() === joins[key].model.getTableName()) && (joins[key].leftKey === joins[key].rightKey)) {
              // In case the model is linked with itself on the same key

              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: joins[key].leftKey+"_"+joins[key].leftKey}).concatMap(function(link) {
                return r.table(joins[key].model.getTableName()).getAll(
                  r.branch(
                    doc(joins[key].leftKey).eq(link(joins[key].leftKey+"_"+joins[key].leftKey).nth(0)),
                    link(joins[key].leftKey+"_"+joins[key].leftKey).nth(1),
                    link(joins[key].leftKey+"_"+joins[key].leftKey).nth(0)
                  )
                , {index: joins[key].rightKey})
              });

              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
                innerQuery = modelToGet[key]._apply(innerQuery);
              }

              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {
                innerQuery = innerQuery.coerceTo("ARRAY");
              }

              return r.branch(
                doc.hasFields(joins[key].leftKey),
                r.object(key, new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),
                {}
              )
            }
            else {
              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: model.getTableName()+"_"+joins[key].leftKey}).concatMap(function(link) {
                return r.table(joins[key].model.getTableName()).getAll(link(joins[key].model.getTableName()+"_"+joins[key].rightKey), {index: joins[key].rightKey})
              });

              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {
                innerQuery = modelToGet[key]._apply(innerQuery)
              }

              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {
                innerQuery = innerQuery.coerceTo("ARRAY");
              }

              return r.branch(
                doc.hasFields(joins[key].leftKey),
                r.object(key,
                  new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),
                {}
              )
            }
          });
          break;
      }
    }
  });

  return self;
};


/**
 * Add a relation
 * @param {string} field The field of the joined document(s)
 * @param {Object} joinedDocument An object with the primary key defined or the related key
 * @return {Promise}
 *
 * hasOne, primary key required
 * User.get(1).addRelation("account", {id: 2, sold: 2132})
 * The promise resolved the document on which addRelation is called
 *
 * hasMany, primary key required
 * User.get(1).addRelation("accounts", {id: 2, sold: 2132})
 * The promise resolved the updated joined document
 *
 * belongsTo, right joined key OR primary key required
 * User.get(1).addRelation("account", {id: 2, sold: 2132})
 * The promise resolved the document on which addRelation is called
 *
 * hasAndBelongsToMany, right joined key required
 * User.get(1).addRelation("accounts", {id: 2, sold: 2132})
 * The promise resolved with true
 */

Query.prototype.addRelation = function(field, joinedDocument) {
  var self = this;
  var model = self._model;
  var joins = self._model._getModel()._joins;
  var joinedModel = joins[field].model;
  var r = self._model._thinky.r;

  switch (joins[field].type) {
    case 'hasOne':
    case 'hasMany':
      if (joinedDocument[joinedModel._pk] === undefined) {
        return new Query(model, self, {},
            new Error('Primary key for the joined document not found for a `hasOne/hasMany` relation.')
        );
      }
      var updateValue = {};
      updateValue[joins[field].rightKey] = self._query(joins[field].leftKey);
      return joinedModel.get(joinedDocument[joinedModel._pk]).update(updateValue, {nonAtomic: true}).run()
    case 'belongsTo':
      var updateValue = {};
      if (joinedDocument[joins[field].rightKey] === undefined) {
        if (joinedDocument[joinedModel._pk] === undefined) {
          return new Query(model, self, {},
              new Error('The primary key or the joined key must be defined in the joined document for a `belongsTo` relation.')
          );
        }
        updateValue[joins[field].leftKey] = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query;
      }
      else {
        updateValue[joins[field].leftKey] = joinedDocument[joins[field].rightKey];
      }
      return self.update(updateValue, {nonAtomic: true}).run();
    case 'hasAndBelongsToMany':
      var linkModel = joins[field].linkModel;
      var linkValue;
      var link;
      if (joinedDocument[joins[field].rightKey] === undefined) {
        if (joinedDocument[joinedModel._pk] === undefined) {
          return new Query(model, self, {},
              new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')
          );
        }
        link = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query
      }
      else {
        link = r.expr(joinedDocument[joins[field].rightKey]);
      }

      if ((model.getTableName() === joinedModel.getTableName())
          && (joins[field].leftKey === joins[field].rightKey)) {
        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {
          return link.do(function(rightKey) {
            return r.branch(
                rightKey.lt(leftKey),
                r.object(
                  'id', rightKey.add('_').add(leftKey),
                  joins[field].leftKey+"_"+joins[field].leftKey, [leftKey, rightKey]
                ),
                r.object(
                  'id', leftKey.add('_').add(rightKey),
                  joins[field].leftKey+"_"+joins[field].leftKey, [leftKey, rightKey]
                )
            )
          });
        });
      }
      else {
        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {
          return link.do(function(rightKey) {
            if (model.getTableName() < joinedModel.getTableName()) {
              return r.object(
                'id', leftKey.add('_').add(rightKey),
                model.getTableName()+"_"+joins[field].leftKey, leftKey,
                joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey 
              )
            }
            else if (model.getTableName() > joinedModel.getTableName()) {
              return r.object(
                'id', rightKey.add('_').add(leftKey),
                model.getTableName()+"_"+joins[field].leftKey, leftKey,
                joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey 
              )
            }
            else {
              return r.branch(
                rightKey.lt(leftKey),
                r.object(
                  'id', leftKey.add('_').add(rightKey),
                  model.getTableName()+"_"+joins[field].leftKey, leftKey,
                  joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey 
                ),
                r.object(
                  'id', rightKey.add('_').add(leftKey),
                  model.getTableName()+"_"+joins[field].leftKey, leftKey,
                  joinedModel.getTableName()+"_"+joins[field].rightKey,rightKey 
                )
              )
            }
          });
        });
      }

      return linkModel.insert(linkValue, {conflict: "replace", returnChanges: 'always'}).do(function(result) {
        return r.branch(
            result('errors').eq(0),
            true, // not relevant value
            r.error(result('errors'))
        )
      }).execute()
    default:
      return new Query(model, self, {},
          new Error('The provided field `'+field+'` does not store joined documents.')
      ).run()
  }
}

/**
 * Remove the provided relation
 * @param {string} field The field of the joined document(s) to remove
 * @param {Array} joinedDocument The document with who the relation should be removed
 * @return {Promise}
 */
//TODO Support an array of joinedDocuments?
Query.prototype.removeRelation = function(field, joinedDocument) {
  var self = this;
  var model = self._model;
  var joins = self._model._getModel()._joins;
  var joinedModel = joins[field].model;
  var r = self._model._thinky.r;

  var query;
  switch (joins[field].type) {
    case 'hasOne':
      query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {
        return row.without(joins[field].rightKey)
      });
      query.setPostValidation();
      query.setPointWrite();
      return query;
    case 'hasMany':
      if (joinedDocument === undefined) {
        query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {
          return row.without(joins[field].rightKey)
        })
      }
      else {
        query = joinedModel.getAll(r.expr(joinedDocument)(joinedModel._pk)).replace(function(row) {
          return row.without(joins[field].rightKey)
        })
      }
      query.setPostValidation();
      return query;
    case 'belongsTo':
      query = self.replace(function(row) {
        return row.without(joins[field].leftKey)
      })
      query.setPostValidation();
      return query;
    case 'hasAndBelongsToMany':
      var linkModel = joins[field].linkModel;
      if (joinedDocument === undefined) {
        query = self._query(joins[field].leftKey).do(function(leftKey) {
          // range are not supported at the moment, so keys is an object and we don't have to worry about empty sequences
          if ((model.getTableName() === joinedModel.getTableName())
              && (joins[field].leftKey === joins[field].rightKey)) {
            return linkModel.getAll(leftKey, {index: joins[field].leftKey+'_'+joins[field].leftKey}).delete()._query
          }
          else {
            return linkModel.getAll(leftKey, {index: model.getTableName()+'_'+joins[field].leftKey}).delete()._query
          }
        }).do(function(result) {
          return r.branch(
              result('errors').eq(0),
              true, // not relevant value
              r.error(result('errors'))
           )
        })
      }
      else {
        if (joinedDocument[joins[field].rightKey] === undefined) {
          if (joinedDocument[joinedModel._pk] === undefined) {
            return new Query(model, self, {},
                new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')
            );
          }

          if ((model.getTableName() === joinedModel.getTableName())
              && (joins[field].leftKey === joins[field].rightKey)) {
            query = self._query(joins[field].leftKey).do(function(leftKey) {
              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {
                if (model.getTableName() < joinedModel.getTableName()) {
                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query;
                }
                else if (model.getTableName() > joinedModel.getTableName()) {
                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query;
                }
                else {
                  return r.branch(
                    leftKey.lt(rightKey),
                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,
                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
                  )
                }
              });
            })
          }
          else {
            query = self._query(joins[field].leftKey).do(function(leftKey) {
              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {
                if (model.getTableName() < joinedModel.getTableName()) {
                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query
                }
                else if (model.getTableName() > joinedModel.getTableName()) {
                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
                }
                else {
                  return r.branch(
                    leftKey.lt(rightKey),
                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,
                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
                  )

                }
              });
            })
          }
        }
        else {
          query = self._query(joins[field].leftKey).do(function(leftKey) {
            var rightKey = r.expr(joinedDocument[joins[field].rightKey]);
            if (model.getTableName() < joinedModel.getTableName()) {
              return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query
            }
            else if (model.getTableName() > joinedModel.getTableName()) {
              return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
            }
            else {
              return r.branch(
                leftKey.lt(rightKey),
                linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,
                linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query
              )

            }
          })
        }
      }
      return query;
    default:
      return new Query(model, self, {},
          new Error('The provided field `'+field+'` does not store joined documents.')
      );
  }
};

/**
 * Import all the methods from rethinkdbdash, expect the private one (the one
 * starting with an underscore).
 * Some method are slightly changed: `get`, `update`, `replace`.
 */
(function() {
  var Term = __webpack_require__(/*! rethinkdbdash */ "../node_modules/rethinkdbdash/lib/index.js")({pool: false}).expr(1).__proto__;
  util.loopKeys(Term, function(Term, key) {
    if (key === 'run' || key[0] === '_') return;
    // Note: We suppose that no method has an empty name
    switch (key) {
      case 'get':
        // `get` in thinky returns an error if the document is not found.
        // The driver currently just returns `null`.
        (function(key) {
          Query.prototype[key] = function() {
            return new Query(this._model, this._query[key].apply(this._query, arguments)).default(this._r.error(new Errors.DocumentNotFound().message));
          }
        })(key);
        // Copy it in `_get` without `default`.
        (function(key) {
          Query.prototype['_get'] = function() {
            // Create a new query to let people fork it
            return new Query(this._model, this._query[key].apply(this._query, arguments));
          }
        })(key);
        break;
      case 'update':
      case 'replace':
        // `update` and `replace` can be used. A partial validation is performed before
        // sending the query, and a full validation is performed after the query. If the
        // validation fails, the document(s) will be reverted.
        (function(key) {
          Query.prototype[key] = function(value, options) {
            options = options || {};
            options.returnChanges = 'always';
            var error = null;
            var self = this;
            util.tryCatch(function() {
              if (util.isPlainObject(value)) {
                schemaUtil.validate(value, self._model._schema, '', {enforce_missing: false});
              }
            }, function(err) {
              error = err;
            });
            return new Query(this._model, this._query[key].call(this._query, value, options), {postValidation: true}, error);
          }
        })(key);
        break;

      case 'changes':
        (function(key) {
          Query.prototype[key] = function() {
            // In case of `get().changes()` we want to remove the default(r.errror(...))
            // TODO: Do not hardcode this?
            if ((typeof this._query === 'function') && (this._query._query[0] === 92)) {
              this._query._query = this._query._query[1][0];
            }
            return new Query(this._model, this._query[key].apply(this._query, arguments));
          }
        })(key);
        break;

      case 'then':
      case 'error':
      case 'catch':
      case 'finally':
        (function(key) {
          Query.prototype[key] = function() {
            var promise = this.run();
            return promise[key].apply(promise, arguments);
          }
        })(key);
        break;

      case 'ungroup':
        (function(key) {
          Query.prototype[key] = function() {
            return new Query(this._model, this._query[key].apply(this._query, arguments), {ungroup: true});
          }
        })(key);
        break;

      default:
        (function(key) {
          Query.prototype[key] = function() {
            // Create a new query to let people fork it
            return new Query(this._model, this._query[key].apply(this._query, arguments));
          }
        })(key);
        break;
      }
  });
})();

Query.prototype._isPointWrite = function() {
  return this._pointWrite || (Array.isArray(this._query._query) &&
      (this._query._query.length > 1) &&
      Array.isArray(this._query._query[1]) &&
      (this._query._query[1].length > 0) &&
      Array.isArray(this._query._query[1][0]) &&
      (this._query._query[1][0].length > 1) &&
      Array.isArray(this._query._query[1][0][1]) &&
      (this._query._query[1][0][1].length > 0) &&
      Array.isArray(this._query._query[1][0][1][0]) &&
      (this._query._query[1][0][1][0][0] === 16))
}

/**
 * Convert the query to its string representation.
 * @return {string}
 */
Query.prototype.toString = function() {
  return this._query.toString();
}

module.exports = Query;


/***/ }),

/***/ "../node_modules/thinky/lib/schema.js":
/*!********************************************!*\
  !*** ../node_modules/thinky/lib/schema.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPrefix = "__array"
module.exports.arrayPrefix = arrayPrefix;

var util = __webpack_require__(/*! ../node_modules/thinky/lib/util.js */ "../node_modules/thinky/lib/util.js");
var type = __webpack_require__(/*! ../node_modules/thinky/lib/type/index.js */ "../node_modules/thinky/lib/type/index.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/errors.js */ "../node_modules/thinky/lib/errors.js");


function generateVirtual(doc, defaultField, originalDoc, virtual) {
  var path = defaultField.path;
  var value = defaultField.value;
  var field = doc;

  var keepGoing = true;
  var virtualValue = virtual;

  for(var j=0; j<path.length-1; j++) {
    if (util.isPlainObject(virtualValue)) {
      virtualValue = virtualValue[path[j]];
    }
    else {
      virtualValue = undefined;
    }

    if (path[j] === arrayPrefix) {
      if (!Array.isArray(field)) {
        // This is caught by validate, except if there is an `enforce_type: "none"`.
        return;
      }
      else {
        for(var k=0; k<field.length; k++) {
          if (virtual != null) {
            virtualValue = virtual[k];
          }
          generateVirtual(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this, virtualValue);
        }
      }
      keepGoing = false;
    }
    else {
      // field cannot be undefined (doc is not undefined on the first iteration, and we'll return if it becomes undefined
      field = field[path[j]];
      if (field === undefined) {
        // We do not populate parent of default fields by default
        return;
      }
    }
  }
  if (keepGoing) {
    if (value === undefined) {
      if (util.isPlainObject(virtualValue) && (virtualValue[[path[path.length-1]]] !== undefined)) {
        field[path[path.length-1]] = virtualValue[[path[path.length-1]]];
      }
    }
    else if ((typeof value === "function") && !Array.isArray(value._query)) {
      field[path[path.length-1]] = value.call(doc);
    }
    else {
      if (util.isPlainObject(value)) {
        field[path[path.length-1]] = util.deepCopy(value);
      }
      else if (value !== undefined) {
        field[path[path.length-1]] = value;
      }
    }
  }
  return doc;
}

module.exports.generateVirtual = generateVirtual;

function generateDefault(doc, defaultField, originalDoc) {
  var path = defaultField.path;
  var value = defaultField.value;
  var field = doc;

  var keepGoing = true;
  for(var j=0; j<path.length-1; j++) {
    if (path[j] === arrayPrefix) {
      if (!Array.isArray(field)) {
        // This is caught by validate, except if there is an `enforce_type: "none"`.
        return;
      }
      else {
        for(var k=0; k<field.length; k++) {
          generateDefault(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this);
        }
      }
      keepGoing = false;
    }
    else {
      field = field[path[j]];
      if (field === undefined) {
        // We do not populate parent of default fields by default
        return;
      }
    }
  }
  if (keepGoing && util.isPlainObject(field) && field[path[path.length-1]] === undefined) {
    if ((typeof value === "function") && !Array.isArray(value._query)) {
      field[path[path.length-1]] = value.call(doc);
    }
    else {
      if (util.isPlainObject(value) || Array.isArray(value)) {
        field[path[path.length-1]] = util.deepCopy(value);
      }
      else {
        field[path[path.length-1]] = value;
      }
    }
  }
  return doc;
}

module.exports.generateDefault = generateDefault;

function parse(schema, prefix, options, model) {
  var result;

  if ((prefix === '') && (type.isObject(schema) === false) && (util.isPlainObject(schema) === false)) {
    throw new Errors.ValidationError("The schema must be a plain object.")
  }

  // Validate a schema and add the field _enum if needed
  if (util.isPlainObject(schema)) {
    if (schema._type !== undefined) {
      options = util.mergeOptions(options, schema.options);
      var result;
      switch(schema._type) {
        case String:
          result = type.string().options(options).validator(schema.validator).enum(schema.enum);
          if (schema.default !== undefined) { result.default(schema.default); }
          if (typeof schema.min === "number") { result.min(schema.min); }
          if (typeof schema.max === "number") { result.max(schema.max); }
          if (typeof schema.length === "number") { result.length(schema.length); }
          if (schema.alphanum === true) { result.alphanum(); }
          if (schema.lowercase === true) { result.lowercase(); }
          if (schema.uppercase === true) { result.uppercase(); }
          if (typeof schema.regex === "string") { result.regex(regex, schema.flags); }
          return result;
        case Number:
          result = type.number().options(options).validator(schema.validator);
          if (schema.default !== undefined) { result.default(schema.default); }
          if (typeof schema.min === "number") { result.min(schema.min); }
          if (typeof schema.max === "number") { result.max(schema.max); }
          if (typeof schema.length === "number") { result.length(schema.length); }
          if (schema.integer === true) { result.integer(); }
          return result;
        case Boolean:
          result = type.boolean().options(options).validator(schema.validator);
          if (schema.default !== undefined) { result.default(schema.default); }
          return result;
        case Date:
          var result = type.date().options(options).validator(schema.validator);
          if (schema.default !== undefined) { result.default(schema.default); }
          if (schema.min instanceof Date) { result.min(schema.min); }
          if (schema.max instanceof Date) { result.max(schema.max); }
          return result;
        case Buffer:
          result = type.buffer().options(options).validator(schema.validator);
          if (schema.default !== undefined) { result.default(schema.default); }
          return result
        case Object:
          result = type.object().options(options).validator(schema.validator);
          if (schema.default !== undefined) { result.default(schema.default); }
          util.loopKeys(schema.schema, function(_schema, key) {
            result.setKey(key, parse(_schema[key], prefix+"["+key+"]", options));
          })
          if (prefix === '') {
            result._setModel(model)
          }
          return result;
        case Array:
          var result = type.array().options(options).validator(schema.validator);
          if (schema.default !== undefined) { result.default(schema.default); }
          if (schema.schema !== undefined) {
            result.schema(parse(schema.schema, prefix+"[0]", options));
          }
          if (typeof schema.min === "number") { result.min(schema.min); }
          if (typeof schema.max === "number") { result.max(schema.max); }
          if (typeof schema.length === "number") { result.length(schema.length); }
          return result;
        case 'Point':
          result = type.point().options(options).validator(schema.validator);
          if (schema.default !== undefined) { result.default(schema.default); }
          return result;
        case 'virtual':
          result = type.virtual();
          if (schema.default !== undefined) { result.default(schema.default); }
          return result
        default: // Unknown type
          throw new Errors.ValidationError("The field `_type` must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for "+prefix);
      }
    }
    else if (type.isString(schema)
        || type.isNumber(schema)
        || type.isBoolean(schema)
        || type.isDate(schema)
        || type.isBuffer(schema)
        || type.isPoint(schema)
        || type.isObject(schema)
        || type.isArray(schema)
        || type.isAny(schema)
        || type.isVirtual(schema)){ // Unknown type
      // Nothing to do here
      if (type.isObject(schema)) {
        parse(schema._schema, prefix, options);
      }
      else if (type.isArray(schema)) {
        if (schema._schema == undefined) {
          schema._schema = parse(type.any(), prefix, options);
        }
        else {
          schema._schema = parse(schema._schema, prefix, options);
        }
      }

      // We want to copy the model object here
      if (util.isPlainObject(schema._options) === false) {
        schema.options(options);
      }
      else if ((schema._options.enforce_extra === undefined)
          || (schema._options.enforce_missing === undefined)
          || (schema._options.enforce_type === undefined)) {
        var newOptions = {};
        newOptions.enforce_missing = (schema._options.enforce_missing != null) ? schema._options.enforce_missing : options.enforce_missing;
        newOptions.enforce_extra = (schema._options.enforce_extra != null) ? schema._options.enforce_extra : options.enforce_extra;
        newOptions.enforce_type = (schema._options.enforce_type != null) ? schema._options.enforce_type : options.enforce_type;
        schema.options(newOptions);
      }
      return schema;
    }
    else {
      result = type.object().options(options);
      util.loopKeys(schema, function(_schema, key) {
        result.setKey(key, parse(_schema[key], prefix+"["+key+"]", options));
      })
      if (prefix === '') {
        result._setModel(model)
      }
      return result;
    }
  }
  else if (Array.isArray(schema)) {
    result = type.array().options(options);
    if (schema.length > 1) {
      throw new Errors.ValidationError("An array in a schema can have at most one element. Found "+schema.length+" elements in "+prefix)
    }

    if (schema.length > 0) {
      result.schema(parse(schema[0], prefix+"[0]", options));
    }
    return result;

  }
  else if (schema === String) {
    return type.string().options(options);
  }
  else if (schema === Number) {
    return type.number().options(options);
  }
  else if (schema === Boolean) {
    return type.boolean().options(options);
  }
  else if (schema === Date) {
    return type.date().options(options);
  }
  else if (schema === Buffer) {
    return type.buffer().options(options);
  }
  else if (schema === Object) {
    return type.object().options(options);
  }
  else if (schema === Array) {
    return type.array().options(options);
  }
  else if (schema === 'Point') {
    return type.point().options(options);
  }
  else if (schema === 'virtual') {
    return type.virtual().options(options);
  }
  else {
    throw new Errors.ValidationError("The value must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for "+prefix);
  }
}
module.exports.parse = parse;

// The schema doesn't contain joined docs
function validate(doc, schema, prefix, options) {
  schema.validate(doc, prefix, options);
}
module.exports.validate = validate;

function getType(schema) {
  if (util.isPlainObject(schema) && (schema._type !== undefined)) {
    return schema._type;
  }
  return schema;
}


function validateEnum(doc, schema, prefix) {
  if (Array.isArray(schema.enum) && (schema._enum[doc] !== true)) {
    var validValues = Object.keys(schema._enum);
    var message = "The field "+prefix+" must be one of these values: "

    for(var i=0; i<validValues.length; i++) {
      if (i === 10) { break; }
      if ((i === validValues.length-1) || (i === 9)) {
        message = message+validValues[i]
      }
      else {
        message = message+validValues[i]+", "
      }
    }
    if (validValues.length > 10) {
      message = message+"..."
    }
    else {
      message = message+"."
    }

    throw new Errors.ValidationError(message);
  }
}
// Check that schema is a valid object first
function validateCustomizedValidator(doc, schema, prefix) {
  if (typeof schema.validator === 'function') {
    if (schema.validator(doc) === false) {
      throw new Errors.ValidationErrors.ValidationError("Validator for the field "+prefix+" returned `false`.");
    }
  }
}

function validateString(doc, schema, prefix, options) {
  if (validateNotNullUndefined(doc, prefix, "string", options)) return;

  if (typeof doc !== "string") { // doc is not null/undefined
    if (options.enforce_type === "strict") {
      strictType(prefix, "string");
    }
    else if (options.enforce_type === "loose") {
      looseType(prefix, "string");
    }
  }

  if (util.isPlainObject(schema)) {
    validateCustomizedValidator(doc, schema, prefix);
    validateEnum(doc, schema, prefix);
  }
}

function validateNumber(doc, schema, prefix, options) {
  if (validateNotNullUndefined(doc, prefix, "number", options)) return;

  if (typeof doc !== "number") { // doc is not null/undefined
    if (options.enforce_type === "strict") {
      strictType(prefix, "number");
    }
    else if (options.enforce_type === "loose") {
      looseType(prefix, "number");
    }
  }

  if (util.isPlainObject(schema)) {
    validateCustomizedValidator(doc, schema, prefix);
    validateEnum(doc, schema, prefix);
  }

}

function validateBoolean(doc, schema, prefix, options) {
  if (validateNotNullUndefined(doc, prefix, "boolean", options)) return;

  if (typeof doc !== "boolean") { // doc is not null/undefined
    if (options.enforce_type === "strict") {
      strictType(prefix, "boolean");
    }
    else if (options.enforce_type === "loose") {
      looseType(prefix, "boolean");
    }
  }

  if (util.isPlainObject(schema)) {
    validateCustomizedValidator(doc, schema, prefix);
    validateEnum(doc, schema, prefix);
  }
}

function validateDate(doc, schema, prefix, options) {
  if (validateNotNullUndefined(doc, prefix, "date", options)) return;

  if (options.enforce_type !== "none") {
    if (util.isPlainObject(doc) && (doc["$reql_type$"] === "TIME")) {
      if (doc.epoch_time === undefined) {
        pseudoTypeError("date", "epoch_time", prefix);
      }
      else if (doc.timezone === undefined) {
        pseudoTypeError("date", "timezone", prefix);
      }
    }
    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {
      // TOIMPROVE -- we currently just check if it's a term from the driver
      // We suppose for now that this is enough and we don't throw an error
    }
    else if (typeof doc === 'string') {
      var date = new Date(doc);
      if (date.getTime() !== date.getTime()) {
        if (options.enforce_type === "strict") {
          strictType(prefix, "date or a valid string");
        }
        else if (options.enforce_type !== "none") {
          looseType(prefix, "date or a valid string");
        }
      }
    }
    else if ((doc instanceof Date) === false)  {
      if (options.enforce_type === "strict") {
        strictType(prefix, "date");
      }
      else if (options.enforce_type !== "none") {
        looseType(prefix, "date");
      }
    }
  }

  if (util.isPlainObject(schema)) {
    validateCustomizedValidator(doc, schema, prefix);
  }
}

function validatePoint(doc, schema, prefix, options) {
  if (validateNotNullUndefined(doc, prefix, "point", options)) return;

  if (options.enforce_type !== "none") {
    if (util.isPlainObject(doc) && (doc["$reql_type$"] === "GEOMETRY")) {
      if (doc.type === undefined) {
        pseudoTypeError("Point", "type", prefix);
      }
      else if (doc.type !== "Point") {
        throw new Errors.ValidationError("The field `type` for "+prefix+" must be `'Point'`.")
      }
      else if (doc.coordinates === undefined) {
        pseudoTypeError("date", "coordinates", prefix);
      }
      else if ((!Array.isArray(doc.coordinates)) || (doc.coordinates.length !== 2)) {
        throw new Errors.ValidationError("The field `coordinates` for "+prefix+" must be an Array of two numbers.")
      }
    }
    else if (util.isPlainObject(doc) && (doc.type === "Point") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson
      // Geojson format
    }
    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {
      // TOIMPROvE -- we currently just check if it's a term from the driver
      // We suppose for now that this is enough and we don't throw an error
    }
    else if (util.isPlainObject(doc)) {
      var keys = Object.keys(doc).sort();
      if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof doc.latitude !== "number") || (typeof doc.longitude !== "number")) {
        throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
      }
      else if ((typeof doc.latitude !== 'number') || (typeof doc.latitude !== 'number')) {
        throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
      }
    }
    else if (Array.isArray(doc)) {
      if ((doc.length !== 2) || (typeof doc[0] !== "number") || (typeof doc[1] !== "number")) {
        throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
      }
    }
  }
  if (util.isPlainObject(schema)) {
    validateCustomizedValidator(doc, schema, prefix);
  }
}

function validateBuffer(doc, schema, prefix, options) {
  if (validateNotNullUndefined(doc, prefix, "buffer", options)) return;

  if (util.isPlainObject(doc) && (doc["$reql_type$"] === "BINARY")) {
    if (doc.data === undefined) {
      pseudoTypeError("binary", "data", prefix);
    }
  }
  else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {
    // TOIMPROvE -- we currently just check if it's a term from the driver
    // We suppose for now that this is enough and we don't throw an error
  }
  else if ((doc instanceof Buffer) === false)  {
    if (options.enforce_type === "strict") {
      strictType(prefix, "buffer");
    }
    else if (options.enforce_type !== "none") {
      looseType(prefix, "buffer");
    }
  }

  if (util.isPlainObject(schema)) {
    validateCustomizedValidator(doc, schema, prefix);
  }
}


/***/ }),

/***/ "../node_modules/thinky/lib/thinky.js":
/*!********************************************!*\
  !*** ../node_modules/thinky/lib/thinky.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rethinkdbdash = __webpack_require__(/*! rethinkdbdash */ "../node_modules/rethinkdbdash/lib/index.js");
var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var Model = __webpack_require__(/*! ../node_modules/thinky/lib/model.js */ "../node_modules/thinky/lib/model.js");
var util = __webpack_require__(/*! ../node_modules/thinky/lib/util.js */ "../node_modules/thinky/lib/util.js");
var type = __webpack_require__(/*! ../node_modules/thinky/lib/type/index.js */ "../node_modules/thinky/lib/type/index.js");
var Query = __webpack_require__(/*! ../node_modules/thinky/lib/query.js */ "../node_modules/thinky/lib/query.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/errors.js */ "../node_modules/thinky/lib/errors.js");

/**
 * Main method, create the default database.
 *
 * @param {Object} options the options for the driver and the future models created.
 *  - `max` {number} The maximum number of connections in the pool, default 1000
 *  - `buffer` {number} The minimum number of connections available in the pool, default 50
 *  - `timeoutError` {number} The wait time before reconnecting in case of an error (in ms), default 1000
 *  - `timeoutGb` {number} How long the pool keep a connection that hasn't been used (in ms), default 60*60*1000
 *  - `enforce_missing` {boolean}, default `false`
 *  - `enforce_extra` {"strict"|"remove"|"none"}, default `"none"`
 *  - `enforce_type` {"strict"|"loose"|"none"}, default `"loose"`
 *  - `timeFormat` {"raw"|"native"}
 *  - `createDatabase` {boolean} Whether thinky should create the database or not.
 */
function Thinky(config) {
  var self = this;

  config = config || {};
  config.db = config.db || 'test'; // We need the default db to create it.
  self._config = config;

  self._options = {};
  // Option passed to each model we are going to create.
  self._options.enforce_missing =
    (config.enforce_missing != null) ? config.enforce_missing : false;
  self._options.enforce_extra =
    (config.enforce_extra != null) ? config.enforce_extra : "none";
  self._options.enforce_type =
    (config.enforce_type != null) ? config.enforce_type : 'loose';

  // Format of time objects returned by the database, by default we convert
  // them to JavaScript Dates.
  self._options.timeFormat =
    (config.timeFormat != null) ? config.timeFormat : 'native';
  // Option passed to each model we are going to create.
  self._options.validate =
    (config.validate != null) ? config.validate : 'onsave';

  if (config.r === undefined) {
    self.r = rethinkdbdash(config);
  }
  else {
    self.r = config.r;
  }
  self.type = type;
  self.Query = Query;
  self.models = {};

  // Export errors
  self.Errors = Errors;

  // Initialize the database.
  self.dbReady().then().error(function(error) {
    throw error;
  });
}


/**
 * Initialize our database.
 * @return {Promise=} Returns a promise which will resolve when the database is ready.
 */
Thinky.prototype.dbReady = function() {
  var self = this;
  if (this._dbReadyPromise) return this._dbReadyPromise;
  var r = self.r;
  if (self._config.createDatabase === false) {
    return Promise.resolve();
  }
  this._dbReadyPromise = r.dbCreate(self._config.db)
  .run()
  .error(function(error) {
    // The `do` is not atomic, we a concurrent query could create the database
    // between the time `dbList` is ran and `dbCreate` is.
    if (error.message.match(/^Database `.*` already exists in/)) {
      return;
    }

    // In case something went wrong here, we do not recover and throw.
    throw error;
  });

  return self._dbReadyPromise;
};

/**
 * Return the current option used.
 * @return {object} The global options of the library
 */
Thinky.prototype.getOptions = function() {
  return this._options;
}


/**
 * Create a model
 *
 * @param {string} name The name of the table used behind this model.
 * @param {object|Type} schema The schema of this model.
 * @param {object=} options Options for this model. The fields can be:
 *  - `init` {boolean} Whether the table should be created or not. The value
 *  `false` is used to speed up testing, and should probably be `true` in
 *  other use cases.
 *  - `timeFormat` {"raw"|"native"} Format of ReQL dates.
 *  - `enforce_missing` {boolean}, default `false`.
 *  - `enforce_extra` {"strict"|"remove"|"none"}, default `"none"`.
 *  - `enforce_type` {"strict"|"loose"|"none"}, default `"loose"`.
 *  - `validate` {"oncreate"|"onsave"}, default "onsave".
 */
Thinky.prototype.createModel = function(name, schema, options) {
  var self = this;

  // Make a deep copy of the options as the model may overwrite them.
  var fullOptions = util.deepCopy(this._options);
  options = options || {};
  util.loopKeys(options, function(options, key) {
    fullOptions[key] = options[key];
  });

  // Two models cannot share the same name.
  if (self.models[name] !== undefined) {
    throw new Error("Cannot redefine a Model");
  }

  // Create the constructor returned. This will also validate the schema.
  var model = Model.new(name, schema, fullOptions, self);

  // Keep a reference of this model.
  self.models[name] = model;
  return model;
}


/**
 * Method to clean all the references to the models. This is used to speed up
 * testing and should not be used in other use cases.
 */
Thinky.prototype._clean = function() {
  this.models = {};
}


// Export the module.
module.exports = function(config) {
  return new Thinky(config);
}

// Expose thinky types directly from module
module.exports.type = type;


/***/ }),

/***/ "../node_modules/thinky/lib/type/any.js":
/*!**********************************************!*\
  !*** ../node_modules/thinky/lib/type/any.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var schema =      __webpack_require__(/*! ../node_modules/thinky/lib/type/../schema.js */ "../node_modules/thinky/lib/schema.js");

function TypeAny() {
  this._default = undefined;
  this._validator = undefined;
  this._options = {};
}

TypeAny.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
}
TypeAny.prototype.validator = function(fn) {
  this._validator = fn;
}
TypeAny.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
}

// Dummy methods, just to allow users to easily switch from a valid type to any
TypeAny.prototype.options = function(options) {
  return this;
}
TypeAny.prototype.optional = function() {
  return this;
}
TypeAny.prototype.required = function() {
  return this;
}
TypeAny.prototype.allowNull = function() {
  return this;
}
TypeAny.prototype.min = function() {
  return this;
}
TypeAny.prototype.max = function() {
  return this;
}
TypeAny.prototype.length = function() {
  return this;
}
TypeAny.prototype.schema = function() {
  return this;
}
TypeAny.prototype.validate = function() {
  return this;
}

module.exports = TypeAny;


/***/ }),

/***/ "../node_modules/thinky/lib/type/array.js":
/*!************************************************!*\
  !*** ../node_modules/thinky/lib/type/array.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var schema =      __webpack_require__(/*! ../node_modules/thinky/lib/type/../schema.js */ "../node_modules/thinky/lib/schema.js");
var arrayPrefix = schema.arrayPrefix;
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

function TypeArray() {
  this._min = -1;
  this._max = -1;
  this._length = -1;
  this._schema = undefined;
  this._validator = undefined;
  this._options = {};
}


TypeArray.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


TypeArray.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


TypeArray.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


TypeArray.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}


TypeArray.prototype.min = function(min) {
  if (min < 0) {
    throw new Errors.ValidationError("The value for `min` must be a positive integer");
  }
  this._min = min;
  return this;
}


TypeArray.prototype.max = function(max) {
  if (max < 0) {
    throw new Errors.ValidationError("The value for `max` must be a positive integer");
  }
  this._max = max;
  return this;
}


TypeArray.prototype.length = function(length) {
  if (length < 0) {
    throw new Errors.ValidationError("The value for `length` must be a positive integer");
  }
  this._length = length;
  return this;
}


TypeArray.prototype.schema = function(schema) {
  this._schema = schema;
  return this;
}


TypeArray.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


TypeArray.prototype.validator = function(fn) {
  this._validator = fn;
  return this;
}


TypeArray.prototype.validate = function(array, prefix, options) {
  var self = this;
  var localOptions = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(array, prefix, "array", localOptions)) return;

  if ((typeof self._validator === "function") && (self._validator(array) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }

  if ((typeof array === 'function') && (array._query !== undefined)) {
    // We do not check ReQL terms
  }
  else if (Array.isArray(array) === false) {
    if (localOptions.enforce_type === "strict") {
      util.strictType(prefix, "array");
    }
    else if ((localOptions.enforce_type === "loose") && (array !== null)) {
      util.looseType(prefix, "array");
    }
  }
  else {
    if ((this._min !== -1) && (this._min > array.length)){
      throw new Errors.ValidationError("Value for "+prefix+" must have at least "+this._min+" elements.")
    }
    if ((this._max !== -1) && (this._max < array.length)){
      throw new Errors.ValidationError("Value for "+prefix+" must have at most "+this._max+" elements.")
    }
    if ((this._length !== -1) && (this._length !== array.length)){
      throw new Errors.ValidationError("Value for "+prefix+" must be an array with "+this._length+" elements.")
    }

    for(var i=0; i<array.length; i++) {
      if (array[i] === undefined) {
        throw new Errors.ValidationError("The element in the array "+prefix+" (position "+i+") cannot be `undefined`.");
      }
      if (this._schema !== undefined) {
        this._schema.validate(array[i], prefix+"["+i+"]", options);
      }
    }
  }
}


TypeArray.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
  if (this._schema !== undefined) {
    this._schema._getDefaultFields(prefix.concat(arrayPrefix), defaultFields, virtualFields);
  }
}


module.exports = TypeArray;


/***/ }),

/***/ "../node_modules/thinky/lib/type/boolean.js":
/*!**************************************************!*\
  !*** ../node_modules/thinky/lib/type/boolean.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

function TypeBoolean() {
  this._default = undefined;
  this._validator = undefined;
  this._options = {};
}


TypeBoolean.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


TypeBoolean.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


TypeBoolean.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


TypeBoolean.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}



TypeBoolean.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


TypeBoolean.prototype.validator = function(fn) {
  if (typeof fn === "function") {
    this._validator = fn;
  }
  return this;
}


TypeBoolean.prototype.validate = function(bool, prefix, options) {
  options = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(bool, prefix, "boolean", options)) return;

  if ((typeof this._validator === "function") && (this._validator(bool) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }

  if (typeof bool !== "boolean") {
    if (options.enforce_type === "strict") {
      util.strictType(prefix, "boolean");
    }
    else if ((options.enforce_type === "loose") && (bool !== null)) {
      util.looseType(prefix, "boolean");
    }
  }
}


TypeBoolean.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
}


module.exports = TypeBoolean;


/***/ }),

/***/ "../node_modules/thinky/lib/type/buffer.js":
/*!*************************************************!*\
  !*** ../node_modules/thinky/lib/type/buffer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

function TypeBuffer() {
  this._default = undefined;
  this._options = {};
  this._validator = undefined;
}


TypeBuffer.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


TypeBuffer.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


TypeBuffer.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


TypeBuffer.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}


TypeBuffer.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


TypeBuffer.prototype.validator = function(fn) {
  if (typeof fn === "function") {
    this._validator = fn;
  }
  return this;
}


TypeBuffer.prototype.validate = function(buffer, prefix, options) {
  options = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(buffer, prefix, "buffer", options)) return;

  if ((typeof this._validator === "function") && (this._validator(buffer) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }

  if (util.isPlainObject(buffer) && (buffer["$reql_type$"] === "BINARY")) {
    if (buffer.data === undefined) {
      util.pseudoTypeError("binary", "data", prefix);
    }
  }
  else if ((typeof buffer === 'function') && (buffer._query !== undefined)) {
    // TOIMPROvE -- we currently just check if it's a term from the driver
    // We suppose for now that this is enough and we don't throw an error
  }
  else if ((buffer instanceof Buffer) === false)  { // We don't have a buffer
    if (options.enforce_type === "strict") {
      util.strictType(prefix, "buffer");
    }
    else if ((options.enforce_type === "loose") && (buffer !== null)) {
      util.looseType(prefix, "buffer");
    }
  }
}


TypeBuffer.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
}


module.exports = TypeBuffer;


/***/ }),

/***/ "../node_modules/thinky/lib/type/date.js":
/*!***********************************************!*\
  !*** ../node_modules/thinky/lib/type/date.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

function TypeDate() {
  this._min = undefined;
  this._max = undefined;
  this._validator = undefined;
  this._options = {};
}


TypeDate.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


TypeDate.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


TypeDate.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


TypeDate.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}


TypeDate.prototype.min = function(min) {
  this._min = min;
  return this;
}


TypeDate.prototype.max = function(max) {
  this._max = max;
  return this;
}


TypeDate.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


TypeDate.prototype.validator = function(fn) {
  if (typeof fn === "function") {
    this._validator = fn;
  }
  return this;
}


TypeDate.prototype.validate = function(date, prefix, options) {
  options = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(date, prefix, "date", options)) return;

  if ((typeof this._validator === "function") && (this._validator(date) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }

  var jsDate;
  if (util.isPlainObject(date) && (date["$reql_type$"] === "TIME")) {
    if (date.epoch_time === undefined) {
      util.pseudoTypeError("date", "epoch_time", prefix);
    }
    else if (date.timezone === undefined) {
      util.pseudoTypeError("date", "timezone", prefix);
    }

    jsDate = new Date(0);
    jsDate.setUTCSeconds(date.epoch_time)
  }
  else if ((typeof date === 'function') && (date._query !== undefined)) {
    // TOIMPROVE -- we currently just check if it's a term from the driver
    // We suppose for now that this is enough and we don't throw an error
  }
  else if (typeof date === 'string' || typeof date === 'number') {
    var numericDate = parseInt(date, 10);
    if(!isNaN(numericDate)){
      date = numericDate;
    }
    jsDate = new Date(date);
    if (jsDate.getTime() !== jsDate.getTime()) {
      if (options.enforce_type === "strict") {
        util.strictType(prefix, "date or a valid string");
      }
      else if (options.enforce_type !== "none") {
        util.looseType(prefix, "date or a valid string");
      }
    }
  }
  else if ((date instanceof Date) === false) { // We have a non valid date
    if (options.enforce_type === "strict") {
      util.strictType(prefix, "date");
    }
    else if ((options.enforce_type === "loose") && (date !== null)) {
      util.looseType(prefix, "date");
    }
  }
  else {
    jsDate = date;
  }

  // We check for min/max only if we could create a javascript date from the value
  if (jsDate !== undefined) {
    if ((this._min instanceof Date) && (this._min > jsDate)){
      throw new Errors.ValidationError("Value for "+prefix+" must be after "+this._min+".")
    }
    if ((this._max instanceof Date) && (this._max < jsDate)){
      throw new Errors.ValidationError("Value for "+prefix+" must be before "+this._max+".")
    }
  }
}


TypeDate.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
}


module.exports = TypeDate;


/***/ }),

/***/ "../node_modules/thinky/lib/type/index.js":
/*!************************************************!*\
  !*** ../node_modules/thinky/lib/type/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var schema =      __webpack_require__(/*! ../node_modules/thinky/lib/type/../schema.js */ "../node_modules/thinky/lib/schema.js");
var util =        __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var TypeAny =     __webpack_require__(/*! ../node_modules/thinky/lib/type/any.js */ "../node_modules/thinky/lib/type/any.js");
var TypeArray =   __webpack_require__(/*! ../node_modules/thinky/lib/type/array.js */ "../node_modules/thinky/lib/type/array.js");
var TypeBoolean = __webpack_require__(/*! ../node_modules/thinky/lib/type/boolean.js */ "../node_modules/thinky/lib/type/boolean.js");
var TypeBuffer =  __webpack_require__(/*! ../node_modules/thinky/lib/type/buffer.js */ "../node_modules/thinky/lib/type/buffer.js");
var TypeDate =    __webpack_require__(/*! ../node_modules/thinky/lib/type/date.js */ "../node_modules/thinky/lib/type/date.js");
var TypeNumber =  __webpack_require__(/*! ../node_modules/thinky/lib/type/number.js */ "../node_modules/thinky/lib/type/number.js");
var TypeObject =  __webpack_require__(/*! ../node_modules/thinky/lib/type/object.js */ "../node_modules/thinky/lib/type/object.js");
var TypePoint =   __webpack_require__(/*! ../node_modules/thinky/lib/type/point.js */ "../node_modules/thinky/lib/type/point.js");
var TypeString =  __webpack_require__(/*! ../node_modules/thinky/lib/type/string.js */ "../node_modules/thinky/lib/type/string.js");
var TypeVirtual = __webpack_require__(/*! ../node_modules/thinky/lib/type/virtual.js */ "../node_modules/thinky/lib/type/virtual.js");


/**
 * Create a new Type that let users create sub-types.
 * @return {Type}
 */
function Type() { }


/**
 * Create a new TypeAny object
 * @return {TypeAny}
 */

Type.prototype.any = function() {
  return new TypeAny();
}


/**
 * Create a new TypeString object.
 * @return {TypeString}
 */
Type.prototype.string = function() {
  return new TypeString();
}


/**
 * Create a new TypeNumber object.
 * @return {TypeNumber}
 */
Type.prototype.number = function() {
  return new TypeNumber();
}


/**
 * Create a new TypeBoolean object.
 * @return {TypeBoolean}
 */
Type.prototype.boolean = function() {
  return new TypeBoolean();
}


/**
 * Create a new TypeDate object.
 * @return {TypeDate}
 */
Type.prototype.date = function() {
  return new TypeDate();
}


/**
 * Create a new TypeBuffer object.
 * @return {TypeBuffer}
 */
Type.prototype.buffer = function() {
  return new TypeBuffer();
}


/**
 * Create a new TypePoint object.
 * @return {TypePoint}
 */
Type.prototype.point = function() {
  return new TypePoint();
}


/**
 * Create a new TypeObject object.
 * @return {TypeObject}
 */
Type.prototype.object = function() {
  return new TypeObject();
}


/**
 * Create a new TypeArray object.
 * @return {TypeArray}
 */
Type.prototype.array = function() {
  return new TypeArray();
}


/**
 * Create a new TypeVirtual object.
 * @return {TypeVirtual}
 */
Type.prototype.virtual = function() {
  return new TypeVirtual();
}


/**
 * Create a new TypeString object to use as an id.
 * @return {TypeString}
 */
Type.prototype.id = function() {
  return new TypeString().optional();
}


/**
 * Check if the first argument is a TypeString object or not
 * @param {Object} obj The object to check against TypeString.
 * @return {boolean}
 */
Type.prototype.isString = function(obj) {
  return obj instanceof TypeString;
}


/**
 * Check if the first argument is a TypeNumber object or not
 * @param {Object} obj The object to check against TypeNumber.
 * @return {boolean}
 */
Type.prototype.isNumber = function(obj) {
  return obj instanceof TypeNumber;
}


/**
 * Check if the first argument is a TypeBoolean object or not
 * @param {Object} obj The object to check against TypeBoolean.
 * @return {boolean}
 */
Type.prototype.isBoolean = function(obj) {
  return obj instanceof TypeBoolean;
}


/**
 * Check if the first argument is a TypeDate object or not
 * @param {Object} obj The object to check against TypeDate.
 * @return {boolean}
 */
Type.prototype.isDate = function(obj) {
  return obj instanceof TypeDate;
}


/**
 * Check if the first argument is a TypeBuffer object or not
 * @param {Object} obj The object to check against TypeBuffer.
 * @return {boolean}
 */
Type.prototype.isBuffer = function(obj) {
  return obj instanceof TypeBuffer;
}


/**
 * Check if the first argument is a TypePoint object or not
 * @param {Object} obj The object to check against TypePoint.
 * @return {boolean}
 */
Type.prototype.isPoint = function(obj) {
  return obj instanceof TypePoint;
}


/**
 * Check if the first argument is a TypeObject object or not
 * @param {Object} obj The object to check against TypeObject.
 * @return {boolean}
 */
Type.prototype.isObject = function(obj) {
  return obj instanceof TypeObject;
}


/**
 * Check if the first argument is a TypeArray object or not
 * @param {Object} obj The object to check against TypeArray.
 * @return {boolean}
 */
Type.prototype.isArray = function(obj) {
  return obj instanceof TypeArray;
}


/**
 * Check if the first argument is a TypeVirtual object or not
 * @param {Object} obj The object to check against TypeVirtual.
 * @return {boolean}
 */
Type.prototype.isVirtual = function(obj) {
  return obj instanceof TypeVirtual;
}


/**
 * Check if the first argument is a TypeAny object or not
 * @param {Object} obj The object to check against TypeAny.
 * @return {boolean}
 */
Type.prototype.isAny = function(obj) {
  return obj instanceof TypeAny;
}


module.exports = new Type();


/***/ }),

/***/ "../node_modules/thinky/lib/type/number.js":
/*!*************************************************!*\
  !*** ../node_modules/thinky/lib/type/number.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

function TypeNumber() {
  this._min = undefined;
  this._max = undefined;
  this._integer = false;
  this._default = undefined;
  this._validator = undefined;
  this._options = {};
}


TypeNumber.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


TypeNumber.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


TypeNumber.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


TypeNumber.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}



TypeNumber.prototype.min = function(min) {
  if ((typeof(min) !== 'number') || (isFinite(min) == false)) {
    throw new Errors.ValidationError("The value for `min` must be a finite number");
  }
  this._min = min;
  return this;
}


TypeNumber.prototype.max = function(max) {
  if ((typeof(max) !== 'number') || (isFinite(max) == false)) {
    throw new Errors.ValidationError("The value for `max` must be a finite number");
  }
  this._max = max;
  return this;
}


TypeNumber.prototype.integer = function() {
  this._integer = true;
  return this;
}


TypeNumber.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


TypeNumber.prototype.validator = function(fn) {
  if (typeof fn === "function") {
    this._validator = fn;
  }
  return this;
}


TypeNumber.prototype.validate = function(number, prefix, options) {
  options = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(number, prefix, "number", options)) return;

  if ((typeof this._validator === "function") && (this._validator(number) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }

  if(typeof number === 'string'){
    var numericString = parseFloat(number);
    if(!isNaN(numericString)){
      number = numericString;
    }
  }

  if ((typeof number === 'function') && (number._query !== undefined)) {
    // We do not check ReQL terms
  }
  else if ((typeof number !== "number") || (isFinite(number) === false)) {
    if (options.enforce_type === "strict") {
      util.strictType(prefix, "finite number");
    }
    else if ((options.enforce_type === "loose") && (number !== null)) {
      util.looseType(prefix, "finite number");
    }
  }
  else {
    if ((this._min !== undefined) && (this._min > number)){
      throw new Errors.ValidationError("Value for "+prefix+" must be greater than or equal to "+this._min+".")
    }
    if ((this._max !== undefined) && (this._max < number)){
      throw new Errors.ValidationError("Value for "+prefix+" must be less than or equal to "+this._max+".")
    }
    if ((this._integer === true) && (number % 1 !== 0)){
      throw new Errors.ValidationError("Value for "+prefix+" must be an integer.")
    }
  }
}


TypeNumber.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
}


module.exports = TypeNumber;


/***/ }),

/***/ "../node_modules/thinky/lib/type/object.js":
/*!*************************************************!*\
  !*** ../node_modules/thinky/lib/type/object.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

function TypeObject() {
  this._default = undefined;
  this._validator = undefined;
  this._options = {};
  this._schema = {};
}


TypeObject.prototype._setModel = function(model) {
  this._model = model;
  return this;
}


TypeObject.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


TypeObject.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


TypeObject.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


TypeObject.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}


TypeObject.prototype.allowExtra = function(allowed) {
  if (allowed === true) {
    this._options.enforce_extra = 'none';
  }
  else if (allowed === false) {
    this._options.enforce_extra = 'strict';
  }
  return this;
}


TypeObject.prototype.removeExtra = function() {
  this._options.enforce_extra = 'remove';
  return this;
}


TypeObject.prototype.schema = function(schema) {
  // Users shouldn't use the deprecated syntax with the chainable one
  // We do not parse the schema as we don't have the current prefix, options etc.
  this._schema = schema;
  return this;
}


TypeObject.prototype.setKey = function(key, schema) {
  this._schema[key] = schema;
  return this;
}


TypeObject.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


TypeObject.prototype.validator = function(fn) {
  if (typeof fn === "function") {
    this._validator = fn;
  }
  return this;
}


TypeObject.prototype.validate = function(object, prefix, options) {
  var self = this;
  var localOptions = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(object, prefix, "object", localOptions)) return;

  if ((typeof self._validator === "function") && (self._validator(object) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }

  if ((typeof object === 'function') && (object._query !== undefined)) {
    // We do not check ReQL terms
  }
  else if (util.isPlainObject(object) === false) {
    if (localOptions.enforce_type === "strict") {
      util.strictType(prefix, "object");
    }
    else if ((localOptions.enforce_type === "loose") && (object !== null)) {
      util.looseType(prefix, "object");
    }
  }
  else {
    util.loopKeys(self._schema, function(schema, key) {
      schema[key].validate(object[key], prefix+"["+key+"]", options);
    });

    // We clean extra fields in validate, for a use case, see:
    // https://github.com/neumino/thinky/pull/123#issuecomment-56254682
    if (localOptions.enforce_extra === "remove") {
      util.loopKeys(object, function(object, key) {
        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)
            && (self._schema[key] === undefined)) {
          delete object[key];
        }
      });
    }
    else if (localOptions.enforce_extra === "strict") {
      util.loopKeys(object, function(object, key) {
        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)
            && (self._schema[key] === undefined)) {
          util.extraField(prefix, key);
        }
      });
    }
  }
}


TypeObject.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
  if (this._schema !== undefined) {
    util.loopKeys(this._schema, function(_schema, key) {
      if (typeof _schema[key]._getDefaultFields !== 'function') {
        console.log(_schema);
        console.log(key);
        console.log(_schema[key]);
      }
      _schema[key]._getDefaultFields(prefix.concat(key), defaultFields, virtualFields);
    })
  }
}


module.exports = TypeObject;


/***/ }),

/***/ "../node_modules/thinky/lib/type/point.js":
/*!************************************************!*\
  !*** ../node_modules/thinky/lib/type/point.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

function TypePoint() {
  this._default = undefined;
  this._validator = undefined;
  this._options = {};
}


TypePoint.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


TypePoint.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


TypePoint.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


TypePoint.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}


TypePoint.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


TypePoint.prototype.validator = function(fn) {
  if (typeof fn === "function") {
   this._validator = fn;
  }
  return this;
}


TypePoint.prototype.validate = function(point, prefix, options) {
  options = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(point, prefix, "point", options)) return;

  if ((typeof this._validator === "function") && (this._validator(point) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }

  if (util.isPlainObject(point) && (point["$reql_type$"] === "GEOMETRY")) {
    if (point.type === undefined) {
      util.pseudoTypeError("Point", "type", prefix);
    }
    else if (point.type !== "Point") {
      throw new Errors.ValidationError("The field `type` for "+prefix+" must be `'Point'`.")
    }
    else if (point.coordinates === undefined) {
      util.pseudoTypeError("date", "coordinates", prefix);
    }
    else if ((!Array.isArray(point.coordinates)) || (point.coordinates.length !== 2)) {
      throw new Errors.ValidationError("The field `coordinates` for "+prefix+" must be an Array of two numbers.")
    }
  }
  else if (util.isPlainObject(point) && (point.type === "Point") && (Array.isArray(point.coordinates)) && (point.coordinates.length === 2)) { // Geojson
    // Geojson format
  }
  else if ((typeof point === 'function') && (point._query !== undefined)) {
    // TOIMPROvE -- we currently just check if it's a term from the driver
    // We suppose for now that this is enough and we don't throw an error
  }
  else if (util.isPlainObject(point)) {
    var keys = Object.keys(point).sort();
    if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof point.latitude !== "number") || (typeof point.longitude !== "number")) {
      throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
    }
    else if ((typeof point.latitude !== 'number') || (typeof point.latitude !== 'number')) {
      throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
    }
  }
  else if (Array.isArray(point)) {
    if ((point.length !== 2) || (typeof point[0] !== "number") || (typeof point[1] !== "number")) {
      throw new Errors.ValidationError("The value for "+prefix+" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].")
    }
  }
  else { // We don't have a point
    if (options.enforce_type === "strict") {
      util.strictType(prefix, "Point");
    }
    else if ((options.enforce_type === "loose") && (point !== null)) {
      util.looseType(prefix, "Point");
    }
  }
}


TypePoint.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
}

module.exports = TypePoint;


/***/ }),

/***/ "../node_modules/thinky/lib/type/string.js":
/*!*************************************************!*\
  !*** ../node_modules/thinky/lib/type/string.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util =       __webpack_require__(/*! ../node_modules/thinky/lib/type/../util.js */ "../node_modules/thinky/lib/util.js");
var validator =  __webpack_require__(/*! validator */ "../node_modules/validator/validator.js");
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/type/../errors.js */ "../node_modules/thinky/lib/errors.js");

/**
 * Create a new TypeString object
 */
function TypeString() {
  /**
   * Minimum length of the string, negative if no minimum length is required.
   * @type {number}
   */
  this._min = -1;
  /**
   * Maximum length of the string, negative if no maximum length is required.
   * @type {number}
   */
  this._max = -1;
  /**
   * Length of the string, negative if no length is required.
   * @type {number}
   */
  this._length = -1;
  /**
   * Whether the string must be alphanumeric or not. We used the npm validator
   * package, and as 2014/12/14, it check against the regex [a-zA-Z0-9]
   * @type {boolean}
   */
  this._alphanum = false;
  /**
   * Whether this string must be uppercase or not.
   * @type {boolean}
   */
  this._uppercase = false;
  /**
   * Whether this string must be lowercase or not.
   * @type {boolean}
   */
  this._lowercase = false;
  /*
   * The regex against which the string must conform. Undefined if the string
   * does not have to conform to a RegExp.
   * @type {RegExp=}
   */
  this._regex = undefined;
  /**
   * The validator called with the string must return {true} if the string is valid,
   * {false} if the string is not.
   * @type {function(string)=}
   */
  this._enum = undefined;
  /**
   * The default value for this field or a function to generate the default value.
   * @type {function|string}
   */
  this._default = undefined;
  /**
   * Whether this string must be a uuid or not.
   * @type {number}
   */
  this._uuid = undefined;
  /**
   * Options for this type "enforce_missing", "enforce_type", "enforce_extra"
   * @type {Object=}
   */
  this._validator = undefined;
  /**
   * An object whose keys are the acceptable values for the string. Undefined if this
   * is not a requirement.
   * @type {Object=}
   */
  this._options = {};
}


/**
 * Set the options for this field.
 * @param {!object} options The options for this field. The valid fields are:
 *  - `enforce_missing` {boolean}, default `false`
 *  - `enforce_extra` {"strict"|"remove"|"none"}, default `"none"`
 *  - `enforce_type` {"strict"|"loose"|"none"}, default `"loose"`
 * @return {TypeString}
 */
TypeString.prototype.options = function(options) {
  if (util.isPlainObject(options)) {
    if (options.enforce_missing != null) {
      this._options.enforce_missing =  options.enforce_missing
    }
    if (options.enforce_type != null) {
      this._options.enforce_type = options.enforce_type;
    }
    if (options.enforce_extra != null) {
      this._options.enforce_extra = options.enforce_extra
    }
  }
  return this;
}


/**
 * Set the property as optional (enforce_missing = false).
 * Leaves other existing options unchanged.
 * @return {TypeString}
 */
TypeString.prototype.optional = function() {
  this._options.enforce_missing = false;
  return this;
}


/**
 * Set the property as required (enforce_missing = true).
 * Leaves other existing options unchanged.
 * @return {TypeString}
 */
TypeString.prototype.required = function() {
  this._options.enforce_missing = true;
  return this;
}


/**
 * Set the property as not strict (null allowed, enforce_missing = true).
 * Leaves other existing options unchanged.
 * @return {TypeString}
 */
TypeString.prototype.allowNull = function(value) {
  if (this._options.enforce_type === 'strict') {
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    // else a no-op, strict -> strict
  }
  else if (this._options.enforce_type !== 'none') {
    // The value is loose or undefined
    if (value === true) {
      this._options.enforce_type = 'loose'
    }
    else {
      // The default value is loose, so if we call allowNull(false), it becomes strict
      this._options.enforce_type = 'strict'
    }
  }
  // else no op, type.any() is the same as type.any().allowNull(<bool>)
  return this;
}


/**
 * Set the minimum length allowed for a string.
 * @param {number} min Minimum length for the string
 * @return {TypeString}
 */
TypeString.prototype.min = function(min) {
  if (min < 0) {
    throw new Errors.ValidationError("The value for `min` must be a positive integer");
  }
  this._min = min;
  return this;
}


/**
 * Set the maximum length allowed for a string.
 * @param {number} min Minimum length for the string
 * @return {TypeString}
 */
TypeString.prototype.max = function(max) {
  if (max < 0) {
    throw new Errors.ValidationError("The value for `max` must be a positive integer");
  }
  this._max = max;
  return this;
}


/**
 * Set the length allowed for a string.
 * @param {number} min Minimum length for the string
 * @return {TypeString}
 */
TypeString.prototype.length = function(length) {
  if (length < 0) {
    throw new Errors.ValidationError("The value for `length` must be a positive integer");
  }
  this._length = length;
  return this;
}


/**
 * Set the regex that the string must match.
 * @param {string} regex The string representation of the regex
 * @param {string} flags The flags used when calling new RegExp(...)
 * @return {TypeString}
 */
TypeString.prototype.regex = function(regex, flags) {
  if (typeof flags === "string") {
    this._regex = new RegExp(regex, flags);
  }
  else {
    this._regex = new RegExp(regex);
  }
  return this;
}


/**
 * Set the string to be alphanumeric.
 * @return {TypeString}
 */
TypeString.prototype.alphanum = function() {
  this._alphanum = true;
  return this;
}


/**
 * Set the string to be an email.
 * @return {TypeString}
 */
TypeString.prototype.email = function() {
  this._email = true;
  return this;
}


/**
 * Set the string to be lowercase.
 * @return {TypeString}
 */
TypeString.prototype.lowercase = function() {
  this._lowercase = true;
  return this;
}


/**
 * Set the string to be uppercase.
 * @return {TypeString}
 */
TypeString.prototype.uppercase = function() {
  this._uppercase = true;
  return this;
}


/**
 * Set the default value for this string, or the function that will generate
 * the default value
 * @param {string|function} fnOrValue
 * @return {TypeString}
 */
TypeString.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}

/**
 * Set the string to be a uuid.
 * @param {number} version
 * @return {TypeString}
 */
TypeString.prototype.uuid = function(version) {
  if (isNaN(version)) {
    throw new Errors.ValidationError("The value for `version` must be a number.");
  }
  if (version < 3 || version > 5) {
    throw new Errors.ValidationError("The value for `version` must be either 3, 4 or 5");
  }
  this._uuid = version;
  return this;
}


/**
 * Set a custom validator that will be called with the string. The validator
 * should return a boolean whether the field is valid or not.
 * @param {function} fn
 * @return {TypeString}
 */
TypeString.prototype.validator = function(fn) {
  if (typeof fn === "function") {
    this._validator = fn;
  }
  return this;
}


/**
 * Set the valid values for this field. The arguments must be strings
 * or an array of strings.
 * @param {...string|Array.<string>} fn
 * @return {TypeString}
 */
TypeString.prototype.enum = function() {
  if ((arguments.length === 1) && (Array.isArray(arguments[0]))) {
    this._enum = {};
    for(var i=0; i<arguments[0].length; i++) {
      this._enum[arguments[0][i]] = true;
    }
  }
  else if ((arguments.length !== 1) || (arguments[0] !== undefined)) {
    this._enum = {};
    for(var i=0; i<arguments.length; i++) {
      this._enum[arguments[i]] = true;
    }
  }
  return this;
}


/**
 * Validate the string given optional options, and throw an error in case
 * the field is not valid.
 * @param {string} str The string to validate.
 * @param {string} prefix The prefix leading to `str`.
 * @param {object=} options Options to overwrite the one defined for the field.
 * @throws {Error}
 */
TypeString.prototype.validate = function(str, prefix, options) {
  var _options = util.mergeOptions(this._options, options);

  if (util.validateIfUndefined(str, prefix, "string", _options)) return;

  if ((typeof this._validator === "function") && (this._validator(str) === false)) {
    throw new Errors.ValidationError("Validator for the field "+prefix+" returned `false`.");
  }


  if ((typeof str === 'function') && (str._query !== undefined)) {
    // We do not check ReQL terms
  }
  else if (typeof str !== "string") {
    if (_options.enforce_type === "strict") {
      util.strictType(prefix, "string");
    }
    else if ((_options.enforce_type === "loose") && (str !== null)) {
      util.looseType(prefix, "string");
    }
  }
  else {
    if ((this._min !== -1) && (this._min > str.length)){
      throw new Errors.ValidationError("Value for "+prefix+" must not be shorter than "+this._min+".")
    }
    if ((this._max !== -1) && (this._max < str.length)){
      throw new Errors.ValidationError("Value for "+prefix+" must not be longer than "+this._max+".")
    }
    if ((this._length !== -1) && (this._length !== str.length)){
      throw new Errors.ValidationError("Value for "+prefix+" must be a string with "+this._length+" characters.")
    }
    if ((this._regex instanceof RegExp) && (this._regex.test(str) === false)) {
      throw new Errors.ValidationError("Value for "+prefix+" must match the regex.")
    }
    if ((this._alphanum === true) && (validator.isAlphanumeric(str) === false)) {
      throw new Errors.ValidationError("Value for "+prefix+" must be an alphanumeric string.")
    }
    if ((this._email === true) && (validator.isEmail(str) === false)) {
      throw new Errors.ValidationError("Value for "+prefix+" must be a valid email.")
    }
    if ((this._lowercase === true) && (validator.isLowercase(str) === false)) {
      throw new Errors.ValidationError("Value for "+prefix+" must be a lowercase string.")
    }
    if ((this._uppercase === true) && (validator.isUppercase(str) === false)) {
      throw new Errors.ValidationError("Value for "+prefix+" must be a uppercase string.")
    }
    if ((this._uuid !== undefined) && (validator.isUUID(str, this._uuid) === false)) {
      throw new Errors.ValidationError("Value for "+prefix+" must be a uuid string.")
    }
    if ((this._enum !== undefined) && (this._enum[str] !== true)) {
      var validValues = Object.keys(this._enum);
      var message = "The field "+prefix+" must be one of these values: "

      for(var i=0; i<validValues.length; i++) {
        if (i === 10) { break; }
        if ((i === validValues.length-1) || (i === 9)) {
          message = message+validValues[i]
        }
        else {
          message = message+validValues[i]+", "
        }
      }
      if (validValues.length > 10) {
        message = message+"..."
      }
      else {
        message = message+"."
      }

      throw new Errors.ValidationError(message);
    }
  }
}


/**
 * Look for a default value or default function, and append an object to `defaultFields`.
 * @param {string} prefix The prefix leading to `str`.
 * @param {Array.<Object>} defaultFields The default fields to generate
 * @param {Array.<Object>} virtualFields The virtual fields to generate
 * @return {TypeString}
 */
TypeString.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  if (this._default !== undefined) {
    defaultFields.push({
      path: prefix,
      value: this._default,
    });
  }
  return this;
}


module.exports = TypeString;


/***/ }),

/***/ "../node_modules/thinky/lib/type/virtual.js":
/*!**************************************************!*\
  !*** ../node_modules/thinky/lib/type/virtual.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function TypeVirtual() {
  this._default = undefined;
  this._validator = undefined;
  this._options = {};
}


TypeVirtual.prototype.default = function(fnOrValue) {
  this._default = fnOrValue;
  return this;
}


// Dummy functions
TypeVirtual.prototype.validate = function() {}


TypeVirtual.prototype.options = function() {}


TypeVirtual.prototype.optional = function() {}


TypeVirtual.prototype.required = function() {}


TypeVirtual.prototype.allowNull = function() {}


TypeVirtual.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {
  // We keep track of virtual fields even if there is no default value
  virtualFields.push({
    path: prefix,
    value: this._default,
  });
}

module.exports = TypeVirtual;


/***/ }),

/***/ "../node_modules/thinky/lib/util.js":
/*!******************************************!*\
  !*** ../node_modules/thinky/lib/util.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = {};
var Promise = __webpack_require__(/*! bluebird */ "bluebird");
var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
var Errors = __webpack_require__(/*! ../node_modules/thinky/lib/errors.js */ "../node_modules/thinky/lib/errors.js");

/**
 * Random useful methods used everywhere.
 */


/**
 * Is `obj` a plain object.
 * @return {boolean}
 */
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
util.isPlainObject = isPlainObject;


/**
 * Make a "deep copy".
 * The prototype chain is not copied.
 */
function deepCopy(value) {
  var result;
  if (value instanceof Buffer) {
    // isPlainObject(buffer) returns true.
    return new Buffer(value);
  }

  if (isPlainObject(value) === true) {
    result = {};
    loopKeys(value, function(_value, key) {
      if (_value.hasOwnProperty(key)) {
        result[key] = deepCopy(_value[key]);
      }
    });
    return result;
  }

  if (Array.isArray(value)) {
    result = []
    for(var i=0; i<value.length; i++) {
      result.push(deepCopy(value[i]));
    }
    return result;
  }

  return value;
}
util.deepCopy = deepCopy;


/**
 * Wrap try/catch for v8
 */
function tryCatch(toTry, handleError) {
  try{
    toTry()
  }
  catch(err) {
    handleError(err)
  }
}
util.tryCatch = tryCatch;


/**
 * Return a promise if a hook is asynchronous
 * Note: If no hook is asynchronous, `fn` can still be asynchronous in which
 * case we return a promise or undefined
 * @param {Object} options, the arguments are:
 * - preHooks {Array} the methods to execute before the main one
 * - postHooks {Array} the methods to execute after the main one
 * - async {boolean} whether this this hook is asynchronous or not
 * - doc {Document} the document that triggered the hooks
 * - fn {Function} the main function
 * - fnArgs {Array} arguments for `fn`
 * @return {Promise=}
 */
function hook(options) {
  var preHooks = options.preHooks;
  if (Array.isArray(preHooks) === false) {
    preHooks = [];
  }
  var postHooks = options.postHooks;
  if (Array.isArray(postHooks) === false) {
    postHooks = [];
  }
  var doc = options.doc; // We need the doc to set the context of the hooks
  var async = options.async || false;
  var fn = options.fn; // The function that we are hook
  var fnArgs = options.fnArgs;

  if (async === true) {
    return new Promise(function(resolve, reject) {
      _asyncHook({
        resolve: resolve,
        reject: reject,
        preHooks: preHooks,
        postHooks: postHooks,
        doc: doc,
        fn: fn,
        fnArgs: fnArgs
      });
    });
  }

  return _syncHook({
    preHooks: preHooks,
    postHooks: postHooks,
    doc: doc,
    fn: fn,
    fnArgs: fnArgs
  });
}
function _syncHook(args) {
  var preHooks = args.preHooks;
  var postHooks = args.postHooks;
  var fn = args.fn;
  var doc = args.doc;
  var fnArgs = args.fnArgs;

  for(var i=0; i<preHooks.length; i++) {
    preHooks[i].call(doc);
  }
  var result = fn.apply(doc, fnArgs);
  for(var j=0; j<postHooks.length; j++) {
    postHooks[j].call(doc);
  }
  return result;
}
function _asyncHook(args) {
  // One of the hook, or the function is asynchronous, so we will
  // always return a promise
  // We only need to keep track of the result return/resolved for fn

  var preHooks = args.preHooks;
  var postHooks = args.postHooks;
  var fn = args.fn;
  var fnArgs = args.fnArgs;
  var doc = args.doc;
  var resolve = args.resolve;
  var reject = args.reject;
  var args = args.args;

  var result;

  var nextPost = function() {
    if (typeof resolve === "function") {
      resolve(result);
    }
    return result;
  }

  var executeMain = function() {
    result = fn.apply(doc, fnArgs);
    if (result instanceof Promise) {
      return result.then(function(res) {
        result = res;
        executeHooks(0, postHooks, doc, reject, nextPost);
      }).error(reject);
    }
    return executeHooks(0, postHooks, doc, reject, nextPost);
  }

  var nextPre = function() {
    tryCatch(executeMain, function (err) {
      return reject(err);
    });
  }
  return executeHooks(0, preHooks, doc, reject, nextPre);
}
util.hook = hook;

function executeHooks(hookIndex, hooks, doc, reject, next) {
  if (hookIndex < hooks.length) {
    if (hooks[hookIndex].length === 1) {
      hooks[hookIndex].call(doc, function(err) {
        if (err) return reject(err);
        executeHooks(hookIndex+1, hooks, doc, reject, next)
      });
    }
    else {
      hooks[hookIndex].call(doc);
      executeHooks(hookIndex+1, hooks, doc, reject, next)
    }
  }
  else {
    next();
  }
}

function loopKeys(obj, fn) {
  if (isPlainObject(obj)) {
    var keys = Object.keys(obj);
    var result;
    for(var i=0; i<keys.length; i++) {
      result = fn(obj, keys[i]);
      if (result === false) return;
    }
  }
}
util.loopKeys = loopKeys;

function changeProto(object, newProto) {
  object.__proto__ = newProto;
}
util.changeProto = changeProto;

function recurse(key, joins, modelTo, all, done) {
  return (util.isPlainObject(modelTo) && modelTo.hasOwnProperty(key))
    || ((all === true) && (done[joins[key].model.getTableName()] !== true))
}
util.recurse = recurse;

function bindEmitter(self) {
  util.loopKeys(EventEmitter.prototype, function(emitter, key) {
    var fn = emitter[key];
    if (typeof fn === 'function') {
      self[key] = function() {
        var args = new Array(arguments.length);
        for(var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        fn.apply(self, args);
      }
    }
  });
}
util.bindEmitter = bindEmitter;

function mergeOptions(options, newOptions) {
  if (util.isPlainObject(newOptions)) {
    if (!options) {
      options = {};
    }
    var localOptions = {};
    localOptions.enforce_missing = (newOptions.enforce_missing != null) ? newOptions.enforce_missing : options.enforce_missing;
    localOptions.enforce_type = (newOptions.enforce_type != null) ? newOptions.enforce_type : options.enforce_type;
    localOptions.enforce_extra = (newOptions.enforce_extra != null) ? newOptions.enforce_extra : options.enforce_extra;
    return localOptions;
  }
  return options;
}
util.mergeOptions = mergeOptions;

function extractPrimaryKey(oldValue, newValue, primaryKey) {
  var primaryKey;
  if (oldValue !== null) {
    return oldValue[primaryKey];
  }
  if (newValue !== null) {
    return newValue[primaryKey];
  }
  return undefined;
}
util.extractPrimaryKey = extractPrimaryKey;


function undefinedField(prefix) {
  throw new Errors.ValidationError("Value for "+prefix+" must be defined.")
}
util.undefinedField = undefinedField;


var vowels = {a: true, e: true, i: true, o: true, u: true};
function strictType(prefix, expected) {
  if ((expected.length > 0) && (vowels[expected[0]])) {
    throw new Errors.ValidationError("Value for "+prefix+" must be an "+expected+".")
  }
  throw new Errors.ValidationError("Value for "+prefix+" must be a "+expected+".")
}
util.strictType = strictType;


function extraField(prefix, key) {
  if (prefix === '') {
    throw new Errors.ValidationError("Extra field `"+key+"` not allowed.")
  }
  throw new Errors.ValidationError("Extra field `"+key+"` in "+prefix+" not allowed.")
}
util.extraField = extraField;


function looseType(prefix, expected) {
  if ((expected.length > 0) && (vowels[expected[0]])) {
    throw new Errors.ValidationError("Value for "+prefix+" must be an "+expected+" or null.")
  }
  throw new Errors.ValidationError("Value for "+prefix+" must be a "+expected+" or null.")
}
util.looseType = looseType;


function pseudoTypeError(type, missingField, prefix) {
  throw new Errors.ValidationError("The raw "+type+" object for "+prefix+" is missing the required field "+missingField+".")
}
util.pseudoTypeError = pseudoTypeError;


// Return true if doc is undefined, else false
function validateIfUndefined(value, prefix, type, options) {
  if (value === undefined) {
    if (options.enforce_missing === true) {
      undefinedField(prefix);
    }
    return true;
  }
  return false;
}
util.validateIfUndefined = validateIfUndefined;

function toArray(args) {
    return Array.prototype.slice.call(args);
}
util.toArray = toArray;

module.exports = util;


/***/ }),

/***/ "../node_modules/validator/validator.js":
/*!**********************************************!*\
  !*** ../node_modules/validator/validator.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Copyright (c) 2014 Chris O'Hara <cohara87@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function (name, definition) {
    if (true) {
        module.exports = definition();
    } else {}
})('validator', function (validator) {

    'use strict';

    validator = { version: '3.34.0' };

    var emailAddress = /((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))/;
    var displayName = /([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~\.]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~\.]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|\s)*/;

    var email = new RegExp('^' + emailAddress.source + '$', 'i');
    var emailWithDisplayName = new RegExp('^' + displayName.source + '<' + emailAddress.source + '>$', 'i');

    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/;

    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

    var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/
      , isbn13Maybe = /^(?:[0-9]{13})$/;

    var ipv4Maybe = /^(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)\.(\d?\d?\d)$/
      , ipv6Block = /^[0-9A-F]{1,4}$/i;

    var uuid = {
        '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i
      , '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
      , '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
      , all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };

    var alpha = /^[a-zA-Z]+$/
      , alphanumeric = /^[a-zA-Z0-9]+$/
      , numeric = /^[-+]?[0-9]+$/
      , int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/
      , float = /^(?:[-+]?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/
      , hexadecimal = /^[0-9a-fA-F]+$/
      , hexcolor = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;

    var ascii = /^[\x00-\x7F]+$/
      , multibyte = /[^\x00-\x7F]/
      , fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/
      , halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;

    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

    var base64 = /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})$/;

    var phones = {
      'zh-CN': /^(\+?0?86\-?)?1[345789]\d{9}$/,
      'en-ZA': /^(\+?27|0)\d{9}$/,
      'en-AU': /^(\+?61|0)4\d{8}$/,
      'en-HK': /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
      'fr-FR': /^(\+?33|0)[67]\d{8}$/,
      'pt-PT': /^(\+351)?9[1236]\d{7}$/,
      'el-GR' : /^(\+30)?((2\d{9})|(69\d{8}))$/
    };

    validator.extend = function (name, fn) {
        validator[name] = function () {
            var args = Array.prototype.slice.call(arguments);
            args[0] = validator.toString(args[0]);
            return fn.apply(validator, args);
        };
    };

    //Right before exporting the validator object, pass each of the builtins
    //through extend() so that their first argument is coerced to a string
    validator.init = function () {
        for (var name in validator) {
            if (typeof validator[name] !== 'function' || name === 'toString' ||
                    name === 'toDate' || name === 'extend' || name === 'init') {
                continue;
            }
            validator.extend(name, validator[name]);
        }
    };

    validator.toString = function (input) {
        if (typeof input === 'object' && input !== null && input.toString) {
            input = input.toString();
        } else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {
            input = '';
        } else if (typeof input !== 'string') {
            input += '';
        }
        return input;
    };

    validator.toDate = function (date) {
        if (Object.prototype.toString.call(date) === '[object Date]') {
            return date;
        }
        date = Date.parse(date);
        return !isNaN(date) ? new Date(date) : null;
    };

    validator.toFloat = function (str) {
        return parseFloat(str);
    };

    validator.toInt = function (str, radix) {
        return parseInt(str, radix || 10);
    };

    validator.toBoolean = function (str, strict) {
        if (strict) {
            return str === '1' || str === 'true';
        }
        return str !== '0' && str !== 'false' && str !== '';
    };

    validator.equals = function (str, comparison) {
        return str === validator.toString(comparison);
    };

    validator.contains = function (str, elem) {
        return str.indexOf(validator.toString(elem)) >= 0;
    };

    validator.matches = function (str, pattern, modifiers) {
        if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
            pattern = new RegExp(pattern, modifiers);
        }
        return pattern.test(str);
    };

    var default_email_options = {
        allow_display_name: false
    };

    validator.isEmail = function (str, options) {
        options = merge(options, default_email_options);

        return email.test(str) || (options.allow_display_name === true && emailWithDisplayName.test(str));
    };

    var default_url_options = {
        protocols: [ 'http', 'https', 'ftp' ]
      , require_tld: true
      , require_protocol: false
      , allow_underscores: false
      , allow_trailing_dot: false
      , allow_protocol_relative_urls: false
    };

    validator.isURL = function (url, options) {
        if (!url || url.length >= 2083) {
            return false;
        }
        if (url.indexOf('mailto:') === 0) {
            return false;
        }
        options = merge(options, default_url_options);
        var protocol, user, pass, auth, host, hostname, port,
            port_str, path, query, hash, split;
        split = url.split('://');
        if (split.length > 1) {
            protocol = split.shift();
            if (options.protocols.indexOf(protocol) === -1) {
                return false;
            }
        } else if (options.require_protocol) {
            return false;
        }  else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
            split[0] = url.substr(2);
        }
        url = split.join('://');
        split = url.split('#');
        url = split.shift();
        hash = split.join('#');
        if (hash && /\s/.test(hash)) {
            return false;
        }
        split = url.split('?');
        url = split.shift();
        query = split.join('?');
        if (query && /\s/.test(query)) {
            return false;
        }

        split = url.split('/');
        url = split.shift();
        path = split.join('/');
        if (path && /\s/.test(path)) {
            return false;
        }
        split = url.split('@');
        if (split.length > 1) {
            auth = split.shift();
            if (auth.indexOf(':') >= 0) {
                auth = auth.split(':');
                user = auth.shift();
                if (!/^\S+$/.test(user)) {
                    return false;
                }
                pass = auth.join(':');
                if (!/^\S*$/.test(user)) {
                    return false;
                }
            }
        }
        hostname = split.join('@');
        split = hostname.split(':');
        host = split.shift();
        if (split.length) {
            port_str = split.join(':');
            port = parseInt(port_str, 10);
            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
                return false;
            }
        }
        if (!validator.isIP(host) && !validator.isFQDN(host, options) &&
                host !== 'localhost') {
            return false;
        }
        if (options.host_whitelist &&
                options.host_whitelist.indexOf(host) === -1) {
            return false;
        }
        if (options.host_blacklist &&
                options.host_blacklist.indexOf(host) !== -1) {
            return false;
        }
        return true;
    };

    validator.isIP = function (str, version) {
        version = validator.toString(version);
        if (!version) {
            return validator.isIP(str, 4) || validator.isIP(str, 6);
        } else if (version === '4') {
            if (!ipv4Maybe.test(str)) {
                return false;
            }
            var parts = str.split('.').sort(function (a, b) {
                return a - b;
            });
            return parts[3] <= 255;
        } else if (version === '6') {
            var blocks = str.split(':');
            var foundOmissionBlock = false; // marker to indicate ::

            if (blocks.length > 8)
                return false;

            // initial or final ::
            if (str === '::') {
                return true;
            } else if (str.substr(0, 2) === '::') {
                blocks.shift();
                blocks.shift();
                foundOmissionBlock = true;
            } else if (str.substr(str.length - 2) === '::') {
                blocks.pop();
                blocks.pop();
                foundOmissionBlock = true;
            }

            for (var i = 0; i < blocks.length; ++i) {
                // test for a :: which can not be at the string start/end
                // since those cases have been handled above
                if (blocks[i] === '' && i > 0 && i < blocks.length -1) {
                    if (foundOmissionBlock)
                        return false; // multiple :: in address
                    foundOmissionBlock = true;
                } else if (!ipv6Block.test(blocks[i])) {
                    return false;
                }
            }

            if (foundOmissionBlock) {
                return blocks.length >= 1;
            } else {
                return blocks.length === 8;
            }
        }
        return false;
    };

    var default_fqdn_options = {
        require_tld: true
      , allow_underscores: false
      , allow_trailing_dot: false
    };

    validator.isFQDN = function (str, options) {
        options = merge(options, default_fqdn_options);

        /* Remove the optional trailing dot before checking validity */
        if (options.allow_trailing_dot && str[str.length - 1] === '.') {
            str = str.substring(0, str.length - 1);
        }
        var parts = str.split('.');
        if (options.require_tld) {
            var tld = parts.pop();
            if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
                return false;
            }
        }
        for (var part, i = 0; i < parts.length; i++) {
            part = parts[i];
            if (options.allow_underscores) {
                if (part.indexOf('__') >= 0) {
                    return false;
                }
                part = part.replace(/_/g, '');
            }
            if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
                return false;
            }
            if (part[0] === '-' || part[part.length - 1] === '-' ||
                    part.indexOf('---') >= 0) {
                return false;
            }
        }
        return true;
    };

    validator.isAlpha = function (str) {
        return alpha.test(str);
    };

    validator.isAlphanumeric = function (str) {
        return alphanumeric.test(str);
    };

    validator.isNumeric = function (str) {
        return numeric.test(str);
    };

    validator.isHexadecimal = function (str) {
        return hexadecimal.test(str);
    };

    validator.isHexColor = function (str) {
        return hexcolor.test(str);
    };

    validator.isLowercase = function (str) {
        return str === str.toLowerCase();
    };

    validator.isUppercase = function (str) {
        return str === str.toUpperCase();
    };

    validator.isInt = function (str) {
        return int.test(str);
    };

    validator.isFloat = function (str) {
        return str !== '' && float.test(str);
    };

    validator.isDivisibleBy = function (str, num) {
        return validator.toFloat(str) % validator.toInt(num) === 0;
    };

    validator.isNull = function (str) {
        return str.length === 0;
    };

    validator.isLength = function (str, min, max) {
        var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
        var len = str.length - surrogatePairs.length;
        return len >= min && (typeof max === 'undefined' || len <= max);
    };

    validator.isByteLength = function (str, min, max) {
        return str.length >= min && (typeof max === 'undefined' || str.length <= max);
    };

    validator.isUUID = function (str, version) {
        var pattern = uuid[version ? version : 'all'];
        return pattern && pattern.test(str);
    };

    validator.isDate = function (str) {
        return !isNaN(Date.parse(str));
    };

    validator.isAfter = function (str, date) {
        var comparison = validator.toDate(date || new Date())
          , original = validator.toDate(str);
        return !!(original && comparison && original > comparison);
    };

    validator.isBefore = function (str, date) {
        var comparison = validator.toDate(date || new Date())
          , original = validator.toDate(str);
        return original && comparison && original < comparison;
    };

    validator.isIn = function (str, options) {
        var i;
        if (Object.prototype.toString.call(options) === '[object Array]') {
            var array = [];
            for (i in options) {
                array[i] = validator.toString(options[i]);
            }
            return array.indexOf(str) >= 0;
        } else if (typeof options === 'object') {
            return options.hasOwnProperty(str);
        } else if (options && typeof options.indexOf === 'function') {
            return options.indexOf(str) >= 0;
        }
        return false;
    };

    validator.isCreditCard = function (str) {
        var sanitized = str.replace(/[^0-9]+/g, '');
        if (!creditCard.test(sanitized)) {
            return false;
        }
        var sum = 0, digit, tmpNum, shouldDouble;
        for (var i = sanitized.length - 1; i >= 0; i--) {
            digit = sanitized.substring(i, (i + 1));
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                    sum += ((tmpNum % 10) + 1);
                } else {
                    sum += tmpNum;
                }
            } else {
                sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
        }
        return !!((sum % 10) === 0 ? sanitized : false);
    };

    validator.isISIN = function (str) {
        if (!isin.test(str)) {
            return false;
        }
        
        var checksumStr = str.replace(/[A-Z]/g, function(character) {
            return parseInt(character, 36);
        });
        
        var sum = 0, digit, tmpNum, shouldDouble = true;
        for (var i = checksumStr.length - 2; i >= 0; i--) {
            digit = checksumStr.substring(i, (i + 1));
            tmpNum = parseInt(digit, 10);
            if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                    sum += tmpNum + 1;
                } else {
                    sum += tmpNum;
                }
            } else {
                
                sum += tmpNum;
            }
            shouldDouble = !shouldDouble;
        }
        
        return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
    };

    validator.isISBN = function (str, version) {
        version = validator.toString(version);
        if (!version) {
            return validator.isISBN(str, 10) || validator.isISBN(str, 13);
        }
        var sanitized = str.replace(/[\s-]+/g, '')
          , checksum = 0, i;
        if (version === '10') {
            if (!isbn10Maybe.test(sanitized)) {
                return false;
            }
            for (i = 0; i < 9; i++) {
                checksum += (i + 1) * sanitized.charAt(i);
            }
            if (sanitized.charAt(9) === 'X') {
                checksum += 10 * 10;
            } else {
                checksum += 10 * sanitized.charAt(9);
            }
            if ((checksum % 11) === 0) {
                return !!sanitized;
            }
        } else  if (version === '13') {
            if (!isbn13Maybe.test(sanitized)) {
                return false;
            }
            var factor = [ 1, 3 ];
            for (i = 0; i < 12; i++) {
                checksum += factor[i % 2] * sanitized.charAt(i);
            }
            if (sanitized.charAt(12) - ((10 - (checksum % 10)) % 10) === 0) {
                return !!sanitized;
            }
        }
        return false;
    };

    validator.isMobilePhone = function(str, locale) {
        if (locale in phones) {
            return phones[locale].test(str);
        }
        return false;
    };

    var default_currency_options = {
        symbol: '$'
      , require_symbol: false
      , allow_space_after_symbol: false
      , symbol_after_digits: false
      , allow_negatives: true
      , parens_for_negatives: false
      , negative_sign_before_digits: false
      , negative_sign_after_digits: false
      , allow_negative_sign_placeholder: false
      , thousands_separator: ','
      , decimal_separator: '.'
      , allow_space_after_digits: false
    };

    validator.isCurrency = function (str, options) {
        options = merge(options, default_currency_options);

        return currencyRegex(options).test(str);
    };

    validator.isJSON = function (str) {
        try {
            JSON.parse(str);
        } catch (e) {
            return false;
        }
        return true;
    };

    validator.isMultibyte = function (str) {
        return multibyte.test(str);
    };

    validator.isAscii = function (str) {
        return ascii.test(str);
    };

    validator.isFullWidth = function (str) {
        return fullWidth.test(str);
    };

    validator.isHalfWidth = function (str) {
        return halfWidth.test(str);
    };

    validator.isVariableWidth = function (str) {
        return fullWidth.test(str) && halfWidth.test(str);
    };

    validator.isSurrogatePair = function (str) {
        return surrogatePair.test(str);
    };

    validator.isBase64 = function (str) {
        return base64.test(str);
    };

    validator.isMongoId = function (str) {
        return validator.isHexadecimal(str) && str.length === 24;
    };

    validator.ltrim = function (str, chars) {
        var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\s+/g;
        return str.replace(pattern, '');
    };

    validator.rtrim = function (str, chars) {
        var pattern = chars ? new RegExp('[' + chars + ']+$', 'g') : /\s+$/g;
        return str.replace(pattern, '');
    };

    validator.trim = function (str, chars) {
        var pattern = chars ? new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g') : /^\s+|\s+$/g;
        return str.replace(pattern, '');
    };

    validator.escape = function (str) {
        return (str.replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\//g, '&#x2F;')
            .replace(/\`/g, '&#96;'));
    };

    validator.stripLow = function (str, keep_new_lines) {
        var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
        return validator.blacklist(str, chars);
    };

    validator.whitelist = function (str, chars) {
        return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
    };

    validator.blacklist = function (str, chars) {
        return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
    };

    var default_normalize_email_options = {
        lowercase: true
    };

    validator.normalizeEmail = function (email, options) {
        options = merge(options, default_normalize_email_options);
        if (!validator.isEmail(email)) {
            return false;
        }
        var parts = email.split('@', 2);
        parts[1] = parts[1].toLowerCase();
        if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
            parts[0] = parts[0].toLowerCase().replace(/\./g, '');
            if (parts[0][0] === '+') {
                return false;
            }
            parts[0] = parts[0].split('+')[0];
            parts[1] = 'gmail.com';
        } else if (options.lowercase) {
            parts[0] = parts[0].toLowerCase();
        }
        return parts.join('@');
    };

    function merge(obj, defaults) {
        obj = obj || {};
        for (var key in defaults) {
            if (typeof obj[key] === 'undefined') {
                obj[key] = defaults[key];
            }
        }
        return obj;
    }

    function currencyRegex(options) {
        var symbol = '(\\' + options.symbol.replace(/\./g, '\\.') + ')' + (options.require_symbol ? '' : '?')
            , negative = '-?'
            , whole_dollar_amount_without_sep = '[1-9]\\d*'
            , whole_dollar_amount_with_sep = '[1-9]\\d{0,2}(\\' + options.thousands_separator + '\\d{3})*'
            , valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep]
            , whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?'
            , decimal_amount = '(\\' + options.decimal_separator + '\\d{2})?';
        var pattern = whole_dollar_amount + decimal_amount;
        // default is negative sign before symbol, but there are two other options (besides parens)
        if (options.allow_negatives && !options.parens_for_negatives) {
            if (options.negative_sign_after_digits) {
                pattern += negative;
            }
            else if (options.negative_sign_before_digits) {
                pattern = negative + pattern;
            }
        }
        // South African Rand, for example, uses R 123 (space) and R-123 (no space)
        if (options.allow_negative_sign_placeholder) {
            pattern = '( (?!\\-))?' + pattern;
        }
        else if (options.allow_space_after_symbol) {
            pattern = ' ?' + pattern;
        }
        else if (options.allow_space_after_digits) {
            pattern += '( (?!$))?';
        }
        if (options.symbol_after_digits) {
            pattern += symbol;
        } else {
            pattern = symbol + pattern;
        }
        if (options.allow_negatives) {
            if (options.parens_for_negatives) {
                pattern = '(\\(' + pattern + '\\)|' + pattern + ')';
            }
            else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
                pattern = negative + pattern;
            }
        }
        return new RegExp(
            '^' +
            // ensure there's a dollar and/or decimal amount, and that it doesn't start with a space or a negative sign followed by a space
            '(?!-? )(?=.*\\d)' +
            pattern +
            '$'
        );
    }

    validator.init();

    return validator;

});


/***/ }),

/***/ "./src/api/index.js":
/*!**************************!*\
  !*** ./src/api/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Page = exports.Template = undefined;

var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _isomorphicFetch = __webpack_require__(/*! isomorphic-fetch */ "isomorphic-fetch");

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").enterModule;

  enterModule && enterModule(module);
})();

var API_BASE = 'http://0.0.0.0:9999/api';

var api = function api(path, options) {
  return fetch(path, options).then(function (res) {
    if (res.status > 200) {
      throw { msg: 'error' };
    }
    return res;
  });
};

var API = {
  get: function get(path) {
    return api('' + API_BASE + path);
  },
  post: function post(path, data) {
    // eslint-disabel-line
    return api('' + API_BASE + path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: (0, _stringify2.default)(data)
    });
  },
  patch: function patch(path, data) {
    // eslint-disabel-line
    return api('' + API_BASE + path, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: (0, _stringify2.default)(data)
    });
  },
  delete: function _delete(path) {
    // eslint-disabel-line
    return api('' + API_BASE + path, {
      method: 'DELETE'
    });
  }
};

var Template = exports.Template = {
  getAll: function getAll() {
    return API.get('/templates');
  },
  get: function get(id) {
    return API.get('/templates/' + id);
  },
  getBy: function getBy(by, value) {
    return API.get('/templates/' + by + '/' + value);
  },
  deleteAll: function deleteAll() {
    return API.delete('/templates');
  },
  create: function create(data) {
    return API.post('/templates', data);
  },
  update: function update(data) {
    return API.patch('/templates', data);
  }
};

var Page = exports.Page = {
  getAll: function getAll() {
    return API.get('/pages');
  },
  get: function get(id) {
    return API.get('/pages/' + id);
  },
  getBy: function getBy(by, value) {
    return API.get('/pages/' + by + '/' + value);
  },
  deleteAll: function deleteAll() {
    return API.delete('/pages');
  },
  create: function create(data) {
    return API.post('/pages', data);
  },
  update: function update(data) {
    return API.patch('/pages', data);
  }
};

var _default = API;
exports.default = _default;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(API_BASE, 'API_BASE', '/Users/m3000/repos/rethink-draftjs/frontend/src/api/index.js');
  reactHotLoader.register(api, 'api', '/Users/m3000/repos/rethink-draftjs/frontend/src/api/index.js');
  reactHotLoader.register(API, 'API', '/Users/m3000/repos/rethink-draftjs/frontend/src/api/index.js');
  reactHotLoader.register(Template, 'Template', '/Users/m3000/repos/rethink-draftjs/frontend/src/api/index.js');
  reactHotLoader.register(Page, 'Page', '/Users/m3000/repos/rethink-draftjs/frontend/src/api/index.js');
  reactHotLoader.register(_default, 'default', '/Users/m3000/repos/rethink-draftjs/frontend/src/api/index.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../ssr3000/node_modules/webpack/buildin/module.js */ "../../ssr3000/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/components/App.js":
/*!*******************************!*\
  !*** ./src/components/App.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader");

var _propTypes = __webpack_require__(/*! prop-types */ "prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Blank = __webpack_require__(/*! ./Blank */ "./src/components/Blank.js");

var _Blank2 = _interopRequireDefault(_Blank);

var _EditContext = __webpack_require__(/*! ./EditContext */ "./src/components/EditContext.js");

var _PageList = __webpack_require__(/*! ./PageList */ "./src/components/PageList.js");

var _PageList2 = _interopRequireDefault(_PageList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").enterModule;

  enterModule && enterModule(module);
})();

var App = function App(props) {
  return (// eslint-disable-line
    _react2.default.createElement(
      _EditContext.EditContext.Provider,
      { value: props.edit },
      _react2.default.createElement(_Blank2.default, { id: 'asd' }),
      _react2.default.createElement(_PageList2.default, null)
    )
  );
};

App.propTypes = {
  edit: _propTypes2.default.object.isRequired
};

var _default = (0, _reactHotLoader.hot)(module)(App);

exports.default = _default;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(App, 'App', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/App.js');
  reactHotLoader.register(_default, 'default', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/App.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../ssr3000/node_modules/webpack/buildin/module.js */ "../../ssr3000/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/components/Blank.js":
/*!*********************************!*\
  !*** ./src/components/Blank.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _dec, _class, _class2, _temp;

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _template = __webpack_require__(/*! ./template */ "./src/components/template.js");

var _template2 = _interopRequireDefault(_template);

var _api = __webpack_require__(/*! ../api */ "./src/api/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").enterModule;

  enterModule && enterModule(module);
})();

var blank = {
  name: 'Blank',
  values: [{
    key: 'abstract',
    value: 'Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.'
  }, {
    key: 'title',
    value: 'New Blank Template'
  }, {
    key: 'tel',
    value: '+49 30 123 456 78'
  }]
};

var Blank = (_dec = (0, _template2.default)(blank, { receiveUpdates: false }), _dec(_class = (_temp = _class2 = function (_Component) {
  (0, _inherits3.default)(Blank, _Component);

  function Blank() {
    (0, _classCallCheck3.default)(this, Blank);
    return (0, _possibleConstructorReturn3.default)(this, (Blank.__proto__ || (0, _getPrototypeOf2.default)(Blank)).apply(this, arguments));
  }

  (0, _createClass3.default)(Blank, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          values = _props.values,
          remote = _props.remote;

      console.log(remote);
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'button',
          { onMouseDown: function onMouseDown() {
              _api.Page.create((0, _extends3.default)({}, blank, {
                values: (0, _keys2.default)(values).map(function (key) {
                  return { key: key, value: values[key] };
                })
              }));
            } },
          'create page'
        ),
        _react2.default.createElement(
          'h1',
          null,
          values.title
        ),
        _react2.default.createElement(
          'p',
          null,
          values.abstract
        ),
        _react2.default.createElement(
          'p',
          null,
          values.tel
        )
      );
    }
  }, {
    key: '__reactstandin__regenerateByEval',
    value: function __reactstandin__regenerateByEval(key, code) {
      this[key] = eval(code);
    }
  }], [{
    key: 'getInitialProps',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(props) {
        var data, parsed;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                console.log('props', props);
                _context.next = 3;
                return _api.Template.create(blank);

              case 3:
                data = _context.sent;
                _context.next = 6;
                return data.json();

              case 6:
                parsed = _context.sent;
                return _context.abrupt('return', {
                  test: parsed
                });

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getInitialProps(_x) {
        return _ref.apply(this, arguments);
      }

      return getInitialProps;
    }() // eslint-disable-line

  }]);
  return Blank;
}(_react.Component), _class2.propTypes = {
  values: _propTypes2.default.object.isRequired,
  edit: _propTypes2.default.object.isRequired,
  remote: _propTypes2.default.object.isRequired
}, _temp)) || _class);
var _default = Blank;
exports.default = _default;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(blank, 'blank', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/Blank.js');
  reactHotLoader.register(Blank, 'Blank', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/Blank.js');
  reactHotLoader.register(_default, 'default', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/Blank.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../ssr3000/node_modules/webpack/buildin/module.js */ "../../ssr3000/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/components/EditContext.js":
/*!***************************************!*\
  !*** ./src/components/EditContext.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditContext = exports.edit = undefined;

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").enterModule;

  enterModule && enterModule(module);
})();

var edit = exports.edit = function edit() {
  var isServer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var snapshot = arguments[1];

  var initialActions = [];
  if (snapshot) {
    return snapshot;
  }
  return {
    initialActions: initialActions,
    isServer: isServer,
    addAction: function addAction(action) {
      initialActions.push(action);
    },
    inits: {}
  };
};

var EditContext = exports.EditContext = _react2.default.createContext(edit());
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(edit, 'edit', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/EditContext.js');
  reactHotLoader.register(EditContext, 'EditContext', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/EditContext.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../ssr3000/node_modules/webpack/buildin/module.js */ "../../ssr3000/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/components/PageList.js":
/*!************************************!*\
  !*** ./src/components/PageList.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _api = __webpack_require__(/*! ../api */ "./src/api/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").enterModule;

  enterModule && enterModule(module);
})();

var PageList = function (_React$Component) {
  (0, _inherits3.default)(PageList, _React$Component);

  function PageList() {
    (0, _classCallCheck3.default)(this, PageList);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PageList.__proto__ || (0, _getPrototypeOf2.default)(PageList)).call(this));

    _this.state = {
      pages: []
    };
    return _this;
  }

  (0, _createClass3.default)(PageList, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      _api.Page.getAll().then(function (pages) {
        return pages.json();
      }).then(function (pages) {
        _this2.setState({
          pages: pages.pages
        });
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var pages = this.state.pages;

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement('hr', null),
        _react2.default.createElement(
          'ul',
          null,
          pages.map(function (page) {
            return _react2.default.createElement(
              'li',
              { key: page.id },
              _react2.default.createElement(
                'h2',
                null,
                page.title,
                ' (',
                page.type || page.name,
                ')'
              )
            );
          })
        )
      );
    }
  }, {
    key: '__reactstandin__regenerateByEval',
    value: function __reactstandin__regenerateByEval(key, code) {
      this[key] = eval(code);
    }
  }]);
  return PageList;
}(_react2.default.Component);

var _default = PageList;
exports.default = _default;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(PageList, 'PageList', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/PageList.js');
  reactHotLoader.register(_default, 'default', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/PageList.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../ssr3000/node_modules/webpack/buildin/module.js */ "../../ssr3000/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/components/template.js":
/*!************************************!*\
  !*** ./src/components/template.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(/*! babel-runtime/helpers/defineProperty */ "babel-runtime/helpers/defineProperty");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends3 = __webpack_require__(/*! babel-runtime/helpers/extends */ "babel-runtime/helpers/extends");

var _extends4 = _interopRequireDefault(_extends3);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = template;

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _api = __webpack_require__(/*! ../api */ "./src/api/index.js");

var _EditContext = __webpack_require__(/*! ./EditContext */ "./src/components/EditContext.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").enterModule;

  enterModule && enterModule(module);
})();

function template(data, _ref) {
  var _ref$receiveUpdates = _ref.receiveUpdates,
      receiveUpdates = _ref$receiveUpdates === undefined ? true : _ref$receiveUpdates;

  return function (Wrapped) {
    var _class, _temp;

    var name = Wrapped.displayName || Wrapped.name;
    var Template = (_temp = _class = function (_Component) {
      (0, _inherits3.default)(Template, _Component);

      function Template(props) {
        (0, _classCallCheck3.default)(this, Template);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Template.__proto__ || (0, _getPrototypeOf2.default)(Template)).call(this));

        _this.handleUpdate = function () {
          _api.Template.update((0, _extends4.default)({}, data, {
            id: _this.state.id
          }));
        };

        var remote = null;
        if (Wrapped.getInitialProps) {
          if (!props.edit.inits[name]) {
            props.edit.inits[name] = {
              data: null,
              init: Wrapped.getInitialProps(props).catch(function (err) {
                return console.log('getInitialProps Error:', err);
              }).then(function (data) {
                props.edit.inits[name].data = data;
              })
            };
          } else {
            if (props.edit.inits[name].data) {
              remote = props.edit.inits[name].data;
            }
          }
        }

        _this.state = {
          id: null,
          hasChanges: false,
          values: data.values.reduce(function (acc, v) {
            return (0, _extends4.default)({}, acc, (0, _defineProperty3.default)({}, v.key, v.value));
          }, {}),
          remote: remote
        };
        return _this;
      }

      (0, _createClass3.default)(Template, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
          var edit = this.props.edit;
          // const action = templateApi.create(data).then(async (res) => {
          //   const json = await res.json();
          //   if (!receiveUpdates) return;
          //   const {
          //     template: resTemplate,
          //     hasChanges,
          //   } = json;
          //   this.setState({
          //     id: resTemplate.id,
          //     values: resTemplate.values.reduce((acc, v) => ({ ...acc, [v.key]: v.value }), {}),
          //     hasChanges,
          //   });
          // });
          // edit.addAction(action);
        }
      }, {
        key: 'render',
        value: function render() {
          var hasChanges = this.state.hasChanges;

          return _react2.default.createElement(
            'div',
            null,
            hasChanges && _react2.default.createElement(
              'div',
              null,
              'The remote version of this template doesn\'t match. You can sync the remote with your local version. ',
              _react2.default.createElement(
                'a',
                { href: '#' },
                'more information'
              ),
              '\xA0',
              _react2.default.createElement(
                'button',
                { onMouseDown: this.handleUpdate },
                'Update Template'
              )
            ),
            _react2.default.createElement(Wrapped, (0, _extends4.default)({}, this.props, this.state))
          );
        }
      }, {
        key: '__reactstandin__regenerateByEval',
        value: function __reactstandin__regenerateByEval(key, code) {
          this[key] = eval(code);
        }
      }]);
      return Template;
    }(_react.Component), _class.propTypes = {
      edit: _propTypes2.default.object.isRequired
    }, _temp);


    Template.displayName = 'Template(' + name + ')';
    return function (props) {
      return _react2.default.createElement(
        _EditContext.EditContext.Consumer,
        null,
        function (edit) {
          return _react2.default.createElement(Template, (0, _extends4.default)({}, props, { edit: edit }));
        }
      );
    };
  };
}
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(template, 'template', '/Users/m3000/repos/rethink-draftjs/frontend/src/components/template.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../ssr3000/node_modules/webpack/buildin/module.js */ "../../ssr3000/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/serverMiddleware/index.ejs":
/*!****************************************!*\
  !*** ./src/serverMiddleware/index.ejs ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<html>\n  <head>\n    <title>SSR3000 App</title>\n  </head>\n  <body>\n    <div id=\"root\"><%= app %></div>\n    <script>window.SNAPSHOT = <%= JSON.stringify(snapshot) %>;</script>\n    <% chunks.js.forEach((chunk) => { %><script src=\"<%= chunk %>\"></script><% }); %>\n  </body>\n</html>"

/***/ }),

/***/ "./src/serverMiddleware/index.js":
/*!***************************************!*\
  !*** ./src/serverMiddleware/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _server = __webpack_require__(/*! react-dom/server */ "react-dom/server");

var _express = __webpack_require__(/*! express */ "express");

var _lodash = __webpack_require__(/*! lodash.template */ "lodash.template");

var _lodash2 = _interopRequireDefault(_lodash);

var _rethinkDraftJs = __webpack_require__(/*! rethink-draft-js */ "../lib/index.js");

var _rethinkDraftJs2 = _interopRequireDefault(_rethinkDraftJs);

var _index = __webpack_require__(/*! ./index.ejs */ "./src/serverMiddleware/index.ejs");

var _index2 = _interopRequireDefault(_index);

var _App = __webpack_require__(/*! ../components/App */ "./src/components/App.js");

var _App2 = _interopRequireDefault(_App);

var _EditContext = __webpack_require__(/*! ../components/EditContext */ "./src/components/EditContext.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").enterModule;

  enterModule && enterModule(module);
})();

var clearRequire = __webpack_require__(/*! clear-require */ "clear-require");

var template = (0, _lodash2.default)(_index2.default);

var _default = function _default(chunks) {
  var router = new _express.Router();
  router.use('/favicon.ico', function (req, res) {
    res.status(200).send('lol');
  });
  router.use(function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(req, res, next) {
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              //const rethink = require('rethink-draft-js');
              (0, _rethinkDraftJs2.default)()(req, res, next);

            case 1:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, undefined);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }());
  router.use(function (req, res) {
    var editInstance = (0, _EditContext.edit)(true);

    (0, _server.renderToString)(_react2.default.createElement(_App2.default, { edit: editInstance }));
    //console.log('app rendered', editInstance);
    var all = (0, _keys2.default)(editInstance.inits).map(function (key) {
      return editInstance.inits[key].init;
    });
    _promise2.default.all(all).then(function (test) {
      res.status(200).send(template({
        chunks: chunks,
        app: (0, _server.renderToString)(_react2.default.createElement(_App2.default, { edit: editInstance })),
        snapshot: editInstance
      }));
    });
    console.log('send response');
  });
  return router;
};

exports.default = _default;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "react-hot-loader").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(template, 'template', '/Users/m3000/repos/rethink-draftjs/frontend/src/serverMiddleware/index.js');
  reactHotLoader.register(_default, 'default', '/Users/m3000/repos/rethink-draftjs/frontend/src/serverMiddleware/index.js');
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../ssr3000/node_modules/webpack/buildin/module.js */ "../../ssr3000/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ 0:
/*!*********************************************!*\
  !*** multi ./src/serverMiddleware/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/m3000/repos/rethink-draftjs/frontend/src/serverMiddleware/index.js */"./src/serverMiddleware/index.js");


/***/ }),

/***/ "babel-runtime/core-js/json/stringify":
/*!*******************************************************!*\
  !*** external "babel-runtime/core-js/json/stringify" ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/json/stringify");

/***/ }),

/***/ "babel-runtime/core-js/object/get-prototype-of":
/*!****************************************************************!*\
  !*** external "babel-runtime/core-js/object/get-prototype-of" ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/get-prototype-of");

/***/ }),

/***/ "babel-runtime/core-js/object/keys":
/*!****************************************************!*\
  !*** external "babel-runtime/core-js/object/keys" ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),

/***/ "babel-runtime/core-js/promise":
/*!************************************************!*\
  !*** external "babel-runtime/core-js/promise" ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),

/***/ "babel-runtime/helpers/asyncToGenerator":
/*!*********************************************************!*\
  !*** external "babel-runtime/helpers/asyncToGenerator" ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),

/***/ "babel-runtime/helpers/classCallCheck":
/*!*******************************************************!*\
  !*** external "babel-runtime/helpers/classCallCheck" ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/classCallCheck");

/***/ }),

/***/ "babel-runtime/helpers/createClass":
/*!****************************************************!*\
  !*** external "babel-runtime/helpers/createClass" ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/createClass");

/***/ }),

/***/ "babel-runtime/helpers/defineProperty":
/*!*******************************************************!*\
  !*** external "babel-runtime/helpers/defineProperty" ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/defineProperty");

/***/ }),

/***/ "babel-runtime/helpers/extends":
/*!************************************************!*\
  !*** external "babel-runtime/helpers/extends" ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),

/***/ "babel-runtime/helpers/inherits":
/*!*************************************************!*\
  !*** external "babel-runtime/helpers/inherits" ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/inherits");

/***/ }),

/***/ "babel-runtime/helpers/objectWithoutProperties":
/*!****************************************************************!*\
  !*** external "babel-runtime/helpers/objectWithoutProperties" ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/objectWithoutProperties");

/***/ }),

/***/ "babel-runtime/helpers/possibleConstructorReturn":
/*!******************************************************************!*\
  !*** external "babel-runtime/helpers/possibleConstructorReturn" ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/possibleConstructorReturn");

/***/ }),

/***/ "babel-runtime/regenerator":
/*!********************************************!*\
  !*** external "babel-runtime/regenerator" ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/regenerator");

/***/ }),

/***/ "bluebird":
/*!***************************!*\
  !*** external "bluebird" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("bluebird");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("body-parser");

/***/ }),

/***/ "clear-require":
/*!********************************!*\
  !*** external "clear-require" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("clear-require");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("express");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "isomorphic-fetch":
/*!***********************************!*\
  !*** external "isomorphic-fetch" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("isomorphic-fetch");

/***/ }),

/***/ "lodash.template":
/*!**********************************!*\
  !*** external "lodash.template" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("lodash.template");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "object-assign":
/*!********************************!*\
  !*** external "object-assign" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("object-assign");

/***/ }),

/***/ "prop-types":
/*!*****************************!*\
  !*** external "prop-types" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("prop-types");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),

/***/ "react-dom/server":
/*!***********************************!*\
  !*** external "react-dom/server" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-dom/server");

/***/ }),

/***/ "react-hot-loader":
/*!***********************************!*\
  !*** external "react-hot-loader" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-hot-loader");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "vary":
/*!***********************!*\
  !*** external "vary" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("vary");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYi9hcGkvY29udHJvbGxlcnMvRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYi9hcGkvY29udHJvbGxlcnMvUGFnZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYi9hcGkvY29udHJvbGxlcnMvVGVtcGxhdGVzLmpzIiwid2VicGFjazovLy8uLi9saWIvYXBpL2NvbnRyb2xsZXJzL1ZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbGliL2FwaS9kYi5qcyIsIndlYnBhY2s6Ly8vLi4vbGliL2FwaS9tb2RlbHMvUGFnZS5qcyIsIndlYnBhY2s6Ly8vLi4vbGliL2FwaS9tb2RlbHMvVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL2xpYi9hcGkvbW9kZWxzL1ZhbHVlLmpzIiwid2VicGFjazovLy8uLi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jb3JzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2RlZXAtZGlmZi9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2RvdGVudi9saWIvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JldGhpbmtkYmRhc2gvbGliL2Nvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZXRoaW5rZGJkYXNoL2xpYi9jdXJzb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZXRoaW5rZGJkYXNoL2xpYi9kZXF1ZXVlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmV0aGlua2RiZGFzaC9saWIvZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZXRoaW5rZGJkYXNoL2xpYi9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZXRoaW5rZGJkYXNoL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JldGhpbmtkYmRhc2gvbGliL21ldGFkYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmV0aGlua2RiZGFzaC9saWIvcG9vbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JldGhpbmtkYmRhc2gvbGliL3Bvb2xfbWFzdGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmV0aGlua2RiZGFzaC9saWIvcHJvdG9kZWYuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZXRoaW5rZGJkYXNoL2xpYi9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZXRoaW5rZGJkYXNoL2xpYi90ZXJtLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmV0aGlua2RiZGFzaC9saWIvdHJhbnNmb3JtX3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JldGhpbmtkYmRhc2gvbGliL3dyaXRhYmxlX3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvZG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aGlua3kvbGliL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvZmVlZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aGlua3kvbGliL3F1ZXJ5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdGhpbmt5L2xpYi9zY2hlbWEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aGlua3kvbGliL3RoaW5reS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvdHlwZS9hbnkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aGlua3kvbGliL3R5cGUvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aGlua3kvbGliL3R5cGUvYm9vbGVhbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvdHlwZS9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aGlua3kvbGliL3R5cGUvZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvdHlwZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvdHlwZS9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90aGlua3kvbGliL3R5cGUvb2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdGhpbmt5L2xpYi90eXBlL3BvaW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdGhpbmt5L2xpYi90eXBlL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3RoaW5reS9saWIvdHlwZS92aXJ0dWFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdGhpbmt5L2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdmFsaWRhdG9yL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0FwcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbGFuay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9FZGl0Q29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9QYWdlTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyTWlkZGxld2FyZS9pbmRleC5lanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlck1pZGRsZXdhcmUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyB3YXNtIG1vZHVsZXNcbiBcdHZhciBpbnN0YWxsZWRXYXNtTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3RhdGljL1wiO1xuXG4gXHQvLyBvYmplY3Qgd2l0aCBhbGwgY29tcGlsZWQgV2ViQXNzZW1ibHkuTW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy53ID0ge307XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKHJlcywgZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcignZXJyb3InLCBlcnJvcik7XG4gIHJldHVybiByZXMuc3RhdHVzKDUwMCkuc2VuZChlcnJvcik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UnKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvcicpO1xuXG52YXIgX3JlZ2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlZ2VuZXJhdG9yKTtcblxudmFyIF9vYmplY3RXaXRob3V0UHJvcGVydGllczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMnKTtcblxudmFyIF9vYmplY3RXaXRob3V0UHJvcGVydGllczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RXaXRob3V0UHJvcGVydGllczIpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FzeW5jVG9HZW5lcmF0b3IyKTtcblxudmFyIF9rZXlzID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzJyk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9kZWVwRGlmZiA9IHJlcXVpcmUoJ2RlZXAtZGlmZicpO1xuXG52YXIgX2RlZXBEaWZmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBEaWZmKTtcblxudmFyIF9FcnJvciA9IHJlcXVpcmUoJy4vRXJyb3InKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFBhZ2UgPSByZXF1aXJlKCcuLi9tb2RlbHMvUGFnZScpO1xudmFyIFZhbHVlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ZhbHVlJyk7XG52YXIgbm9ybWFsaXplRmllbGRzID0gZnVuY3Rpb24gbm9ybWFsaXplRmllbGRzKG9yaWdpbmFsLCB0YXJnZXQpIHtcbiAgcmV0dXJuICgwLCBfa2V5czIuZGVmYXVsdCkob3JpZ2luYWwpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG5cbnZhciBub3JtYWxpemVEb2N1bWVudCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZURvY3VtZW50KG9yaWdpbmFsLCB0YXJnZXQpIHtcbiAgcmV0dXJuICgwLCBfa2V5czIuZGVmYXVsdCkob3JpZ2luYWwpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsW2tleV07XG4gICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFsdWUgPSB0YXJnZXRba2V5XS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplRmllbGRzKG9yaWdpbmFsVmFsdWVbMF0sIHZhbCk7XG4gICAgICB9KS5yZXZlcnNlKCk7XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbFZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB2YWx1ZSA9IG5vcm1hbGl6ZUZpZWxkcyhvcmlnaW5hbFZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMy5kZWZhdWx0KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxLCByZXMpIHtcbiAgICB2YXIgX3JlcSRib2R5LCB2YWx1ZXMsIHJlc3QsIHBhZ2UsIHRWYWx1ZXMsIHNhdmVkUGFnZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IyLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgX3JlcSRib2R5ID0gcmVxLmJvZHksIHZhbHVlcyA9IF9yZXEkYm9keS52YWx1ZXMsIHJlc3QgPSAoMCwgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMy5kZWZhdWx0KShfcmVxJGJvZHksIFsndmFsdWVzJ10pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnPz8nLCByZXEuYm9keSk7XG4gICAgICAgICAgICBwYWdlID0gbmV3IFBhZ2UocmVzdCk7XG4gICAgICAgICAgICB0VmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlKHYpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhZ2UudmFsdWVzID0gdFZhbHVlcztcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2Uuc2F2ZUFsbCh7IHZhbHVlczogdHJ1ZSB9KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHNhdmVkUGFnZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgICAgIHNhdmVkUGFnZTogc2F2ZWRQYWdlXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEyO1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFsnY2F0Y2gnXSgwKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHVuZGVmaW5lZCwgW1swLCAxMl1dKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gIHZhciBpZCA9IHJlcS5wYXJhbXMuaWQ7XG4gIFBhZ2UuZ2V0KGlkKS5nZXRKb2luKHsgdmFsdWVzOiB0cnVlIH0pLnJ1bigpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmVzLmpzb24oe1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucGF0Y2ggPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgdmFyIF9yZXEkYm9keTIgPSByZXEuYm9keSxcbiAgICAgIHZhbHVlcyA9IF9yZXEkYm9keTIudmFsdWVzLFxuICAgICAgcmVzdCA9ICgwLCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMzLmRlZmF1bHQpKF9yZXEkYm9keTIsIFsndmFsdWVzJ10pO1xuXG4gIFBhZ2UuZ2V0KHJlc3QuaWQpLmdldEpvaW4oeyB2YWx1ZXM6IHRydWUgfSkucnVuKCkudGhlbihmdW5jdGlvbiAoZXhpc3RpbmdQYWdlKSB7XG4gICAgdmFyIGFjdGlvbnMgPSB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbHVlKSB7XG4gICAgICB2YXIgZXhpc3RzID0gZXhpc3RpbmdQYWdlLnZhbHVlcy5maW5kSW5kZXgoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYua2V5ID09PSB2YWx1ZS5rZXk7XG4gICAgICB9KTtcbiAgICAgIGlmIChleGlzdHMgPiAtMSkge1xuICAgICAgICBjb25zb2xlLmxvZyhleGlzdHMpO1xuICAgICAgICBhY2MudXBkYXRlLnB1c2goZXhpc3RpbmdQYWdlLnZhbHVlc1tleGlzdHNdLm1lcmdlKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZS5rZXkpO1xuICAgICAgICBhY2MuY3JlYXRlLnB1c2gobmV3IFZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHsgdXBkYXRlOiBbXSwgY3JlYXRlOiBbXSB9KTtcbiAgICBleGlzdGluZ1BhZ2UudmFsdWVzID0gW10uY29uY2F0KGFjdGlvbnMudXBkYXRlLCBhY3Rpb25zLmNyZWF0ZSk7XG4gICAgZXhpc3RpbmdQYWdlLnNhdmVBbGwoeyB2YWx1ZXM6IHRydWUgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXMuanNvbihyZXN1bHQpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiAoMCwgX0Vycm9yLmhhbmRsZUVycm9yKShlcnIsIGVycik7XG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZ2V0QnkgPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgdmFyIF9QYWdlJGZpbHRlcjtcblxuICB2YXIgYnkgPSByZXEucGFyYW1zLmJ5O1xuICB2YXIgdmFsdWUgPSByZXEucGFyYW1zLnZhbHVlO1xuICBQYWdlLmZpbHRlcigoX1BhZ2UkZmlsdGVyID0ge30sIF9QYWdlJGZpbHRlcltieV0gPSB2YWx1ZSwgX1BhZ2UkZmlsdGVyKSkuZ2V0Sm9pbih7IHZhbHVlczogdHJ1ZSB9KS5ydW4oKS50aGVuKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgcmVzLmpzb24oe1xuICAgICAgcGFnZTogcGFnZVxuICAgIH0pO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuICgwLCBfRXJyb3IuaGFuZGxlRXJyb3IpKHJlcywgZXJyKTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmdldEFsbCA9IGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICBQYWdlLmdldEpvaW4oe1xuICAgIHZhbHVlczogdHJ1ZVxuICB9KS5ydW4oKS50aGVuKGZ1bmN0aW9uIChwYWdlcykge1xuICAgIHJlcy5qc29uKHtcbiAgICAgIHBhZ2VzOiBwYWdlc1xuICAgIH0pO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuICgwLCBfRXJyb3IuaGFuZGxlRXJyb3IpKHJlcywgZXJyKTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlbGV0ZUFsbCA9IGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICBQYWdlLmdldEpvaW4oeyB2YWx1ZXM6IHRydWUgfSkucnVuKCkudGhlbihmdW5jdGlvbiAocGFnZXMpIHtcbiAgICB2YXIgYWxsID0gcGFnZXMubWFwKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICByZXR1cm4gcGFnZS5kZWxldGVBbGwoeyB2YWx1ZXM6IHRydWUgfSk7XG4gICAgfSk7XG4gICAgX3Byb21pc2UyLmRlZmF1bHQuYWxsKGFsbCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXMuanNvbih7XG4gICAgICAgIG1zZzogJ2FsbCBwYWdlcyBkZWxldGVkJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucHVyZ2VBbGwgPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgUGFnZS5ydW4oKS50aGVuKGZ1bmN0aW9uIChwYWdlcykge1xuICAgIHZhciBhbGwgPSBwYWdlcy5tYXAoZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgIHJldHVybiBwYWdlLnB1cmdlKCk7XG4gICAgfSk7XG4gICAgX3Byb21pc2UyLmRlZmF1bHQuYWxsKGFsbCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXMuanNvbih7XG4gICAgICAgIG1zZzogJ2FsbCBwYWdlcyBwdXJnZWQnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiAoMCwgX0Vycm9yLmhhbmRsZUVycm9yKShyZXMsIGVycik7XG4gIH0pO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlJyk7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3InKTtcblxudmFyIF9yZWdlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWdlbmVyYXRvcik7XG5cbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJyk7XG5cbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMyKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yJyk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luY1RvR2VuZXJhdG9yMik7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cycpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfZGVlcERpZmYgPSByZXF1aXJlKCdkZWVwLWRpZmYnKTtcblxudmFyIF9kZWVwRGlmZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRGlmZik7XG5cbnZhciBfRXJyb3IgPSByZXF1aXJlKCcuL0Vycm9yJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL21vZGVscy9UZW1wbGF0ZScpO1xudmFyIFZhbHVlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ZhbHVlJyk7XG52YXIgbm9ybWFsaXplRmllbGRzID0gZnVuY3Rpb24gbm9ybWFsaXplRmllbGRzKG9yaWdpbmFsLCB0YXJnZXQpIHtcbiAgcmV0dXJuICgwLCBfa2V5czIuZGVmYXVsdCkob3JpZ2luYWwpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG5cbnZhciBub3JtYWxpemVEb2N1bWVudCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZURvY3VtZW50KG9yaWdpbmFsLCB0YXJnZXQpIHtcbiAgcmV0dXJuICgwLCBfa2V5czIuZGVmYXVsdCkob3JpZ2luYWwpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsW2tleV07XG4gICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFsdWUgPSB0YXJnZXRba2V5XS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplRmllbGRzKG9yaWdpbmFsVmFsdWVbMF0sIHZhbCk7XG4gICAgICB9KS5yZXZlcnNlKCk7XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbFZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB2YWx1ZSA9IG5vcm1hbGl6ZUZpZWxkcyhvcmlnaW5hbFZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMy5kZWZhdWx0KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxLCByZXMpIHtcbiAgICB2YXIgX3JlcSRib2R5LCB2YWx1ZXMsIHJlc3QsIGV4aXN0cywgX3RlbXBsYXRlLCBub3JtYWxpemVkVGVtcGxhdGUsIGNoYW5nZXMsIHRlbXBsYXRlLCB0VmFsdWVzLCBzYXZlZFRlbXBsYXRlO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX3JlcSRib2R5ID0gcmVxLmJvZHksIHZhbHVlcyA9IF9yZXEkYm9keS52YWx1ZXMsIHJlc3QgPSAoMCwgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMy5kZWZhdWx0KShfcmVxJGJvZHksIFsndmFsdWVzJ10pO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5maWx0ZXIoeyBuYW1lOiByZXN0Lm5hbWUgfSkucnVuKCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBleGlzdHMgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIWV4aXN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuZmlsdGVyKHsgbmFtZTogcmVzdC5uYW1lIH0pLmdldEpvaW4oeyB2YWx1ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfdGVtcGxhdGUgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlID0gbm9ybWFsaXplRG9jdW1lbnQocmVxLmJvZHksIF90ZW1wbGF0ZVswXSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gKDAsIF9kZWVwRGlmZjIuZGVmYXVsdCkobm9ybWFsaXplZFRlbXBsYXRlLCByZXEuYm9keSkgfHwgZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgICAgIHRlbXBsYXRlOiBfdGVtcGxhdGVbMF0sXG4gICAgICAgICAgICAgIGhhc0NoYW5nZXM6ICEhY2hhbmdlcy5sZW5ndGgsXG4gICAgICAgICAgICAgIGNoYW5nZXM6IGNoYW5nZXMgfHwgbnVsbFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHRlbXBsYXRlID0gbmV3IFRlbXBsYXRlKHJlc3QpO1xuICAgICAgICAgICAgdFZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZSh2KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YWx1ZXMgPSB0VmFsdWVzO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnNhdmVBbGwoeyB2YWx1ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgc2F2ZWRUZW1wbGF0ZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgICAgIHNhdmVkVGVtcGxhdGU6IHNhdmVkVGVtcGxhdGVcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjE7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0WydjYXRjaCddKDEpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dC50MCk7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdW5kZWZpbmVkLCBbWzEsIDIxXV0pO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgdmFyIGlkID0gcmVxLnBhcmFtcy5pZDtcbiAgVGVtcGxhdGUuZ2V0KGlkKS5nZXRKb2luKHsgdmFsdWVzOiB0cnVlIH0pLnJ1bigpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmVzLmpzb24oe1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucGF0Y2ggPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgdmFyIF9yZXEkYm9keTIgPSByZXEuYm9keSxcbiAgICAgIHZhbHVlcyA9IF9yZXEkYm9keTIudmFsdWVzLFxuICAgICAgcmVzdCA9ICgwLCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMzLmRlZmF1bHQpKF9yZXEkYm9keTIsIFsndmFsdWVzJ10pO1xuXG4gIFRlbXBsYXRlLmdldChyZXN0LmlkKS5nZXRKb2luKHsgdmFsdWVzOiB0cnVlIH0pLnJ1bigpLnRoZW4oZnVuY3Rpb24gKGV4aXN0aW5nVGVtcGxhdGUpIHtcbiAgICB2YXIgYWN0aW9ucyA9IHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdmFsdWUpIHtcbiAgICAgIHZhciBleGlzdHMgPSBleGlzdGluZ1RlbXBsYXRlLnZhbHVlcy5maW5kSW5kZXgoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYua2V5ID09PSB2YWx1ZS5rZXk7XG4gICAgICB9KTtcbiAgICAgIGlmIChleGlzdHMgPiAtMSkge1xuICAgICAgICBjb25zb2xlLmxvZyhleGlzdHMpO1xuICAgICAgICBhY2MudXBkYXRlLnB1c2goZXhpc3RpbmdUZW1wbGF0ZS52YWx1ZXNbZXhpc3RzXS5tZXJnZSh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2codmFsdWUua2V5KTtcbiAgICAgICAgYWNjLmNyZWF0ZS5wdXNoKG5ldyBWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7IHVwZGF0ZTogW10sIGNyZWF0ZTogW10gfSk7XG4gICAgZXhpc3RpbmdUZW1wbGF0ZS52YWx1ZXMgPSBbXS5jb25jYXQoYWN0aW9ucy51cGRhdGUsIGFjdGlvbnMuY3JlYXRlKTtcbiAgICBleGlzdGluZ1RlbXBsYXRlLnNhdmVBbGwoeyB2YWx1ZXM6IHRydWUgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXMuanNvbihyZXN1bHQpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiAoMCwgX0Vycm9yLmhhbmRsZUVycm9yKShlcnIsIGVycik7XG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZ2V0QnkgPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgdmFyIF9UZW1wbGF0ZSRmaWx0ZXI7XG5cbiAgdmFyIGJ5ID0gcmVxLnBhcmFtcy5ieTtcbiAgdmFyIHZhbHVlID0gcmVxLnBhcmFtcy52YWx1ZTtcbiAgVGVtcGxhdGUuZmlsdGVyKChfVGVtcGxhdGUkZmlsdGVyID0ge30sIF9UZW1wbGF0ZSRmaWx0ZXJbYnldID0gdmFsdWUsIF9UZW1wbGF0ZSRmaWx0ZXIpKS5nZXRKb2luKHsgdmFsdWVzOiB0cnVlIH0pLnJ1bigpLnRoZW4oZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICByZXMuanNvbih7XG4gICAgICBwYWdlOiBwYWdlXG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZ2V0QWxsID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gIFRlbXBsYXRlLmdldEpvaW4oe1xuICAgIHZhbHVlczogdHJ1ZVxuICB9KS5ydW4oKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZXMpIHtcbiAgICByZXMuanNvbih7XG4gICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlc1xuICAgIH0pO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuICgwLCBfRXJyb3IuaGFuZGxlRXJyb3IpKHJlcywgZXJyKTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlbGV0ZUFsbCA9IGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICBUZW1wbGF0ZS5nZXRKb2luKHsgdmFsdWVzOiB0cnVlIH0pLnJ1bigpLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlcykge1xuICAgIHZhciBhbGwgPSB0ZW1wbGF0ZXMubWFwKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLmRlbGV0ZUFsbCh7IHZhbHVlczogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgICBfcHJvbWlzZTIuZGVmYXVsdC5hbGwoYWxsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcy5qc29uKHtcbiAgICAgICAgbXNnOiAnYWxsIHRlbXBsYXRlcyBkZWxldGVkJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucHVyZ2VBbGwgPSBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgVGVtcGxhdGUucnVuKCkudGhlbihmdW5jdGlvbiAodGVtcGxhdGVzKSB7XG4gICAgdmFyIGFsbCA9IHRlbXBsYXRlcy5tYXAoZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGUucHVyZ2UoKTtcbiAgICB9KTtcbiAgICBfcHJvbWlzZTIuZGVmYXVsdC5hbGwoYWxsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcy5qc29uKHtcbiAgICAgICAgbXNnOiAnYWxsIHRlbXBsYXRlcyBwdXJnZWQnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiAoMCwgX0Vycm9yLmhhbmRsZUVycm9yKShyZXMsIGVycik7XG4gIH0pO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlJyk7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxudmFyIF9FcnJvciA9IHJlcXVpcmUoJy4vRXJyb3InKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFZhbHVlID0gcmVxdWlyZSgnLi4vbW9kZWxzL1ZhbHVlJyk7XG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gIHZhciBpZCA9IHJlcS5wYXJhbXMuaWQ7XG4gIFZhbHVlLmdldChpZCkuZ2V0Sm9pbih7IHRlbXBsYXRlOiB0cnVlIH0pLnJ1bigpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmVzLmpzb24oe1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gKDAsIF9FcnJvci5oYW5kbGVFcnJvcikocmVzLCBlcnIpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZ2V0QWxsID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gIFZhbHVlLmdldEpvaW4oeyB0ZW1wbGF0ZTogdHJ1ZSB9KS5ydW4oKS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICByZXMuanNvbih7XG4gICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgIH0pO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuICgwLCBfRXJyb3IuaGFuZGxlRXJyb3IpKHJlcywgZXJyKTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlbGV0ZUFsbCA9IGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICBWYWx1ZS5ydW4oKS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB2YXIgYWxsID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5kZWxldGUoKTtcbiAgICB9KTtcbiAgICBfcHJvbWlzZTIuZGVmYXVsdC5hbGwoYWxsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcy5qc29uKHtcbiAgICAgICAgbXNnOiAnYWxsIHZhbHVlcyBwdXJnZWQnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiAoMCwgX0Vycm9yLmhhbmRsZUVycm9yKShyZXMsIGVycik7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5wdXJnZUFsbCA9IGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICBWYWx1ZS5ydW4oKS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB2YXIgYWxsID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5wdXJnZSgpO1xuICAgIH0pO1xuICAgIF9wcm9taXNlMi5kZWZhdWx0LmFsbChhbGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmVzLmpzb24oe1xuICAgICAgICBtc2c6ICdhbGwgdmFsdWVzIHB1cmdlZCdcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuICgwLCBfRXJyb3IuaGFuZGxlRXJyb3IpKHJlcywgZXJyKTtcbiAgfSk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnZG90ZW52JykuY29uZmlnKCk7XG5cbnZhciB0aGlua3kgPSByZXF1aXJlKCd0aGlua3knKSh7XG4gIGhvc3Q6IHByb2Nlc3MuZW52LkhPU1QsXG4gIHBvcnQ6IHByb2Nlc3MuZW52LlBPUlQsXG4gIGRiOiBwcm9jZXNzLmVudi5EQlxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGhpbmt5OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9kYiA9IHJlcXVpcmUoJy4uL2RiJyk7XG5cbnZhciBfZGIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUGFnZSA9IF9kYjIuZGVmYXVsdC5jcmVhdGVNb2RlbCgnUGFnZScsIHtcbiAgaWQ6IF9kYjIuZGVmYXVsdC50eXBlLnN0cmluZygpLFxuICAvLyB0aXRsZTogdGhpbmt5LnR5cGUuc3RyaW5nKCksXG4gIHR5cGU6IF9kYjIuZGVmYXVsdC50eXBlLnN0cmluZygpLFxuICB0aXRsZTogX2RiMi5kZWZhdWx0LnR5cGUudmlydHVhbCgpLmRlZmF1bHQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcyAmJiB0aGlzLnZhbHVlcy5maW5kKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdi5rZXkgPT09ICd0aXRsZSc7XG4gICAgfSkgPyB0aGlzLnZhbHVlcy5maW5kKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdi5rZXkgPT09ICd0aXRsZSc7XG4gICAgfSkudmFsdWUgOiAnTm8gdGl0bGUgZm91bmQnO1xuICB9KVxufSk7IC8vIGltcG9ydCBjeXBoZXIgZnJvbSAnY3lwaGVyLXF1ZXJ5JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2U7XG5cbi8vIGNvbnN0IFZhbHVlID0gcmVxdWlyZSgnLi9WYWx1ZScpO1xuLy8gUGFnZS5oYXNNYW55KFZhbHVlLCAndmFsdWVzJywgJ2lkJywgJ3BhZ2VJZCcpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9kYiA9IHJlcXVpcmUoJy4uL2RiJyk7XG5cbnZhciBfZGIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgVGVtcGxhdGUgPSBudWxsOyAvLyBpbXBvcnQgY3lwaGVyIGZyb20gJ2N5cGhlci1xdWVyeSc7XG5cblxuaWYgKCFUZW1wbGF0ZSkge1xuICBjb25zb2xlLmxvZygnQ1JFQVRJTkcgVEVNUExBVEUnLCBUZW1wbGF0ZSk7XG4gIFRlbXBsYXRlID0gX2RiMi5kZWZhdWx0LmNyZWF0ZU1vZGVsKCdUZW1wbGF0ZScsIHtcbiAgICBpZDogX2RiMi5kZWZhdWx0LnR5cGUuc3RyaW5nKCksXG4gICAgbmFtZTogX2RiMi5kZWZhdWx0LnR5cGUuc3RyaW5nKCksXG4gICAgdGl0bGU6IF9kYjIuZGVmYXVsdC50eXBlLnZpcnR1YWwoKS5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcyA/IHRoaXMudmFsdWVzLmZpbmQoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYua2V5ID09PSAndGl0bGUnO1xuICAgICAgfSkudmFsdWUgOiAnTm8gdGl0bGUgZm91bmQnO1xuICAgIH0pXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlbXBsYXRlO1xuXG52YXIgVmFsdWUgPSByZXF1aXJlKCcuL1ZhbHVlJyk7XG5UZW1wbGF0ZS5oYXNNYW55KFZhbHVlLCAndmFsdWVzJywgJ2lkJywgJ3RlbXBsYXRlSWQnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZGIgPSByZXF1aXJlKCcuLi9kYicpO1xuXG52YXIgX2RiMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFZhbHVlID0gbnVsbDsgLy8gaW1wb3J0IGN5cGhlciBmcm9tICdjeXBoZXItcXVlcnknO1xuXG5pZiAoIVZhbHVlKSB7XG4gIGNvbnNvbGUubG9nKCdDUkVBVElORyBWYWx1ZScsIFZhbHVlKTtcbiAgVmFsdWUgPSBfZGIyLmRlZmF1bHQuY3JlYXRlTW9kZWwoJ1ZhbHVlJywge1xuICAgIGlkOiBfZGIyLmRlZmF1bHQudHlwZS5zdHJpbmcoKSxcbiAgICB0ZW1wbGF0ZUlkOiBfZGIyLmRlZmF1bHQudHlwZS5zdHJpbmcoKSxcbiAgICBrZXk6IF9kYjIuZGVmYXVsdC50eXBlLnN0cmluZygpLFxuICAgIHZhbHVlOiBfZGIyLmRlZmF1bHQudHlwZS5zdHJpbmcoKVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWYWx1ZTtcblxudmFyIFRlbXBsYXRlID0gcmVxdWlyZSgnLi9UZW1wbGF0ZScpO1xuVmFsdWUuYmVsb25nc1RvKFRlbXBsYXRlLCAndGVtbGF0ZScsICd0ZW1wbGF0ZUlkJywgJ2lkJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XG5cbnZhciBfZXhwcmVzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHByZXNzKTtcblxudmFyIF9ib2R5UGFyc2VyID0gcmVxdWlyZSgnYm9keS1wYXJzZXInKTtcblxudmFyIF9ib2R5UGFyc2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JvZHlQYXJzZXIpO1xuXG52YXIgX2NvcnMgPSByZXF1aXJlKCdjb3JzJyk7XG5cbnZhciBfY29yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JzKTtcblxudmFyIF9WYWx1ZXMgPSByZXF1aXJlKCcuL2FwaS9jb250cm9sbGVycy9WYWx1ZXMnKTtcblxudmFyIF9WYWx1ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsdWVzKTtcblxudmFyIF9QYWdlcyA9IHJlcXVpcmUoJy4vYXBpL2NvbnRyb2xsZXJzL1BhZ2VzJyk7XG5cbnZhciBfUGFnZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFnZXMpO1xuXG52YXIgX1RlbXBsYXRlcyA9IHJlcXVpcmUoJy4vYXBpL2NvbnRyb2xsZXJzL1RlbXBsYXRlcycpO1xuXG52YXIgX1RlbXBsYXRlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UZW1wbGF0ZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcm91dGVyID0gbmV3IF9leHByZXNzLlJvdXRlcigpO1xuLy8gaW1wb3J0IHRlc3RQYWdlIGZyb20gJy4vc2FtcGxlLWRhdGEvZHJhZnQtanMtc2FtcGxlJztcblxuXG5yb3V0ZXIudXNlKCgwLCBfY29yczIuZGVmYXVsdCkoKSk7XG4vLyBwYXJzZSBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcbnJvdXRlci51c2UoX2JvZHlQYXJzZXIyLmRlZmF1bHQudXJsZW5jb2RlZCh7IGV4dGVuZGVkOiBmYWxzZSB9KSk7XG4vLyBwYXJzZSBhcHBsaWNhdGlvbi9qc29uXG5yb3V0ZXIudXNlKF9ib2R5UGFyc2VyMi5kZWZhdWx0Lmpzb24oKSk7XG5cbi8qXG4gKiBCTE9DS1NcbiAqL1xuXG5yb3V0ZXIucm91dGUoJy9hcGkvdmFsdWVzJykuZ2V0KF9WYWx1ZXMyLmRlZmF1bHQuZ2V0QWxsKTtcbnJvdXRlci5yb3V0ZSgnL2FwaS92YWx1ZXMvOmlkJykuZGVsZXRlKF9WYWx1ZXMyLmRlZmF1bHQuZ2V0KTtcbnJvdXRlci5yb3V0ZSgnL2FwaS92YWx1ZXMnKS5kZWxldGUoX1ZhbHVlczIuZGVmYXVsdC5kZWxldGVBbGwpO1xucm91dGVyLnJvdXRlKCcvYXBpL3ZhbHVlcy9wdXJnZScpLmRlbGV0ZShfVmFsdWVzMi5kZWZhdWx0LnB1cmdlQWxsKTtcblxuLypcbiAqIFRlbXBsYXRlc1xuICovXG5cbnJvdXRlci5yb3V0ZSgnL2FwaS90ZW1wbGF0ZXMnKS5nZXQoX1RlbXBsYXRlczIuZGVmYXVsdC5nZXRBbGwpO1xucm91dGVyLnJvdXRlKCcvYXBpL3RlbXBsYXRlcy86aWQnKS5kZWxldGUoX1RlbXBsYXRlczIuZGVmYXVsdC5nZXQpO1xucm91dGVyLnJvdXRlKCcvYXBpL3RlbXBsYXRlcy86YnkvOnZhbHVlJykuZ2V0KF9UZW1wbGF0ZXMyLmRlZmF1bHQuZ2V0QnkpO1xucm91dGVyLnJvdXRlKCcvYXBpL3RlbXBsYXRlcycpLnBvc3QoX1RlbXBsYXRlczIuZGVmYXVsdC5jcmVhdGUpO1xucm91dGVyLnJvdXRlKCcvYXBpL3RlbXBsYXRlcycpLnBhdGNoKF9UZW1wbGF0ZXMyLmRlZmF1bHQucGF0Y2gpO1xucm91dGVyLnJvdXRlKCcvYXBpL3RlbXBsYXRlcycpLmRlbGV0ZShfVGVtcGxhdGVzMi5kZWZhdWx0LmRlbGV0ZUFsbCk7XG5yb3V0ZXIucm91dGUoJy9hcGkvdGVtcGxhdGVzL3B1cmdlJykuZGVsZXRlKF9UZW1wbGF0ZXMyLmRlZmF1bHQucHVyZ2VBbGwpO1xuXG5yb3V0ZXIucm91dGUoJy9hcGkvcGFnZXMnKS5nZXQoX1BhZ2VzMi5kZWZhdWx0LmdldEFsbCk7XG5yb3V0ZXIucm91dGUoJy9hcGkvcGFnZXMvOmlkJykuZGVsZXRlKF9QYWdlczIuZGVmYXVsdC5nZXQpO1xucm91dGVyLnJvdXRlKCcvYXBpL3BhZ2VzLzpieS86dmFsdWUnKS5nZXQoX1BhZ2VzMi5kZWZhdWx0LmdldEJ5KTtcbnJvdXRlci5yb3V0ZSgnL2FwaS9wYWdlcycpLnBvc3QoX1BhZ2VzMi5kZWZhdWx0LmNyZWF0ZSk7XG5yb3V0ZXIucm91dGUoJy9hcGkvcGFnZXMnKS5wYXRjaChfUGFnZXMyLmRlZmF1bHQucGF0Y2gpO1xucm91dGVyLnJvdXRlKCcvYXBpL3BhZ2VzJykuZGVsZXRlKF9QYWdlczIuZGVmYXVsdC5kZWxldGVBbGwpO1xucm91dGVyLnJvdXRlKCcvYXBpL3BhZ2VzL3B1cmdlJykuZGVsZXRlKF9QYWdlczIuZGVmYXVsdC5wdXJnZUFsbCk7XG5cbi8vIHJvdXRlci5yb3V0ZSgnKicpLmdldChyb3V0ZXMuaW5kZXgpO1xuXG4vLyBTdGFydCBzZXJ2ZXJcbi8vIGFwcC5saXN0ZW4oJzMwMDAnLCAoKSA9PiB7XG4vLyAgICAgLy8gY29uc29sZS5sb2coJ0V4cHJlc3Mgc2VydmVyIGxpc3RlbmluZyBvbiBwb3J0ICVkIGluICVzIG1vZGUnLFxuLy8gICAgIC8vICAgICBjb25maWcuZXhwcmVzc1BvcnQsIGFwcC5zZXR0aW5ncy5lbnYpO1xuLy8gfSk7XG5cbi8vIGNvbnN0IGV4aXRIYW5kbGVyID0gKCkgPT4ge1xuLy8gICBjb25zb2xlLmxvZygnY2xvc2luZyBkcml2ZXIgb24gcHJvZ3JhbW0gZXhpdCcpO1xuLy8gICBwcm9jZXNzLmV4aXQoMCk7XG4vLyB9O1xuXG4vLyBwcm9jZXNzLm9uKCdTSUdJTlQnLCAoKSA9PiB7IHByb2Nlc3MuZXhpdCgwKTsgfSk7XG4vLyBwcm9jZXNzLm9uKCdleGl0JywgZXhpdEhhbmRsZXIpO1xuXG4vLyBwcm9jZXNzLm9uY2UoJ1NJR1VTUjInLCAoKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKCdbbm9kZW1vbl0gY2xlYW51cCcpO1xuLy8gfSk7XG4vLyBcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcm91dGVyO1xufTsiLCIoZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuICB2YXIgdmFyeSA9IHJlcXVpcmUoJ3ZhcnknKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBvcmlnaW46ICcqJyxcbiAgICAgIG1ldGhvZHM6ICdHRVQsSEVBRCxQVVQsUEFUQ0gsUE9TVCxERUxFVEUnLFxuICAgICAgcHJlZmxpZ2h0Q29udGludWU6IGZhbHNlLFxuICAgICAgb3B0aW9uc1N1Y2Nlc3NTdGF0dXM6IDIwNFxuICAgIH07XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmcocykge1xuICAgIHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgfHwgcyBpbnN0YW5jZW9mIFN0cmluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JpZ2luQWxsb3dlZChvcmlnaW4sIGFsbG93ZWRPcmlnaW4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvd2VkT3JpZ2luKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd2VkT3JpZ2luLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpc09yaWdpbkFsbG93ZWQob3JpZ2luLCBhbGxvd2VkT3JpZ2luW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhhbGxvd2VkT3JpZ2luKSkge1xuICAgICAgcmV0dXJuIG9yaWdpbiA9PT0gYWxsb3dlZE9yaWdpbjtcbiAgICB9IGVsc2UgaWYgKGFsbG93ZWRPcmlnaW4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBhbGxvd2VkT3JpZ2luLnRlc3Qob3JpZ2luKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICEhYWxsb3dlZE9yaWdpbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmVPcmlnaW4ob3B0aW9ucywgcmVxKSB7XG4gICAgdmFyIHJlcXVlc3RPcmlnaW4gPSByZXEuaGVhZGVycy5vcmlnaW4sXG4gICAgICBoZWFkZXJzID0gW10sXG4gICAgICBpc0FsbG93ZWQ7XG5cbiAgICBpZiAoIW9wdGlvbnMub3JpZ2luIHx8IG9wdGlvbnMub3JpZ2luID09PSAnKicpIHtcbiAgICAgIC8vIGFsbG93IGFueSBvcmlnaW5cbiAgICAgIGhlYWRlcnMucHVzaChbe1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLFxuICAgICAgICB2YWx1ZTogJyonXG4gICAgICB9XSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhvcHRpb25zLm9yaWdpbikpIHtcbiAgICAgIC8vIGZpeGVkIG9yaWdpblxuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbicsXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLm9yaWdpblxuICAgICAgfV0pO1xuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ1ZhcnknLFxuICAgICAgICB2YWx1ZTogJ09yaWdpbidcbiAgICAgIH1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBbGxvd2VkID0gaXNPcmlnaW5BbGxvd2VkKHJlcXVlc3RPcmlnaW4sIG9wdGlvbnMub3JpZ2luKTtcbiAgICAgIC8vIHJlZmxlY3Qgb3JpZ2luXG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJyxcbiAgICAgICAgdmFsdWU6IGlzQWxsb3dlZCA/IHJlcXVlc3RPcmlnaW4gOiBmYWxzZVxuICAgICAgfV0pO1xuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ1ZhcnknLFxuICAgICAgICB2YWx1ZTogJ09yaWdpbidcbiAgICAgIH1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU1ldGhvZHMob3B0aW9ucykge1xuICAgIHZhciBtZXRob2RzID0gb3B0aW9ucy5tZXRob2RzO1xuICAgIGlmIChtZXRob2RzLmpvaW4pIHtcbiAgICAgIG1ldGhvZHMgPSBvcHRpb25zLm1ldGhvZHMuam9pbignLCcpOyAvLyAubWV0aG9kcyBpcyBhbiBhcnJheSwgc28gdHVybiBpdCBpbnRvIGEgc3RyaW5nXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzJyxcbiAgICAgIHZhbHVlOiBtZXRob2RzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5jcmVkZW50aWFscyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHMnLFxuICAgICAgICB2YWx1ZTogJ3RydWUnXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZUFsbG93ZWRIZWFkZXJzKG9wdGlvbnMsIHJlcSkge1xuICAgIHZhciBhbGxvd2VkSGVhZGVycyA9IG9wdGlvbnMuYWxsb3dlZEhlYWRlcnMgfHwgb3B0aW9ucy5oZWFkZXJzO1xuICAgIHZhciBoZWFkZXJzID0gW107XG5cbiAgICBpZiAoIWFsbG93ZWRIZWFkZXJzKSB7XG4gICAgICBhbGxvd2VkSGVhZGVycyA9IHJlcS5oZWFkZXJzWydhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnXTsgLy8gLmhlYWRlcnMgd2Fzbid0IHNwZWNpZmllZCwgc28gcmVmbGVjdCB0aGUgcmVxdWVzdCBoZWFkZXJzXG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnVmFyeScsXG4gICAgICAgIHZhbHVlOiAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJ1xuICAgICAgfV0pO1xuICAgIH0gZWxzZSBpZiAoYWxsb3dlZEhlYWRlcnMuam9pbikge1xuICAgICAgYWxsb3dlZEhlYWRlcnMgPSBhbGxvd2VkSGVhZGVycy5qb2luKCcsJyk7IC8vIC5oZWFkZXJzIGlzIGFuIGFycmF5LCBzbyB0dXJuIGl0IGludG8gYSBzdHJpbmdcbiAgICB9XG4gICAgaWYgKGFsbG93ZWRIZWFkZXJzICYmIGFsbG93ZWRIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnLFxuICAgICAgICB2YWx1ZTogYWxsb3dlZEhlYWRlcnNcbiAgICAgIH1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZUV4cG9zZWRIZWFkZXJzKG9wdGlvbnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuZXhwb3NlZEhlYWRlcnM7XG4gICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMuam9pbikge1xuICAgICAgaGVhZGVycyA9IGhlYWRlcnMuam9pbignLCcpOyAvLyAuaGVhZGVycyBpcyBhbiBhcnJheSwgc28gdHVybiBpdCBpbnRvIGEgc3RyaW5nXG4gICAgfVxuICAgIGlmIChoZWFkZXJzICYmIGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycsXG4gICAgICAgIHZhbHVlOiBoZWFkZXJzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU1heEFnZShvcHRpb25zKSB7XG4gICAgdmFyIG1heEFnZSA9IG9wdGlvbnMubWF4QWdlICYmIG9wdGlvbnMubWF4QWdlLnRvU3RyaW5nKCk7XG4gICAgaWYgKG1heEFnZSAmJiBtYXhBZ2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1NYXgtQWdlJyxcbiAgICAgICAgdmFsdWU6IG1heEFnZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUhlYWRlcnMoaGVhZGVycywgcmVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBoZWFkZXJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIGhlYWRlciA9IGhlYWRlcnNbaV07XG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgICAgICBhcHBseUhlYWRlcnMoaGVhZGVyLCByZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGhlYWRlci5rZXkgPT09ICdWYXJ5JyAmJiBoZWFkZXIudmFsdWUpIHtcbiAgICAgICAgICB2YXJ5KHJlcywgaGVhZGVyLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIudmFsdWUpIHtcbiAgICAgICAgICByZXMuc2V0SGVhZGVyKGhlYWRlci5rZXksIGhlYWRlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JzKG9wdGlvbnMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgdmFyIGhlYWRlcnMgPSBbXSxcbiAgICAgIG1ldGhvZCA9IHJlcS5tZXRob2QgJiYgcmVxLm1ldGhvZC50b1VwcGVyQ2FzZSAmJiByZXEubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnT1BUSU9OUycpIHtcbiAgICAgIC8vIHByZWZsaWdodFxuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZU9yaWdpbihvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVDcmVkZW50aWFscyhvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVNZXRob2RzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZUFsbG93ZWRIZWFkZXJzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZU1heEFnZShvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVFeHBvc2VkSGVhZGVycyhvcHRpb25zLCByZXEpKTtcbiAgICAgIGFwcGx5SGVhZGVycyhoZWFkZXJzLCByZXMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5wcmVmbGlnaHRDb250aW51ZSApIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2FmYXJpIChhbmQgcG90ZW50aWFsbHkgb3RoZXIgYnJvd3NlcnMpIG5lZWQgY29udGVudC1sZW5ndGggMCxcbiAgICAgICAgLy8gICBmb3IgMjA0IG9yIHRoZXkganVzdCBoYW5nIHdhaXRpbmcgZm9yIGEgYm9keVxuICAgICAgICByZXMuc3RhdHVzQ29kZSA9IG9wdGlvbnMub3B0aW9uc1N1Y2Nlc3NTdGF0dXMgfHwgZGVmYXVsdHMub3B0aW9uc1N1Y2Nlc3NTdGF0dXM7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgJzAnKTtcbiAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhY3R1YWwgcmVzcG9uc2VcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVPcmlnaW4ob3B0aW9ucywgcmVxKSk7XG4gICAgICBoZWFkZXJzLnB1c2goY29uZmlndXJlQ3JlZGVudGlhbHMob3B0aW9ucywgcmVxKSk7XG4gICAgICBoZWFkZXJzLnB1c2goY29uZmlndXJlRXhwb3NlZEhlYWRlcnMob3B0aW9ucywgcmVxKSk7XG4gICAgICBhcHBseUhlYWRlcnMoaGVhZGVycywgcmVzKTtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtaWRkbGV3YXJlV3JhcHBlcihvKSB7XG4gICAgLy8gaWYgb3B0aW9ucyBhcmUgc3RhdGljIChlaXRoZXIgdmlhIGRlZmF1bHRzIG9yIGN1c3RvbSBvcHRpb25zIHBhc3NlZCBpbiksIHdyYXAgaW4gYSBmdW5jdGlvblxuICAgIHZhciBvcHRpb25zQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9uc0NhbGxiYWNrID0gbztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uc0NhbGxiYWNrID0gZnVuY3Rpb24gKHJlcSwgY2IpIHtcbiAgICAgICAgY2IobnVsbCwgbyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBjb3JzTWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCkge1xuICAgICAgb3B0aW9uc0NhbGxiYWNrKHJlcSwgZnVuY3Rpb24gKGVyciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb3JzT3B0aW9ucyA9IGFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBvcmlnaW5DYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgaWYgKGNvcnNPcHRpb25zLm9yaWdpbiAmJiB0eXBlb2YgY29yc09wdGlvbnMub3JpZ2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcmlnaW5DYWxsYmFjayA9IGNvcnNPcHRpb25zLm9yaWdpbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvcnNPcHRpb25zLm9yaWdpbikge1xuICAgICAgICAgICAgb3JpZ2luQ2FsbGJhY2sgPSBmdW5jdGlvbiAob3JpZ2luLCBjYikge1xuICAgICAgICAgICAgICBjYihudWxsLCBjb3JzT3B0aW9ucy5vcmlnaW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3JpZ2luQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9yaWdpbkNhbGxiYWNrKHJlcS5oZWFkZXJzLm9yaWdpbiwgZnVuY3Rpb24gKGVycjIsIG9yaWdpbikge1xuICAgICAgICAgICAgICBpZiAoZXJyMiB8fCAhb3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgbmV4dChlcnIyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3JzT3B0aW9ucy5vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgY29ycyhjb3JzT3B0aW9ucywgcmVxLCByZXMsIG5leHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGNhbiBwYXNzIGVpdGhlciBhbiBvcHRpb25zIGhhc2gsIGFuIG9wdGlvbnMgZGVsZWdhdGUsIG9yIG5vdGhpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBtaWRkbGV3YXJlV3JhcHBlcjtcblxufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkc2NvcGUsIGNvbmZsaWN0LCBjb25mbGljdFJlc29sdXRpb24gPSBbXTtcbmlmICh0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHtcbiAgJHNjb3BlID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAkc2NvcGUgPSB3aW5kb3c7XG59IGVsc2Uge1xuICAkc2NvcGUgPSB7fTtcbn1cbmNvbmZsaWN0ID0gJHNjb3BlLkRlZXBEaWZmO1xuaWYgKGNvbmZsaWN0KSB7XG4gIGNvbmZsaWN0UmVzb2x1dGlvbi5wdXNoKFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uZmxpY3QgJiYgJHNjb3BlLkRlZXBEaWZmID09PSBhY2N1bXVsYXRlRGlmZikge1xuICAgICAgICAkc2NvcGUuRGVlcERpZmYgPSBjb25mbGljdDtcbiAgICAgICAgY29uZmxpY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbi8vIG5vZGVqcyBjb21wYXRpYmxlIG9uIHNlcnZlciBzaWRlIGFuZCBpbiB0aGUgYnJvd3Nlci5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gRGlmZihraW5kLCBwYXRoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAna2luZCcsIHtcbiAgICB2YWx1ZToga2luZCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBpZiAocGF0aCAmJiBwYXRoLmxlbmd0aCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGF0aCcsIHtcbiAgICAgIHZhbHVlOiBwYXRoLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIERpZmZFZGl0KHBhdGgsIG9yaWdpbiwgdmFsdWUpIHtcbiAgRGlmZkVkaXQuc3VwZXJfLmNhbGwodGhpcywgJ0UnLCBwYXRoKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsaHMnLCB7XG4gICAgdmFsdWU6IG9yaWdpbixcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JocycsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmluaGVyaXRzKERpZmZFZGl0LCBEaWZmKTtcblxuZnVuY3Rpb24gRGlmZk5ldyhwYXRoLCB2YWx1ZSkge1xuICBEaWZmTmV3LnN1cGVyXy5jYWxsKHRoaXMsICdOJywgcGF0aCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmhzJywge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuaW5oZXJpdHMoRGlmZk5ldywgRGlmZik7XG5cbmZ1bmN0aW9uIERpZmZEZWxldGVkKHBhdGgsIHZhbHVlKSB7XG4gIERpZmZEZWxldGVkLnN1cGVyXy5jYWxsKHRoaXMsICdEJywgcGF0aCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGhzJywge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuaW5oZXJpdHMoRGlmZkRlbGV0ZWQsIERpZmYpO1xuXG5mdW5jdGlvbiBEaWZmQXJyYXkocGF0aCwgaW5kZXgsIGl0ZW0pIHtcbiAgRGlmZkFycmF5LnN1cGVyXy5jYWxsKHRoaXMsICdBJywgcGF0aCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaW5kZXgnLCB7XG4gICAgdmFsdWU6IGluZGV4LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXRlbScsIHtcbiAgICB2YWx1ZTogaXRlbSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuaW5oZXJpdHMoRGlmZkFycmF5LCBEaWZmKTtcblxuZnVuY3Rpb24gYXJyYXlSZW1vdmUoYXJyLCBmcm9tLCB0bykge1xuICB2YXIgcmVzdCA9IGFyci5zbGljZSgodG8gfHwgZnJvbSkgKyAxIHx8IGFyci5sZW5ndGgpO1xuICBhcnIubGVuZ3RoID0gZnJvbSA8IDAgPyBhcnIubGVuZ3RoICsgZnJvbSA6IGZyb207XG4gIGFyci5wdXNoLmFwcGx5KGFyciwgcmVzdCk7XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHJlYWxUeXBlT2Yoc3ViamVjdCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0O1xuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGlmIChzdWJqZWN0ID09PSBNYXRoKSB7XG4gICAgcmV0dXJuICdtYXRoJztcbiAgfSBlbHNlIGlmIChzdWJqZWN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN1YmplY3QpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJqZWN0LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nICYmIC9eXFwvLipcXC8vLnRlc3Qoc3ViamVjdC50b1N0cmluZygpKSkge1xuICAgIHJldHVybiAncmVnZXhwJztcbiAgfVxuICByZXR1cm4gJ29iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGRlZXBEaWZmKGxocywgcmhzLCBjaGFuZ2VzLCBwcmVmaWx0ZXIsIHBhdGgsIGtleSwgc3RhY2spIHtcbiAgcGF0aCA9IHBhdGggfHwgW107XG4gIHN0YWNrID0gc3RhY2sgfHwgW107XG4gIHZhciBjdXJyZW50UGF0aCA9IHBhdGguc2xpY2UoMCk7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChwcmVmaWx0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YocHJlZmlsdGVyKSA9PT0gJ2Z1bmN0aW9uJyAmJiBwcmVmaWx0ZXIoY3VycmVudFBhdGgsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuOyB9IGVsc2UgaWYgKHR5cGVvZihwcmVmaWx0ZXIpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocHJlZmlsdGVyLnByZWZpbHRlciAmJiBwcmVmaWx0ZXIucHJlZmlsdGVyKGN1cnJlbnRQYXRoLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuOyB9XG4gICAgICAgIGlmIChwcmVmaWx0ZXIubm9ybWFsaXplKSB7XG4gICAgICAgICAgdmFyIGFsdCA9IHByZWZpbHRlci5ub3JtYWxpemUoY3VycmVudFBhdGgsIGtleSwgbGhzLCByaHMpO1xuICAgICAgICAgIGlmIChhbHQpIHtcbiAgICAgICAgICAgIGxocyA9IGFsdFswXTtcbiAgICAgICAgICAgIHJocyA9IGFsdFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudFBhdGgucHVzaChrZXkpO1xuICB9XG5cbiAgLy8gVXNlIHN0cmluZyBjb21wYXJpc29uIGZvciByZWdleGVzXG4gIGlmIChyZWFsVHlwZU9mKGxocykgPT09ICdyZWdleHAnICYmIHJlYWxUeXBlT2YocmhzKSA9PT0gJ3JlZ2V4cCcpIHtcbiAgICBsaHMgPSBsaHMudG9TdHJpbmcoKTtcbiAgICByaHMgPSByaHMudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhciBsdHlwZSA9IHR5cGVvZiBsaHM7XG4gIHZhciBydHlwZSA9IHR5cGVvZiByaHM7XG5cbiAgdmFyIGxkZWZpbmVkID0gbHR5cGUgIT09ICd1bmRlZmluZWQnIHx8IChzdGFjayAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5saHMgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ubGhzLmhhc093blByb3BlcnR5KGtleSkpO1xuICB2YXIgcmRlZmluZWQgPSBydHlwZSAhPT0gJ3VuZGVmaW5lZCcgfHwgKHN0YWNrICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnJocyAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5yaHMuaGFzT3duUHJvcGVydHkoa2V5KSk7XG5cbiAgaWYgKCFsZGVmaW5lZCAmJiByZGVmaW5lZCkge1xuICAgIGNoYW5nZXMobmV3IERpZmZOZXcoY3VycmVudFBhdGgsIHJocykpO1xuICB9IGVsc2UgaWYgKCFyZGVmaW5lZCAmJiBsZGVmaW5lZCkge1xuICAgIGNoYW5nZXMobmV3IERpZmZEZWxldGVkKGN1cnJlbnRQYXRoLCBsaHMpKTtcbiAgfSBlbHNlIGlmIChyZWFsVHlwZU9mKGxocykgIT09IHJlYWxUeXBlT2YocmhzKSkge1xuICAgIGNoYW5nZXMobmV3IERpZmZFZGl0KGN1cnJlbnRQYXRoLCBsaHMsIHJocykpO1xuICB9IGVsc2UgaWYgKHJlYWxUeXBlT2YobGhzKSA9PT0gJ2RhdGUnICYmIChsaHMgLSByaHMpICE9PSAwKSB7XG4gICAgY2hhbmdlcyhuZXcgRGlmZkVkaXQoY3VycmVudFBhdGgsIGxocywgcmhzKSk7XG4gIH0gZWxzZSBpZiAobHR5cGUgPT09ICdvYmplY3QnICYmIGxocyAhPT0gbnVsbCAmJiByaHMgIT09IG51bGwpIHtcbiAgICBpZiAoIXN0YWNrLmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB4LmxocyA9PT0gbGhzOyB9KS5sZW5ndGgpIHtcbiAgICAgIHN0YWNrLnB1c2goeyBsaHM6IGxocywgcmhzOiByaHMgfSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShsaHMpKSB7XG4gICAgICAgIHZhciBpLCBsZW4gPSBsaHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPj0gcmhzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2hhbmdlcyhuZXcgRGlmZkFycmF5KGN1cnJlbnRQYXRoLCBpLCBuZXcgRGlmZkRlbGV0ZWQodW5kZWZpbmVkLCBsaHNbaV0pKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZXBEaWZmKGxoc1tpXSwgcmhzW2ldLCBjaGFuZ2VzLCBwcmVmaWx0ZXIsIGN1cnJlbnRQYXRoLCBpLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgcmhzLmxlbmd0aCkge1xuICAgICAgICAgIGNoYW5nZXMobmV3IERpZmZBcnJheShjdXJyZW50UGF0aCwgaSwgbmV3IERpZmZOZXcodW5kZWZpbmVkLCByaHNbaSsrXSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFrZXlzID0gT2JqZWN0LmtleXMobGhzKTtcbiAgICAgICAgdmFyIHBrZXlzID0gT2JqZWN0LmtleXMocmhzKTtcbiAgICAgICAgYWtleXMuZm9yRWFjaChmdW5jdGlvbihrLCBpKSB7XG4gICAgICAgICAgdmFyIG90aGVyID0gcGtleXMuaW5kZXhPZihrKTtcbiAgICAgICAgICBpZiAob3RoZXIgPj0gMCkge1xuICAgICAgICAgICAgZGVlcERpZmYobGhzW2tdLCByaHNba10sIGNoYW5nZXMsIHByZWZpbHRlciwgY3VycmVudFBhdGgsIGssIHN0YWNrKTtcbiAgICAgICAgICAgIHBrZXlzID0gYXJyYXlSZW1vdmUocGtleXMsIG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVlcERpZmYobGhzW2tdLCB1bmRlZmluZWQsIGNoYW5nZXMsIHByZWZpbHRlciwgY3VycmVudFBhdGgsIGssIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwa2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICBkZWVwRGlmZih1bmRlZmluZWQsIHJoc1trXSwgY2hhbmdlcywgcHJlZmlsdGVyLCBjdXJyZW50UGF0aCwgaywgc3RhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIGlmIChsaHMgIT09IHJocykge1xuICAgICAgLy8gbGhzIGlzIGNvbnRhaW5zIGEgY3ljbGUgYXQgdGhpcyBlbGVtZW50IGFuZCBpdCBkaWZmZXJzIGZyb20gcmhzXG4gICAgICBjaGFuZ2VzKG5ldyBEaWZmRWRpdChjdXJyZW50UGF0aCwgbGhzLCByaHMpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGhzICE9PSByaHMpIHtcbiAgICBpZiAoIShsdHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4obGhzKSAmJiBpc05hTihyaHMpKSkge1xuICAgICAgY2hhbmdlcyhuZXcgRGlmZkVkaXQoY3VycmVudFBhdGgsIGxocywgcmhzKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaWZmKGxocywgcmhzLCBwcmVmaWx0ZXIsIGFjY3VtKSB7XG4gIGFjY3VtID0gYWNjdW0gfHwgW107XG4gIGRlZXBEaWZmKGxocywgcmhzLFxuICAgIGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIGFjY3VtLnB1c2goZGlmZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcmVmaWx0ZXIpO1xuICByZXR1cm4gKGFjY3VtLmxlbmd0aCkgPyBhY2N1bSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYXBwbHlBcnJheUNoYW5nZShhcnIsIGluZGV4LCBjaGFuZ2UpIHtcbiAgaWYgKGNoYW5nZS5wYXRoICYmIGNoYW5nZS5wYXRoLmxlbmd0aCkge1xuICAgIHZhciBpdCA9IGFycltpbmRleF0sXG4gICAgICBpLCB1ID0gY2hhbmdlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdTsgaSsrKSB7XG4gICAgICBpdCA9IGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICB9XG4gICAgc3dpdGNoIChjaGFuZ2Uua2luZCkge1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGFwcGx5QXJyYXlDaGFuZ2UoaXRbY2hhbmdlLnBhdGhbaV1dLCBjaGFuZ2UuaW5kZXgsIGNoYW5nZS5pdGVtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgZGVsZXRlIGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFJzpcbiAgICAgIGNhc2UgJ04nOlxuICAgICAgICBpdFtjaGFuZ2UucGF0aFtpXV0gPSBjaGFuZ2UucmhzO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChjaGFuZ2Uua2luZCkge1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGFwcGx5QXJyYXlDaGFuZ2UoYXJyW2luZGV4XSwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGFyciA9IGFycmF5UmVtb3ZlKGFyciwgaW5kZXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgY2FzZSAnTic6XG4gICAgICAgIGFycltpbmRleF0gPSBjaGFuZ2UucmhzO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gYXBwbHlDaGFuZ2UodGFyZ2V0LCBzb3VyY2UsIGNoYW5nZSkge1xuICBpZiAodGFyZ2V0ICYmIHNvdXJjZSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmtpbmQpIHtcbiAgICB2YXIgaXQgPSB0YXJnZXQsXG4gICAgICBpID0gLTEsXG4gICAgICBsYXN0ID0gY2hhbmdlLnBhdGggPyBjaGFuZ2UucGF0aC5sZW5ndGggLSAxIDogMDtcbiAgICB3aGlsZSAoKytpIDwgbGFzdCkge1xuICAgICAgaWYgKHR5cGVvZiBpdFtjaGFuZ2UucGF0aFtpXV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGl0W2NoYW5nZS5wYXRoW2ldXSA9ICh0eXBlb2YgY2hhbmdlLnBhdGhbaV0gPT09ICdudW1iZXInKSA/IFtdIDoge307XG4gICAgICB9XG4gICAgICBpdCA9IGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICB9XG4gICAgc3dpdGNoIChjaGFuZ2Uua2luZCkge1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGFwcGx5QXJyYXlDaGFuZ2UoY2hhbmdlLnBhdGggPyBpdFtjaGFuZ2UucGF0aFtpXV0gOiBpdCwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGRlbGV0ZSBpdFtjaGFuZ2UucGF0aFtpXV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRSc6XG4gICAgICBjYXNlICdOJzpcbiAgICAgICAgaXRbY2hhbmdlLnBhdGhbaV1dID0gY2hhbmdlLnJocztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldmVydEFycmF5Q2hhbmdlKGFyciwgaW5kZXgsIGNoYW5nZSkge1xuICBpZiAoY2hhbmdlLnBhdGggJiYgY2hhbmdlLnBhdGgubGVuZ3RoKSB7XG4gICAgLy8gdGhlIHN0cnVjdHVyZSBvZiB0aGUgb2JqZWN0IGF0IHRoZSBpbmRleCBoYXMgY2hhbmdlZC4uLlxuICAgIHZhciBpdCA9IGFycltpbmRleF0sXG4gICAgICBpLCB1ID0gY2hhbmdlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdTsgaSsrKSB7XG4gICAgICBpdCA9IGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICB9XG4gICAgc3dpdGNoIChjaGFuZ2Uua2luZCkge1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIHJldmVydEFycmF5Q2hhbmdlKGl0W2NoYW5nZS5wYXRoW2ldXSwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGl0W2NoYW5nZS5wYXRoW2ldXSA9IGNoYW5nZS5saHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRSc6XG4gICAgICAgIGl0W2NoYW5nZS5wYXRoW2ldXSA9IGNoYW5nZS5saHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTic6XG4gICAgICAgIGRlbGV0ZSBpdFtjaGFuZ2UucGF0aFtpXV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgYXJyYXkgaXRlbSBpcyBkaWZmZXJlbnQuLi5cbiAgICBzd2l0Y2ggKGNoYW5nZS5raW5kKSB7XG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgcmV2ZXJ0QXJyYXlDaGFuZ2UoYXJyW2luZGV4XSwgY2hhbmdlLmluZGV4LCBjaGFuZ2UuaXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGFycltpbmRleF0gPSBjaGFuZ2UubGhzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgICBhcnJbaW5kZXhdID0gY2hhbmdlLmxocztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOJzpcbiAgICAgICAgYXJyID0gYXJyYXlSZW1vdmUoYXJyLCBpbmRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiByZXZlcnRDaGFuZ2UodGFyZ2V0LCBzb3VyY2UsIGNoYW5nZSkge1xuICBpZiAodGFyZ2V0ICYmIHNvdXJjZSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmtpbmQpIHtcbiAgICB2YXIgaXQgPSB0YXJnZXQsXG4gICAgICBpLCB1O1xuICAgIHUgPSBjaGFuZ2UucGF0aC5sZW5ndGggLSAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCB1OyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgaXRbY2hhbmdlLnBhdGhbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpdFtjaGFuZ2UucGF0aFtpXV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGl0ID0gaXRbY2hhbmdlLnBhdGhbaV1dO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNoYW5nZS5raW5kKSB7XG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgLy8gQXJyYXkgd2FzIG1vZGlmaWVkLi4uXG4gICAgICAgIC8vIGl0IHdpbGwgYmUgYW4gYXJyYXkuLi5cbiAgICAgICAgcmV2ZXJ0QXJyYXlDaGFuZ2UoaXRbY2hhbmdlLnBhdGhbaV1dLCBjaGFuZ2UuaW5kZXgsIGNoYW5nZS5pdGVtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgLy8gSXRlbSB3YXMgZGVsZXRlZC4uLlxuICAgICAgICBpdFtjaGFuZ2UucGF0aFtpXV0gPSBjaGFuZ2UubGhzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAvLyBJdGVtIHdhcyBlZGl0ZWQuLi5cbiAgICAgICAgaXRbY2hhbmdlLnBhdGhbaV1dID0gY2hhbmdlLmxocztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOJzpcbiAgICAgICAgLy8gSXRlbSBpcyBuZXcuLi5cbiAgICAgICAgZGVsZXRlIGl0W2NoYW5nZS5wYXRoW2ldXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGlmZih0YXJnZXQsIHNvdXJjZSwgZmlsdGVyKSB7XG4gIGlmICh0YXJnZXQgJiYgc291cmNlKSB7XG4gICAgdmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIodGFyZ2V0LCBzb3VyY2UsIGNoYW5nZSkpIHtcbiAgICAgICAgYXBwbHlDaGFuZ2UodGFyZ2V0LCBzb3VyY2UsIGNoYW5nZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkZWVwRGlmZih0YXJnZXQsIHNvdXJjZSwgb25DaGFuZ2UpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFjY3VtdWxhdGVEaWZmLCB7XG5cbiAgZGlmZjoge1xuICAgIHZhbHVlOiBhY2N1bXVsYXRlRGlmZixcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sXG4gIG9ic2VydmFibGVEaWZmOiB7XG4gICAgdmFsdWU6IGRlZXBEaWZmLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgYXBwbHlEaWZmOiB7XG4gICAgdmFsdWU6IGFwcGx5RGlmZixcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sXG4gIGFwcGx5Q2hhbmdlOiB7XG4gICAgdmFsdWU6IGFwcGx5Q2hhbmdlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgcmV2ZXJ0Q2hhbmdlOiB7XG4gICAgdmFsdWU6IHJldmVydENoYW5nZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0sXG4gIGlzQ29uZmxpY3Q6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25mbGljdDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgbm9Db25mbGljdDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjb25mbGljdFJlc29sdXRpb24pIHtcbiAgICAgICAgY29uZmxpY3RSZXNvbHV0aW9uLmZvckVhY2goZnVuY3Rpb24oaXQpIHtcbiAgICAgICAgICBpdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uZmxpY3RSZXNvbHV0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlRGlmZjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFjY3VtdWxhdGVEaWZmO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcblxuLypcbiAqIFBhcnNlcyBhIHN0cmluZyBvciBidWZmZXIgaW50byBhbiBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gc3JjIC0gc291cmNlIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH1cbiovXG5mdW5jdGlvbiBwYXJzZSAoc3JjKSB7XG4gIHZhciBvYmogPSB7fVxuXG4gIC8vIGNvbnZlcnQgQnVmZmVycyBiZWZvcmUgc3BsaXR0aW5nIGludG8gbGluZXMgYW5kIHByb2Nlc3NpbmdcbiAgc3JjLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAvLyBtYXRjaGluZyBcIktFWScgYW5kICdWQUwnIGluICdLRVk9VkFMJ1xuICAgIHZhciBrZXlWYWx1ZUFyciA9IGxpbmUubWF0Y2goL15cXHMqKFtcXHdcXC5cXC1dKylcXHMqPVxccyooLiopP1xccyokLylcbiAgICAvLyBtYXRjaGVkP1xuICAgIGlmIChrZXlWYWx1ZUFyciAhPSBudWxsKSB7XG4gICAgICB2YXIga2V5ID0ga2V5VmFsdWVBcnJbMV1cblxuICAgICAgLy8gZGVmYXVsdCB1bmRlZmluZWQgb3IgbWlzc2luZyB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5nXG4gICAgICB2YXIgdmFsdWUgPSBrZXlWYWx1ZUFyclsyXSA/IGtleVZhbHVlQXJyWzJdIDogJydcblxuICAgICAgLy8gZXhwYW5kIG5ld2xpbmVzIGluIHF1b3RlZCB2YWx1ZXNcbiAgICAgIHZhciBsZW4gPSB2YWx1ZSA/IHZhbHVlLmxlbmd0aCA6IDBcbiAgICAgIGlmIChsZW4gPiAwICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gJ1wiJyAmJiB2YWx1ZS5jaGFyQXQobGVuIC0gMSkgPT09ICdcIicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcbi9nbSwgJ1xcbicpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBhbnkgc3Vycm91bmRpbmcgcXVvdGVzIGFuZCBleHRyYSBzcGFjZXNcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKF5bJ1wiXXxbJ1wiXSQpL2csICcnKS50cmltKClcblxuICAgICAgb2JqW2tleV0gPSB2YWx1ZVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gb2JqXG59XG5cbi8qXG4gKiBNYWluIGVudHJ5IHBvaW50IGludG8gZG90ZW52LiBBbGxvd3MgY29uZmlndXJhdGlvbiBiZWZvcmUgbG9hZGluZyAuZW52XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHZhbGlkIG9wdGlvbnM6IHBhdGggKCcuZW52JyksIGVuY29kaW5nICgndXRmOCcpXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiovXG5mdW5jdGlvbiBjb25maWcgKG9wdGlvbnMpIHtcbiAgdmFyIHBhdGggPSAnLmVudidcbiAgdmFyIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXRoKSB7XG4gICAgICBwYXRoID0gb3B0aW9ucy5wYXRoXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHNwZWNpZnlpbmcgYW4gZW5jb2RpbmcgcmV0dXJucyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgYnVmZmVyXG4gICAgdmFyIHBhcnNlZE9iaiA9IHBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoLCB7IGVuY29kaW5nOiBlbmNvZGluZyB9KSlcblxuICAgIE9iamVjdC5rZXlzKHBhcnNlZE9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBwcm9jZXNzLmVudltrZXldID0gcHJvY2Vzcy5lbnZba2V5XSB8fCBwYXJzZWRPYmpba2V5XVxuICAgIH0pXG5cbiAgICByZXR1cm4geyBwYXJzZWQ6IHBhcnNlZE9iaiB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlcnJvcjogZSB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuY29uZmlnID0gY29uZmlnXG5tb2R1bGUuZXhwb3J0cy5sb2FkID0gY29uZmlnXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG4iLCJ2YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgdGxzID0gcmVxdWlyZSgndGxzJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxudmFyIGhlbHBlciA9IHJlcXVpcmUoX19kaXJuYW1lKycvaGVscGVyLmpzJyk7XG52YXIgRXJyID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9lcnJvci5qcycpO1xudmFyIEN1cnNvciA9IHJlcXVpcmUoX19kaXJuYW1lKycvY3Vyc29yLmpzJyk7XG52YXIgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKF9fZGlybmFtZSsnL3N0cmVhbS5qcycpO1xudmFyIE1ldGFkYXRhID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9tZXRhZGF0YS5qcycpO1xuXG52YXIgcHJvdG9kZWYgPSByZXF1aXJlKF9fZGlybmFtZSsnL3Byb3RvZGVmLmpzJyk7XG52YXIgcmVzcG9uc2VUeXBlcyA9IHByb3RvZGVmLlJlc3BvbnNlLlJlc3BvbnNlVHlwZTtcblxuLy8gV2UnbGwgcGluZyBhIGNvbm5lY3Rpb24gdXNpbmcgdGhpcyBzcGVjaWFsIHZhbHVlLlxudmFyIFBJTkdfVkFMVUUgPSBcIl9fcmV0aGlua2RiZGFzaF9waW5nX19cIjtcblxudmFyIFBST1RPQ09MX1ZFUlNJT04gPSAwO1xudmFyIEFVVEhFTlRJRklDQVRJT05fTUVUSE9EID0gXCJTQ1JBTS1TSEEtMjU2XCI7XG52YXIgS0VZX0xFTkdUSCA9IDMyOyAvLyBCZWNhdXNlIHdlIGFyZSBjdXJyZW50bHkgdXNpbmcgU0hBIDI1NlxudmFyIE5VTExfQlVGRkVSID0gbmV3IEJ1ZmZlcignXFwwJywgXCJiaW5hcnlcIik7XG52YXIgQ0FDSEVfUEJLREYyID0ge307XG5cbmZ1bmN0aW9uIENvbm5lY3Rpb24ociwgb3B0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yID0gcjtcbiAgdGhpcy5zdGF0ZSA9IDA7IC8vIFRyYWNrIHRoZSBwcm9ncmVzcyBvZiB0aGUgaGFuZHNoYWtlLiAtMSB3aWxsIGJlIHVzZWQgZm9yIGFuIGVycm9yIHN0YXRlLlxuXG4gIC8vIFNldCBkZWZhdWx0IG9wdGlvbnMgLSBXZSBoYXZlIHRvIHNhdmUgdGhlbSBpbiBjYXNlIHRoZSB1c2VyIHRyaWVzIHRvIHJlY29ubmVjdFxuICBpZiAoIWhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSBvcHRpb25zID0ge307XG4gIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdCB8fCByLl9ob3N0O1xuICB0aGlzLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgci5fcG9ydDtcbiAgaWYgKG9wdGlvbnMuYXV0aEtleSAhPSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlciAhPSBudWxsIHx8IG9wdGlvbnMucGFzc3dvcmQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVyci5SZXFsRHJpdmVyRXJyb3IoJ0Nhbm5vdCB1c2UgYm90aCBhdXRoS2V5IGFuZCBwYXNzd29yZCcpO1xuICAgIH1cbiAgICB0aGlzLnVzZXIgPSByLl91c2VyO1xuICAgIHRoaXMucGFzc3dvcmQgPSBvcHRpb25zLmF1dGhLZXk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbnMudXNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVzZXIgPSByLl91c2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVzZXIgPSBvcHRpb25zLnVzZXI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhc3N3b3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSByLl9wYXNzd29yZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXNzd29yZCA9IG9wdGlvbnMucGFzc3dvcmQ7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hdXRoS2V5ID0gb3B0aW9ucy5hdXRoS2V5IHx8IHIuX2F1dGhLZXk7XG4gIC8vIHBlcmlvZCBpbiAqc2Vjb25kcyogZm9yIHRoZSBjb25uZWN0aW9uIHRvIGJlIG9wZW5lZFxuICB0aGlzLnRpbWVvdXRDb25uZWN0ID0gb3B0aW9ucy50aW1lb3V0IHx8IHIuX3RpbWVvdXRDb25uZWN0O1xuICAvLyBUaGUgY29ubmVjdGlvbiB3aWxsIGJlIHBpbmdlZCBldmVyeSA8cGluZ0ludGVydmFsPiBzZWNvbmRzXG4gIHRoaXMucGluZ0ludGVydmFsID0gb3B0aW9ucy5waW5nSW50ZXJ2YWwgfHwgci5fcGluZ0ludGVydmFsO1xuXG4gIGlmIChvcHRpb25zLmRiKSB0aGlzLmRiID0gb3B0aW9ucy5kYjsgLy8gUGFzcyB0byBlYWNoIHF1ZXJ5XG5cbiAgdGhpcy50b2tlbiA9IDE7XG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlcigwKTtcblxuICB0aGlzLm1ldGFkYXRhID0ge31cblxuICB0aGlzLm9wZW4gPSBmYWxzZTsgLy8gdHJ1ZSBvbmx5IGlmIHRoZSB1c2VyIGNhbiB3cml0ZSBvbiB0aGUgc29ja2V0XG4gIHRoaXMudGltZW91dCA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuY29ubmVjdGlvbikge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG9wdGlvbnMuY29ubmVjdGlvbjtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZmFtaWx5ID0gJ0lQdjQnO1xuICAgIGlmIChuZXQuaXNJUHY2KHNlbGYuaG9zdCkpIHtcbiAgICAgIGZhbWlseSA9ICdJUHY2JztcbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdGlvbkFyZ3MgPSB7XG4gICAgICBob3N0OiBzZWxmLmhvc3QsXG4gICAgICBwb3J0OiBzZWxmLnBvcnQsXG4gICAgICBmYW1pbHk6IGZhbWlseVxuICAgIH1cblxuICAgIHZhciB0bHNPcHRpb25zID0gb3B0aW9ucy5zc2wgfHwgZmFsc2U7XG4gICAgaWYgKHRsc09wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICBzZWxmLmNvbm5lY3Rpb24gPSBuZXQuY29ubmVjdChjb25uZWN0aW9uQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdCh0bHNPcHRpb25zKSkge1xuICAgICAgICAvLyBDb3B5IHRoZSBUTFMgb3B0aW9ucyBpbiBjb25uZWN0aW9uQXJnc1xuICAgICAgICBoZWxwZXIubG9vcEtleXModGxzT3B0aW9ucywgZnVuY3Rpb24odGxzT3B0aW9ucywga2V5KSB7XG4gICAgICAgICAgY29ubmVjdGlvbkFyZ3Nba2V5XSA9IHRsc09wdGlvbnNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZWxmLmNvbm5lY3Rpb24gPSB0bHMuY29ubmVjdChjb25uZWN0aW9uQXJncyk7XG4gICAgfVxuICB9XG5cbiAgc2VsZi5jb25uZWN0aW9uLnNldEtlZXBBbGl2ZSh0cnVlKTtcblxuICBzZWxmLnRpbWVvdXRPcGVuID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmNvbm5lY3Rpb24uZW5kKCk7IC8vIFNlbmQgYSBGSU4gcGFja2V0XG4gICAgcmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byAnK3NlbGYuaG9zdCsnOicrc2VsZi5wb3J0KycgaW4gbGVzcyB0aGFuICcrc2VsZi50aW1lb3V0Q29ubmVjdCsncycpLnNldE9wZXJhdGlvbmFsKCkpO1xuICB9LCBzZWxmLnRpbWVvdXRDb25uZWN0KjEwMDApO1xuXG4gIHNlbGYuY29ubmVjdGlvbi5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5vcGVuID0gZmFsc2U7XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgICAvLyBXZSBnb3QgYSBGSU4gcGFja2V0LCBzbyB3ZSdsbCBqdXN0IGZsdXNoXG4gICAgc2VsZi5fZmx1c2goKTtcbiAgfSk7XG4gIHNlbGYuY29ubmVjdGlvbi5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBXZSBlbWl0IGVuZCBvciBjbG9zZSBqdXN0IG9uY2VcbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0T3BlbilcbiAgICBjbGVhckludGVydmFsKHNlbGYucGluZ0ludGVydmFsSWQpO1xuICAgIHNlbGYuY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBzZWxmLm9wZW4gPSBmYWxzZTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlZCcpO1xuICAgIC8vIFRoZSBjb25uZWN0aW9uIGlzIGZ1bGx5IGNsb3NlZCwgZmx1c2ggKGluIGNhc2UgJ2VuZCcgd2FzIG5vdCB0cmlnZ2VyZWQpXG4gICAgc2VsZi5fZmx1c2goKTtcbiAgfSk7XG4gIHNlbGYuY29ubmVjdGlvbi5zZXROb0RlbGF5KCk7XG4gIHNlbGYuY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgcmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byAnK3NlbGYuaG9zdCsnOicrc2VsZi5wb3J0KydcXG5GdWxsIGVycm9yOlxcbicrSlNPTi5zdHJpbmdpZnkoZXJyb3IpKS5zZXRPcGVyYXRpb25hbCgpKTtcbiAgfSk7XG4gIHNlbGYuY29ubmVjdGlvbi5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG4gICAgc2VsZi5jb25uZWN0aW9uLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgdmFyIHZlcnNpb25CdWZmZXIgPSBuZXcgQnVmZmVyKDQpXG4gICAgdmVyc2lvbkJ1ZmZlci53cml0ZVVJbnQzMkxFKHByb3RvZGVmLlZlcnNpb25EdW1teS5WZXJzaW9uLlYxXzAsIDApXG5cbiAgICBzZWxmLnJhbmRvbVN0cmluZyA9IG5ldyBCdWZmZXIoY3J5cHRvLnJhbmRvbUJ5dGVzKDE4KSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgdmFyIGF1dGhCdWZmZXIgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHByb3RvY29sX3ZlcnNpb246IFBST1RPQ09MX1ZFUlNJT04sXG4gICAgICBhdXRoZW50aWNhdGlvbl9tZXRob2Q6IEFVVEhFTlRJRklDQVRJT05fTUVUSE9ELFxuICAgICAgYXV0aGVudGljYXRpb246IFwibiwsbj1cIiArIHNlbGYudXNlciArIFwiLHI9XCIgKyBzZWxmLnJhbmRvbVN0cmluZ1xuICAgIH0pKTtcblxuICAgIGhlbHBlci50cnlDYXRjaChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuY29ubmVjdGlvbi53cml0ZShCdWZmZXIuY29uY2F0KFt2ZXJzaW9uQnVmZmVyLCBhdXRoQnVmZmVyLCBOVUxMX0JVRkZFUl0pKTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIC8vIFRoZSBUQ1AgY29ubmVjdGlvbiBpcyBvcGVuLCBidXQgdGhlIFJlUUwgY29ubmVjdGlvbiB3YXNuJ3QgZXN0YWJsaXNoZWQuXG4gICAgICAvLyBXZSBjYW4ganVzdCBhYm9ydCB0aGUgd2hvbGUgdGhpbmdcbiAgICAgIHNlbGYub3BlbiA9IGZhbHNlO1xuICAgICAgcmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdGYWlsZWQgdG8gcGVyZm9ybSBoYW5kc2hha2Ugd2l0aCAnK3NlbGYuaG9zdCsnOicrc2VsZi5wb3J0KS5zZXRPcGVyYXRpb25hbCgpKTtcbiAgICB9KTtcbiAgfSk7XG4gIHNlbGYuY29ubmVjdGlvbi5vbmNlKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9wZW4gPSBmYWxzZTtcbiAgfSk7XG5cbiAgc2VsZi5jb25uZWN0aW9uLm9uKCdkYXRhJywgZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGVycm9yIHN0YXRlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbc2VsZi5idWZmZXIsIGJ1ZmZlcl0pO1xuXG4gICAgaWYgKHNlbGYub3BlbiA9PSBmYWxzZSkge1xuICAgICAgZm9yKHZhciBpPTA7IGk8c2VsZi5idWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuYnVmZmVyW2ldID09PSAwKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VTZXJ2ZXJTdHIgPSBzZWxmLmJ1ZmZlci5zbGljZSgwLCBpKS50b1N0cmluZygpO1xuICAgICAgICAgIHNlbGYuYnVmZmVyID0gc2VsZi5idWZmZXIuc2xpY2UoaSsxKTsgLy8gKzEgdG8gcmVtb3ZlIHRoZSBudWxsIGJ5dGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VTZXJ2ZXIgPSBKU09OLnBhcnNlKG1lc3NhZ2VTZXJ2ZXJTdHIpO1xuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuX2Fib3J0KCk7XG4gICAgICAgICAgICByZWplY3QobmV3IEVyci5SZXFsRHJpdmVyRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSB0aGUgbWVzc2FnZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgOiBcXCcnK21lc3NhZ2VTZXJ2ZXJTdHIrJ1xcJycpLnNldE9wZXJhdGlvbmFsKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZVNlcnZlci5zdWNjZXNzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBzZWxmLl9hYm9ydCgpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdFcnJvciAnK21lc3NhZ2VTZXJ2ZXIuZXJyb3JfY29kZSsnOicrbWVzc2FnZVNlcnZlci5lcnJvcikuc2V0T3BlcmF0aW9uYWwoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuX2NoZWNrUHJvdG9jb2xWZXJzaW9uKG1lc3NhZ2VTZXJ2ZXIsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHNhbHQgYW5kIHNlbmQgdGhlIHByb29mXG4gICAgICAgICAgICBzZWxmLl9jb21wdXRlU2FsdGVkUGFzc3dvcmQobWVzc2FnZVNlcnZlciwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdGUgPT09IDIpIHtcbiAgICAgICAgICAgIHNlbGYuX2NvbXBhcmVEaWdlc3QobWVzc2FnZVNlcnZlciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3aGlsZShzZWxmLmJ1ZmZlci5sZW5ndGggPj0gMTIpIHtcbiAgICAgICAgdmFyIHRva2VuID0gc2VsZi5idWZmZXIucmVhZFVJbnQzMkxFKDApICsgMHgxMDAwMDAwMDAgKiBzZWxmLmJ1ZmZlci5yZWFkVUludDMyTEUoNCk7XG4gICAgICAgIHZhciByZXNwb25zZUxlbmd0aCA9IHNlbGYuYnVmZmVyLnJlYWRVSW50MzJMRSg4KTtcblxuICAgICAgICBpZiAoc2VsZi5idWZmZXIubGVuZ3RoIDwgMTIrcmVzcG9uc2VMZW5ndGgpIGJyZWFrO1xuXG4gICAgICAgIHZhciByZXNwb25zZUJ1ZmZlciA9IHNlbGYuYnVmZmVyLnNsaWNlKDEyLCAxMityZXNwb25zZUxlbmd0aCk7XG4gICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2VCdWZmZXIpO1xuXG4gICAgICAgIHNlbGYuX3Byb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgdG9rZW4pO1xuXG4gICAgICAgIHNlbGYuYnVmZmVyID0gc2VsZi5idWZmZXIuc2xpY2UoMTIrcmVzcG9uc2VMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgc2VsZi5jb25uZWN0aW9uLm9uKCd0aW1lb3V0JywgZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgc2VsZi5jb25uZWN0aW9uLm9wZW4gPSBmYWxzZTtcbiAgICBzZWxmLmVtaXQoJ3RpbWVvdXQnKTtcbiAgfSlcbiAgc2VsZi5jb25uZWN0aW9uLnRvSlNPTiA9IGZ1bmN0aW9uKCkgeyAvLyBXZSB3YW50IHBlb3BsZSB0byBiZSBhYmxlIHRvIGpzb25pZnkgYSBjdXJzb3JcbiAgICByZXR1cm4gJ1wiQSBzb2NrZXQgb2JqZWN0IGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gSlNPTiBkdWUgdG8gY2lyY3VsYXIgcmVmZXJlbmNlcy5cIidcbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKENvbm5lY3Rpb24sIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fY2hlY2tQcm90b2NvbFZlcnNpb24gPSBmdW5jdGlvbihtZXNzYWdlU2VydmVyLCByZWplY3QpIHtcbiAgLy8gRXhwZWN0IG1heF9wcm90b2NvbF92ZXJzaW9uLCBtaW5fcHJvdG9jb2xfdmVyc2lvbiwgc2VydmVyX3ZlcnNpb24sIHN1Y2Nlc3NcbiAgdmFyIG1pblZlcnNpb24gPSBtZXNzYWdlU2VydmVyLm1pbl9wcm90b2NvbF92ZXJzaW9uXG4gIHZhciBtYXhWZXJzaW9uID0gbWVzc2FnZVNlcnZlci5tYXhfcHJvdG9jb2xfdmVyc2lvblxuXG4gIGlmIChtaW5WZXJzaW9uID4gUFJPVE9DT0xfVkVSU0lPTiB8fCBtYXhWZXJzaW9uIDwgUFJPVE9DT0xfVkVSU0lPTikge1xuICAgIHRoaXMuX2Fib3J0KCk7XG4gICAgcmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAnK1BST1RPQ09MX1ZFUlNJT04rJywgZXhwZWN0ZWQgYmV0d2VlbiAnK21pblZlcnNpb24rJyBhbmQgJysgbWF4VmVyc2lvbikuc2V0T3BlcmF0aW9uYWwoKSk7XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IDE7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fY29tcHV0ZVNhbHRlZFBhc3N3b3JkID0gZnVuY3Rpb24obWVzc2FnZVNlcnZlciwgcmVqZWN0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGF1dGhlbnRpY2F0aW9uID0gaGVscGVyLnNwbGl0Q29tbWFFcXVhbChtZXNzYWdlU2VydmVyLmF1dGhlbnRpY2F0aW9uKTtcblxuICB2YXIgcmFuZG9tTm9uY2UgPSBhdXRoZW50aWNhdGlvbi5yXG4gIHZhciBzYWx0ID0gbmV3IEJ1ZmZlcihhdXRoZW50aWNhdGlvbi5zLCAnYmFzZTY0JylcbiAgdmFyIGl0ZXJhdGlvbnMgPSBwYXJzZUludChhdXRoZW50aWNhdGlvbi5pKVxuXG4gIGlmIChyYW5kb21Ob25jZS5zdWJzdHIoMCwgc2VsZi5yYW5kb21TdHJpbmcubGVuZ3RoKSAhPT0gc2VsZi5yYW5kb21TdHJpbmcpIHtcbiAgICBzZWxmLl9hYm9ydCgpO1xuICAgIHJlamVjdChuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignSW52YWxpZCBub25jZSBmcm9tIHNlcnZlcicpLnNldE9wZXJhdGlvbmFsKCkpO1xuICB9XG5cbiAgLy8gVGhlIHNhbHQgaXMgY29uc3RhbnQsIHNvIHdlIGNhbiBjYWNoZSB0aGUgc2FsdGVkIHBhc3N3b3JkLlxuICB2YXIgY2FjaGVLZXkgPSBzZWxmLnBhc3N3b3JkLnRvU3RyaW5nKFwiYmFzZTY0XCIpKycsJytzYWx0LnRvU3RyaW5nKFwiYmFzZTY0XCIpKycsJytpdGVyYXRpb25zO1xuICBpZiAoQ0FDSEVfUEJLREYyLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgIGhlbHBlci50cnlDYXRjaChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3NlbmRQcm9vZihtZXNzYWdlU2VydmVyLmF1dGhlbnRpY2F0aW9uLCByYW5kb21Ob25jZSwgQ0FDSEVfUEJLREYyW2NhY2hlS2V5XSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAvLyBUaGUgVENQIGNvbm5lY3Rpb24gaXMgb3BlbiwgYnV0IHRoZSBSZVFMIGNvbm5lY3Rpb24gd2Fzbid0IGVzdGFibGlzaGVkLlxuICAgICAgLy8gV2UgY2FuIGp1c3QgYWJvcnQgdGhlIHdob2xlIHRoaW5nXG4gICAgICBzZWxmLm9wZW4gPSBmYWxzZTtcbiAgICAgIHJlamVjdChuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignRmFpbGVkIHRvIHBlcmZvcm0gaGFuZHNoYWtlIHdpdGggJytzZWxmLmhvc3QrJzonK3NlbGYucG9ydCkuc2V0T3BlcmF0aW9uYWwoKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY3J5cHRvLnBia2RmMihzZWxmLnBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBLRVlfTEVOR1RILCBcInNoYTI1NlwiLCBmdW5jdGlvbihlcnJvciwgc2FsdGVkUGFzc3dvcmQpIHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNlbGYuX2Fib3J0KCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignQ291bGQgbm90IGRlcml2ZSB0aGUga2V5LiBFcnJvcjonICsgZXJyb3IudG9TdHJpbmcoKSkuc2V0T3BlcmF0aW9uYWwoKSk7XG4gICAgICB9XG4gICAgICBDQUNIRV9QQktERjJbY2FjaGVLZXldID0gc2FsdGVkUGFzc3dvcmQ7XG4gICAgICBoZWxwZXIudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX3NlbmRQcm9vZihtZXNzYWdlU2VydmVyLmF1dGhlbnRpY2F0aW9uLCByYW5kb21Ob25jZSwgc2FsdGVkUGFzc3dvcmQpO1xuICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIFRoZSBUQ1AgY29ubmVjdGlvbiBpcyBvcGVuLCBidXQgdGhlIFJlUUwgY29ubmVjdGlvbiB3YXNuJ3QgZXN0YWJsaXNoZWQuXG4gICAgICAgIC8vIFdlIGNhbiBqdXN0IGFib3J0IHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICBzZWxmLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdGYWlsZWQgdG8gcGVyZm9ybSBoYW5kc2hha2Ugd2l0aCAnK3NlbGYuaG9zdCsnOicrc2VsZi5wb3J0KS5zZXRPcGVyYXRpb25hbCgpKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gIH1cbn1cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NlbmRQcm9vZiA9IGZ1bmN0aW9uKGF1dGhlbnRpY2F0aW9uLCByYW5kb21Ob25jZSwgc2FsdGVkUGFzc3dvcmQpIHtcbiAgdmFyIGNsaWVudEZpbmFsTWVzc2FnZVdpdGhvdXRQcm9vZiA9IFwiYz1iaXdzLHI9XCIgKyByYW5kb21Ob25jZTtcbiAgdmFyIGNsaWVudEtleSA9IGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIHNhbHRlZFBhc3N3b3JkKS51cGRhdGUoXCJDbGllbnQgS2V5XCIpLmRpZ2VzdCgpXG4gIHZhciBzdG9yZWRLZXkgPSBjcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoY2xpZW50S2V5KS5kaWdlc3QoKVxuXG4gIHZhciBhdXRoTWVzc2FnZSA9XG4gICAgICBcIm49XCIgKyB0aGlzLnVzZXIgKyBcIixyPVwiICsgdGhpcy5yYW5kb21TdHJpbmcgKyBcIixcIiArXG4gICAgICBhdXRoZW50aWNhdGlvbiArIFwiLFwiICtcbiAgICAgIGNsaWVudEZpbmFsTWVzc2FnZVdpdGhvdXRQcm9vZlxuXG4gIHZhciBjbGllbnRTaWduYXR1cmUgPSBjcnlwdG8uY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBzdG9yZWRLZXkpLnVwZGF0ZShhdXRoTWVzc2FnZSkuZGlnZXN0KClcbiAgdmFyIGNsaWVudFByb29mID0gaGVscGVyLnhvckJ1ZmZlcihjbGllbnRLZXksIGNsaWVudFNpZ25hdHVyZSlcblxuICB2YXIgc2VydmVyS2V5ID0gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgc2FsdGVkUGFzc3dvcmQpLnVwZGF0ZShcIlNlcnZlciBLZXlcIikuZGlnZXN0KClcbiAgdGhpcy5zZXJ2ZXJTaWduYXR1cmUgPSBjcnlwdG8uY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBzZXJ2ZXJLZXkpLnVwZGF0ZShhdXRoTWVzc2FnZSkuZGlnZXN0KClcblxuICB0aGlzLnN0YXRlID0gMlxuICB2YXIgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICBhdXRoZW50aWNhdGlvbjogY2xpZW50RmluYWxNZXNzYWdlV2l0aG91dFByb29mICsgXCIscD1cIiArIGNsaWVudFByb29mLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gIH0pXG4gIHRoaXMuY29ubmVjdGlvbi53cml0ZShCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKG1lc3NhZ2UudG9TdHJpbmcoKSksIE5VTExfQlVGRkVSXSkpXG59XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jb21wYXJlRGlnZXN0ID0gZnVuY3Rpb24obWVzc2FnZVNlcnZlciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGZpcnN0RXF1YWxzID0gbWVzc2FnZVNlcnZlci5hdXRoZW50aWNhdGlvbi5pbmRleE9mKCc9JylcbiAgdmFyIHNlcnZlclNpZ25hdHVyZVZhbHVlID0gbWVzc2FnZVNlcnZlci5hdXRoZW50aWNhdGlvbi5zbGljZShmaXJzdEVxdWFscysxKVxuXG4gIGlmICghaGVscGVyLmNvbXBhcmVEaWdlc3Qoc2VydmVyU2lnbmF0dXJlVmFsdWUsIHNlbGYuc2VydmVyU2lnbmF0dXJlLnRvU3RyaW5nKFwiYmFzZTY0XCIpKSkge1xuICAgIHJlamVjdChuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignSW52YWxpZCBzZXJ2ZXIgc2lnbmF0dXJlJykuc2V0T3BlcmF0aW9uYWwoKSk7XG4gIH1cblxuICBzZWxmLnN0YXRlID0gNFxuICBzZWxmLmNvbm5lY3Rpb24ucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICBzZWxmLm9wZW4gPSB0cnVlO1xuICBzZWxmLmNvbm5lY3Rpb24ub24oJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuICAgIHNlbGYub3BlbiA9IGZhbHNlO1xuICB9KTtcbiAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dE9wZW4pXG4gIHJlc29sdmUoc2VsZik7XG4gIGlmIChzZWxmLnBpbmdJbnRlcnZhbCA+IDApIHtcbiAgICBzZWxmLnBpbmdJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnBlbmRpbmdQaW5nID0gdHJ1ZTtcbiAgICAgIHNlbGYuci5lcnJvcihQSU5HX1ZBTFVFKS5ydW4oc2VsZikuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgc2VsZi5wZW5kaW5nUGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSAhPT0gUElOR19WQUxVRSkge1xuICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcihcbiAgICAgICAgICAgICAgICAnQ291bGQgbm90IHBpbmcgdGhlIGNvbm5lY3Rpb24nKS5zZXRPcGVyYXRpb25hbCgpKTtcbiAgICAgICAgICBzZWxmLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uZW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHNlbGYucGluZ0ludGVydmFsKjEwMDApO1xuICB9XG59XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0YXRlID0gLTE7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuY2xvc2UoKTtcbn1cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3Byb2Nlc3NSZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlLCB0b2tlbikge1xuICAvL2NvbnNvbGUubG9nKCdDb25uZWN0aW9uLnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3BvbnNlOiAnK3Rva2VuKTtcbiAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShyZXNwb25zZSwgbnVsbCwgMikpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHR5cGUgPSByZXNwb25zZS50O1xuICB2YXIgcmVzdWx0O1xuICB2YXIgY3Vyc29yO1xuICB2YXIgc3RyZWFtO1xuICB2YXIgY3VycmVudFJlc29sdmUsIGN1cnJlbnRSZWplY3Q7XG4gIHZhciBkYXR1bTtcbiAgdmFyIG9wdGlvbnM7XG5cbiAgaWYgKHR5cGUgPT09IHJlc3BvbnNlVHlwZXMuQ09NUElMRV9FUlJPUikge1xuICAgIHNlbGYuZW1pdCgncmVsZWFzZScpO1xuICAgIGlmICh0eXBlb2Ygc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZWplY3QobmV3IEVyci5SZXFsQ29tcGlsZUVycm9yKGhlbHBlci5tYWtlQXRvbShyZXNwb25zZSksIHNlbGYubWV0YWRhdGFbdG9rZW5dLnF1ZXJ5LCByZXNwb25zZSkpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBzZWxmLm1ldGFkYXRhW3Rva2VuXVxuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IHJlc3BvbnNlVHlwZXMuQ0xJRU5UX0VSUk9SKSB7XG4gICAgc2VsZi5lbWl0KCdyZWxlYXNlJyk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFJlc29sdmUgPSBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZXNvbHZlO1xuICAgICAgY3VycmVudFJlamVjdCA9IHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlamVjdDtcbiAgICAgIHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlbW92ZUNhbGxiYWNrcygpO1xuICAgICAgY3VycmVudFJlamVjdChuZXcgRXJyLlJlcWxDbGllbnRFcnJvcihoZWxwZXIubWFrZUF0b20ocmVzcG9uc2UpLCBzZWxmLm1ldGFkYXRhW3Rva2VuXS5xdWVyeSwgcmVzcG9uc2UpKTtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5tZXRhZGF0YVt0b2tlbl0uZW5kUmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIE5vIHBlbmRpbmcgU1RPUCBxdWVyeSwgd2UgY2FuIGRlbGV0ZVxuICAgICAgICBkZWxldGUgc2VsZi5tZXRhZGF0YVt0b2tlbl1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRSZXNvbHZlID0gc2VsZi5tZXRhZGF0YVt0b2tlbl0uZW5kUmVzb2x2ZTtcbiAgICAgIGN1cnJlbnRSZWplY3QgPSBzZWxmLm1ldGFkYXRhW3Rva2VuXS5lbmRSZWplY3Q7XG4gICAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZW1vdmVFbmRDYWxsYmFja3MoKTtcbiAgICAgIGN1cnJlbnRSZWplY3QobmV3IEVyci5SZXFsQ2xpZW50RXJyb3IoaGVscGVyLm1ha2VBdG9tKHJlc3BvbnNlKSwgc2VsZi5tZXRhZGF0YVt0b2tlbl0ucXVlcnksIHJlc3BvbnNlKSk7XG4gICAgICBkZWxldGUgc2VsZi5tZXRhZGF0YVt0b2tlbl1cbiAgICB9XG4gICAgZWxzZSBpZiAodG9rZW4gPT09IC0xKSB7IC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gbm93IHNpbmNlIDEuMTMgdG9vayB0aGUgdG9rZW4gb3V0IG9mIHRoZSBxdWVyeVxuICAgICAgdmFyIGVycm9yID0gbmV3IEVyci5SZXFsQ2xpZW50RXJyb3IoaGVscGVyLm1ha2VBdG9tKHJlc3BvbnNlKSsnXFxuQ2xvc2luZyBhbGwgb3V0c3RhbmRpbmcgcXVlcmllcy4uLicpO1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgYSBmdW5jdGlvbiB0byB5aWVsZCBmb3JldmVyLCBzbyB3ZSBqdXN0IHJlamVjdCBldmVyeXRoaW5nXG4gICAgICBoZWxwZXIubG9vcEtleXMoc2VsZi5yZWplY3RNYXAsIGZ1bmN0aW9uKHJlamVjdE1hcCwga2V5KSB7XG4gICAgICAgIHJlamVjdE1hcFtrZXldKGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgZGVsZXRlIHNlbGYubWV0YWRhdGFbdG9rZW5dXG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IHJlc3BvbnNlVHlwZXMuUlVOVElNRV9FUlJPUikge1xuICAgIHZhciBlcnJvclZhbHVlID0gaGVscGVyLm1ha2VBdG9tKHJlc3BvbnNlKTtcbiAgICB2YXIgZXJyb3I7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZWxlYXNlIGEgY29ubmVjdGlvbiBpZiB3ZSBqdXN0IHBpbmdlZCBpdC5cbiAgICBpZiAoc2VsZi5wZW5kaW5nUGluZyA9PT0gZmFsc2UgfHwgKGVycm9yVmFsdWUgIT09IFBJTkdfVkFMVUUpKSB7XG4gICAgICBzZWxmLmVtaXQoJ3JlbGVhc2UnKTtcbiAgICAgIGVycm9yID0gbmV3IEVyci5SZXFsUnVudGltZUVycm9yKGVycm9yVmFsdWUsIHNlbGYubWV0YWRhdGFbdG9rZW5dLnF1ZXJ5LCByZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yID0gbmV3IEVyci5SZXFsUnVudGltZUVycm9yKGVycm9yVmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50UmVzb2x2ZSA9IHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlc29sdmU7XG4gICAgICBjdXJyZW50UmVqZWN0ID0gc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVqZWN0O1xuICAgICAgc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVtb3ZlQ2FsbGJhY2tzKCk7XG4gICAgICBlcnJvci5zZXROYW1lKHJlc3BvbnNlLmUpO1xuICAgICAgY3VycmVudFJlamVjdChlcnJvcik7XG4gICAgICBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBObyBwZW5kaW5nIFNUT1AgcXVlcnksIHdlIGNhbiBkZWxldGVcbiAgICAgICAgZGVsZXRlIHNlbGYubWV0YWRhdGFbdG9rZW5dXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxmLm1ldGFkYXRhW3Rva2VuXS5lbmRSZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50UmVzb2x2ZSA9IHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlc29sdmU7XG4gICAgICBjdXJyZW50UmVqZWN0ID0gc2VsZi5tZXRhZGF0YVt0b2tlbl0uZW5kUmVqZWN0O1xuICAgICAgc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVtb3ZlRW5kQ2FsbGJhY2tzKCk7XG4gICAgICBkZWxldGUgc2VsZi5tZXRhZGF0YVt0b2tlbl1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gcmVzcG9uc2VUeXBlcy5TVUNDRVNTX0FUT00pIHtcbiAgICBzZWxmLmVtaXQoJ3JlbGVhc2UnKTtcbiAgICAvLyBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZXNvbHZlIGlzIGFsd2F5cyBhIGZ1bmN0aW9uXG4gICAgZGF0dW0gPSBoZWxwZXIubWFrZUF0b20ocmVzcG9uc2UsIHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnMpO1xuXG4gICAgaWYgKChBcnJheS5pc0FycmF5KGRhdHVtKSkgJiZcbiAgICAgICAgKChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLmN1cnNvciA9PT0gdHJ1ZSkgfHwgKChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLmN1cnNvciA9PT0gdW5kZWZpbmVkKSAmJiAoc2VsZi5yLl9vcHRpb25zLmN1cnNvciA9PT0gdHJ1ZSkpKSkge1xuICAgICAgY3Vyc29yID0gbmV3IEN1cnNvcihzZWxmLCB0b2tlbiwgc2VsZi5tZXRhZGF0YVt0b2tlbl0ub3B0aW9ucywgJ2N1cnNvcicpO1xuICAgICAgaWYgKHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnMucHJvZmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZXNvbHZlKHtcbiAgICAgICAgICBwcm9maWxlOiByZXNwb25zZS5wLFxuICAgICAgICAgIHJlc3VsdDogY3Vyc29yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlc29sdmUoY3Vyc29yKTtcbiAgICAgIH1cblxuICAgICAgY3Vyc29yLl9wdXNoKHtkb25lOiB0cnVlLCByZXNwb25zZTogeyByOiBkYXR1bSB9fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChBcnJheS5pc0FycmF5KGRhdHVtKSkgJiZcbiAgICAgICAgKChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLnN0cmVhbSA9PT0gdHJ1ZSB8fCBzZWxmLnIuX29wdGlvbnMuc3RyZWFtID09PSB0cnVlKSkpIHtcbiAgICAgIGN1cnNvciA9IG5ldyBDdXJzb3Ioc2VsZiwgdG9rZW4sIHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnMsICdjdXJzb3InKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7fSwgY3Vyc29yKTtcbiAgICAgIGlmIChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLnByb2ZpbGUgPT09IHRydWUpIHtcbiAgICAgICAgc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVzb2x2ZSh7XG4gICAgICAgICAgcHJvZmlsZTogcmVzcG9uc2UucCxcbiAgICAgICAgICByZXN1bHQ6IHN0cmVhbSBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVzb2x2ZShzdHJlYW0pO1xuICAgICAgfVxuICAgICAgY3Vyc29yLl9wdXNoKHtkb25lOiB0cnVlLCByZXNwb25zZTogeyByOiBkYXR1bSB9fSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnMucHJvZmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgcHJvZmlsZTogcmVzcG9uc2UucCxcbiAgICAgICAgICByZXN1bHQ6IGN1cnNvciB8fCBkYXR1bVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZGF0dW07XG4gICAgICB9XG4gICAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHNlbGYubWV0YWRhdGFbdG9rZW5dO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IHJlc3BvbnNlVHlwZXMuU1VDQ0VTU19QQVJUSUFMKSB7XG4gICAgLy8gV2Ugc2F2ZSB0aGUgY3VycmVudCByZXNvbHZlIGZ1bmN0aW9uIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIGNhbGwgY3Vyc29yLl9mZXRjaCBiZWZvcmUgcmVzdW1pbmcgdGhlIHVzZXIncyB5aWVsZFxuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZXNvbHZlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBY2NvcmRpbmcgdG8gaXNzdWVzLzE5MCwgd2UgY2FuIGdldCBhIFNVQ0VTU19DT01QTEVURSBmb2xsb3dlZCBieSBhXG4gICAgICAvLyBTVUNDRVNTX1BBUlRJQUwgd2hlbiBjbG9zaW5nIGFuIGZlZWQuIFNvIHJlc29sdmUvcmVqZWN0IHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgICAvLyBpbiB0aGlzIGNhc2UuXG4gICAgICBjdXJyZW50UmVzb2x2ZSA9IHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlc29sdmU7XG4gICAgICBjdXJyZW50UmVqZWN0ID0gc2VsZi5tZXRhZGF0YVt0b2tlbl0uZW5kUmVqZWN0O1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50UmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjdXJyZW50UmVzb2x2ZSA9IHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlc29sdmU7XG4gICAgICBjdXJyZW50UmVqZWN0ID0gc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVqZWN0O1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gZGVsZXRlIGJlZm9yZSBjYWxsaW5nIGN1cnNvci5fcHVzaFxuICAgIHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlbW92ZUNhbGxiYWNrcygpO1xuXG4gICAgaWYgKCFzZWxmLm1ldGFkYXRhW3Rva2VuXS5jdXJzb3IpIHsgLy9ObyBjdXJzb3IsIGxldCdzIGNyZWF0ZSBvbmVcbiAgICAgIHNlbGYubWV0YWRhdGFbdG9rZW5dLmN1cnNvciA9IHRydWU7XG5cbiAgICAgIHZhciB0eXBlUmVzdWx0ID0gJ0N1cnNvcic7XG4gICAgICB2YXIgaW5jbHVkZXNTdGF0ZXMgPSBmYWxzZTs7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZS5uKSkge1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxyZXNwb25zZS5uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLm5baV0gPT09IHByb3RvZGVmLlJlc3BvbnNlLlJlc3BvbnNlTm90ZS5TRVFVRU5DRV9GRUVEKSB7XG4gICAgICAgICAgICB0eXBlUmVzdWx0ID0gJ0ZlZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5uW2ldID09PSBwcm90b2RlZi5SZXNwb25zZS5SZXNwb25zZU5vdGUuQVRPTV9GRUVEKSB7XG4gICAgICAgICAgICB0eXBlUmVzdWx0ID0gJ0F0b21GZWVkJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UubltpXSA9PT0gcHJvdG9kZWYuUmVzcG9uc2UuUmVzcG9uc2VOb3RlLk9SREVSX0JZX0xJTUlUX0ZFRUQpIHtcbiAgICAgICAgICAgIHR5cGVSZXN1bHQgPSAnT3JkZXJCeUxpbWl0RmVlZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLm5baV0gPT09IHByb3RvZGVmLlJlc3BvbnNlLlJlc3BvbnNlTm90ZS5VTklPTkVEX0ZFRUQpIHtcbiAgICAgICAgICAgIHR5cGVSZXN1bHQgPSAnVW5pb25lZEZlZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5uW2ldID09PSBwcm90b2RlZi5SZXNwb25zZS5SZXNwb25zZU5vdGUuSU5DTFVERVNfU1RBVEVTKSB7XG4gICAgICAgICAgICBpbmNsdWRlc1N0YXRlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFJlamVjdChuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignVW5rbm93biBSZXNwb25zZU5vdGUgJytyZXNwb25zZS5uW2ldKycsIHRoZSBkcml2ZXIgaXMgcHJvYmFibHkgb3V0IG9mIGRhdGUuJykuc2V0T3BlcmF0aW9uYWwoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJzb3IgPSBuZXcgQ3Vyc29yKHNlbGYsIHRva2VuLCBzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLCB0eXBlUmVzdWx0KTtcbiAgICAgIGlmIChpbmNsdWRlc1N0YXRlcyA9PT0gdHJ1ZSkge1xuICAgICAgICBjdXJzb3Iuc2V0SW5jbHVkZXNTdGF0ZXMoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoc2VsZi5tZXRhZGF0YVt0b2tlbl0ub3B0aW9ucy5jdXJzb3IgPT09IHRydWUpIHx8ICgoc2VsZi5tZXRhZGF0YVt0b2tlbl0ub3B0aW9ucy5jdXJzb3IgPT09IHVuZGVmaW5lZCkgJiYgKHNlbGYuci5fb3B0aW9ucy5jdXJzb3IgPT09IHRydWUpKSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBjdXJzb3JcbiAgICAgICAgaWYgKHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnMucHJvZmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGN1cnJlbnRSZXNvbHZlKHtcbiAgICAgICAgICAgIHByb2ZpbGU6IHJlc3BvbnNlLnAsXG4gICAgICAgICAgICByZXN1bHQ6IGN1cnNvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRSZXNvbHZlKGN1cnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLnN0cmVhbSA9PT0gdHJ1ZSB8fCBzZWxmLnIuX29wdGlvbnMuc3RyZWFtID09PSB0cnVlKSkge1xuICAgICAgICBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe30sIGN1cnNvcik7XG4gICAgICAgIGlmIChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLnByb2ZpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICBjdXJyZW50UmVzb2x2ZSh7XG4gICAgICAgICAgICBwcm9maWxlOiByZXNwb25zZS5wLFxuICAgICAgICAgICAgcmVzdWx0OiBzdHJlYW0gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3VycmVudFJlc29sdmUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZVJlc3VsdCAhPT0gJ0N1cnNvcicpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgZmVlZFxuICAgICAgICBpZiAoc2VsZi5tZXRhZGF0YVt0b2tlbl0ub3B0aW9ucy5wcm9maWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgY3VycmVudFJlc29sdmUoe1xuICAgICAgICAgICAgcHJvZmlsZTogcmVzcG9uc2UucCxcbiAgICAgICAgICAgIHJlc3VsdDogY3Vyc29yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3VycmVudFJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ2V0IFNVQ0NFU1NfU0VRVUVOQ0UsIHdlIHdpbGwgZGVsZXRlIHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnNcbiAgICAgICAgLy8gU28gd2Uga2VlcCBhIHJlZmVyZW5jZSBvZiBpdCBoZXJlXG4gICAgICAgIG9wdGlvbnMgPSBzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zO1xuXG4gICAgICAgIC8vIEZldGNoIGV2ZXJ5dGhpbmcgYW5kIHJldHVybiBhbiBhcnJheVxuICAgICAgICBjdXJzb3IudG9BcnJheSgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucHJvZmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY3VycmVudFJlc29sdmUoe1xuICAgICAgICAgICAgICBwcm9maWxlOiByZXNwb25zZS5wLFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmVycm9yKGN1cnJlbnRSZWplY3QpXG4gICAgICB9XG4gICAgICBjdXJzb3IuX3B1c2goe2RvbmU6IGZhbHNlLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIFRoYXQgd2FzIGEgY29udGludWUgcXVlcnlcbiAgICAgIGN1cnJlbnRSZXNvbHZlKHtkb25lOiBkb25lLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gcmVzcG9uc2VUeXBlcy5TVUNDRVNTX1NFUVVFTkNFKSB7XG4gICAgc2VsZi5lbWl0KCdyZWxlYXNlJyk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRSZXNvbHZlID0gc2VsZi5tZXRhZGF0YVt0b2tlbl0ucmVzb2x2ZTtcbiAgICAgIGN1cnJlbnRSZWplY3QgPSBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZWplY3Q7XG4gICAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZW1vdmVDYWxsYmFja3MoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRSZXNvbHZlID0gc2VsZi5tZXRhZGF0YVt0b2tlbl0uZW5kUmVzb2x2ZTtcbiAgICAgIGN1cnJlbnRSZWplY3QgPSBzZWxmLm1ldGFkYXRhW3Rva2VuXS5lbmRSZWplY3Q7XG4gICAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZW1vdmVFbmRDYWxsYmFja3MoKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGYubWV0YWRhdGFbdG9rZW5dLmN1cnNvcikgeyAvLyBObyBjdXJzb3IsIGxldCdzIGNyZWF0ZSBvbmVcbiAgICAgIGN1cnNvciA9IG5ldyBDdXJzb3Ioc2VsZiwgdG9rZW4sIHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnMsICdDdXJzb3InKTtcblxuICAgICAgaWYgKChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLmN1cnNvciA9PT0gdHJ1ZSkgfHwgKChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLmN1cnNvciA9PT0gdW5kZWZpbmVkKSAmJiAoc2VsZi5yLl9vcHRpb25zLmN1cnNvciA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgIGlmIChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLnByb2ZpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICBjdXJyZW50UmVzb2x2ZSh7XG4gICAgICAgICAgICBwcm9maWxlOiByZXNwb25zZS5wLFxuICAgICAgICAgICAgcmVzdWx0OiBjdXJzb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UmVzb2x2ZShjdXJzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIHRoZSBvcHRpb25zIGluIHRoZSBlbHNlIHN0YXRlbWVudCwgc28gd2UgY2xlYW4gaXQgaW5zaWRlIHRoZSBpZi9lbHNlIGJsb2Nrc1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlc29sdmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZi5tZXRhZGF0YVt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLnN0cmVhbSA9PT0gdHJ1ZSB8fCBzZWxmLnIuX29wdGlvbnMuc3RyZWFtID09PSB0cnVlKSkge1xuICAgICAgICBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe30sIGN1cnNvcik7XG4gICAgICAgIGlmIChzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zLnByb2ZpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICBjdXJyZW50UmVzb2x2ZSh7XG4gICAgICAgICAgICBwcm9maWxlOiByZXNwb25zZS5wLFxuICAgICAgICAgICAgcmVzdWx0OiBzdHJlYW1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UmVzb2x2ZShzdHJlYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIHRoZSBvcHRpb25zIGluIHRoZSBlbHNlIHN0YXRlbWVudCxcbiAgICAgICAgLy8gc28gd2UgY2xlYW4gaXQgaW5zaWRlIHRoZSBpZi9lbHNlIGJsb2NrcyAodGhlIG9uZSBsb29raW5nIFxuICAgICAgICAvLyBpZiBhIGN1cnNvciB3YXMgYWxyZWFkeSBjcmVhdGVkKVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlc29sdmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBkZWxldGUgdGhlIG1ldGFkYXRhIGlmIHRoZXJlIGlzIGFuIEVORCBxdWVyeSB3YWl0aW5nXG4gICAgICAgICAgZGVsZXRlIHNlbGYubWV0YWRhdGFbdG9rZW5dO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdXJzb3IudG9BcnJheSgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHNlbGYubWV0YWRhdGFbdG9rZW5dLm9wdGlvbnMucHJvZmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY3VycmVudFJlc29sdmUoe1xuICAgICAgICAgICAgICBwcm9maWxlOiByZXNwb25zZS5wLFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm1ldGFkYXRhW3Rva2VuXS5lbmRSZXNvbHZlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5tZXRhZGF0YVt0b2tlbl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pLmVycm9yKGN1cnJlbnRSZWplY3QpXG4gICAgICB9XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGN1cnNvci5fcHVzaCh7ZG9uZTogdHJ1ZSwgcmVzcG9uc2U6IHJlc3BvbnNlfSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBUaGF0IHdhcyBhIGNvbnRpbnVlIHF1ZXJ5XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgU1RPUCBxdWVyeSB3ZSBkbyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3Vyc29yIHlldFxuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHNlbGYubWV0YWRhdGFbdG9rZW5dLmVuZFJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY3VycmVudFJlc29sdmUoe2RvbmU6IGRvbmUsIHJlc3BvbnNlOiByZXNwb25zZX0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0eXBlID09PSByZXNwb25zZVR5cGVzLldBSVRfQ09NUExFVEUpIHtcbiAgICBzZWxmLmVtaXQoJ3JlbGVhc2UnKTtcbiAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZXNvbHZlKCk7XG5cbiAgICBkZWxldGUgc2VsZi5tZXRhZGF0YVt0b2tlbl07XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gcmVzcG9uc2VUeXBlcy5TRVJWRVJfSU5GTykge1xuICAgIHNlbGYuZW1pdCgncmVsZWFzZScpO1xuICAgIGRhdHVtID0gaGVscGVyLm1ha2VBdG9tKHJlc3BvbnNlLCBzZWxmLm1ldGFkYXRhW3Rva2VuXS5vcHRpb25zKTtcbiAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXS5yZXNvbHZlKGRhdHVtKTtcbiAgICBkZWxldGUgc2VsZi5tZXRhZGF0YVt0b2tlbl07XG4gIH1cbn1cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoIWhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSBvcHRpb25zID0ge307XG5cbiAgaWYgKG9wdGlvbnMubm9yZXBseVdhaXQgPT09IHRydWUpIHtcbiAgICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2VsZi5jbG9zZShvcHRpb25zKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnIuY29ubmVjdCh7XG4gICAgICAgICAgaG9zdDogc2VsZi5ob3N0LFxuICAgICAgICAgIHBvcnQ6IHNlbGYucG9ydCxcbiAgICAgICAgICBhdXRoS2V5OiBzZWxmLmF1dGhLZXksXG4gICAgICAgICAgZGI6IHNlbGYuZGJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmVzb2x2ZShjKTtcbiAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5lcnJvcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHJlamVjdChlKVxuICAgICAgfSlcbiAgICB9KS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gc2VsZi5yLmNvbm5lY3Qoe1xuICAgICAgaG9zdDogc2VsZi5ob3N0LFxuICAgICAgcG9ydDogc2VsZi5wb3J0LFxuICAgICAgYXV0aEtleTogc2VsZi5hdXRoS2V5LFxuICAgICAgZGI6IHNlbGYuZGJcbiAgICB9LCBjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihxdWVyeSwgdG9rZW4sIHJlc29sdmUsIHJlamVjdCwgb3JpZ2luYWxRdWVyeSwgb3B0aW9ucywgZW5kKSB7XG4gIC8vY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLl9zZW5kOiAnK3Rva2VuKTtcbiAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShxdWVyeSwgbnVsbCwgMikpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYub3BlbiA9PT0gZmFsc2UpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVyci5SZXFsRHJpdmVyRXJyb3IoJ1RoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYnkgdGhlIG90aGVyIHBhcnR5Jyk7XG4gICAgZXJyLnNldE9wZXJhdGlvbmFsKCk7XG4gICAgcmVqZWN0KGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHF1ZXJ5U3RyID0gSlNPTi5zdHJpbmdpZnkocXVlcnkpO1xuICB2YXIgcXVlcnlTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgocXVlcnlTdHIpO1xuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDgrNCtxdWVyeVNpemUpO1xuICBidWZmZXIud3JpdGVVSW50MzJMRSh0b2tlbiAmIDB4RkZGRkZGRkYsIDApXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IodG9rZW4gLyAweEZGRkZGRkZGKSwgNClcblxuICBidWZmZXIud3JpdGVVSW50MzJMRShxdWVyeVNpemUsIDgpO1xuXG4gIGJ1ZmZlci53cml0ZShxdWVyeVN0ciwgMTIpO1xuXG4gIC8vIG5vcmVwbHkgaW5zdGVhZCBvZiBub1JlcGx5IGJlY2F1c2UgdGhlIG90cGlvbnMgYXJlIHRyYW5zbGF0ZWQgZm9yIHRoZSBzZXJ2ZXJcbiAgaWYgKCghaGVscGVyLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHx8IChvcHRpb25zLm5vcmVwbHkgIT0gdHJ1ZSkpIHtcbiAgICBpZiAoIXNlbGYubWV0YWRhdGFbdG9rZW5dKSB7XG4gICAgICBzZWxmLm1ldGFkYXRhW3Rva2VuXSA9IG5ldyBNZXRhZGF0YShyZXNvbHZlLCByZWplY3QsIG9yaWdpbmFsUXVlcnksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbmQgPT09IHRydWUpIHtcbiAgICAgIHNlbGYubWV0YWRhdGFbdG9rZW5dLnNldEVuZChyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNlbGYubWV0YWRhdGFbdG9rZW5dLnNldENhbGxiYWNrcyhyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmUgPT09ICdmdW5jdGlvbicpIHJlc29sdmUoKTtcbiAgICB0aGlzLmVtaXQoJ3JlbGVhc2UnKTtcbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCBlbWl0IGFuIGVycm9yIGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZFxuICBoZWxwZXIudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5jb25uZWN0aW9uLndyaXRlKGJ1ZmZlcik7XG4gIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIHNlbGYubWV0YWRhdGFbdG9rZW5dLnJlamVjdChlcnIpO1xuICAgIGRlbGV0ZSBzZWxmLm1ldGFkYXRhW3Rva2VuXVxuICB9KTtcblxufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NvbnRpbnVlID0gZnVuY3Rpb24odG9rZW4sIHJlc29sdmUsIHJlamVjdCkge1xuICB2YXIgcXVlcnkgPSBbcHJvdG9kZWYuUXVlcnkuUXVlcnlUeXBlLkNPTlRJTlVFXTtcbiAgdGhpcy5fc2VuZChxdWVyeSwgdG9rZW4sIHJlc29sdmUsIHJlamVjdCk7XG59XG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24odG9rZW4sIHJlc29sdmUsIHJlamVjdCkge1xuICB2YXIgcXVlcnkgPSBbcHJvdG9kZWYuUXVlcnkuUXVlcnlUeXBlLlNUT1BdO1xuICB0aGlzLl9zZW5kKHF1ZXJ5LCB0b2tlbiwgcmVzb2x2ZSwgcmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG59XG5cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oZGIpIHtcbiAgaWYgKHR5cGVvZiBkYiAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdGaXJzdCBhcmd1bWVudCBvZiBgdXNlYCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgdGhpcy5kYiA9IGRiO1xufVxuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZXJ2ZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcXVlcnkgPSBbcHJvdG9kZWYuUXVlcnkuUXVlcnlUeXBlLlNFUlZFUl9JTkZPXTtcbiAgICBzZWxmLl9zZW5kKHF1ZXJ5LCBzZWxmLl9nZXRUb2tlbigpLCByZXNvbHZlLCByZWplY3QsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgfSkubm9kZWlmeShjYWxsYmFjayk7XG59XG5cbi8vIFJldHVybiB0aGUgbmV4dCB0b2tlbiBhbmQgdXBkYXRlIGl0LlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2dldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2VuKys7XG59XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSBvcHRpb25zID0ge307XG4gICAgaWYgKG9wdGlvbnMubm9yZXBseVdhaXQgPT09IHRydWUpIHtcbiAgICAgIHNlbGYubm9yZXBseVdhaXQoKS50aGVuKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgc2VsZi5vcGVuID0gZmFsc2U7XG4gICAgICAgIHNlbGYuY29ubmVjdGlvbi5lbmQoKVxuICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgfSkuZXJyb3IoZnVuY3Rpb24oZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgc2VsZi5vcGVuID0gZmFsc2U7XG4gICAgICBzZWxmLmNvbm5lY3Rpb24uZW5kKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9KS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgcmV0dXJuIHA7XG59O1xuXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm5vUmVwbHlXYWl0ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdEaWQgeW91IG1lYW4gdG8gdXNlIGBub3JlcGx5V2FpdGAgaW5zdGVhZCBvZiBgbm9SZXBseVdhaXRgPycpXG59XG5Db25uZWN0aW9uLnByb3RvdHlwZS5ub3JlcGx5V2FpdCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRva2VuID0gc2VsZi5fZ2V0VG9rZW4oKTtcblxuICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBxdWVyeSA9IFtwcm90b2RlZi5RdWVyeS5RdWVyeVR5cGUuTk9SRVBMWV9XQUlUXTtcblxuICAgIHNlbGYuX3NlbmQocXVlcnksIHRva2VuLCByZXNvbHZlLCByZWplY3QpO1xuICB9KS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgcmV0dXJuIHA7XG59XG5Db25uZWN0aW9uLnByb3RvdHlwZS5faXNDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cnVlO1xufVxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2lzT3BlbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcGVuO1xufVxuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgaGVscGVyLmxvb3BLZXlzKHRoaXMubWV0YWRhdGEsIGZ1bmN0aW9uKG1ldGFkYXRhLCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhW2tleV0ucmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtZXRhZGF0YVtrZXldLnJlamVjdChuZXcgRXJyLlJlcWxTZXJ2ZXJFcnJvcihcbiAgICAgICAgICAgICdUaGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgcXVlcnkgY291bGQgYmUgY29tcGxldGVkLicsXG4gICAgICAgICAgICBtZXRhZGF0YVtrZXldLnF1ZXJ5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGFba2V5XS5lbmRSZWplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1ldGFkYXRhW2tleV0uZW5kUmVqZWN0KG5ldyBFcnIuUmVxbFNlcnZlckVycm9yKFxuICAgICAgICAgICAgJ1RoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBxdWVyeSBjb3VsZCBiZSBjb21wbGV0ZWQuJyxcbiAgICAgICAgICAgIG1ldGFkYXRhW2tleV0ucXVlcnkpKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLm1ldGFkYXRhID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvblxuIiwidmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIEVyciA9IHJlcXVpcmUoX19kaXJuYW1lKycvZXJyb3IuanMnKTtcbnZhciBoZWxwZXIgPSByZXF1aXJlKF9fZGlybmFtZSsnL2hlbHBlci5qcycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIE1BWF9DQUxMX1NUQUNLID0gMTAwMDtcblxuZnVuY3Rpb24gQ3Vyc29yKGNvbm5lY3Rpb24sIHRva2VuLCBvcHRpb25zLCB0eXBlKSB7XG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcblxuICB0aGlzLl9zdGFja1NpemUgPSAwOyAvLyBFc3RpbWF0aW9uIG9mIG91ciBjYWxsIHN0YWNrLlxuICB0aGlzLl9pbmRleCA9IDA7IC8vIFBvc2l0aW9uIGluIHRoaXMuX2RhdGFbMF1cbiAgdGhpcy5fZGF0YSA9IFtdOyAvLyBBcnJheSBvZiBub24gZW1wdHkgYXJyYXlzXG4gIHRoaXMuX2ZldGNoaW5nID0gZmFsc2U7IC8vIEFyZSB3ZSBmZXRjaGluZyBkYXRhXG4gIHRoaXMuX2NhbkZldGNoID0gdHJ1ZTsgLy8gQ2FuIHdlIGZldGNoIG1vcmUgZGF0YT9cbiAgdGhpcy5fcGVuZGluZ1Byb21pc2VzID0gW107IC8vIFBlbmRpbmcgcHJvbWlzZXMnIHJlc29sdmUvcmVqZWN0XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICB0aGlzLl9jbG9zaW5nUHJvbWlzZSA9IG51bGw7IC8vIFByb21pc2UgcmV0dXJuZWQgYnkgY2xvc2VcbiAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gIHRoaXMuX3NldEluY2x1ZGVzU3RhdGVzID0gZmFsc2U7XG4gIGlmICgodHlwZSA9PT0gJ2ZlZWQnKSB8fCAodHlwZSA9PT0gJ2F0b21GZWVkJykpIHtcbiAgICB0aGlzLnRvQXJyYXkgPSBfdW5zdXBwb3J0ZWRUb0FycmF5O1xuICB9XG4gIHRoaXMuX2VtaXR0ZWRFbmQgPSBmYWxzZTtcbn1cblxuQ3Vyc29yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyt0aGlzLl90eXBlKyddJztcbn1cbkN1cnNvci5wcm90b3R5cGUuc2V0SW5jbHVkZXNTdGF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc2V0SW5jbHVkZXNTdGF0ZXMgPSB0cnVlO1xufVxuQ3Vyc29yLnByb3RvdHlwZS5pbmNsdWRlc1N0YXRlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2V0SW5jbHVkZXNTdGF0ZXM7XG59XG5DdXJzb3IucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3R5cGU7XG59XG5cbkN1cnNvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl90eXBlID09PSAnQ3Vyc29yJykge1xuICAgIHRocm93IG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdZb3UgY2Fubm90IHNlcmlhbGl6ZSBhIEN1cnNvciB0byBKU09OLiBSZXRyaWV2ZSBkYXRhIGZyb20gdGhlIGN1cnNvciB3aXRoIGB0b0FycmF5YCBvciBgbmV4dGAnKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignWW91IGNhbm5vdCBzZXJpYWxpemUgYSAnK3RoaXMuX3R5cGUrJyB0byBKU09OLiBSZXRyaWV2ZSBkYXRhIGZyb20gdGhlIGN1cnNvciB3aXRoIGBlYWNoYCBvciBgbmV4dGAnKTtcbiAgfVxufVxuXG5DdXJzb3IucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fY2xvc2VkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKFxuICAgICAgJ1lvdSBjYW5ub3QgY2FsbCBgbmV4dGAgb24gYSBjbG9zZWQgJytzZWxmLl90eXBlKS5zZXRPcGVyYXRpb25hbCgpXG4gICAgKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIGlmICgoc2VsZi5fZGF0YS5sZW5ndGggPT09IDApICYmIChzZWxmLl9jYW5GZXRjaCA9PT0gZmFsc2UpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKFxuICAgICAgJ05vIG1vcmUgcm93cyBpbiB0aGUgJytzZWxmLl90eXBlLnRvTG93ZXJDYXNlKCkpLnNldE9wZXJhdGlvbmFsKClcbiAgICApLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICgoc2VsZi5fZGF0YS5sZW5ndGggPiAwKSAmJiAoc2VsZi5fZGF0YVswXS5sZW5ndGggPiBzZWxmLl9pbmRleCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBzZWxmLl9kYXRhWzBdW3NlbGYuX2luZGV4KytdO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXN1bHQpLm5vZGVpZnkoY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgcG9zc2libGUgaWYgd2UgZ2V0IGJhY2sgYmF0Y2ggd2l0aCBqdXN0IG9uZSBkb2N1bWVudD9cbiAgICAgICAgaWYgKHNlbGYuX2RhdGFbMF0ubGVuZ3RoID09PSBzZWxmLl9pbmRleCkge1xuICAgICAgICAgIHNlbGYuX2luZGV4ID0gMDtcbiAgICAgICAgICBzZWxmLl9kYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKChzZWxmLl9kYXRhLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICYmIChzZWxmLl9jYW5GZXRjaCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICYmIChzZWxmLl9jbG9zZWQgPT09IGZhbHNlKVxuICAgICAgICAgICAgJiYgKHNlbGYuX2ZldGNoaW5nID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZmV0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLm5vZGVpZnkoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5fcGVuZGluZ1Byb21pc2VzLnB1c2goe3Jlc29sdmU6IHJlc29sdmUsIHJlamVjdDogcmVqZWN0fSk7XG4gICAgICB9KS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cbkN1cnNvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgaGFzTmV4dGAgY29tbWFuZCBoYXMgYmVlbiByZW1vdmVkIGluIDEuMTMsIHBsZWFzZSB1c2UgYG5leHRgLicpXG59XG5DdXJzb3IucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0wO1xuICAgIHNlbGYuX2VhY2goZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9KS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgcmV0dXJuIHA7XG59XG5cbkN1cnNvci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fZmV0Y2hpbmcgPSB0cnVlO1xuXG4gIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgc2VsZi5jb25uZWN0aW9uLl9jb250aW51ZShzZWxmLnRva2VuLCByZXNvbHZlLCByZWplY3QpO1xuICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgc2VsZi5fcHVzaChyZXNwb25zZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fZmV0Y2hpbmcgPSBmYWxzZTtcbiAgICBzZWxmLl9jYW5GZXRjaCA9IGZhbHNlO1xuICAgIHNlbGYuX3B1c2hFcnJvcihlcnJvcik7XG4gIH0pXG59XG5cbkN1cnNvci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBjb3VsZGZldGNoID0gdGhpcy5fY2FuRmV0Y2g7XG4gIGlmIChkYXRhLmRvbmUpIHRoaXMuX2RvbmUoKTtcbiAgdmFyIHJlc3BvbnNlID0gZGF0YS5yZXNwb25zZTtcbiAgdGhpcy5fZmV0Y2hpbmcgPSBmYWxzZTtcbiAgLy8gSWYgdGhlIGN1cnNvciB3YXMgY2xvc2VkLCB3ZSBpZ25vcmUgYWxsIGZvbGxvd2luZyByZXNwb25zZVxuICBpZiAoKHJlc3BvbnNlLnIubGVuZ3RoID4gMCkgJiYgKGNvdWxkZmV0Y2ggPT09IHRydWUpKSB7XG4gICAgdGhpcy5fZGF0YS5wdXNoKGhlbHBlci5tYWtlU2VxdWVuY2UocmVzcG9uc2UsIHRoaXMub3B0aW9ucykpO1xuICB9XG4gIC8vIHRoaXMuX2ZldGNoaW5nID0gZmFsc2VcbiAgaWYgKCh0aGlzLl9jbG9zZWQgPT09IGZhbHNlKSAmJiAodGhpcy5fY2FuRmV0Y2gpICYmICh0aGlzLl9kYXRhLmxlbmd0aCA8PSAxKSkgdGhpcy5fZmV0Y2goKTtcbiAgdGhpcy5fZmx1c2goKTtcbn1cbi8vIFRyeSB0byBzb2x2ZSBhcyBtYW55IHBlbmRpbmcgcHJvbWlzZXMgYXMgcG9zc2libGVcbkN1cnNvci5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICgodGhpcy5fcGVuZGluZ1Byb21pc2VzLmxlbmd0aCA+IDApICYmICgodGhpcy5fZGF0YS5sZW5ndGggPiAwKSB8fCAoKHRoaXMuX2ZldGNoaW5nID09PSBmYWxzZSkgJiYgKHRoaXMuX2NhbkZldGNoID09PSBmYWxzZSkpKSkge1xuICAgIHZhciBmdWxsZmlsbGVyID0gdGhpcy5fcGVuZGluZ1Byb21pc2VzLnNoaWZ0KCk7XG4gICAgdmFyIHJlc29sdmUgPSBmdWxsZmlsbGVyLnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGZ1bGxmaWxsZXIucmVqZWN0O1xuXG4gICAgaWYgKHRoaXMuX2RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RhdGFbMF1bdGhpcy5faW5kZXgrK107XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZGF0YVswXS5sZW5ndGggPT09IHRoaXMuX2luZGV4KSB7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fZGF0YS5zaGlmdCgpO1xuICAgICAgICBpZiAoKHRoaXMuX2RhdGEubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgJiYgKHRoaXMuX2NhbkZldGNoID09PSB0cnVlKVxuICAgICAgICAgICYmICh0aGlzLl9jbG9zZWQgPT09IGZhbHNlKVxuICAgICAgICAgICYmICh0aGlzLl9mZXRjaGluZyA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9mZXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdObyBtb3JlIHJvd3MgaW4gdGhlICcrdGhpcy5fdHlwZS50b0xvd2VyQ2FzZSgpKS5zZXRPcGVyYXRpb25hbCgpKVxuICAgIH1cbiAgfVxufVxuQ3Vyc29yLnByb3RvdHlwZS5fcHVzaEVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdGhpcy5fZGF0YS5wdXNoKFtlcnJvcl0pO1xuICB0aGlzLl9mbHVzaCgpO1xufVxuXG5DdXJzb3IucHJvdG90eXBlLl9kb25lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NhbkZldGNoID0gZmFsc2U7XG4gIGlmICh0aGlzLl9ldmVudEVtaXR0ZXIpIHtcbiAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuQ3Vyc29yLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24oYXIpIHtcbiAgdGhpcy5fZmV0Y2hpbmcgPSBmYWxzZTtcbiAgdGhpcy5fY2FuRmV0Y2ggPSBmYWxzZTtcbiAgaWYgKGFyLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9kYXRhLnB1c2goYXIpO1xuICB9XG4gIHRoaXMuX2ZsdXNoKCk7XG59XG5cbkN1cnNvci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9jbG9zZWQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc2VsZi5fY2xvc2luZ1Byb21pc2Uubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cbiAgc2VsZi5fY2xvc2VkID0gdHJ1ZTtcblxuICBzZWxmLl9jbG9zaW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICgoc2VsZi5fY2FuRmV0Y2ggPT09IGZhbHNlKSAmJiAoc2VsZi5fZmV0Y2hpbmcgPT09IGZhbHNlKSkge1xuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIGVsc2UgeyAvLyBzaW5jZSB2MF80IChSZXRoaW5rREIgMi4wKSB3ZSBjYW4gKG11c3QpIGZvcmNlIGEgU1RPUCByZXF1ZXN0IGV2ZW4gaWYgYSBDT05USU5VRSBxdWVyeSBpcyBwZW5kaW5nXG4gICAgICB2YXIgZW5kQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlbGYuX2V2ZW50RW1pdHRlciAmJiAoc2VsZi5fZW1pdHRlZEVuZCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgc2VsZi5fZW1pdHRlZEVuZCA9IHRydWU7XG4gICAgICAgICAgc2VsZi5fZXZlbnRFbWl0dGVyLmVtaXQoJ2VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY29ubmVjdGlvbi5fZW5kKHNlbGYudG9rZW4sIGVuZENhbGxiYWNrLCByZWplY3QpO1xuICAgIH1cbiAgfSkubm9kZWlmeShjYWxsYmFjayk7XG4gIHJldHVybiBzZWxmLl9jbG9zaW5nUHJvbWlzZTtcbn1cbkN1cnNvci5wcm90b3R5cGUuX2VhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgb25GaW5pc2gpIHtcbiAgaWYgKHRoaXMuX2Nsb3NlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignWW91IGNhbm5vdCByZXRyaWV2ZSBkYXRhIGZyb20gYSBjdXJzb3IgdGhhdCBpcyBjbG9zZWQnKS5zZXRPcGVyYXRpb25hbCgpKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ05vIG1vcmUgcm93cyBpbiB0aGUgJytzZWxmLl90eXBlLnRvTG93ZXJDYXNlKCkrJy4nKSB7XG4gICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5fc3RhY2tTaXplKys7XG4gICAgdmFyIGtlZXBHb2luZyA9IGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIGlmIChrZWVwR29pbmcgPT09IGZhbHNlKSB7XG4gICAgICBpZiAodHlwZW9mIG9uRmluaXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHNlbGYuX2Nsb3NlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHNlbGYuX3N0YWNrU2l6ZSA8PSBNQVhfQ0FMTF9TVEFDSykge1xuICAgICAgICAgIHNlbGYuX25leHQoKS50aGVuKHJlc29sdmUpLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKGVycm9yLm1lc3NhZ2UgIT09ICdZb3UgY2Fubm90IHJldHJpZXZlIGRhdGEgZnJvbSBhIGN1cnNvciB0aGF0IGlzIGNsb3NlZC4nKSAmJlxuICAgICAgICAgICAgICAgIChlcnJvci5tZXNzYWdlLm1hdGNoKC9Zb3UgY2Fubm90IGNhbGwgYG5leHRgIG9uIGEgY2xvc2VkLykgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YWNrU2l6ZSA9IDA7XG4gICAgICAgICAgICBzZWxmLl9uZXh0KCkudGhlbihyZXNvbHZlKS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoKGVycm9yLm1lc3NhZ2UgIT09ICdZb3UgY2Fubm90IHJldHJpZXZlIGRhdGEgZnJvbSBhIGN1cnNvciB0aGF0IGlzIGNsb3NlZC4nKSAmJlxuICAgICAgICAgICAgICAgICAgKGVycm9yLm1lc3NhZ2UubWF0Y2goL1lvdSBjYW5ub3QgY2FsbCBgbmV4dGAgb24gYSBjbG9zZWQvKSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNlbGYuX25leHQoKS50aGVuKHJlc29sdmUpLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gV2UgY2FuIHNpbGVuY2UgZXJyb3Igd2hlbiB0aGUgY3Vyc29yIGlzIGNsb3NlZCBhcyB0aGlzXG4gICAgaWYgKChlcnJvci5tZXNzYWdlICE9PSAnWW91IGNhbm5vdCByZXRyaWV2ZSBkYXRhIGZyb20gYSBjdXJzb3IgdGhhdCBpcyBjbG9zZWQuJykgJiZcbiAgICAgICAgKGVycm9yLm1lc3NhZ2UubWF0Y2goL1lvdSBjYW5ub3QgY2FsbCBgbmV4dGAgb24gYSBjbG9zZWQvKSA9PT0gbnVsbCkpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5DdXJzb3IucHJvdG90eXBlLl9lYWNoQXN5bmMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZWxmLl9lYWNoQXN5bmNJbnRlcm5hbChjYWxsYmFjaywgcmVzb2x2ZSwgcmVqZWN0KVxuICB9KTtcbn1cbkN1cnNvci5wcm90b3R5cGUuX2VhY2hBc3luY0ludGVybmFsID0gZnVuY3Rpb24oY2FsbGJhY2ssIGZpbmFsUmVzb2x2ZSwgZmluYWxSZWplY3QpIHtcbiAgaWYgKHRoaXMuX2Nsb3NlZCA9PT0gdHJ1ZSkge1xuICAgIGZpbmFsUmVqZWN0KG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdZb3UgY2Fubm90IHJldHJpZXZlIGRhdGEgZnJvbSBhIGN1cnNvciB0aGF0IGlzIGNsb3NlZCcpLnNldE9wZXJhdGlvbmFsKCkpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIG5leHRDYiA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YWNrU2l6ZSsrO1xuICAgIHNlbGYuX25leHQoKS50aGVuKGZ1bmN0aW9uKHJvdykge1xuICAgICAgaWYgKHNlbGYuX3N0YWNrU2l6ZSA8PSBNQVhfQ0FMTF9TVEFDSykge1xuICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoY2FsbGJhY2socm93KSkudGhlbihuZXh0Q2IpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socm93LCByZXNvbHZlKVxuICAgICAgICAgIH0pLnRoZW4obmV4dENiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9zdGFja1NpemUgPSAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShjYWxsYmFjayhyb3cpKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJvdywgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgfSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKVxuICAgICAgICB9KS50aGVuKG5leHRDYik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAoKGVycm9yLm1lc3NhZ2UgPT09ICdObyBtb3JlIHJvd3MgaW4gdGhlICcrc2VsZi5fdHlwZS50b0xvd2VyQ2FzZSgpKycuJykgfHxcbiAgICAgICAgICAoZXJyb3IubWVzc2FnZSA9PT0gJ1lvdSBjYW5ub3QgcmV0cmlldmUgZGF0YSBmcm9tIGEgY3Vyc29yIHRoYXQgaXMgY2xvc2VkLicpIHx8XG4gICAgICAgICAgKGVycm9yLm1lc3NhZ2UubWF0Y2goL1lvdSBjYW5ub3QgY2FsbCBgbmV4dGAgb24gYSBjbG9zZWQvKSAhPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGZpbmFsUmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmFsUmVqZWN0KEVyci5zZXRPcGVyYXRpb25hbChlcnJvcikpO1xuICAgIH0pO1xuICB9XG4gIG5leHRDYigpO1xufVxuQ3Vyc29yLnByb3RvdHlwZS5lYWNoQXN5bmMgPSBDdXJzb3IucHJvdG90eXBlLl9lYWNoQXN5bmM7XG5DdXJzb3IucHJvdG90eXBlLm5leHQgPSBDdXJzb3IucHJvdG90eXBlLl9uZXh0O1xuQ3Vyc29yLnByb3RvdHlwZS5lYWNoID0gQ3Vyc29yLnByb3RvdHlwZS5fZWFjaDtcbkN1cnNvci5wcm90b3R5cGUuX3Vuc3VwcG9ydGVkVG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgdG9BcnJheWAgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgb24gZmVlZHMuJylcbn1cblxuQ3Vyc29yLnByb3RvdHlwZS5fbWFrZUVtaXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVyci5SZXFsRHJpdmVyRXJyb3IoJ1lvdSBjYW5ub3QgY2FsbCBgbmV4dGAgb25jZSB5b3UgaGF2ZSBib3VuZCBsaXN0ZW5lcnMgb24gdGhlICcrdGhpcy5fdHlwZSlcbiAgfVxuICB0aGlzLmVhY2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignWW91IGNhbm5vdCBjYWxsIGBlYWNoYCBvbmNlIHlvdSBoYXZlIGJvdW5kIGxpc3RlbmVycyBvbiB0aGUgJyt0aGlzLl90eXBlKVxuICB9XG4gIHRoaXMuZWFjaEFzeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVyci5SZXFsRHJpdmVyRXJyb3IoJ1lvdSBjYW5ub3QgY2FsbCBgZWFjaEFzeW5jYCBvbmNlIHlvdSBoYXZlIGJvdW5kIGxpc3RlbmVycyBvbiB0aGUgJyt0aGlzLl90eXBlKVxuICB9XG4gIHRoaXMudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnIuUmVxbERyaXZlckVycm9yKCdZb3UgY2Fubm90IGNhbGwgYHRvQXJyYXlgIG9uY2UgeW91IGhhdmUgYm91bmQgbGlzdGVuZXJzIG9uIHRoZSAnK3RoaXMuX3R5cGUpXG4gIH1cbiAgdGhpcy5fZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xufVxuQ3Vyc29yLnByb3RvdHlwZS5fZWFjaENiID0gZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gIC8vIFdlIHNob3VsZCBzaWxlbnQgdGhpbmdzIGlmIHRoZSBjdXJzb3IvZmVlZCBpcyBjbG9zZWRcbiAgaWYgKHRoaXMuX2Nsb3NlZCA9PT0gZmFsc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBtZXRob2RzID0gW1xuICAnYWRkTGlzdGVuZXInLFxuICAnb24nLFxuICAnb25jZScsXG4gICdyZW1vdmVMaXN0ZW5lcicsXG4gICdyZW1vdmVBbGxMaXN0ZW5lcnMnLFxuICAnc2V0TWF4TGlzdGVuZXJzJyxcbiAgJ2xpc3RlbmVycycsXG4gICdlbWl0J1xuXTtcblxuZm9yKHZhciBpPTA7IGk8bWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAoZnVuY3Rpb24obikge1xuICAgIHZhciBtZXRob2QgPSBtZXRob2RzW25dO1xuICAgIEN1cnNvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKHNlbGYuX2V2ZW50RW1pdHRlciA9PSBudWxsKSB7XG4gICAgICAgIHNlbGYuX21ha2VFbWl0dGVyKCk7XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLl9lYWNoKHNlbGYuX2VhY2hDYi5iaW5kKHNlbGYpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9lbWl0dGVkRW5kID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VsZi5fZXZlbnRFbWl0dGVyLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICAgIHNlbGYuX2V2ZW50RW1pdHRlclttZXRob2RdLmFwcGx5KHNlbGYuX2V2ZW50RW1pdHRlciwgX2FyZ3MpO1xuICAgIH07XG4gIH0pKGkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnNvcjtcbiIsIi8vIEltcGxlbWVudCBhIGRlcXVldWUgd2l0aCBhIGNpcmN1bGFyIGJ1ZmZlclxuLy8gVGhlIGJ1ZmZlciBjYW4gZXhwYW5kIGJ1dCBjdXJyZW50bHkgZG9lc24ndCBhdXRvbWF0aWNhbGx5IHNocmlua1xuLy8gYXMgaXQgaXMgbm90IGEgZGVzaXJlZCBiZWhhdmlvci4gV2UgbWF5IHdhbnQgdG8gZXhwbGljaXRseSByZXNpemUgaXQgdGhvdWdoLlxuZnVuY3Rpb24gRGVxdWV1ZShzaXplKSB7XG4gIHRoaXMuc3RhcnQgPSAwO1xuICB0aGlzLmVuZCA9IDA7XG5cbiAgc2l6ZSA9IHNpemUgfHwgNTA7XG4gIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KHNpemUpO1xufVxuRGVxdWV1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKHRoaXMuc3RhcnQraW5kZXggPiB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5zdGFydCtpbmRleC10aGlzLmJ1ZmZlci5sZW5ndGhdXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuc3RhcnQraW5kZXhdXG4gIH1cbn1cblxuRGVxdWV1ZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8dGhpcy5nZXRMZW5ndGgoKTsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2godGhpcy5nZXQoaSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbkRlcXVldWUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBjdXJyZW50LCBuZXh0O1xuICBpZiAodGhpcy5zdGFydCtpbmRleCA+PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjdXJyZW50ID0gdGhpcy5zdGFydCtpbmRleC10aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgbmV4dCA9IHRoaXMuc3RhcnQraW5kZXgtdGhpcy5idWZmZXIubGVuZ3RoKzE7XG4gIH1cbiAgZWxzZSB7XG4gICAgY3VycmVudCA9IHRoaXMuc3RhcnQraW5kZXg7XG4gICAgbmV4dCA9IHRoaXMuc3RhcnQraW5kZXgrMTtcbiAgfVxuXG4gIGZvcih2YXIgaT1pbmRleDsgaTwodGhpcy5idWZmZXIubGVuZ3RoLWluZGV4KTsgaSsrKSB7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuYnVmZmVyLmxlbmd0aCkgbmV4dCA9IDA7XG4gICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuYnVmZmVyLmxlbmd0aCkgY3VycmVudCA9IDA7XG5cbiAgICB0aGlzLmJ1ZmZlcltjdXJyZW50XSA9IHRoaXMuYnVmZmVyW25leHRdO1xuICAgIGN1cnJlbnQrKztcbiAgICBuZXh0Kys7XG4gIH1cblxuICB0aGlzLmVuZC0tO1xuICBpZiAodGhpcy5lbmQgPCAwKSB0aGlzLmVuZCA9IHRoaXMuYnVmZmVyLmxlbmd0aC0xXG59XG5cbkRlcXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIC8vIHB1c2ggb24gdGhpcy5lbmQgYW5kIHRoZW4gaW5jcmVhc2UgdGhpcy5lbmRcbiAgLy8gdGhpcy5lbmQgc2hvdWxkIE5FVkVSIGJlIGVxdWFsIHRvIHRoaXMuYnVmZmVyLmxlbmd0aFxuICB0aGlzLmJ1ZmZlclt0aGlzLmVuZF0gPSBlbGVtZW50O1xuICB0aGlzLmVuZCsrO1xuICBpZiAodGhpcy5lbmQgPT09IHRoaXMuYnVmZmVyLmxlbmd0aCkgdGhpcy5lbmQgPSAwO1xuXG4gIGlmICh0aGlzLnN0YXJ0ID09PSB0aGlzLmVuZCkge1xuICAgIC8vIFJlc2l6ZVxuICAgIHZhciBwcmV2aW91c0J1ZmZlciA9IHRoaXMuYnVmZmVyO1xuXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXkocHJldmlvdXNCdWZmZXIubGVuZ3RoKjIpO1xuXG4gICAgdmFyIGksIGsgPSAwO1xuICAgIGZvcihpPXRoaXMuc3RhcnQ7IGk8cHJldmlvdXNCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYnVmZmVyW2srK10gPSBwcmV2aW91c0J1ZmZlcltpXTtcbiAgICB9XG4gICAgZm9yKGk9MDsgaTx0aGlzLnN0YXJ0OyBpKyspIHtcbiAgICAgIHRoaXMuYnVmZmVyW2srK10gPSBwcmV2aW91c0J1ZmZlcltpXTtcbiAgICB9XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5lbmQgPSBwcmV2aW91c0J1ZmZlci5sZW5ndGg7XG4gIH1cbn1cblxuRGVxdWV1ZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAvL1RPRE86IERlY3JlYXNlIHNpemUgd2hlbiBwb3NzaWJsZS9uZWVkZWQ/IFRoaXMgbWF5IG5vdCBiZVxuICAvL3NvbWV0aGluZyB3ZSByZWFsbHkgbmVlZC93YW50XG4gIC8vIFJldHVybiB0aGUgZWxlbWVudCBpbiB0aGlzLmVuZC0xXG4gIGlmICh0aGlzLmdldExlbmd0aCgpID4gMCkge1xuICAgIHZhciBwb3MgPSB0aGlzLmVuZC0xO1xuICAgIGlmIChwb3MgPCAwKSBwb3MgPSB0aGlzLmJ1ZmZlci5sZW5ndGgtMTtcbiAgICB0aGlzLmVuZCA9IHBvcztcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5idWZmZXJbcG9zXTtcbiAgICB0aGlzLmJ1ZmZlcltwb3NdID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbkRlcXVldWUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIC8vIHB1c2ggb24gdGhpcy5zdGFydC0xIGFuZCB0aGVuIGRlY3JlYXNlIHRoaXMuc3RhcnQuXG4gIC8vIHRoaXMuZW5kIHNob3VsZCBORVZFUiBiZSBlcXVhbCB0byB0aGlzLmJ1ZmZlci5sZW5ndGhcblxuICB2YXIgcG9zID0gdGhpcy5zdGFydC0xO1xuICBpZiAocG9zIDwgMCkgcG9zID0gdGhpcy5idWZmZXIubGVuZ3RoLTE7XG5cbiAgdGhpcy5idWZmZXJbcG9zXSA9IGVsZW1lbnQ7XG4gIHRoaXMuc3RhcnQgPSBwb3M7XG5cbiAgaWYgKHRoaXMuc3RhcnQgPT09IHRoaXMuZW5kKSB7XG4gICAgLy9SZXNpemVcbiAgICB2YXIgcHJldmlvdXNCdWZmZXIgPSB0aGlzLmJ1ZmZlcjtcblxuICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KHByZXZpb3VzQnVmZmVyLmxlbmd0aCoyKTtcblxuICAgIHZhciBpLCBrID0gMDtcbiAgICBmb3IoaT10aGlzLnN0YXJ0OyBpPHByZXZpb3VzQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmJ1ZmZlcltrKytdID0gcHJldmlvdXNCdWZmZXJbaV07XG4gICAgfVxuICAgIGZvcihpPTA7IGk8dGhpcy5zdGFydDsgaSsrKSB7XG4gICAgICB0aGlzLmJ1ZmZlcltrKytdID0gcHJldmlvdXNCdWZmZXJbaV07XG4gICAgfVxuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuZW5kID0gcHJldmlvdXNCdWZmZXIubGVuZ3RoO1xuICB9XG59XG5cbkRlcXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFJldHVybiB0aGUgZWxlbWVudCBpbiB0aGlzLnN0YXJ0XG5cbiAgaWYgKHRoaXMuZ2V0TGVuZ3RoKCkgPiAwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuYnVmZmVyW3RoaXMuc3RhcnRdO1xuICAgIHRoaXMuYnVmZmVyW3RoaXMuc3RhcnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnQrKztcbiAgICBpZiAodGhpcy5zdGFydCA9PT0gdGhpcy5idWZmZXIubGVuZ3RoKSB0aGlzLnN0YXJ0ID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbkRlcXVldWUucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdGFydCA8PSB0aGlzLmVuZCkge1xuICAgIHJldHVybiB0aGlzLmVuZC10aGlzLnN0YXJ0O1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGgtKHRoaXMuc3RhcnQtdGhpcy5lbmQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVxdWV1ZTtcbiIsInZhciBoZWxwZXIgPSByZXF1aXJlKF9fZGlybmFtZSsnL2hlbHBlci5qcycpO1xudmFyIElOREVOVCA9IDQ7XG52YXIgTElNSVQgPSA4MDtcbnZhciBJU19PUEVSQVRJT05BTCA9ICdpc09wZXJhdGlvbmFsJztcblxudmFyIHByb3RvZGVmID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9wcm90b2RlZi5qcycpO1xudmFyIHJlc3BvbnNlVHlwZXMgPSBwcm90b2RlZi5SZXNwb25zZS5SZXNwb25zZVR5cGU7XG52YXIgcHJvdG9FcnJvclR5cGUgPSBwcm90b2RlZi5SZXNwb25zZS5FcnJvclR5cGU7XG52YXIgdGVybVR5cGVzID0gcHJvdG9kZWYuVGVybS5UZXJtVHlwZTtcbnZhciBkYXR1bVR5cGVzID0gcHJvdG9kZWYuRGF0dW0uRGF0dW1UeXBlO1xudmFyIGZyYW1lVHlwZXMgPSBwcm90b2RlZi5GcmFtZS5GcmFtZVR5cGU7XG5cblxuZnVuY3Rpb24gUmVxbERyaXZlckVycm9yKG1lc3NhZ2UsIHF1ZXJ5LCBzZWNvbmRNZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IHRoaXMubXNnID0gbWVzc2FnZTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVxbERyaXZlckVycm9yKTtcblxuICBpZiAoKEFycmF5LmlzQXJyYXkocXVlcnkpICYmIChxdWVyeS5sZW5ndGggPiAwKSkgfHwgKCFBcnJheS5pc0FycmF5KHF1ZXJ5KSAmJiBxdWVyeSAhPSBudWxsKSkge1xuICAgIGlmICgodGhpcy5tZXNzYWdlLmxlbmd0aCA+IDApICYmICh0aGlzLm1lc3NhZ2VbdGhpcy5tZXNzYWdlLmxlbmd0aC0xXSA9PT0gJy4nKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5sZW5ndGgtMSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubWVzc2FnZSArPSAnIGFmdGVyOlxcbic7XG5cbiAgICB2YXIgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UocXVlcnksIDAsIG51bGwsIFtdLCB7aW5kZW50OiAwLCBleHRyYTogMH0pO1xuXG4gICAgdGhpcy5tZXNzYWdlICs9IGJhY2t0cmFjZS5zdHI7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMubWVzc2FnZVt0aGlzLm1lc3NhZ2UubGVuZ3RoLTFdICE9PSAnPycpIHRoaXMubWVzc2FnZSArPSAnLic7XG4gIH1cbiAgaWYgKHNlY29uZE1lc3NhZ2UpIHRoaXMubWVzc2FnZSArPSAnXFxuJytzZWNvbmRNZXNzYWdlO1xufTtcblJlcWxEcml2ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblJlcWxEcml2ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdSZXFsRHJpdmVyRXJyb3InO1xuUmVxbERyaXZlckVycm9yLnByb3RvdHlwZS5zZXRPcGVyYXRpb25hbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzW0lTX09QRVJBVElPTkFMXSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMuUmVxbERyaXZlckVycm9yID0gUmVxbERyaXZlckVycm9yO1xuXG5cbmZ1bmN0aW9uIFJlcWxTZXJ2ZXJFcnJvcihtZXNzYWdlLCBxdWVyeSkge1xuICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1zZyA9IG1lc3NhZ2U7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcWxTZXJ2ZXJFcnJvcik7XG5cbiAgaWYgKChBcnJheS5pc0FycmF5KHF1ZXJ5KSAmJiAocXVlcnkubGVuZ3RoID4gMCkpIHx8ICghQXJyYXkuaXNBcnJheShxdWVyeSkgJiYgcXVlcnkgIT0gbnVsbCkpIHtcbiAgICBpZiAoKHRoaXMubWVzc2FnZS5sZW5ndGggPiAwKSAmJiAodGhpcy5tZXNzYWdlW3RoaXMubWVzc2FnZS5sZW5ndGgtMV0gPT09ICcuJykpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMubWVzc2FnZS5zbGljZSgwLCB0aGlzLm1lc3NhZ2UubGVuZ3RoLTEpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm1lc3NhZ2UgKz0gJyBmb3I6XFxuJztcblxuICAgIHZhciBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZShxdWVyeSwgMCwgbnVsbCwgW10sIHtpbmRlbnQ6IDAsIGV4dHJhOiAwfSk7XG5cbiAgICB0aGlzLm1lc3NhZ2UgKz0gYmFja3RyYWNlLnN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodGhpcy5tZXNzYWdlW3RoaXMubWVzc2FnZS5sZW5ndGgtMV0gIT09ICc/JykgdGhpcy5tZXNzYWdlICs9ICcuJztcbiAgfVxufTtcblJlcWxTZXJ2ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblJlcWxTZXJ2ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdSZXFsU2VydmVyRXJyb3InO1xuUmVxbFNlcnZlckVycm9yLnByb3RvdHlwZVtJU19PUEVSQVRJT05BTF0gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cy5SZXFsU2VydmVyRXJyb3IgPSBSZXFsU2VydmVyRXJyb3I7XG5cblxuZnVuY3Rpb24gUmVxbFJ1bnRpbWVFcnJvcihtZXNzYWdlLCBxdWVyeSwgZnJhbWVzKSB7XG4gIHRoaXMubWVzc2FnZSA9IHRoaXMubXNnID0gbWVzc2FnZTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVxbFJ1bnRpbWVFcnJvcik7XG5cbiAgaWYgKChxdWVyeSAhPSBudWxsKSAmJiAoZnJhbWVzKSkge1xuICAgIGlmICgodGhpcy5tZXNzYWdlLmxlbmd0aCA+IDApICYmICh0aGlzLm1lc3NhZ2VbdGhpcy5tZXNzYWdlLmxlbmd0aC0xXSA9PT0gJy4nKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5sZW5ndGgtMSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubWVzc2FnZSArPSAnIGluOlxcbic7XG5cbiAgICBmcmFtZXMgPSBmcmFtZXMuYjtcbiAgICBpZiAoZnJhbWVzKSB0aGlzLmZyYW1lcyA9IGZyYW1lcy5zbGljZSgwKTtcbiAgICAvL3RoaXMuZnJhbWVzID0gSlNPTi5zdHJpbmdpZnkoZnJhbWVzLCBudWxsLCAyKTtcblxuICAgIHZhciBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZShxdWVyeSwgMCwgbnVsbCwgZnJhbWVzLCB7aW5kZW50OiAwLCBleHRyYTogMH0pO1xuXG4gICAgdmFyIHF1ZXJ5TGluZXMgPSBiYWNrdHJhY2Uuc3RyLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgY2Fycm90TGluZXMgPSBiYWNrdHJhY2UuY2FyLnNwbGl0KCdcXG4nKTtcblxuICAgIGZvcih2YXIgaT0wOyBpPHF1ZXJ5TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubWVzc2FnZSArPSBxdWVyeUxpbmVzW2ldKydcXG4nO1xuICAgICAgaWYgKGNhcnJvdExpbmVzW2ldLm1hdGNoKC9cXF4vKSkge1xuICAgICAgICB2YXIgcG9zID0gcXVlcnlMaW5lc1tpXS5tYXRjaCgvW15cXHNdLyk7XG4gICAgICAgIGlmICgocG9zKSAmJiAocG9zLmluZGV4KSkge1xuICAgICAgICAgIHRoaXMubWVzc2FnZSArPSBzcGFjZShwb3MuaW5kZXgpK2NhcnJvdExpbmVzW2ldLnNsaWNlKHBvcy5pbmRleCkrJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlICs9IGNhcnJvdExpbmVzW2ldKydcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vdGhpcy5xdWVyeSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LCBudWxsLCAyKTtcbn07XG5SZXFsUnVudGltZUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuUmVxbFJ1bnRpbWVFcnJvci5wcm90b3R5cGUubmFtZSA9ICdSZXFsUnVudGltZUVycm9yJztcblJlcWxSdW50aW1lRXJyb3IucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBwcm90b0Vycm9yVHlwZS5JTlRFUk5BTDpcbiAgICAgIHRoaXMubmFtZSA9ICdSZXFsSW50ZXJuYWxFcnJvcic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHByb3RvRXJyb3JUeXBlLlJFU09VUkNFX0xJTUlUOlxuICAgICAgdGhpcy5uYW1lID0gJ1JlcWxSZXNvdXJjZUVycm9yJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcHJvdG9FcnJvclR5cGUuUVVFUllfTE9HSUM6XG4gICAgICB0aGlzLm5hbWUgPSAnUmVxbExvZ2ljRXJyb3InO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwcm90b0Vycm9yVHlwZS5PUF9GQUlMRUQ6XG4gICAgICB0aGlzLm5hbWUgPSAnUmVxbE9wRmFpbGVkRXJyb3InO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwcm90b0Vycm9yVHlwZS5PUF9JTkRFVEVSTUlOQVRFOlxuICAgICAgdGhpcy5uYW1lID0gJ1JlcWxPcEluZGV0ZXJtaW5hdGVFcnJvcic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHByb3RvRXJyb3JUeXBlLlVTRVI6XG4gICAgICB0aGlzLm5hbWUgPSAnUmVxbFVzZXJFcnJvcic7XG4gICAgICBicmVhaztcbiAgICAvL2RlZmF1bHQ6IC8vIERvIG5vdGhpbmdcbiAgfVxufVxuUmVxbFJ1bnRpbWVFcnJvci5wcm90b3R5cGVbSVNfT1BFUkFUSU9OQUxdID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMuUmVxbFJ1bnRpbWVFcnJvciA9IFJlcWxSdW50aW1lRXJyb3I7XG5cblxuZnVuY3Rpb24gUmVxbENvbXBpbGVFcnJvcihtZXNzYWdlLCBxdWVyeSwgZnJhbWVzKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcWxDb21waWxlRXJyb3IpO1xuXG4gIGlmICgocXVlcnkgIT0gbnVsbCkgJiYgKGZyYW1lcykpIHtcbiAgICBpZiAoKHRoaXMubWVzc2FnZS5sZW5ndGggPiAwKSAmJiAodGhpcy5tZXNzYWdlW3RoaXMubWVzc2FnZS5sZW5ndGgtMV0gPT09ICcuJykpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMubWVzc2FnZS5zbGljZSgwLCB0aGlzLm1lc3NhZ2UubGVuZ3RoLTEpO1xuICAgIH1cblxuICAgIHRoaXMubWVzc2FnZSArPSAnIGluOlxcbic7XG5cbiAgICBmcmFtZXMgPSBmcmFtZXMuYjtcbiAgICBpZiAoZnJhbWVzKSB0aGlzLmZyYW1lcyA9IGZyYW1lcy5zbGljZSgwKTtcbiAgICAvL3RoaXMuZnJhbWVzID0gSlNPTi5zdHJpbmdpZnkoZnJhbWVzLCBudWxsLCAyKTtcblxuICAgIHZhciBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZShxdWVyeSwgMCwgbnVsbCwgZnJhbWVzLCB7aW5kZW50OiAwLCBleHRyYTogMH0pO1xuXG4gICAgdmFyIHF1ZXJ5TGluZXMgPSBiYWNrdHJhY2Uuc3RyLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgY2Fycm90TGluZXMgPSBiYWNrdHJhY2UuY2FyLnNwbGl0KCdcXG4nKTtcblxuICAgIGZvcih2YXIgaT0wOyBpPHF1ZXJ5TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubWVzc2FnZSArPSBxdWVyeUxpbmVzW2ldKydcXG4nO1xuICAgICAgaWYgKGNhcnJvdExpbmVzW2ldLm1hdGNoKC9cXF4vKSkge1xuICAgICAgICB2YXIgcG9zID0gcXVlcnlMaW5lc1tpXS5tYXRjaCgvW15cXHNdLyk7XG4gICAgICAgIGlmICgocG9zKSAmJiAocG9zLmluZGV4KSkge1xuICAgICAgICAgIHRoaXMubWVzc2FnZSArPSBzcGFjZShwb3MuaW5kZXgpK2NhcnJvdExpbmVzW2ldLnNsaWNlKHBvcy5pbmRleCkrJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlICs9IGNhcnJvdExpbmVzW2ldKydcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuUmVxbENvbXBpbGVFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblJlcWxDb21waWxlRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnUmVxbENvbXBpbGVFcnJvcic7XG5SZXFsQ29tcGlsZUVycm9yLnByb3RvdHlwZVtJU19PUEVSQVRJT05BTF0gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cy5SZXFsQ29tcGlsZUVycm9yID0gUmVxbENvbXBpbGVFcnJvcjtcblxuXG5mdW5jdGlvbiBSZXFsQ2xpZW50RXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXFsQ2xpZW50RXJyb3IpO1xufTtcblJlcWxDbGllbnRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblJlcWxDbGllbnRFcnJvci5wcm90b3R5cGUubmFtZSA9ICdSZXFsQ2xpZW50RXJyb3InO1xuUmVxbENsaWVudEVycm9yLnByb3RvdHlwZVtJU19PUEVSQVRJT05BTF0gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cy5SZXFsQ2xpZW50RXJyb3IgPSBSZXFsQ2xpZW50RXJyb3I7XG5cblxuXG52YXIgX2NvbnN0YW50cyA9IHtcbiAgTU9OREFZOiB0cnVlLFxuICBUVUVTREFZOiB0cnVlLFxuICBXRURORVNEQVk6IHRydWUsXG4gIFRIVVJTREFZOiB0cnVlLFxuICBGUklEQVk6IHRydWUsXG4gIFNBVFVSREFZOiB0cnVlLFxuICBTVU5EQVk6IHRydWUsXG4gIEpBTlVBUlk6IHRydWUsXG4gIEZFQlJVQVJZOiB0cnVlLFxuICBNQVJDSDogdHJ1ZSxcbiAgQVBSSUw6IHRydWUsXG4gIE1BWTogdHJ1ZSxcbiAgSlVORTogdHJ1ZSxcbiAgSlVMWTogdHJ1ZSxcbiAgQVVHVVNUOiB0cnVlLFxuICBTRVBURU1CRVI6IHRydWUsXG4gIE9DVE9CRVI6IHRydWUsXG4gIE5PVkVNQkVSOiB0cnVlLFxuICBERUNFTUJFUjogdHJ1ZSxcbiAgTUlOVkFMOiB0cnVlLFxuICBNQVhWQUw6IHRydWUsXG59XG52YXIgY29uc3RhbnRzID0ge307XG5mb3IodmFyIGtleSBpbiBfY29uc3RhbnRzKSB7XG4gIGNvbnN0YW50c1t0ZXJtVHlwZXNba2V5XV0gPSB0cnVlO1xufVxuXG5cbnZhciBfbm9uUHJlZml4ID0ge1xuICBEQjogdHJ1ZSxcbiAgREJfQ1JFQVRFOiB0cnVlLFxuICBEQl9MSVNUOiB0cnVlLFxuICBEQl9EUk9QOiB0cnVlLFxuICBKUzogdHJ1ZSxcbiAgTk9XOiB0cnVlLFxuICBUSU1FOiB0cnVlLFxuICBFUE9DSF9USU1FOiB0cnVlLFxuICBJU084NjAxOiB0cnVlLFxuICBCUkFOQ0g6IHRydWUsXG4gIEpBVkFTQ1JJUFQ6IHRydWUsXG4gIEVSUk9SOiB0cnVlLFxuICBNQUtFX0FSUkFZOiB0cnVlLFxuICBKU09OOiB0cnVlLFxuICBBUkdTOiB0cnVlLFxuICBIVFRQOiB0cnVlLFxuICBSQU5ET006IHRydWUsXG4gIEJJTkFSWTogdHJ1ZSxcbiAgT0JKRUNUOiB0cnVlLFxuICBDSVJDTEU6IHRydWUsXG4gIEdFT0pTT046IHRydWUsXG4gIFBPSU5UOiB0cnVlLFxuICBMSU5FOiB0cnVlLFxuICBQT0xZR09OOiB0cnVlLFxuICBVVUlEOiB0cnVlLFxuICBERVNDOiB0cnVlLFxuICBBU0M6IHRydWUsXG4gIFJBTkdFOiB0cnVlLFxuICBMSVRFUkFMOiAndHJ1ZSdcbn1cbnZhciBub25QcmVmaXggPSB7fTtcbmZvcih2YXIga2V5IGluIF9ub25QcmVmaXgpIHtcbiAgbm9uUHJlZml4W3Rlcm1UeXBlc1trZXldXSA9IHRydWU7XG59XG4vLyBDb25zdGFudHMgYXJlIGFsc28gaW4gbm9uUHJlZml4XG5mb3IodmFyIGtleSBpbiBfY29uc3RhbnRzKSB7XG4gIG5vblByZWZpeFt0ZXJtVHlwZXNba2V5XV0gPSB0cnVlO1xufVxuXG5cbnZhciBfdHlwZVRvU3RyaW5nID0ge1xuICBEQjogJ2RiJyxcbiAgREJfQ1JFQVRFOiAnZGJDcmVhdGUnLFxuICBEQl9MSVNUOiAnZGJMaXN0JyxcbiAgREJfRFJPUDogJ2RiRHJvcCcsXG4gIFRBQkxFX0NSRUFURTogJ3RhYmxlQ3JlYXRlJyxcbiAgVEFCTEVfTElTVDogJ3RhYmxlTGlzdCcsXG4gIFRBQkxFX0RST1A6ICd0YWJsZURyb3AnLFxuICBUQUJMRTogJ3RhYmxlJyxcbiAgSU5ERVhfQ1JFQVRFOiAnaW5kZXhDcmVhdGUnLFxuICBJTkRFWF9EUk9QOiAnaW5kZXhEcm9wJyxcbiAgSU5ERVhfTElTVDogJ2luZGV4TGlzdCcsXG4gIElOREVYX1dBSVQ6ICdpbmRleFdhaXQnLFxuICBJTkRFWF9TVEFUVVM6ICdpbmRleFN0YXR1cycsXG4gIElOU0VSVDogJ2luc2VydCcsXG4gIFVQREFURTogJ3VwZGF0ZScsXG4gIFJFUExBQ0U6ICdyZXBsYWNlJyxcbiAgREVMRVRFOiAnZGVsZXRlJyxcbiAgU1lOQzogJ3N5bmMnLFxuICBHRVQ6ICdnZXQnLFxuICBHRVRfQUxMOiAnZ2V0QWxsJyxcbiAgQkVUV0VFTjogJ2JldHdlZW4nLFxuICBGSUxURVI6ICdmaWx0ZXInLFxuICBJTk5FUl9KT0lOOiAnaW5uZXJKb2luJyxcbiAgT1VURVJfSk9JTjogJ291dGVySm9pbicsXG4gIEVRX0pPSU46ICdlcUpvaW4nLFxuICBaSVA6ICd6aXAnLFxuICBNQVA6ICdtYXAnLFxuICBXSVRIX0ZJRUxEUzogJ3dpdGhGaWVsZHMnLFxuICBDT05DQVRfTUFQOiAnY29uY2F0TWFwJyxcbiAgT1JERVJfQlk6ICdvcmRlckJ5JyxcbiAgREVTQzogJ2Rlc2MnLFxuICBBU0M6ICdhc2MnLFxuICBTS0lQOiAnc2tpcCcsXG4gIExJTUlUOiAnbGltaXQnLFxuICBTTElDRTogJ3NsaWNlJyxcbiAgTlRIOiAnbnRoJyxcbiAgT0ZGU0VUU19PRjogJ29mZnNldHNPZicsXG4gIElTX0VNUFRZOiAnaXNFbXB0eScsXG4gIFVOSU9OOiAndW5pb24nLFxuICBTQU1QTEU6ICdzYW1wbGUnLFxuICBSRURVQ0U6ICdyZWR1Y2UnLFxuICBDT1VOVDogJ2NvdW50JyxcbiAgU1VNOiAnc3VtJyxcbiAgQVZHOiAnYXZnJyxcbiAgTUlOOiAnbWluJyxcbiAgTUFYOiAnbWF4JyxcbiAgRk9MRDogJ2ZvbGQnLFxuICBPQkpFQ1Q6ICdvYmplY3QnLFxuICBESVNUSU5DVDogJ2Rpc3RpbmN0JyxcbiAgR1JPVVA6ICdncm91cCcsXG4gIFVOR1JPVVA6ICd1bmdyb3VwJyxcbiAgQ09OVEFJTlM6ICdjb250YWlucycsXG4gIElNUExJQ0lUX1ZBUjogJ3JvdycsXG4gIFBMVUNLOiAncGx1Y2snLFxuICBXSVRIT1VUOiAnd2l0aG91dCcsXG4gIE1FUkdFOiAnbWVyZ2UnLFxuICBBUFBFTkQ6ICdhcHBlbmQnLFxuICBQUkVQRU5EOiAncHJlcGVuZCcsXG4gIERJRkZFUkVOQ0U6ICdkaWZmZXJlbmNlJyxcbiAgU0VUX0lOU0VSVDogJ3NldEluc2VydCcsXG4gIFNFVF9VTklPTjogJ3NldFVuaW9uJyxcbiAgU0VUX0lOVEVSU0VDVElPTjogJ3NldEludGVyc2VjdGlvbicsXG4gIFNFVF9ESUZGRVJFTkNFOiAnc2V0RGlmZmVyZW5jZScsXG4gIEhBU19GSUVMRFM6ICdoYXNGaWVsZHMnLFxuICBJTlNFUlRfQVQ6ICdpbnNlcnRBdCcsXG4gIFNQTElDRV9BVDogJ3NwbGljZUF0JyxcbiAgREVMRVRFX0FUOiAnZGVsZXRlQXQnLFxuICBDSEFOR0VfQVQ6ICdjaGFuZ2VBdCcsXG4gIEtFWVM6ICdrZXlzJyxcbiAgVkFMVUVTOiAndmFsdWVzJyxcbiAgTUFUQ0g6ICdtYXRjaCcsXG4gIFVQQ0FTRTogJ3VwY2FzZScsXG4gIERPV05DQVNFOiAnZG93bmNhc2UnLFxuICBBREQ6ICdhZGQnLFxuICBTVUI6ICdzdWInLFxuICBNVUw6ICdtdWwnLFxuICBESVY6ICdkaXYnLFxuICBNT0Q6ICdtb2QnLFxuICBBTkQ6ICdhbmQnLFxuICBPUjogJ29yJyxcbiAgRVE6ICdlcScsXG4gIE5FOiAnbmUnLFxuICBHVDogJ2d0JyxcbiAgR0U6ICdnZScsXG4gIExUOiAnbHQnLFxuICBMRTogJ2xlJyxcbiAgTk9UOiAnbm90JyxcbiAgRkxPT1I6ICdmbG9vcicsXG4gIENFSUw6ICdjZWlsJyxcbiAgUk9VTkQ6ICdyb3VuZCcsXG4gIE5PVzogJ25vdycsXG4gIFRJTUU6ICd0aW1lJyxcbiAgRVBPQ0hfVElNRTogJ2Vwb2NoVGltZScsXG4gIElTTzg2MDE6ICdJU084NjAxJyxcbiAgSU5fVElNRVpPTkU6ICdpblRpbWV6b25lJyxcbiAgVElNRVpPTkU6ICd0aW1lem9uZScsXG4gIERVUklORzogJ2R1cmluZycsXG4gIERBVEU6ICdkYXRlJyxcbiAgVElNRV9PRl9EQVk6ICd0aW1lT2ZEYXknLFxuICBZRUFSOiAneWVhcicsXG4gIE1PTlRIOiAnbW9udGgnLFxuICBEQVk6ICdkYXknLFxuICBEQVlfT0ZfV0VFSzogJ2RheU9mV2VlaycsXG4gIERBWV9PRl9ZRUFSOiAnZGF5T2ZZZWFyJyxcbiAgSE9VUlM6ICdob3VycycsXG4gIE1JTlVURVM6ICdtaW51dGVzJyxcbiAgU0VDT05EUzogJ3NlY29uZHMnLFxuICBUT19JU084NjAxOiAndG9JU084NjAxJyxcbiAgVE9fRVBPQ0hfVElNRTogJ3RvRXBvY2hUaW1lJyxcbiAgRlVOQ0FMTDogJ2RvJyxcbiAgQlJBTkNIOiAnYnJhbmNoJyxcbiAgRk9SX0VBQ0g6ICdmb3JFYWNoJyxcbiAgRVJST1I6ICdlcnJvcicsXG4gIERFRkFVTFQ6ICdkZWZhdWx0JyxcbiAgSkFWQVNDUklQVDogJ2pzJyxcbiAgQ09FUkNFX1RPOiAnY29lcmNlVG8nLFxuICBUWVBFX09GOiAndHlwZU9mJyxcbiAgSU5GTzogJ2luZm8nLFxuICBKU09OOiAnanNvbicsXG4gIEFSR1M6ICdhcmdzJyxcbiAgSFRUUDogJ2h0dHAnLFxuICBSQU5ET006ICdyYW5kb20nLFxuICBDSEFOR0VTOiAnY2hhbmdlcycsXG4gIEJJTkFSWTogJ2JpbmFyeScsXG4gIElOREVYX1JFTkFNRTogJ2luZGV4UmVuYW1lJyxcbiAgQ0lSQ0xFOiAnY2lyY2xlJyxcbiAgRElTVEFOQ0U6ICdkaXN0YW5jZScsXG4gIEZJTEw6ICdmaWxsJyxcbiAgR0VPSlNPTjogJ2dlb2pzb24nLFxuICBUT19HRU9KU09OOiAndG9HZW9qc29uJyxcbiAgR0VUX0lOVEVSU0VDVElORzogJ2dldEludGVyc2VjdGluZycsXG4gIEdFVF9ORUFSRVNUOiAnZ2V0TmVhcmVzdCcsXG4gIElOQ0xVREVTOiAnaW5jbHVkZXMnLFxuICBJTlRFUlNFQ1RTOiAnaW50ZXJzZWN0cycsXG4gIExJTkU6ICdsaW5lJyxcbiAgUE9JTlQ6ICdwb2ludCcsXG4gIFBPTFlHT046ICdwb2x5Z29uJyxcbiAgUE9MWUdPTl9TVUI6ICdwb2x5Z29uU3ViJyxcbiAgVVVJRDogJ3V1aWQnLFxuICBSQU5HRTogJ3JhbmdlJyxcbiAgVE9fSlNPTl9TVFJJTkc6ICd0b0pTT04nLFxuICBDT05GSUc6ICdjb25maWcnLFxuICBTVEFUVVM6ICdzdGF0dXMnLFxuICBXQUlUOiAnd2FpdCcsXG4gIFJFQ09ORklHVVJFOiAncmVjb25maWd1cmUnLFxuICBSRUJBTEFOQ0U6ICdyZWJhbGFuY2UnLFxuICBHUkFOVDogJ2dyYW50JyxcbiAgU1BMSVQ6ICdzcGxpdCcsXG4gIExJVEVSQUw6ICdsaXRlcmFsJyxcbiAgTU9OREFZOiAnbW9uZGF5JyxcbiAgVFVFU0RBWTogJ3R1ZXNkYXknLFxuICBXRURORVNEQVk6ICd3ZWRuZXNkYXknLFxuICBUSFVSU0RBWTogJ3RodXJzZGF5JyxcbiAgRlJJREFZOiAnZnJpZGF5JyxcbiAgU0FUVVJEQVk6ICdzYXR1cmRheScsXG4gIFNVTkRBWTogJ3N1bmRheScsXG4gIEpBTlVBUlk6ICdqYW51YXJ5JyxcbiAgRkVCUlVBUlk6ICdmZWJydWFyeScsXG4gIE1BUkNIOiAnbWFyY2gnLFxuICBBUFJJTDogJ2FwcmlsJyxcbiAgTUFZOiAnbWF5JyxcbiAgSlVORTogJ2p1bmUnLFxuICBKVUxZOiAnanVseScsXG4gIEFVR1VTVDogJ2F1Z3VzdCcsXG4gIFNFUFRFTUJFUjogJ3NlcHRlbWJlcicsXG4gIE9DVE9CRVI6ICdvY3RvYmVyJyxcbiAgTk9WRU1CRVI6ICdub3ZlbWJlcicsXG4gIERFQ0VNQkVSOiAnZGVjZW1iZXInICxcbiAgTUlOVkFMOiAnbWludmFsJyxcbiAgTUFYVkFMOiAnbWF4dmFsJyxcbn1cbnZhciB0eXBlVG9TdHJpbmcgPSB7fTtcbmZvcih2YXIga2V5IGluIF90eXBlVG9TdHJpbmcpIHtcbiAgdHlwZVRvU3RyaW5nW3Rlcm1UeXBlc1trZXldXSA9IF90eXBlVG9TdHJpbmdba2V5XTtcbn1cblxudmFyIF9ub1ByZWZpeE9wdGFyZ3MgPSB7XG4gIElTTzg2MDE6IHRydWUsXG59XG52YXIgbm9QcmVmaXhPcHRhcmdzID0ge307XG5mb3IodmFyIGtleSBpbiBfbm9QcmVmaXhPcHRhcmdzKSB7XG4gIG5vUHJlZml4T3B0YXJnc1t0ZXJtVHlwZXNba2V5XV0gPSB0cnVlO1xufVxuXG52YXIgX3NwZWNpYWxUeXBlID0ge1xuICBEQVRVTTogZnVuY3Rpb24odGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zLCBvcHRhcmcpIHtcbiAgICBvcHRhcmcgPSBvcHRhcmcgfHwgZmFsc2U7XG5cbiAgICB2YXIgdW5kZXJsaW5lID0gQXJyYXkuaXNBcnJheShmcmFtZXMpICYmIChmcmFtZXMubGVuZ3RoID09PSAwKTtcbiAgICB2YXIgY3VycmVudEZyYW1lLCBiYWNrdHJhY2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZnJhbWVzKSkgY3VycmVudEZyYW1lID0gZnJhbWVzLnNoaWZ0KCk7XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RyOiAnJyxcbiAgICAgIGNhcjogJydcbiAgICB9XG5cbiAgICBpZiAoKGhlbHBlci5pc1BsYWluT2JqZWN0KHRlcm0pKSAmJiAodGVybS4kcmVxbF90eXBlJCA9PT0gJ0JJTkFSWScpKSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnci5iaW5hcnkoPEJ1ZmZlcj4pJywgdW5kZXJsaW5lKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKChpbmRleCA9PT0gMCkgJiYgKChmYXRoZXIgPT0gbnVsbCkgfHwgKCFub25QcmVmaXhbZmF0aGVyWzBdXSkpKSBjYXJpZnkocmVzdWx0LCAnci5leHByKCcsIHVuZGVybGluZSlcblxuICAgIGlmICh0eXBlb2YgdGVybSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnXCInK3Rlcm0rJ1wiJywgdW5kZXJsaW5lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3QodGVybSkpIHtcbiAgICAgIHZhciB0b3RhbEtleXMgPSBPYmplY3Qua2V5cyh0ZXJtKS5sZW5ndGg7XG4gICAgICBpZiAodG90YWxLZXlzID09PSAwKSB7XG4gICAgICAgIGNhcmlmeShyZXN1bHQsICd7fScsIHVuZGVybGluZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FyaWZ5KHJlc3VsdCwgJ3tcXG4nLCB1bmRlcmxpbmUpO1xuICAgICAgICB2YXIgY291bnRLZXlzID0gMDtcbiAgICAgICAgdmFyIGV4dHJhVG9SZW1vdmUgPSBvcHRpb25zLmV4dHJhO1xuICAgICAgICBvcHRpb25zLmluZGVudCArPSBJTkRFTlQrb3B0aW9ucy5leHRyYTtcbiAgICAgICAgb3B0aW9ucy5leHRyYSA9IDA7XG4gICAgICAgIGZvcih2YXIga2V5IGluIHRlcm0pIHtcbiAgICAgICAgICBjb3VudEtleXMrKztcbiAgICAgICAgICAvL2lmICghKChmYXRoZXIpICYmIChBcnJheS5pc0FycmF5KGZhdGhlclsyXSkpICYmIChPYmplY3Qua2V5cyhmYXRoZXJbMl0pLmxlbmd0aCA+IDApKSkgb3B0aW9ucy5leHRyYSA9IDA7XG5cbiAgICAgICAgICBpZiAob3B0YXJnKSB7XG4gICAgICAgICAgICBjYXJpZnkocmVzdWx0LCBzcGFjZShvcHRpb25zLmluZGVudCkrY2FtZWxDYXNlKGtleSkrJzogJywgdW5kZXJsaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXJpZnkocmVzdWx0LCBzcGFjZShvcHRpb25zLmluZGVudCkra2V5Kyc6ICcsIHVuZGVybGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgPT09IGtleSkpIHtcbiAgICAgICAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1ba2V5XSwgaSwgdGVybSwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtW2tleV0sIGksIHRlcm0sIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQuc3RyICs9IGJhY2t0cmFjZS5zdHI7XG4gICAgICAgICAgcmVzdWx0LmNhciArPSBiYWNrdHJhY2UuY2FyO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjb3VudEtleXMgIT09IHRvdGFsS2V5cykgeyBcbiAgICAgICAgICAgIGNhcmlmeShyZXN1bHQsICcsXFxuJywgdW5kZXJsaW5lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmluZGVudCAtPSBJTkRFTlQrZXh0cmFUb1JlbW92ZTtcbiAgICAgICAgY2FyaWZ5KHJlc3VsdCwgJ1xcbicrc3BhY2Uob3B0aW9ucy5pbmRlbnQrZXh0cmFUb1JlbW92ZSkrJ30nLCB1bmRlcmxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRlcm0pKSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnWycsIHVuZGVybGluZSk7XG4gICAgICBmb3IodmFyIGk9MDsgaTx0ZXJtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgPT09IGkpKSB7XG4gICAgICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVtpXSwgaSwgdGVybSwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtW2ldLCBpLCB0ZXJtLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuc3RyICs9IGJhY2t0cmFjZS5zdHI7XG4gICAgICAgIHJlc3VsdC5jYXIgKz0gYmFja3RyYWNlLmNhcjtcbiAgICAgIH1cbiAgICAgIGNhcmlmeShyZXN1bHQsICddJywgdW5kZXJsaW5lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnJyt0ZXJtLCB1bmRlcmxpbmUpO1xuICAgIH1cblxuICAgIGlmICgoaW5kZXggPT09IDApICYmICgoZmF0aGVyID09IG51bGwpIHx8ICghbm9uUHJlZml4W2ZhdGhlclswXV0pKSkgY2FyaWZ5KHJlc3VsdCwgJyknLCB1bmRlcmxpbmUpO1xuXG4gICAgaWYgKHVuZGVybGluZSkgcmVzdWx0LmNhciA9IHJlc3VsdC5zdHIucmVwbGFjZSgvLi9nLCAnXicpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgVEFCTEU6IGZ1bmN0aW9uKHRlcm0sIGluZGV4LCBmYXRoZXIsIGZyYW1lcywgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzdHI6ICcnLFxuICAgICAgY2FyOiAnJ1xuICAgIH1cbiAgICB2YXIgYmFja3RyYWNlLCB1bmRlcmxpbmUsIGN1cnJlbnRGcmFtZTtcblxuXG4gICAgaWYgKCh0ZXJtLmxlbmd0aCA9PT0gMSkgfHwgKHRlcm1bMV0ubGVuZ3RoID09PSAwKSB8fCAodGVybVsxXVswXVswXSAhPT0gdGVybVR5cGVzLkRCKSkge1xuICAgICAgdmFyIHVuZGVybGluZSA9IEFycmF5LmlzQXJyYXkoZnJhbWVzKSAmJiAoZnJhbWVzLmxlbmd0aCA9PT0gMCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFtZXMpKSBjdXJyZW50RnJhbWUgPSBmcmFtZXMuc2hpZnQoKTtcblxuICAgICAgY2FyaWZ5KHJlc3VsdCwgJ3IuJyt0eXBlVG9TdHJpbmdbdGVybVswXV0rJygnLCB1bmRlcmxpbmUpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGVybVsxXSkpIHtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGVybVsxXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpICE9PTApIHJlc3VsdC5zdHIgKz0gJywgJztcblxuXG4gICAgICAgICAgaWYgKChjdXJyZW50RnJhbWUgIT0gbnVsbCkgJiYgKGN1cnJlbnRGcmFtZSA9PT0gMSkpIHtcbiAgICAgICAgICAgIC8vICsxIGZvciBpbmRleCBiZWNhdXNlIGl0J3MgbGlrZSBpZiB0aGVyZSB3YXMgYSByLmRiKC4uLikgYmVmb3JlIC50YWJsZSguLi4pXG4gICAgICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdW2ldLCBpKzEsIHRlcm0sIGZyYW1lcywgb3B0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdW2ldLCBpKzEsIHRlcm0sIG51bGwsIG9wdGlvbnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5zdHIgKz0gYmFja3RyYWNlLnN0cjtcbiAgICAgICAgICByZXN1bHQuY2FyICs9IGJhY2t0cmFjZS5jYXJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBiYWNrdHJhY2UgPSBtYWtlT3B0YXJncyh0ZXJtLCBpLCB0ZXJtLCBmcmFtZXMsIG9wdGlvbnMsIGN1cnJlbnRGcmFtZSlcbiAgICAgIHJlc3VsdC5zdHIgKz0gYmFja3RyYWNlLnN0cjtcbiAgICAgIHJlc3VsdC5jYXIgKz0gYmFja3RyYWNlLmNhcjtcblxuICAgICAgY2FyaWZ5KHJlc3VsdCwgJyknLCB1bmRlcmxpbmUpO1xuXG4gICAgICBpZiAodW5kZXJsaW5lKSByZXN1bHQuY2FyID0gcmVzdWx0LnN0ci5yZXBsYWNlKC8uL2csICdeJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVOb3JtYWxCYWNrdHJhY2UodGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgIHJlc3VsdC5zdHIgPSBiYWNrdHJhY2Uuc3RyO1xuICAgICAgcmVzdWx0LmNhciA9IGJhY2t0cmFjZS5jYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgR0VUX0ZJRUxEOiBmdW5jdGlvbih0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RyOiAnJyxcbiAgICAgIGNhcjogJydcbiAgICB9XG4gICAgdmFyIGJhY2t0cmFjZSwgdW5kZXJsaW5lLCBjdXJyZW50RnJhbWU7XG5cbiAgICB2YXIgdW5kZXJsaW5lID0gQXJyYXkuaXNBcnJheShmcmFtZXMpICYmIChmcmFtZXMubGVuZ3RoID09PSAwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFtZXMpKSBjdXJyZW50RnJhbWUgPSBmcmFtZXMuc2hpZnQoKTtcblxuICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgPT09IDApKSB7XG4gICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdWzBdLCAwLCB0ZXJtLCBmcmFtZXMsIG9wdGlvbnMpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVswXSwgMCwgdGVybSwgbnVsbCwgb3B0aW9ucylcbiAgICB9XG4gICAgcmVzdWx0LnN0ciA9IGJhY2t0cmFjZS5zdHI7XG4gICAgcmVzdWx0LmNhciA9IGJhY2t0cmFjZS5jYXI7XG5cbiAgICBjYXJpZnkocmVzdWx0LCAnKCcsIHVuZGVybGluZSk7XG5cbiAgICBpZiAoKGN1cnJlbnRGcmFtZSAhPSBudWxsKSAmJiAoY3VycmVudEZyYW1lID09PSAxKSkge1xuICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVsxXSwgMSwgdGVybSwgZnJhbWVzLCBvcHRpb25zKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1bMV1bMV0sIDEsIHRlcm0sIG51bGwsIG9wdGlvbnMpXG4gICAgfVxuICAgIHJlc3VsdC5zdHIgKz0gYmFja3RyYWNlLnN0cjtcbiAgICByZXN1bHQuY2FyICs9IGJhY2t0cmFjZS5jYXI7XG5cbiAgICBjYXJpZnkocmVzdWx0LCAnKScsIHVuZGVybGluZSk7XG5cbiAgICBpZiAodW5kZXJsaW5lKSByZXN1bHQuY2FyID0gcmVzdWx0LnN0ci5yZXBsYWNlKC8uL2csICdeJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBNQUtFX0FSUkFZOiBmdW5jdGlvbih0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RyOiAnJyxcbiAgICAgIGNhcjogJydcbiAgICB9O1xuICAgIHZhciBiYWNrdHJhY2UsIHVuZGVybGluZSwgY3VycmVudEZyYW1lO1xuXG4gICAgdmFyIHVuZGVybGluZSA9IEFycmF5LmlzQXJyYXkoZnJhbWVzKSAmJiAoZnJhbWVzLmxlbmd0aCA9PT0gMCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZnJhbWVzKSkgY3VycmVudEZyYW1lID0gZnJhbWVzLnNoaWZ0KCk7XG5cbiAgICBpZiAoKGluZGV4ID09PSAwKSAmJiAoKGZhdGhlciA9PSBudWxsKSB8fCAoIW5vblByZWZpeFtmYXRoZXJbMF1dKSkpIGNhcmlmeShyZXN1bHQsICdyLmV4cHIoJywgdW5kZXJsaW5lKVxuXG4gICAgaWYgKCEoKG9wdGlvbnMpICYmIChvcHRpb25zLm5vQnJhY2tldCkpKSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnWycsIHVuZGVybGluZSk7XG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPHRlcm1bMV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgIGNhcmlmeShyZXN1bHQsICcsICcsIHVuZGVybGluZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgID09PSBpKSkge1xuICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdW2ldLCBpLCB0ZXJtLCBmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1bMV1baV0sIGksIHRlcm0sIG51bGwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnN0ciArPSBiYWNrdHJhY2Uuc3RyO1xuICAgICAgcmVzdWx0LmNhciArPSBiYWNrdHJhY2UuY2FyO1xuXG4gICAgfVxuXG4gICAgaWYgKCEoKG9wdGlvbnMpICYmIChvcHRpb25zLm5vQnJhY2tldCkpKSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnXScsIHVuZGVybGluZSk7XG4gICAgfVxuXG4gICAgaWYgKChpbmRleCA9PT0gMCkgJiYgKChmYXRoZXIgPT0gbnVsbCkgfHwgKCFub25QcmVmaXhbZmF0aGVyWzBdXSkpKSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnKScsIHVuZGVybGluZSk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVybGluZSkgcmVzdWx0LmNhciA9IHJlc3VsdC5zdHIucmVwbGFjZSgvLi9nLCAnXicpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgRlVOQzogZnVuY3Rpb24odGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0cjogJycsXG4gICAgICBjYXI6ICcnXG4gICAgfTtcbiAgICB2YXIgYmFja3RyYWNlLCB1bmRlcmxpbmUsIGN1cnJlbnRGcmFtZTtcblxuICAgIHZhciB1bmRlcmxpbmUgPSBBcnJheS5pc0FycmF5KGZyYW1lcykgJiYgKGZyYW1lcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZyYW1lcykpIGN1cnJlbnRGcmFtZSA9IGZyYW1lcy5zaGlmdCgpO1xuXG4gICAgaWYgKCh0ZXJtWzFdWzBdWzFdLmxlbmd0aCA9PT0gMSkgJiYgKGhlbHBlci5oYXNJbXBsaWNpdCh0ZXJtWzFdWzFdKSkpIHtcbiAgICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgPT09IDEpKSB7XG4gICAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1bMV1bMV0sIDEsIHRlcm0sIGZyYW1lcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVsxXSwgMSwgdGVybSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXN1bHQuc3RyID0gYmFja3RyYWNlLnN0cjtcbiAgICAgIHJlc3VsdC5jYXIgPSBiYWNrdHJhY2UuY2FyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhcmlmeShyZXN1bHQsICdmdW5jdGlvbignLCB1bmRlcmxpbmUpO1xuXG4gICAgICBmb3IodmFyIGk9MDsgaTx0ZXJtWzFdWzBdWzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgY2FyaWZ5KHJlc3VsdCwgJywgJywgdW5kZXJsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXJpZnkocmVzdWx0LCAndmFyXycrdGVybVsxXVswXVsxXVtpXSwgdW5kZXJsaW5lKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5pbmRlbnQgKz0gSU5ERU5UK29wdGlvbnMuZXh0cmE7XG4gICAgICB2YXIgZXh0cmFUb1JlbW92ZSA9IG9wdGlvbnMuZXh0cmE7XG4gICAgICBvcHRpb25zLmV4dHJhID0gMDtcbiAgICAgIC8vaWYgKCEoKEFycmF5LmlzQXJyYXkodGVybVsyXSkpICYmICh0ZXJtWzJdLmxlbmd0aCA+IDApKSkgb3B0aW9ucy5leHRyYSA9IDA7XG5cbiAgICAgIGNhcmlmeShyZXN1bHQsICcpIHtcXG4nK3NwYWNlKG9wdGlvbnMuaW5kZW50KSsncmV0dXJuICcsIHVuZGVybGluZSk7XG5cbiAgICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgPT09IDEpKSB7XG4gICAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1bMV1bMV0sIDEsIHRlcm0sIGZyYW1lcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVsxXSwgMSwgdGVybSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5zdHIgKz0gYmFja3RyYWNlLnN0cjtcbiAgICAgIHJlc3VsdC5jYXIgKz0gYmFja3RyYWNlLmNhcjtcblxuICAgICAgb3B0aW9ucy5pbmRlbnQgLT0gSU5ERU5UK2V4dHJhVG9SZW1vdmU7XG4gICAgICBvcHRpb25zLmV4dHJhID0gZXh0cmFUb1JlbW92ZTtcblxuICAgICAgY2FyaWZ5KHJlc3VsdCwgJ1xcbicrc3BhY2Uob3B0aW9ucy5pbmRlbnQrZXh0cmFUb1JlbW92ZSkrJ30nLCB1bmRlcmxpbmUpO1xuXG4gICAgfVxuXG4gICAgaWYgKHVuZGVybGluZSkgcmVzdWx0LmNhciA9IHJlc3VsdC5zdHIucmVwbGFjZSgvLi9nLCAnXicpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgVkFSOiBmdW5jdGlvbih0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RyOiAnJyxcbiAgICAgIGNhcjogJydcbiAgICB9XG4gICAgdmFyIGJhY2t0cmFjZSwgdW5kZXJsaW5lLCBjdXJyZW50RnJhbWU7XG5cbiAgICB2YXIgdW5kZXJsaW5lID0gQXJyYXkuaXNBcnJheShmcmFtZXMpICYmIChmcmFtZXMubGVuZ3RoID09PSAwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFtZXMpKSBjdXJyZW50RnJhbWUgPSBmcmFtZXMuc2hpZnQoKTtcblxuICAgIGNhcmlmeShyZXN1bHQsICd2YXJfJyt0ZXJtWzFdWzBdLCB1bmRlcmxpbmUpO1xuXG4gICAgaWYgKHVuZGVybGluZSkgcmVzdWx0LmNhciA9IHJlc3VsdC5zdHIucmVwbGFjZSgvLi9nLCAnXicpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIEZVTkNBTEw6IGZ1bmN0aW9uKHRlcm0sIGluZGV4LCBmYXRoZXIsIGZyYW1lcywgb3B0aW9ucykge1xuICAgIC8vIFRoZSBzeW50YXggaXMgYXJnc1sxXS5kbyhhcmdzWzBdKVxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzdHI6ICcnLFxuICAgICAgY2FyOiAnJ1xuICAgIH07XG4gICAgdmFyIGJhY2t0cmFjZSwgdW5kZXJsaW5lLCBjdXJyZW50RnJhbWU7XG5cbiAgICB2YXIgdW5kZXJsaW5lID0gQXJyYXkuaXNBcnJheShmcmFtZXMpICYmIChmcmFtZXMubGVuZ3RoID09PSAwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFtZXMpKSBjdXJyZW50RnJhbWUgPSBmcmFtZXMuc2hpZnQoKTtcblxuICAgIGlmICh0ZXJtWzFdLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKChjdXJyZW50RnJhbWUgIT0gbnVsbCkgJiYgKGN1cnJlbnRGcmFtZSA9PT0gMSkpIHtcbiAgICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVsxXSwgMCwgdGVybSwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdWzFdLCAwLCB0ZXJtLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5zdHIgPSBiYWNrdHJhY2Uuc3RyO1xuICAgICAgcmVzdWx0LmNhciA9IGJhY2t0cmFjZS5jYXI7XG5cbiAgICAgIGNhcmlmeShyZXN1bHQsICcuZG8oJywgdW5kZXJsaW5lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnci5kbygnLCB1bmRlcmxpbmUpO1xuXG4gICAgICBmb3IodmFyIGk9MTsgaTx0ZXJtWzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgPT09IGkpKSB7XG4gICAgICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVtpXSwgaSwgdGVybSwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdW2ldLCBpLCB0ZXJtLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuc3RyICs9IGJhY2t0cmFjZS5zdHI7XG4gICAgICAgIHJlc3VsdC5jYXIgKz0gYmFja3RyYWNlLmNhcjtcblxuICAgICAgICBpZiAoaSAhPT0gdGVybVsxXS5sZW5ndGgpIHtcbiAgICAgICAgICBjYXJpZnkocmVzdWx0LCAnLCAnICwgdW5kZXJsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChjdXJyZW50RnJhbWUgPT09IDApKSB7XG4gICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdWzBdLCAwLCB0ZXJtLCBmcmFtZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1bMV1bMF0sIDAsIHRlcm0sIG51bGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXN1bHQuc3RyICs9IGJhY2t0cmFjZS5zdHI7XG4gICAgcmVzdWx0LmNhciArPSBiYWNrdHJhY2UuY2FyO1xuXG4gICAgY2FyaWZ5KHJlc3VsdCwgJyknLCB1bmRlcmxpbmUpO1xuXG4gICAgaWYgKHVuZGVybGluZSkgcmVzdWx0LmNhciA9IHJlc3VsdC5zdHIucmVwbGFjZSgvLi9nLCAnXicpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgSU1QTElDSVRfVkFSOiBmdW5jdGlvbih0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RyOiAnJyxcbiAgICAgIGNhcjogJydcbiAgICB9XG4gICAgdmFyIGJhY2t0cmFjZSwgdW5kZXJsaW5lLCBjdXJyZW50RnJhbWU7XG5cbiAgICB2YXIgdW5kZXJsaW5lID0gQXJyYXkuaXNBcnJheShmcmFtZXMpICYmIChmcmFtZXMubGVuZ3RoID09PSAwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFtZXMpKSBjdXJyZW50RnJhbWUgPSBmcmFtZXMuc2hpZnQoKTtcblxuICAgIGNhcmlmeShyZXN1bHQsICdyLnJvdycsIHVuZGVybGluZSk7XG5cbiAgICBpZiAodW5kZXJsaW5lKSByZXN1bHQuY2FyID0gcmVzdWx0LnN0ci5yZXBsYWNlKC8uL2csICdeJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgV0FJVDogZnVuY3Rpb24odGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0cjogJycsXG4gICAgICBjYXI6ICcnXG4gICAgfVxuICAgIHZhciBiYWNrdHJhY2UsIHVuZGVybGluZSwgY3VycmVudEZyYW1lO1xuXG4gICAgaWYgKHRlcm0ubGVuZ3RoID09PSAxIHx8IHRlcm1bMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZVdpdGhvdXRQcmVmaXhCYWNrdHJhY2UodGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgIHJlc3VsdC5zdHIgPSBiYWNrdHJhY2Uuc3RyO1xuICAgICAgcmVzdWx0LmNhciA9IGJhY2t0cmFjZS5jYXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVOb3JtYWxCYWNrdHJhY2UodGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgIHJlc3VsdC5zdHIgPSBiYWNrdHJhY2Uuc3RyO1xuICAgICAgcmVzdWx0LmNhciA9IGJhY2t0cmFjZS5jYXI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIE1BUDogZnVuY3Rpb24odGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0cjogJycsXG4gICAgICBjYXI6ICcnXG4gICAgfVxuICAgIHZhciBiYWNrdHJhY2UsIHVuZGVybGluZSwgY3VycmVudEZyYW1lO1xuXG4gICAgaWYgKHRlcm0ubGVuZ3RoID4gMSAmJiB0ZXJtWzFdLmxlbmd0aCA+IDIpIHtcbiAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlV2l0aG91dFByZWZpeEJhY2t0cmFjZSh0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgcmVzdWx0LnN0ciA9IGJhY2t0cmFjZS5zdHI7XG4gICAgICByZXN1bHQuY2FyID0gYmFja3RyYWNlLmNhcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZU5vcm1hbEJhY2t0cmFjZSh0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgcmVzdWx0LnN0ciA9IGJhY2t0cmFjZS5zdHI7XG4gICAgICByZXN1bHQuY2FyID0gYmFja3RyYWNlLmNhcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbn1cbl9zcGVjaWFsVHlwZS5UQUJMRV9DUkVBVEUgPSBfc3BlY2lhbFR5cGUuVEFCTEU7XG5fc3BlY2lhbFR5cGUuVEFCTEVfRFJPUCA9IF9zcGVjaWFsVHlwZS5UQUJMRTtcbl9zcGVjaWFsVHlwZS5UQUJMRV9MSVNUID0gX3NwZWNpYWxUeXBlLlRBQkxFO1xuX3NwZWNpYWxUeXBlLlJFQ09ORklHVVJFID0gX3NwZWNpYWxUeXBlLldBSVQ7XG5fc3BlY2lhbFR5cGUuUkVCQUxBTkNFID0gX3NwZWNpYWxUeXBlLldBSVQ7XG5fc3BlY2lhbFR5cGUuQlJBQ0tFVCA9IF9zcGVjaWFsVHlwZS5HRVRfRklFTEQ7XG5cbnZhciBzcGVjaWFsVHlwZSA9IHt9O1xuZm9yKHZhciBrZXkgaW4gX3NwZWNpYWxUeXBlKSB7XG4gIHNwZWNpYWxUeXBlW3Rlcm1UeXBlc1trZXldXSA9IF9zcGVjaWFsVHlwZVtrZXldO1xufVxuXG5cbmZ1bmN0aW9uIHNwYWNlKG4pIHtcbiAgcmV0dXJuIG5ldyBBcnJheShuKzEpLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGNhcmlmeShyZXN1bHQsIHN0ciwgdW5kZXJsaW5lKSB7XG4gIGlmICh1bmRlcmxpbmUgPT09IHRydWUpIHtcbiAgICByZXN1bHQuc3RyICs9IHN0cjtcbiAgICByZXN1bHQuY2FyICs9IHN0ci5yZXBsYWNlKC9bXlxcbl0vZywgJ14nKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXN1bHQuc3RyICs9IHN0cjtcbiAgICByZXN1bHQuY2FyICs9IHN0ci5yZXBsYWNlKC9bXlxcbl0vZywgJyAnKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFrZU9wdGFyZ3ModGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zLCBjdXJyZW50RnJhbWUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBzdHI6ICcnLFxuICAgIGNhcjogJydcbiAgfVxuICB2YXIgYmFja3RyYWNlLCBjdXJyZW50RnJhbWUsIHVuZGVybGluZTtcblxuICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3QodGVybVsyXSkpIHtcbiAgICAvL2lmICgoY3VycmVudEZyYW1lICE9IG51bGwpICYmIChmcmFtZXMgIT0gbnVsbCkpIGZyYW1lcy51bnNoaWZ0KGN1cnJlbnRGcmFtZSk7XG5cbiAgICAvL3VuZGVybGluZSA9IEFycmF5LmlzQXJyYXkoZnJhbWVzKSAmJiAoZnJhbWVzLmxlbmd0aCA9PT0gMCk7XG4gICAgdmFyIHVuZGVybGluZSA9IGZhbHNlO1xuICAgIC8vaWYgKEFycmF5LmlzQXJyYXkoZnJhbWVzKSkgY3VycmVudEZyYW1lID0gZnJhbWVzLnNoaWZ0KCk7XG5cbiAgICAvLyBUaGlzIHdvcmtzIGJlZm9yZSB0aGVyZSBpcyBubyBwcmVmaXggdGVybSB0aGFuIGNhbiBiZSBjYWxsZWQgd2l0aCBubyBub3JtYWwgYXJndW1lbnQgYnV0IHdpdGggYW4gb3B0YXJnXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGVybVsxXSkgJiYgKHRlcm1bMV0ubGVuZ3RoID4gMSkpIHtcbiAgICAgIGNhcmlmeShyZXN1bHQsICcsICcgLCB1bmRlcmxpbmUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRlcm1bMV0pICYmICh0ZXJtWzFdLmxlbmd0aCA+IDApICYmIChub1ByZWZpeE9wdGFyZ3NbdGVybVswXV0pKSB7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnLCAnICwgdW5kZXJsaW5lKTtcbiAgICB9XG5cbiAgICBiYWNrdHJhY2UgPSBzcGVjaWFsVHlwZVt0ZXJtVHlwZXMuREFUVU1dKHRlcm1bMl0sIGluZGV4LCB0ZXJtWzJdLCBmcmFtZXMsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgcmVzdWx0LnN0ciArPSBiYWNrdHJhY2Uuc3RyO1xuICAgIHJlc3VsdC5jYXIgKz0gYmFja3RyYWNlLmNhcjtcblxuICAgIGlmICh1bmRlcmxpbmUpIHJlc3VsdC5jYXIgPSByZXN1bHQuc3RyLnJlcGxhY2UoLy4vZywgJ14nKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZU5vcm1hbEJhY2t0cmFjZSh0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBzdHI6ICcnLFxuICAgIGNhcjogJydcbiAgfVxuICB2YXIgYmFja3RyYWNlLCBjdXJyZW50RnJhbWUsIHVuZGVybGluZTtcblxuICAvL2lmICh0ZXJtWzFdKSB7XG4gICAgdmFyIHVuZGVybGluZSA9IEFycmF5LmlzQXJyYXkoZnJhbWVzKSAmJiAoZnJhbWVzLmxlbmd0aCA9PT0gMCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZnJhbWVzKSkgY3VycmVudEZyYW1lID0gZnJhbWVzLnNoaWZ0KCk7XG5cbiAgICBpZiAoKGN1cnJlbnRGcmFtZSAhPSBudWxsKSAmJiAoY3VycmVudEZyYW1lID09PSAwKSkge1xuICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVswXSwgMCwgdGVybSwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdWzBdLCAwLCB0ZXJtLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVzdWx0LnN0ciA9IGJhY2t0cmFjZS5zdHI7XG4gICAgcmVzdWx0LmNhciA9IGJhY2t0cmFjZS5jYXI7XG5cbiAgICB2YXIgbGluZXMgPSBiYWNrdHJhY2Uuc3RyLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aC0xXTtcbiAgICB2YXIgcG9zID0gbGluZS5tYXRjaCgvW15cXHNdLyk7XG4gICAgcG9zID0gKHBvcykgPyBwb3MuaW5kZXggOiAwO1xuXG4gICAgaWYgKGxpbmUubGVuZ3RoLXBvcyA+IExJTUlUKSB7XG4gICAgICBpZiAob3B0aW9ucy5leHRyYSA9PT0gMCkgb3B0aW9ucy5leHRyYSArPSBJTkRFTlQ7XG4gICAgICBjYXJpZnkocmVzdWx0LCAnXFxuJytzcGFjZShvcHRpb25zLmluZGVudCtvcHRpb25zLmV4dHJhKSAsIHVuZGVybGluZSk7XG4gICAgfVxuXG4gICAgY2FyaWZ5KHJlc3VsdCwgJy4nK3R5cGVUb1N0cmluZ1t0ZXJtWzBdXSsnKCcgLCB1bmRlcmxpbmUpO1xuICAgIG9wdGlvbnMuaW5kZW50ICs9IG9wdGlvbnMuZXh0cmE7XG4gICAgdmFyIGV4dHJhVG9SZW1vdmUgPSBvcHRpb25zLmV4dHJhO1xuICAgIG9wdGlvbnMuZXh0cmEgPSAwO1xuXG4gICAgZm9yKHZhciBpPTE7IGk8dGVybVsxXS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgIT09IDEpIHtcbiAgICAgICAgY2FyaWZ5KHJlc3VsdCwgJywgJyAsIHVuZGVybGluZSk7XG4gICAgICB9XG4gICAgICBpZiAoKGN1cnJlbnRGcmFtZSAhPSBudWxsKSAmJiAoY3VycmVudEZyYW1lID09PSBpKSkge1xuICAgICAgICBiYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZSh0ZXJtWzFdW2ldLCBpLCB0ZXJtLCBmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1bMV1baV0sIGksIHRlcm0sIG51bGwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnN0ciArPSBiYWNrdHJhY2Uuc3RyO1xuICAgICAgcmVzdWx0LmNhciArPSBiYWNrdHJhY2UuY2FyO1xuICAgIH1cblxuICAgIGJhY2t0cmFjZSA9IG1ha2VPcHRhcmdzKHRlcm0sIGksIHRlcm0sIGZyYW1lcywgb3B0aW9ucywgY3VycmVudEZyYW1lKVxuICAgIHJlc3VsdC5zdHIgKz0gYmFja3RyYWNlLnN0cjtcbiAgICByZXN1bHQuY2FyICs9IGJhY2t0cmFjZS5jYXI7XG5cbiAgICBvcHRpb25zLmluZGVudCAtPSBleHRyYVRvUmVtb3ZlO1xuICAgIG9wdGlvbnMuZXh0cmEgPSBleHRyYVRvUmVtb3ZlO1xuXG4gICAgY2FyaWZ5KHJlc3VsdCwgJyknICwgdW5kZXJsaW5lKTtcblxuICAgIGlmICh1bmRlcmxpbmUpIHJlc3VsdC5jYXIgPSByZXN1bHQuc3RyLnJlcGxhY2UoLy4vZywgJ14nKTtcbiAgLypcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkcml2ZXIgc2hvdWxkIG5ldmVyIGVudGVyIHRoaXMgY29uZGl0aW9uLiBQbGVhc2UgcmVwb3J0IHRoZSBxdWVyeSB0byB0aGUgZGV2ZWxvcGVycyAtLSBFbmQgMSAtLVxcbicrSlNPTi5zdHJpbmdpZnkodGVybSwgbnVsbCwgMikpXG4gIH1cbiAgKi9cblxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlV2l0aG91dFByZWZpeEJhY2t0cmFjZSh0ZXJtLCBpbmRleCwgZmF0aGVyLCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBzdHI6ICcnLFxuICAgIGNhcjogJydcbiAgfVxuXG4gIHZhciBiYWNrdHJhY2UsIGN1cnJlbnRGcmFtZSwgdW5kZXJsaW5lO1xuXG4gIHZhciB1bmRlcmxpbmUgPSBBcnJheS5pc0FycmF5KGZyYW1lcykgJiYgKGZyYW1lcy5sZW5ndGggPT09IDApO1xuICBpZiAoQXJyYXkuaXNBcnJheShmcmFtZXMpKSBjdXJyZW50RnJhbWUgPSBmcmFtZXMuc2hpZnQoKTtcblxuICBpZiAoY29uc3RhbnRzW3Rlcm1bMF1dKSB7XG4gICAgY2FyaWZ5KHJlc3VsdCwgJ3IuJyt0eXBlVG9TdHJpbmdbdGVybVswXV0sIHVuZGVybGluZSk7IFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjYXJpZnkocmVzdWx0LCAnci4nK3R5cGVUb1N0cmluZ1t0ZXJtWzBdXSsnKCcsIHVuZGVybGluZSk7IFxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRlcm1bMV0pKSB7XG4gICAgZm9yKHZhciBpPTA7IGk8dGVybVsxXS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgIT09IDApIGNhcmlmeShyZXN1bHQsICcsICcsIHVuZGVybGluZSlcblxuICAgICAgaWYgKChjdXJyZW50RnJhbWUgIT0gbnVsbCkgJiYgKGN1cnJlbnRGcmFtZSA9PT0gaSkpIHtcbiAgICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVCYWNrdHJhY2UodGVybVsxXVtpXSwgaSwgdGVybSwgZnJhbWVzLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlQmFja3RyYWNlKHRlcm1bMV1baV0sIGksIHRlcm0sIG51bGwsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgICByZXN1bHQuc3RyICs9IGJhY2t0cmFjZS5zdHI7XG4gICAgICByZXN1bHQuY2FyICs9IGJhY2t0cmFjZS5jYXI7XG4gICAgfVxuICB9XG5cbiAgYmFja3RyYWNlID0gbWFrZU9wdGFyZ3ModGVybSwgaSwgdGVybSwgZnJhbWVzLCBvcHRpb25zLCBjdXJyZW50RnJhbWUpXG4gIHJlc3VsdC5zdHIgKz0gYmFja3RyYWNlLnN0cjtcbiAgcmVzdWx0LmNhciArPSBiYWNrdHJhY2UuY2FyO1xuXG4gIGNhcmlmeShyZXN1bHQsICcpJywgdW5kZXJsaW5lKTtcblxuICBpZiAodW5kZXJsaW5lKSByZXN1bHQuY2FyID0gcmVzdWx0LnN0ci5yZXBsYWNlKC8uL2csICdeJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCYWNrdHJhY2UodGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgc3RyOiAnJyxcbiAgICBjYXI6ICcnXG4gIH1cbiAgdmFyIGJhY2t0cmFjZSwgY3VycmVudEZyYW1lLCB1bmRlcmxpbmU7XG5cbiAgLy8gZnJhbWVzID0gbnVsbCAtPiBkbyBub3QgdW5kZXJsaW5lXG4gIC8vIGZyYW1lcyA9IFtdIC0+IHVuZGVybGluZVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRlcm0pKSB7XG4gICAgaWYgKHRlcm0ubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgdW5kZXJsaW5lID0gQXJyYXkuaXNBcnJheShmcmFtZXMpICYmIChmcmFtZXMubGVuZ3RoID09PSAwKTtcbiAgICAgIGNhcmlmeShyZXN1bHQsICd1bmRlZmluZWQnLCB1bmRlcmxpbmUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzcGVjaWFsVHlwZVt0ZXJtWzBdXSkge1xuICAgICAgYmFja3RyYWNlID0gc3BlY2lhbFR5cGVbdGVybVswXV0odGVybSwgaW5kZXgsIGZhdGhlciwgZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgIHJlc3VsdC5zdHIgPSBiYWNrdHJhY2Uuc3RyO1xuICAgICAgcmVzdWx0LmNhciA9IGJhY2t0cmFjZS5jYXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vblByZWZpeFt0ZXJtWzBdXSkge1xuICAgICAgYmFja3RyYWNlID0gZ2VuZXJhdGVXaXRob3V0UHJlZml4QmFja3RyYWNlKHRlcm0sIGluZGV4LCBmYXRoZXIsIGZyYW1lcywgb3B0aW9ucyk7XG4gICAgICByZXN1bHQuc3RyID0gYmFja3RyYWNlLnN0cjtcbiAgICAgIHJlc3VsdC5jYXIgPSBiYWNrdHJhY2UuY2FyO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gbm9ybWFsIHR5cGUgLS0gdGhpcy48bWV0aG9kPiggdGhpcy5hcmdzLi4uIClcbiAgICAgIGJhY2t0cmFjZSA9IGdlbmVyYXRlTm9ybWFsQmFja3RyYWNlKHRlcm0sIGluZGV4LCBmYXRoZXIsIGZyYW1lcywgb3B0aW9ucyk7XG4gICAgICByZXN1bHQuc3RyID0gYmFja3RyYWNlLnN0cjtcbiAgICAgIHJlc3VsdC5jYXIgPSBiYWNrdHJhY2UuY2FyO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0ZXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICBiYWNrdHJhY2UgPSBzcGVjaWFsVHlwZVt0ZXJtVHlwZXMuREFUVU1dKHRlcm0sIGluZGV4LCBmYXRoZXIsIGZyYW1lcywgb3B0aW9ucyk7XG5cbiAgICByZXN1bHQuc3RyID0gYmFja3RyYWNlLnN0cjtcbiAgICByZXN1bHQuY2FyID0gYmFja3RyYWNlLmNhcjtcbiAgfVxuICBlbHNlIHtcbiAgICAvL3Rocm93IG5ldyBFcnJvcignVGhlIGRyaXZlciBzaG91bGQgbmV2ZXIgZW50ZXIgdGhpcyBjb25kaXRpb24uIFBsZWFzZSByZXBvcnQgdGhlIHF1ZXJ5IHRvIHRoZSBkZXZlbG9wZXJzIC0tIEVuZCAyJylcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXyguKS9nLCBmdW5jdGlvbiAobSwgY2hhcikgeyByZXR1cm4gY2hhci50b1VwcGVyQ2FzZSgpIH0pO1xufVxubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdGVCYWNrdHJhY2UgPSBnZW5lcmF0ZUJhY2t0cmFjZTtcblxubW9kdWxlLmV4cG9ydHMuc2V0T3BlcmF0aW9uYWwgPSBmdW5jdGlvbihlcnJvcikge1xuICBlcnJvcltJU19PUEVSQVRJT05BTF0gPSB0cnVlO1xuICByZXR1cm4gZXJyb3I7XG59O1xuXG4iLCJ2YXIgcHJvdG9kZWYgPSByZXF1aXJlKF9fZGlybmFtZSsnL3Byb3RvZGVmLmpzJyk7XG52YXIgdGVybVR5cGVzID0gcHJvdG9kZWYuVGVybS5UZXJtVHlwZTtcbnZhciBkYXR1bVR5cGVzID0gcHJvdG9kZWYuRGF0dW0uRGF0dW1UeXBlO1xudmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcihwb29sTWFzdGVyLCBzaWxlbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAoc2lsZW50ICE9PSB0cnVlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBwb29sTWFzdGVyLmVtaXQoJ2xvZycsIG1lc3NhZ2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVMb2dnZXIgPSBjcmVhdGVMb2dnZXI7XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5tb2R1bGUuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcblxuZnVuY3Rpb24gdG9BcnJheShhcmdzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbn1cbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiBoYXNJbXBsaWNpdChhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGlmIChhcmdbMF0gPT09IHRlcm1UeXBlcy5JTVBMSUNJVF9WQVIpIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnWzFdKSkge1xuICAgICAgZm9yKHZhciBpPTA7IGk8YXJnWzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNJbXBsaWNpdChhcmdbMV1baV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYXJnWzJdKSkge1xuICAgICAgZm9yKHZhciBrZXkgaW4gYXJnWzJdKSB7XG4gICAgICAgIGlmIChoYXNJbXBsaWNpdChhcmdbMl1ba2V5XSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGFyZykpIHtcbiAgICBmb3IodmFyIGtleSBpbiBhcmcpIHtcbiAgICAgIGlmIChoYXNJbXBsaWNpdChhcmdba2V5XSkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5tb2R1bGUuZXhwb3J0cy5oYXNJbXBsaWNpdCA9IGhhc0ltcGxpY2l0O1xuXG5mdW5jdGlvbiBsb29wS2V5cyhvYmosIGZuKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIGtleXNMZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgZm9yKHZhciBpPTA7IGk8a2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ID0gZm4ob2JqLCBrZXlzW2ldKTtcbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cy5sb29wS2V5cyA9IGxvb3BLZXlzO1xuXG5mdW5jdGlvbiBjb252ZXJ0UHNldWRvdHlwZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHJlcWxUeXBlID0gb2JqWyckcmVxbF90eXBlJCddO1xuICBpZiAocmVxbFR5cGUgPT09ICdUSU1FJyAmJiBvcHRpb25zWyd0aW1lRm9ybWF0J10gIT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG9ialsnZXBvY2hfdGltZSddICogMTAwMCk7XG4gIH1cbiAgZWxzZSBpZiAocmVxbFR5cGUgPT09ICdHUk9VUEVEX0RBVEEnICYmIG9wdGlvbnNbJ2dyb3VwRm9ybWF0J10gIT09ICdyYXcnKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmpbJ2RhdGEnXS5sZW5ndGgsIHJlZjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZWYgPSBvYmouZGF0YVtpXTtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgZ3JvdXA6IHJlZlswXSxcbiAgICAgICAgcmVkdWN0aW9uOiByZWZbMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGVsc2UgaWYgKHJlcWxUeXBlID09PSAnQklOQVJZJyAmJiBvcHRpb25zWydiaW5hcnlGb3JtYXQnXSAhPT0gJ3JhdycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihvYmpbJ2RhdGEnXSwgJ2Jhc2U2NCcpO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseUNvbnZlcnRQc2V1ZG90eXBlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgaSwgdmFsdWUsIGxlbiwga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgIG9ialtpXSA9IHJlY3Vyc2l2ZWx5Q29udmVydFBzZXVkb3R5cGUodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBvYmpba2V5XSA9IHJlY3Vyc2l2ZWx5Q29udmVydFBzZXVkb3R5cGUodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvYmogPSBjb252ZXJ0UHNldWRvdHlwZShvYmosIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBtYWtlQXRvbShyZXNwb25zZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIHJlY3Vyc2l2ZWx5Q29udmVydFBzZXVkb3R5cGUocmVzcG9uc2UuclswXSwgb3B0aW9ucyk7XG59XG5tb2R1bGUuZXhwb3J0cy5tYWtlQXRvbSA9IG1ha2VBdG9tO1xuXG5mdW5jdGlvbiBtYWtlU2VxdWVuY2UocmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiByZWN1cnNpdmVseUNvbnZlcnRQc2V1ZG90eXBlKHJlc3BvbnNlLnIsIG9wdGlvbnMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5tYWtlU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2U7XG5cbmZ1bmN0aW9uIGNoYW5nZVByb3RvKG9iamVjdCwgb3RoZXIpIHtcbiAgb2JqZWN0Ll9fcHJvdG9fXyA9IG90aGVyLl9fcHJvdG9fXztcbn1cbm1vZHVsZS5leHBvcnRzLmNoYW5nZVByb3RvID0gY2hhbmdlUHJvdG87XG5cbi8vIFRyeSB0byBleHRyYWN0IHRoZSBtb3N0IGdsb2JhbCBhZGRyZXNzXG4vLyBOb3RlOiBNdXRhdGUgdGhlIGlucHV0XG5mdW5jdGlvbiBnZXRDYW5vbmljYWxBZGRyZXNzKGFkZHJlc3Nlcykge1xuICAvLyBXZSBzdXBwb3NlIHRoYXQgdGhlIGFkZHJlc3NlcyBhcmUgYWxsIHZhbGlkLCBhbmQgdGhlcmVmb3JlIHVzZSBsb29zZSByZWdleFxuICBmb3IodmFyIGk9MDsgaTxhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYWRkcmVzc2UgPSBhZGRyZXNzZXNbaV07XG4gICAgaWYgKCgvXjEyNyhcXC5cXGR7MSwzfSl7M30kLy50ZXN0KGFkZHJlc3NlLmhvc3QpKSB8fCAoLzA/Oj8wPzo/MD86PzA/Oj8wPzo/MD86MD86MS8udGVzdChhZGRyZXNzZS5ob3N0KSkpIHtcbiAgICAgIGFkZHJlc3NlLnZhbHVlID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG5ldC5pc0lQdjYoYWRkcmVzc2UuaG9zdCkpICYmICgvXltmRl18W2VFXTgwOi4qXFw6LipcXDovLnRlc3QoYWRkcmVzc2UuaG9zdCkpKSB7XG4gICAgICBhZGRyZXNzZS52YWx1ZSA9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eMTY5XFwuMjU0XFwuXFxkezEsM31cXC5cXGR7MSwzfSQvLnRlc3QoYWRkcmVzc2UuaG9zdCkpIHtcbiAgICAgIGFkZHJlc3NlLnZhbHVlID0gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoL14xOTJcXC4xNjhcXC5cXGR7MSwzfVxcLlxcZHsxLDN9JC8udGVzdChhZGRyZXNzZS5ob3N0KSkge1xuICAgICAgYWRkcmVzc2UudmFsdWUgPSAzO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXjE3MlxcLigxXFxkfDJcXGR8MzB8MzEpXFwuXFxkezEsM31cXC5cXGR7MSwzfSQvLnRlc3QoYWRkcmVzc2UuaG9zdCkpIHtcbiAgICAgIGFkZHJlc3NlLnZhbHVlID0gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAoL14xMChcXC5cXGR7MSwzfSl7M30kLy50ZXN0KGFkZHJlc3NlLmhvc3QpKSB7XG4gICAgICBhZGRyZXNzZS52YWx1ZSA9IDU7XG4gICAgfVxuICAgIGVsc2UgaWYgKChuZXQuaXNJUHY2KGFkZHJlc3NlLmhvc3QpKSAmJiAoL15bZkZdfFtjQ2REXS4qXFw6LipcXDovLnRlc3QoJ2FkZHJlc3NlLmhvc3QnKSkpIHtcbiAgICAgIGFkZHJlc3NlLnZhbHVlID0gNjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhZGRyZXNzZS52YWx1ZSA9IDc7XG4gICAgfVxuICB9XG4gIHZhciByZXN1bHQgPSBhZGRyZXNzZXNbMF07XG4gIHZhciBtYXggPSBhZGRyZXNzZXNbMF0udmFsdWU7XG4gIGZvcih2YXIgaT0wOyBpPGFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhZGRyZXNzZXNbaV0udmFsdWUgPiBtYXgpIHtcbiAgICAgIHJlc3VsdCA9IGFkZHJlc3Nlc1tpXTtcbiAgICAgIG1heCA9IGFkZHJlc3Nlc1tpXS52YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbm1vZHVsZS5leHBvcnRzLmdldENhbm9uaWNhbEFkZHJlc3MgPSBnZXRDYW5vbmljYWxBZGRyZXNzO1xuXG5cbm1vZHVsZS5leHBvcnRzLmxvY2FsaG9zdEFsaWFzZXMgPSB7XG4gICdsb2NhbGhvc3QnOiB0cnVlLFxuICAnMTI3LjAuMC4xJzogdHJ1ZSxcbiAgJzo6MSc6IHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMudHJ5Q2F0Y2ggPSBmdW5jdGlvbiB0cnlDYXRjaCh0b1RyeSwgaGFuZGxlRXJyb3IpIHtcbiAgdHJ5e1xuICB0b1RyeSgpXG4gIH1cbiAgY2F0Y2goZXJyKSB7XG4gIGhhbmRsZUVycm9yKGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdENvbW1hRXF1YWwobWVzc2FnZSkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBtZXNzYWdlUGFydHMgPSBtZXNzYWdlLnNwbGl0KCcsJyk7XG4gIGZvcih2YXIgaT0wOyBpPG1lc3NhZ2VQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlcXVhbFBvc2l0aW9uID0gbWVzc2FnZVBhcnRzW2ldLmluZGV4T2YoXCI9XCIpXG4gICAgcmVzdWx0W21lc3NhZ2VQYXJ0c1tpXS5zbGljZSgwLCBlcXVhbFBvc2l0aW9uKV0gPSBtZXNzYWdlUGFydHNbaV0uc2xpY2UoZXF1YWxQb3NpdGlvbisxKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMuc3BsaXRDb21tYUVxdWFsID0gc3BsaXRDb21tYUVxdWFsO1xuXG5mdW5jdGlvbiB4b3JCdWZmZXIoYSwgYikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goYVtpXSBeIGJbaV0pO1xuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHJlc3VsdCk7XG59XG5tb2R1bGUuZXhwb3J0cy54b3JCdWZmZXIgPSB4b3JCdWZmZXI7XG5cbmZ1bmN0aW9uIGNvbXBhcmVEaWdlc3QoYSwgYikge1xuICB2YXIgbGVmdCA9IHVuZGVmaW5lZFxuICB2YXIgcmlnaHQgPSBiXG4gIHZhciByZXN1bHQgPSB1bmRlZmluZWRcbiAgaWYgKGEubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgIGxlZnQgPSBhXG4gICAgcmVzdWx0ID0gMFxuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBiXG4gICAgcmVzdWx0ID0gMVxuICB9XG4gIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICBmb3IodmFyIGk9MDsgaTxsZW47IGkrKykge1xuICAgIHJlc3VsdCB8PSBhW2ldIF5iW2ldXG4gIH1cbiAgcmV0dXJuIHJlc3VsdCA9PT0gMFxufVxubW9kdWxlLmV4cG9ydHMuY29tcGFyZURpZ2VzdCA9IGNvbXBhcmVEaWdlc3Q7XG4iLCJ2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG5cbnZhciBoZWxwZXIgPSByZXF1aXJlKF9fZGlybmFtZSsnL2hlbHBlci5qcycpO1xudmFyIENvbm5lY3Rpb24gPSByZXF1aXJlKF9fZGlybmFtZSsnL2Nvbm5lY3Rpb24uanMnKTtcbnZhciBUZXJtID0gcmVxdWlyZShfX2Rpcm5hbWUrJy90ZXJtLmpzJyk7XG52YXIgRXJyb3IgPSByZXF1aXJlKF9fZGlybmFtZSsnL2Vycm9yLmpzJyk7XG52YXIgUG9vbE1hc3RlciA9IHJlcXVpcmUoX19kaXJuYW1lKycvcG9vbF9tYXN0ZXIuanMnKTtcbnZhciB0ZXJtVHlwZXMgPSByZXF1aXJlKF9fZGlybmFtZSsnL3Byb3RvZGVmLmpzJykuVGVybS5UZXJtVHlwZTtcblxuZnVuY3Rpb24gcigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3IgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKF9yKS5leHByKHgpO1xuICB9XG4gIGhlbHBlci5jaGFuZ2VQcm90byhfciwgc2VsZik7XG5cbiAgVGVybS5wcm90b3R5cGUuX3NldE5lc3RpbmdMZXZlbChyLnByb3RvdHlwZS5uZXN0aW5nTGV2ZWwpO1xuICBUZXJtLnByb3RvdHlwZS5fc2V0QXJyYXlMaW1pdChyLnByb3RvdHlwZS5hcnJheUxpbWl0KTtcblxuICBfci5yb3cgPSBuZXcgVGVybShfcikucm93KCk7XG5cbiAgX3IubW9uZGF5ID0gbmV3IFRlcm0oX3IpLm1vbmRheSgpO1xuICBfci50dWVzZGF5ID0gbmV3IFRlcm0oX3IpLnR1ZXNkYXkoKTtcbiAgX3Iud2VkbmVzZGF5ID0gbmV3IFRlcm0oX3IpLndlZG5lc2RheSgpO1xuICBfci50aHVyc2RheSA9IG5ldyBUZXJtKF9yKS50aHVyc2RheSgpO1xuICBfci5mcmlkYXkgPSBuZXcgVGVybShfcikuZnJpZGF5KCk7XG4gIF9yLnNhdHVyZGF5ID0gbmV3IFRlcm0oX3IpLnNhdHVyZGF5KCk7XG4gIF9yLnN1bmRheSA9ICBuZXcgVGVybShfcikuc3VuZGF5KCk7XG5cbiAgX3IuamFudWFyeSA9IG5ldyBUZXJtKF9yKS5qYW51YXJ5KCk7XG4gIF9yLmZlYnJ1YXJ5ID0gbmV3IFRlcm0oX3IpLmZlYnJ1YXJ5KCk7XG4gIF9yLm1hcmNoID0gbmV3IFRlcm0oX3IpLm1hcmNoKCk7XG4gIF9yLmFwcmlsID0gbmV3IFRlcm0oX3IpLmFwcmlsKCk7XG4gIF9yLm1heSA9IG5ldyBUZXJtKF9yKS5tYXkoKTtcbiAgX3IuanVuZSA9IG5ldyBUZXJtKF9yKS5qdW5lKCk7XG4gIF9yLmp1bHkgPSBuZXcgVGVybShfcikuanVseSgpO1xuICBfci5hdWd1c3QgPSBuZXcgVGVybShfcikuYXVndXN0KCk7XG4gIF9yLnNlcHRlbWJlciA9IG5ldyBUZXJtKF9yKS5zZXB0ZW1iZXIoKTtcbiAgX3Iub2N0b2JlciA9IG5ldyBUZXJtKF9yKS5vY3RvYmVyKCk7XG4gIF9yLm5vdmVtYmVyID0gbmV3IFRlcm0oX3IpLm5vdmVtYmVyKCk7XG4gIF9yLmRlY2VtYmVyID0gbmV3IFRlcm0oX3IpLmRlY2VtYmVyKCk7XG4gIF9yLm1pbnZhbCA9IG5ldyBUZXJtKF9yKS5taW52YWwoKTtcbiAgX3IubWF4dmFsID0gbmV3IFRlcm0oX3IpLm1heHZhbCgpO1xuXG4gIF9yLm5leHRWYXJJZCA9IDE7XG4gIF9yLl9UZXJtID0gVGVybTtcbiAgcmV0dXJuIF9yO1xufTtcbnIucHJvdG90eXBlLl9ob3N0ID0gJ2xvY2FsaG9zdCc7XG5yLnByb3RvdHlwZS5fcG9ydCA9IDI4MDE1O1xuci5wcm90b3R5cGUuX2F1dGhLZXkgPSAnJztcbnIucHJvdG90eXBlLl91c2VyID0gJ2FkbWluJztcbnIucHJvdG90eXBlLl9wYXNzd29yZCA9ICcnO1xuci5wcm90b3R5cGUuX3RpbWVvdXRDb25uZWN0ID0gMjA7IC8vIHNlY29uZHNcbnIucHJvdG90eXBlLl9waW5nSW50ZXJ2YWwgPSAtMTsgLy8gc2Vjb25kc1xuXG5yLnByb3RvdHlwZS5fbmVzdGluZ0xldmVsID0gMTAwO1xuci5wcm90b3R5cGUuX2FycmF5TGltaXQgPSAxMDAwMDA7XG5yLnByb3RvdHlwZS5fZGIgPSAndGVzdCc7XG5yLnByb3RvdHlwZS5fdXNlT3V0ZGF0ZWQgPSBmYWxzZTtcbnIucHJvdG90eXBlLl90aW1lRm9ybWF0ID0gJ25hdGl2ZSc7XG5yLnByb3RvdHlwZS5fcHJvZmlsZSA9IGZhbHNlO1xuXG5cbnIucHJvdG90eXBlLnNldE5lc3RpbmdMZXZlbCA9IGZ1bmN0aW9uKG5lc3RpbmdMZXZlbCkge1xuICBpZiAodHlwZW9mIG5lc3RpbmdMZXZlbCAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBvZiBgc2V0TmVzdGluZ0xldmVsYCBtdXN0IGJlIGEgbnVtYmVyLicpXG4gIHRoaXMubmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsO1xufVxuci5wcm90b3R5cGUuc2V0QXJyYXlMaW1pdCA9IGZ1bmN0aW9uKGFycmF5TGltaXQpIHtcbiAgaWYgKHR5cGVvZiBhcnJheUxpbWl0ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IG9mIGBzZXRBcnJheUxpbWl0YCBtdXN0IGJlIGEgbnVtYmVyLicpXG4gIHRoaXMuYXJyYXlMaW1pdCA9IGFycmF5TGltaXQ7XG59XG5cbnIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIG5ldyBDb25uZWN0aW9uKHNlbGYsIG9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCk7XG4gIH0pLm5vZGVpZnkoY2FsbGJhY2spO1xuICByZXR1cm4gcDtcbn07XG5cbnIucHJvdG90eXBlLmNyZWF0ZVBvb2xzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLl9wb29sTWFzdGVyID0gbmV3IFBvb2xNYXN0ZXIodGhpcywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5yLnByb3RvdHlwZS5nZXRQb29sTWFzdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wb29sTWFzdGVyO1xufVxuci5wcm90b3R5cGUuZ2V0UG9vbCA9IGZ1bmN0aW9uKGkpIHtcbiAgaWYgKGkgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmdldFBvb2xNYXN0ZXIoKS5nZXRQb29scygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9vbE1hc3RlcigpLmdldFBvb2xzKClbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSBtdWx0aXBsZSBwb29scy4gVXNlIGBnZXRQb29sKGluZGV4KWAgb3IgYGdldFBvb2xzKClgJyk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdldFBvb2xNYXN0ZXIoKS5nZXRQb29scygpW2ldO1xuICB9XG59XG5cbnIucHJvdG90eXBlLmV4cHIgPSBmdW5jdGlvbihleHByZXNzaW9uLCBuZXN0aW5nTGV2ZWwpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIDIsICdleHByJywgdGhpcyk7XG4gIH1cbiAgdmFyIF9uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWwgfHwgdGhpcy5uZXN0aW5nTGV2ZWw7XG4gIHJldHVybiBuZXcgVGVybSh0aGlzKS5leHByKGV4cHJlc3Npb24sIF9uZXN0aW5nTGV2ZWwpO1xufTtcbnIucHJvdG90eXBlLmRiID0gZnVuY3Rpb24oZGIpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eShfYXJncywgMSwgJ3IuZGInLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gbmV3IFRlcm0odGhpcykuZGIoZGIpO1xufTtcbnIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24odGFibGUsIG9wdGlvbnMpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIDIsICd0YWJsZScsIHRoaXMpO1xuICB9XG4gIHJldHVybiBuZXcgVGVybSh0aGlzKS50YWJsZSh0YWJsZSwgb3B0aW9ucyk7XG59O1xuci5wcm90b3R5cGUuanMgPSBmdW5jdGlvbihqc1N0cmluZywgb3B0aW9ucykge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ3IuanMnLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gbmV3IFRlcm0odGhpcykuanMoanNTdHJpbmcsIG9wdGlvbnMpO1xufTtcbnIucHJvdG90eXBlLnRhYmxlQ3JlYXRlID0gZnVuY3Rpb24odGFibGUsIG9wdGlvbnMpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIDIsICdyLnRhYmxlQ3JlYXRlJywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLnRhYmxlQ3JlYXRlKHRhYmxlLCBvcHRpb25zKTtcbn07XG5yLnByb3RvdHlwZS50YWJsZURyb3AgPSBmdW5jdGlvbihkYikge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci50YWJsZURyb3AnLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gbmV3IFRlcm0odGhpcykudGFibGVEcm9wKGRiKTtcbn07XG5yLnByb3RvdHlwZS50YWJsZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eShfYXJncywgMCwgJ3IudGFibGVMaXN0JywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLnRhYmxlTGlzdCgpO1xufTtcbnIucHJvdG90eXBlLmRiQ3JlYXRlID0gZnVuY3Rpb24oZGIpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eShfYXJncywgMSwgJ2RiQ3JlYXRlJywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLmRiQ3JlYXRlKGRiKTtcbn07XG5yLnByb3RvdHlwZS5kYkRyb3AgPSBmdW5jdGlvbihkYikge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnZGJEcm9wJywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLmRiRHJvcChkYik7XG59O1xuci5wcm90b3R5cGUuZGJMaXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmIChUZXJtLnByb3RvdHlwZS5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBUZXJtLnByb3RvdHlwZS5fYXJpdHkoX2FyZ3MsIDAsICdkYkxpc3QnLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gbmV3IFRlcm0odGhpcykuZGJMaXN0KCk7XG59O1xuci5wcm90b3R5cGUubGl0ZXJhbCA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDAsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ3IubGl0ZXJhbCcsIHRoaXMpO1xuICB9XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgVGVybSh0aGlzKS5saXRlcmFsKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLmxpdGVyYWwob2JqKTtcbiAgfVxufTtcbnIucHJvdG90eXBlLmRlc2MgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci5kZXNjJywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLmRlc2MoZmllbGQpO1xufTtcbnIucHJvdG90eXBlLmFzYyA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIGlmIChUZXJtLnByb3RvdHlwZS5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBUZXJtLnByb3RvdHlwZS5fYXJpdHkoX2FyZ3MsIDEsICdyLmFzYycsIHRoaXMpO1xuICB9XG4gIHJldHVybiBuZXcgVGVybSh0aGlzKS5hc2MoZmllbGQpO1xufTtcbnIucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS51bmlvbi5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59O1xuci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIEluZmluaXR5LCAnci5hZGQnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS5hZGQuYXBwbHkodGVybSwgX2FyZ3Muc2xpY2UoMSkpO1xufTtcbnIucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAyLCBJbmZpbml0eSwgJ3Iuc3ViJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKS5leHByKF9hcmdzWzBdKTtcbiAgcmV0dXJuIHRlcm0uc3ViLmFwcGx5KHRlcm0sIF9hcmdzLnNsaWNlKDEpKTtcbn07XG5yLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMiwgSW5maW5pdHksICdyLmRpdicsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcykuZXhwcihfYXJnc1swXSk7XG4gIHJldHVybiB0ZXJtLmRpdi5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59O1xuci5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIEluZmluaXR5LCAnci5tdWwnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS5tdWwuYXBwbHkodGVybSwgX2FyZ3Muc2xpY2UoMSkpO1xufTtcbnIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMikgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eShfYXJncywgMiwgJ3IubW9kJywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFRlcm0odGhpcykuZXhwcihhKS5tb2QoYik7XG59O1xuci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS5hbmQuYXBwbHkodGVybSwgX2FyZ3MpO1xufTtcbnIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS5vci5hcHBseSh0ZXJtLCBfYXJncyk7XG59O1xuci5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMiwgSW5maW5pdHksICdyLmVxJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKS5leHByKF9hcmdzWzBdKTtcbiAgcmV0dXJuIHRlcm0uZXEuYXBwbHkodGVybSwgX2FyZ3Muc2xpY2UoMSkpO1xufTtcbnIucHJvdG90eXBlLm5lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIEluZmluaXR5LCAnci5uZScsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcykuZXhwcihfYXJnc1swXSk7XG4gIHJldHVybiB0ZXJtLm5lLmFwcGx5KHRlcm0sIF9hcmdzLnNsaWNlKDEpKTtcbn07XG5yLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAyLCBJbmZpbml0eSwgJ3IuZ3QnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS5ndC5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59O1xuci5wcm90b3R5cGUuZ2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMiwgSW5maW5pdHksICdyLmdlJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKS5leHByKF9hcmdzWzBdKTtcbiAgcmV0dXJuIHRlcm0uZ2UuYXBwbHkodGVybSwgX2FyZ3Muc2xpY2UoMSkpO1xufTtcbnIucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIEluZmluaXR5LCAnci5sdCcsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcykuZXhwcihfYXJnc1swXSk7XG4gIHJldHVybiB0ZXJtLmx0LmFwcGx5KHRlcm0sIF9hcmdzLnNsaWNlKDEpKTtcbn07XG5yLnByb3RvdHlwZS5sZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAyLCBJbmZpbml0eSwgJ3IubGUnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS5sZS5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59O1xuci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci5ub3QnLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gbmV3IFRlcm0odGhpcykuZXhwcihib29sKS5ub3QoKTtcbn1cbnIucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24obnVtKSB7XG4gIGlmIChUZXJtLnByb3RvdHlwZS5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBUZXJtLnByb3RvdHlwZS5fYXJpdHkoX2FyZ3MsIDEsICdyLmZsb29yJywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLmV4cHIobnVtKS5mbG9vcigpO1xufVxuci5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uKG51bSkge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci5jZWlsJywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLmV4cHIobnVtKS5jZWlsKCk7XG59XG5yLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKG51bSkge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci5yb3VuZCcsIHRoaXMpO1xuICB9XG4gIHJldHVybiBuZXcgVGVybSh0aGlzKS5leHByKG51bSkucm91bmQoKTtcbn1cblxuXG5yLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eShfYXJncywgMCwgJ25vdycsIHRoaXMpO1xuICB9XG4gIHJldHVybiBuZXcgVGVybSh0aGlzKS5ub3coKTtcbn1cbnIucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS50aW1lLmFwcGx5KHRlcm0sIF9hcmdzKTtcbn1cbnIucHJvdG90eXBlLmVwb2NoVGltZSA9IGZ1bmN0aW9uKGVwb2NoVGltZSkge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci5lcG9jaFRpbWUnLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gbmV3IFRlcm0odGhpcykuZXBvY2hUaW1lKGVwb2NoVGltZSk7XG59XG5yLnByb3RvdHlwZS5JU084NjAxID0gZnVuY3Rpb24oaXNvVGltZSwgb3B0aW9ucykge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ3IuSVNPODYwMScsIHRoaXMpO1xuICB9XG4gIHJldHVybiBuZXcgVGVybSh0aGlzKS5JU084NjAxKGlzb1RpbWUsIG9wdGlvbnMpO1xufVxuci5wcm90b3R5cGUuYnJhbmNoID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0cnVlQnJhbmNoLCBmYWxzZUJyYW5jaCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAzLCBJbmZpbml0eSwgJ3IuYnJhbmNoJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKS5leHByKHByZWRpY2F0ZSk7XG4gIHJldHVybiB0ZXJtLmJyYW5jaC5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59XG5yLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGVycm9yU3RyKSB7XG4gIGlmIChUZXJtLnByb3RvdHlwZS5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAwLCAxLCAnci5lcnJvcicsIHRoaXMpO1xuICB9XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcyk7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkVSUk9SKTtcbiAgaWYgKGVycm9yU3RyICE9PSB1bmRlZmluZWQpIHtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKFtuZXcgVGVybSh0aGlzKS5leHByKGVycm9yU3RyKS5fcXVlcnldKTtcbiAgfVxuICByZXR1cm4gdGVybTtcblxufVxuci5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eShfYXJncywgMSwgJ3IuanNvbicsIHRoaXMpO1xuICB9XG4gIHJldHVybiBuZXcgVGVybSh0aGlzKS5qc29uKGpzb24pO1xufVxuXG5yLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS5vYmplY3QuYXBwbHkodGVybSwgX2FyZ3MpO1xufVxuci5wcm90b3R5cGUuYXJncyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcyk7XG4gIHJldHVybiB0ZXJtLmFyZ3MuYXBwbHkodGVybSwgX2FyZ3MpO1xufVxuci5wcm90b3R5cGUucmFuZG9tID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKTtcbiAgcmV0dXJuIHRlcm0ucmFuZG9tLmFwcGx5KHRlcm0sIF9hcmdzKTtcbn1cbnIucHJvdG90eXBlLmh0dHAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS5odHRwLmFwcGx5KHRlcm0sIF9hcmdzKTtcbn1cbnIucHJvdG90eXBlLmRvID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnci5kbycsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcykuZXhwcihfYXJnc1swXSk7XG4gIHJldHVybiB0ZXJtLmRvLmFwcGx5KHRlcm0sIF9hcmdzLnNsaWNlKDEpKTtcbn1cbnIucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uKGJpbikge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci5iaW5hcnknLCB0aGlzKTtcbiAgfVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS5iaW5hcnkoYmluKTtcbn1cbnIucHJvdG90eXBlLnV1aWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMCwgMSwgJ3IudXVpZCcsIHRoaXMpO1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS51dWlkKF9hcmdzWzBdKTtcbn1cblxuci5wcm90b3R5cGUubGluZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAyLCBJbmZpbml0eSwgJ3IubGluZScsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcyk7XG4gIHJldHVybiB0ZXJtLmxpbmUuYXBwbHkodGVybSwgX2FyZ3MpO1xufVxuci5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbihsb25naXR1ZGUsIGxhdGl0dWRlKSB7XG4gIGlmIChUZXJtLnByb3RvdHlwZS5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBUZXJtLnByb3RvdHlwZS5fYXJpdHkoX2FyZ3MsIDIsICdyLnBvaW50JywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUZXJtKHRoaXMpLnBvaW50KGxvbmdpdHVkZSwgbGF0aXR1ZGUpO1xufVxuci5wcm90b3R5cGUucG9seWdvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAzLCBJbmZpbml0eSwgJ3IucG9seWdvbicsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcyk7XG4gIHJldHVybiB0ZXJtLnBvbHlnb24uYXBwbHkodGVybSwgX2FyZ3MpO1xufVxuci5wcm90b3R5cGUuY2lyY2xlID0gZnVuY3Rpb24oY2VudGVyLCByYWRpdXMsIG9wdGlvbnMpIHtcbiAgaWYgKFRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAyLCAzKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIDMsICdyLmNpcmNsZScsIHRoaXMpO1xuICB9XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcyk7XG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGVybS5jaXJjbGUoY2VudGVyLCByYWRpdXMsIG9wdGlvbnMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0ZXJtLmNpcmNsZShjZW50ZXIsIHJhZGl1cyk7XG4gIH1cbn1cbnIucHJvdG90eXBlLmdlb2pzb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci5nZW9qc29uJywgdGhpcyk7XG4gIH1cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKTtcbiAgcmV0dXJuIHRlcm0uZ2VvanNvbih2YWx1ZSk7XG59XG5yLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAyLCAzLCAnci5hZGQnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS5kaXN0YW5jZS5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59O1xuXG5yLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ3IucmFuZ2UnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGVybS5yYW5nZShzdGFydCwgZW5kKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdGVybS5yYW5nZShzdGFydCk7XG4gIH1cbn1cbnIucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbigpIHtcbiAgLy8gYHdhaXRgIG9uIHRoZSB0b3AgbGV2ZWwgaGFzIGJlZW4gcmVtb3ZlZCBpbiAyLjMuXG4gIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ2B3YWl0YCBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB0YWJsZSBvciBhIGRhdGFiYXNlIHNpbmNlIDIuMycpO1xufVxuci5wcm90b3R5cGUucmVjb25maWd1cmUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgLy8gYHJlY29uZmlndXJlYCBvbiB0aGUgdG9wIGxldmVsIGhhcyBiZWVuIHJlbW92ZWQgaW4gMi4zLlxuICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdgcmVjb25maWd1cmVgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHRhYmxlIG9yIGEgZGF0YWJhc2Ugc2luY2UgMi4zJyk7XG59XG5yLnByb3RvdHlwZS5yZWJhbGFuY2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgLy8gYHJlYmFsYW5jZWAgb24gdGhlIHRvcCBsZXZlbCBoYXMgYmVlbiByZW1vdmVkIGluIDIuMy5cbiAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignYHJlYmFsYW5jZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgdGFibGUgb3IgYSBkYXRhYmFzZSBzaW5jZSAyLjMnKTtcbn1cbnIucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ3IubWFwJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKTtcbiAgcmV0dXJuIHRlcm0ubWFwLmFwcGx5KHRlcm0sIF9hcmdzKTtcbn07XG5yLnByb3RvdHlwZS50eXBlT2YgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgVGVybS5wcm90b3R5cGUuX2FyaXR5KF9hcmdzLCAxLCAnci50eXBlT2YnLCB0aGlzKTtcbiAgfVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpO1xuICByZXR1cm4gdGVybS5leHByKHZhbHVlKS50eXBlT2YoKTtcbn1cbnIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ3IubWluJywgdGhpcyk7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcykuZXhwcihfYXJnc1swXSk7XG4gIHJldHVybiB0ZXJtLm1pbi5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59XG5yLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICBUZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZShfYXJncywgMSwgSW5maW5pdHksICdyLm1heCcsIHRoaXMpO1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS5tYXguYXBwbHkodGVybSwgX2FyZ3Muc2xpY2UoMSkpO1xufVxuci5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnci5zdW0nLCB0aGlzKTtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzKS5leHByKF9hcmdzWzBdKTtcbiAgcmV0dXJuIHRlcm0uc3VtLmFwcGx5KHRlcm0sIF9hcmdzLnNsaWNlKDEpKTtcbn1cbnIucHJvdG90eXBlLmF2ZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIFRlcm0ucHJvdG90eXBlLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ3IuYXZnJywgdGhpcyk7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcykuZXhwcihfYXJnc1swXSk7XG4gIHJldHVybiB0ZXJtLmF2Zy5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59XG5yLnByb3RvdHlwZS5kaXN0aW5jdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgVGVybS5wcm90b3R5cGUuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnci5kaXN0aW5jdCcsIHRoaXMpO1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMpLmV4cHIoX2FyZ3NbMF0pO1xuICByZXR1cm4gdGVybS5kaXN0aW5jdC5hcHBseSh0ZXJtLCBfYXJncy5zbGljZSgxKSk7XG59XG5cblxuci5wcm90b3R5cGUuRXJyb3IgPSBFcnJvcjtcblxuXG5mdW5jdGlvbiBtYWluKG9wdGlvbnMpIHtcbiAgdmFyIF9yID0gbmV3IHIoKTtcblxuICBpZiAoIWhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSBvcHRpb25zID0ge307XG4gIGlmIChvcHRpb25zLnBvb2wgIT09IGZhbHNlKSBfci5jcmVhdGVQb29scyhvcHRpb25zKTtcbiAgX3IuX29wdGlvbnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuY3Vyc29yID09PSB0cnVlKSBfci5fb3B0aW9ucy5jdXJzb3IgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5zdHJlYW0gPT09IHRydWUpIF9yLl9vcHRpb25zLnN0cmVhbSA9IHRydWU7XG4gIGlmIChvcHRpb25zLm9wdGlvbmFsUnVuID09PSBmYWxzZSkge1xuICAgIGRlbGV0ZSBfci5fVGVybS5wcm90b3R5cGUudGhlblxuICAgIGRlbGV0ZSBfci5fVGVybS5wcm90b3R5cGUuZXJyb3JcbiAgICBkZWxldGUgX3IuX1Rlcm0ucHJvdG90eXBlLmNhdGNoXG4gICAgZGVsZXRlIF9yLl9UZXJtLnByb3RvdHlwZS5maW5hbGx5XG4gIH1cbiAgcmV0dXJuIF9yO1xufVxubW9kdWxlLmV4cG9ydHMgPSBtYWluO1xuIiwiLy8gTWV0YWRhdGEgd2Uga2VlcCBwZXIgcXVlcnlcbmZ1bmN0aW9uIE1ldGFkYXRhKHJlc29sdmUsIHJlamVjdCwgcXVlcnksIG9wdGlvbnMpIHtcbiAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gIHRoaXMucXVlcnkgPSBxdWVyeTsgLy8gVGhlIHF1ZXJ5IGluIGNhc2Ugd2UgaGF2ZSB0byBidWlsZCBhIGJhY2t0cmFjZVxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLmN1cnNvciA9IGZhbHNlO1xufVxuXG5NZXRhZGF0YS5wcm90b3R5cGUuc2V0Q3Vyc29yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3Vyc29yID0gdHJ1ZTtcbn1cblxuTWV0YWRhdGEucHJvdG90eXBlLnNldEVuZCA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICB0aGlzLmVuZFJlc29sdmUgPSByZXNvbHZlO1xuICB0aGlzLmVuZFJlamVjdCA9IHJlamVjdDtcbn1cblxuTWV0YWRhdGEucHJvdG90eXBlLnNldENhbGxiYWNrcyA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbn1cbk1ldGFkYXRhLnByb3RvdHlwZS5yZW1vdmVDYWxsYmFja3MgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZXNvbHZlID0gbnVsbDtcbiAgdGhpcy5yZWplY3QgPSBudWxsO1xufVxuTWV0YWRhdGEucHJvdG90eXBlLnJlbW92ZUVuZENhbGxiYWNrcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVuZFJlc29sdmUgPSBudWxsO1xuICB0aGlzLmVuZFJlamVjdCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWV0YWRhdGE7XG4iLCJ2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG52YXIgRGVxdWV1ZSA9IHJlcXVpcmUoX19kaXJuYW1lKycvZGVxdWV1ZS5qcycpO1xudmFyIGhlbHBlciA9IHJlcXVpcmUoX19kaXJuYW1lKycvaGVscGVyLmpzJyk7XG52YXIgRXJyID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9lcnJvci5qcycpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIFBvb2wociwgb3B0aW9ucykge1xuICB0aGlzLl9yID0gcjtcblxuICBpZiAoIWhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSBvcHRpb25zID0ge307XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLm9wdGlvbnMubWF4ID0gb3B0aW9ucy5tYXggfHwgMTAwMDsgLy8gNDAwMCBpcyBhYm91dCB0aGUgbWF4aW11bSB0aGUga2VybmVsIGNhbiB0YWtlXG4gIHZhciBidWZmZXIgPSAodHlwZW9mIG9wdGlvbnMuYnVmZmVyID09PSAnbnVtYmVyJykgPyBvcHRpb25zLmJ1ZmZlciA6IDUwO1xuICB0aGlzLm9wdGlvbnMuYnVmZmVyID0gKGJ1ZmZlciA8IHRoaXMub3B0aW9ucy5tYXgpID8gYnVmZmVyIDogdGhpcy5vcHRpb25zLm1heDtcbiAgdGhpcy5vcHRpb25zLnRpbWVvdXRFcnJvciA9IG9wdGlvbnMudGltZW91dEVycm9yIHx8IDEwMDA7IC8vIEhvdyBsb25nIHNob3VsZCB3ZSB3YWl0IGJlZm9yZSByZWNyZWF0aW5nIGEgY29ubmVjdGlvbiB0aGF0IGZhaWxlZD9cbiAgdGhpcy5vcHRpb25zLnRpbWVvdXRHYiA9IG9wdGlvbnMudGltZW91dEdiIHx8IDYwKjYwKjEwMDA7IC8vIERlZmF1bHQgdGltZW91dCBmb3IgVENQIGNvbm5lY3Rpb24gaXMgMiBob3VycyBvbiBMaW51eCwgd2UgdGltZSBvdXQgYWZ0ZXIgb25lIGhvdXIuXG4gIHRoaXMub3B0aW9ucy5tYXhFeHBvbmVudCA9IG9wdGlvbnMubWF4RXhwb25lbnQgfHwgNjsgLy8gTWF4aW11bSB0aW1lb3V0IGlzIDJebWF4RXhwb25lbnQqdGltZW91dEVycm9yXG5cbiAgdGhpcy5vcHRpb25zLnNpbGVudCA9IG9wdGlvbnMuc2lsZW50IHx8IGZhbHNlO1xuXG4gIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uID0ge1xuICAgIGhvc3Q6IG9wdGlvbnMuaG9zdCB8fCB0aGlzLl9yLl9ob3N0LFxuICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLl9yLl9wb3J0LFxuICAgIGRiOiBvcHRpb25zLmRiIHx8IHRoaXMuX3IuX2RiLFxuICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCB0aGlzLl9yLl90aW1lb3V0Q29ubmVjdCxcbiAgICBhdXRoS2V5OiBvcHRpb25zLmF1dGhLZXksXG4gICAgdXNlcjogb3B0aW9ucy51c2VyLFxuICAgIHBhc3N3b3JkOiBvcHRpb25zLnBhc3N3b3JkLFxuICAgIGN1cnNvcjogb3B0aW9ucy5jdXJzb3IgfHwgZmFsc2UsXG4gICAgc3RyZWFtOiBvcHRpb25zLnN0cmVhbSB8fCBmYWxzZSxcbiAgICBzc2w6IG9wdGlvbnMuc3NsIHx8IGZhbHNlLFxuICAgIHBpbmdJbnRlcnZhbDogb3B0aW9ucy5waW5nSW50ZXJ2YWwgfHwgdGhpcy5fci5fcGluZ0ludGVydmFsXG4gIH1cbiAgdGhpcy5fbG9nID0gb3B0aW9ucy5fbG9nO1xuXG4gIHRoaXMuX3Bvb2wgPSBuZXcgRGVxdWV1ZSh0aGlzLm9wdGlvbnMuYnVmZmVyKzEpO1xuICB0aGlzLl9kcmFpbmluZyA9IGZhbHNlO1xuICB0aGlzLl9kcmFpbmluZ0hhbmRsZXJzID0gbnVsbDsgLy8gU3RvcmUgdGhlIHJlc29sdmUvcmVqZWN0IG1ldGhvZHMgb25jZSBkcmFpbmluZyBpcyBjYWxsZWRcbiAgdGhpcy5fbG9jYWxob3N0VG9EcmFpbiA9IDA7IC8vIG51bWJlciBvZiBjb25uZWN0aW9ucyB0byBcImxvY2FsaG9zdFwiIHRvIHJlbW92ZVxuICB0aGlzLl9jb25uZWN0aW9uVG9SZXBsYWNlID0gMDsgLy8gbnVtYmVyIG9mIGNvbm5lY3Rpb25zIHRvIFwibG9jYWxob3N0XCIgdG8gcmVtb3ZlXG5cbiAgdGhpcy5fbnVtQ29ubmVjdGlvbnMgPSAwO1xuICB0aGlzLl9vcGVuaW5nQ29ubmVjdGlvbnMgPSAwOyAvLyBOdW1iZXIgb2YgY29ubmVjdGlvbnMgYmVpbmcgb3BlbmVkXG4gIHRoaXMuX2NvbnNlY3V0aXZlRmFpbHMgPSAwOyAgIC8vIEluIHNsb3cgZ3Jvd3RoLCB0aGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGZhaWx1cmVzIHRvIG9wZW4gYSBjb25uZWN0aW9uXG4gIHRoaXMuX3Nsb3dHcm93dGggPSBmYWxzZTsgICAgIC8vIE9wZW5pbmcgb25lIGNvbm5lY3Rpb24gYXQgYSB0aW1lXG4gIHRoaXMuX3Nsb3dseUdyb3dpbmcgPSBmYWxzZTsgIC8vIFRoZSBuZXh0IGNvbm5lY3Rpb24gdG8gYmUgcmV0dXJuZWQgaXMgb25lIG9wZW5lZCBpbiBzbG93R3Jvd3RoIG1vZGVcbiAgdGhpcy5fZXh0cmFDb25uZWN0aW9ucyA9IDA7IC8vIE51bWJlciBvZiBleHRyYSBjb25uZWN0aW9ucyBiZWluZyBvcGVuZWQgdGhhdCB3ZSBzaG91bGQgZXZlbnR1YWxseSBjbG9zZVxuXG4gIHRoaXMuX2VtcHR5ID0gdHJ1ZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIFNvIHdlIGNhbiBsZXQgdGhlIHBvb2wgbWFzdGVyIGJpbmQgbGlzdGVuZXJzXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuX2RyYWluaW5nID09PSBmYWxzZSkge1xuICAgICAgZm9yKHZhciBpPTA7IGk8c2VsZi5vcHRpb25zLmJ1ZmZlcjsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLmdldExlbmd0aCgpIDwgc2VsZi5vcHRpb25zLm1heCkge1xuICAgICAgICAgIHNlbGYuY3JlYXRlQ29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCAwKTtcbiAgdGhpcy5pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwMDApO1xuICB0aGlzLl9sb2coJ0NyZWF0aW5nIGEgcG9vbCBjb25uZWN0ZWQgdG8gJyt0aGlzLmdldEFkZHJlc3MoKSk7XG59XG5cbnV0aWwuaW5oZXJpdHMoUG9vbCwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG4vKlxuICogRXZlbnRzOlxuICogIC0gZHJhaW5pbmcgLy8gd2hlbiBgZHJhaW5gIGlzIGNhbGxlZFxuICogIC0gcXVldWVpbmcoc2l6ZSBvZiB0aGUgcXVldWUpIC8vIHRoZSBudW1iZXIgb2YgcXVlcmllcyBiZWluZyBiZWZmZXJlZCBjaGFuZ2VkXG4gKiAgLSBzaXplKG51bWJlciBvZiBjb25uZWN0aW9ucykgLy8gdGhlIHNpemUgb2YgdGhlIHBvb2wgY2hhbmdlZFxuICogIC0gYXZhaWxhYmxlLXNpemUoYXZhaWxhYmxlIHNpemUpIC8vIHRoZSBudW1iZXIgb2YgQVZBSUxBQkxFIGNvbm5jZXRpb25zIG9mIHRoZSBwb29sIGNoYW5nZWRcbiAqL1xuXG5Qb29sLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoc2VsZi5fZHJhaW5pbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVyci5SZXFsRHJpdmVyRXJyb3IoJ1RoZSBwb29sIGlzIGJlaW5nIGRyYWluZWQnKS5zZXRPcGVyYXRpb25hbCgpKTtcbiAgICB9XG5cbiAgICB2YXIgY29ubmVjdGlvbiA9IHNlbGYuX3Bvb2wucG9wKCk7XG4gICAgc2VsZi5lbWl0KCdhdmFpbGFibGUtc2l6ZScsIHNlbGYuX3Bvb2wuZ2V0TGVuZ3RoKCkpO1xuICAgIHNlbGYuZW1pdCgnYXZhaWxhYmxlLXNpemUtZGlmZicsIC0xKTtcblxuICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbi50aW1lb3V0KTtcbiAgICAgIHJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKChzZWxmLl9udW1Db25uZWN0aW9ucyA9PT0gMCkgJiYgKHNlbGYuX3Nsb3dHcm93dGggPT09IHRydWUpKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgaXMgZG93biB3ZSBkbyBub3Qgd2FudCB0byBidWZmZXIgdGhlIHF1ZXJpZXNcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignVGhlIHBvb2wgZG9lcyBub3QgaGF2ZSBhbnkgb3BlbmVkIGNvbm5lY3Rpb25zIGFuZCBmYWlsZWQgdG8gb3BlbiBhIG5ldyBvbmUnKS5zZXRPcGVyYXRpb25hbCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fc2xvd0dyb3d0aCA9PT0gZmFsc2UpIHtcbiAgICAgIHNlbGYuX2V4cGFuZEJ1ZmZlcigpO1xuICAgIH1cblxuICB9KTtcbiAgcmV0dXJuIHA7XG59O1xuXG5Qb29sLnByb3RvdHlwZS5fZGVjcmVhc2VOdW1Db25uZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9udW1Db25uZWN0aW9ucy0tO1xuICB0aGlzLmVtaXQoJ3NpemUnLCB0aGlzLl9udW1Db25uZWN0aW9ucylcbiAgdGhpcy5lbWl0KCdzaXplLWRpZmYnLCAtMSlcbiAgaWYgKCh0aGlzLl9kcmFpbmluZ0hhbmRsZXJzICE9PSBudWxsKSAmJiAodGhpcy5fbnVtQ29ubmVjdGlvbnMgPT09IDApKSB7XG4gICAgdGhpcy5fZHJhaW5pbmdIYW5kbGVycy5yZXNvbHZlKCk7XG4gIH1cbiAgLy8gV2UgZG8gbm90IGNoZWNrIGZvciB0aGlzLl9lbXB0eSA9PT0gZmFsc2UgYmVjYXVzZSB3ZSB3YW50IHRvIGVtaXQgZW1wdHkgaWYgdGhlIHBvb2xcbiAgLy8gdHJpZXMgdG8gY29ubmVjdCB0byBhbiB1bmF2YWlsYWJsZSBzZXJ2ZXIgKHN1Y2ggdGhhdCB0aGUgbWFzdGVyIGNhbiByZW1vdmUgaXQgZnJvbSB0aGVcbiAgLy8gaGVhbHRoeSBwb29sXG4gIGlmICh0aGlzLl9udW1Db25uZWN0aW9ucyA9PT0gMCkge1xuICAgIHRoaXMuX2VtcHR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2VtcHR5Jyk7XG4gIH1cbn1cblBvb2wucHJvdG90eXBlLl9pbmNyZWFzZU51bUNvbm5lY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX251bUNvbm5lY3Rpb25zKys7XG4gIHRoaXMuZW1pdCgnc2l6ZScsIHRoaXMuX251bUNvbm5lY3Rpb25zKVxuICB0aGlzLmVtaXQoJ3NpemUtZGlmZicsIDEpXG59XG5cblxuUG9vbC5wcm90b3R5cGUucHV0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoY29ubmVjdGlvbi5lbmQgPT09IGZhbHNlKSB7XG4gICAgLy8gVGVtcG9yYXJ5IGF0dGVtcHQgdG8gZml4ICMxOTIgLSB0aGlzIHNob3VsZCBub3QgaGFwcGVuLlxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2VsZi5fZW1wdHkgPT09IHRydWUpIHtcbiAgICBzZWxmLl9lbXB0eSA9IGZhbHNlO1xuICAgIC8vIFdlIGVtaXQgbm90LWVtcHR5IG9ubHkgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgb3BlbmVkIGNvbm5lY3Rpb25cbiAgICBzZWxmLmVtaXQoJ25vdC1lbXB0eScpO1xuICB9XG4gIGlmICgoc2VsZi5fbG9jYWxob3N0VG9EcmFpbiA+IDApICYmIChoZWxwZXIubG9jYWxob3N0QWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShjb25uZWN0aW9uLmhvc3QpKSkge1xuICAgIHNlbGYuX2xvY2FsaG9zdFRvRHJhaW4tLTtcbiAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb24udGltZW91dCk7XG4gICAgc2VsZi5jcmVhdGVDb25uZWN0aW9uKCk7XG4gIH1cbiAgZWxzZSBpZiAoc2VsZi5fZHJhaW5pbmdIYW5kbGVycyAhPT0gbnVsbCkge1xuICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbi50aW1lb3V0KTtcbiAgICBpZiAoc2VsZi5nZXRMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgc2VsZi5fZHJhaW5pbmdIYW5kbGVycy5yZXNvbHZlKCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHNlbGYuX2V4dHJhQ29ubmVjdGlvbnMgPiAwKSB7XG4gICAgc2VsZi5fZXh0cmFDb25uZWN0aW9ucy0tO1xuICAgIGNvbm5lY3Rpb24uY2xvc2UoKS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZi5fbG9nKCdGYWlsIHRvIHByb3Blcmx5IGNsb3NlIGEgY29ubmVjdGlvbi4gRXJyb3I6JytKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgIH0pO1xuICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uLnRpbWVvdXQpO1xuICB9XG4gIC8qXG4gIC8vIFdlIGxldCB0aGUgcG9vbCBnYXJiYWdlIGNvbGxlY3QgdGhlc2UgY29ubmVjdGlvbnNcbiAgZWxzZSBpZiAoc2VsZi5nZXRBdmFpbGFibGVMZW5ndGgoKSsxID4gc2VsZi5vcHRpb25zLmJ1ZmZlcikgeyAvLyArMSBmb3IgdGhlIGNvbm5lY3Rpb24gd2UgbWF5IHB1dCBiYWNrXG4gICAgLy8gTm90ZSB0aGF0IGJlY2F1c2Ugd2UgaGF2ZSBhdmFpbGFibGUgY29ubmVjdGlvbnMgaGVyZSwgdGhlIHBvb2wgbWFzdGVyIGhhcyBubyBwZW5kaW5nXG4gICAgLy8gcXVlcmllcy5cbiAgICBjb25uZWN0aW9uLmNsb3NlKCkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHNlbGYuX2xvZygnRmFpbCB0byBwcm9wZXJseSBjbG9zZSBhIGNvbm5lY3Rpb24uIEVycm9yOicrSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICB9KTtcbiAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbi50aW1lb3V0KTtcbiAgfVxuICAqL1xuICBlbHNlIHtcbiAgICBzZWxmLl9wb29sLnB1c2goY29ubmVjdGlvbik7XG4gICAgc2VsZi5lbWl0KCdhdmFpbGFibGUtc2l6ZScsIHNlbGYuX3Bvb2wuZ2V0TGVuZ3RoKCkpO1xuICAgIHNlbGYuZW1pdCgnYXZhaWxhYmxlLXNpemUtZGlmZicsIDEpO1xuICAgIHNlbGYuZW1pdCgnbmV3LWNvbm5lY3Rpb24nLCBjb25uZWN0aW9uKTtcblxuICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uLnRpbWVvdXQpO1xuICAgIHZhciB0aW1lb3V0Q2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmLl9wb29sLmdldCgwKSA9PT0gY29ubmVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZi5fcG9vbC5nZXRMZW5ndGgoKSA+IHNlbGYub3B0aW9ucy5idWZmZXIpIHtcbiAgICAgICAgICBzZWxmLl9wb29sLnNoaWZ0KCkuY2xvc2UoKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2F2YWlsYWJsZS1zaXplJywgc2VsZi5fcG9vbC5nZXRMZW5ndGgoKSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdhdmFpbGFibGUtc2l6ZS1kaWZmJywgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbm5lY3Rpb24udGltZW91dCA9IHNldFRpbWVvdXQodGltZW91dENiLCBzZWxmLm9wdGlvbnMudGltZW91dEdiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRlY2huaWNhbGx5IG5ldmVyIGhhcHBlbnNcbiAgICAgICAgY29ubmVjdGlvbi50aW1lb3V0ID0gc2V0VGltZW91dCh0aW1lb3V0Q2IsIHNlbGYub3B0aW9ucy50aW1lb3V0R2IpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0aW9uLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpbWVvdXRDYiwgc2VsZi5vcHRpb25zLnRpbWVvdXRHYik7XG4gIH1cbn07XG5cblBvb2wucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9pbmNyZWFzZU51bUNvbm5lY3Rpb25zKCk7XG4gIHNlbGYuX29wZW5pbmdDb25uZWN0aW9ucysrO1xuXG4gIHNlbGYuZW1pdCgnY3JlYXRpbmctY29ubmVjdGlvbicsIHNlbGYpO1xuICBpZiAoc2VsZi5fZHJhaW5pbmcgPT09IHRydWUpIHtcbiAgICByZXR1cm47IC8vIERvIG5vdCBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbiBpZiB3ZSBhcmUgZHJhaW5pbmcgdGhlIHBvb2wuXG4gIH1cblxuICByZXR1cm4gc2VsZi5fci5jb25uZWN0KHNlbGYub3B0aW9ucy5jb25uZWN0aW9uKS50aGVuKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICBzZWxmLmVtaXQoJ2NyZWF0ZWQtY29ubmVjdGlvbicsIHNlbGYpO1xuXG4gICAgc2VsZi5fb3BlbmluZ0Nvbm5lY3Rpb25zLS07XG5cbiAgICBpZiAoKHNlbGYuX3Nsb3dseUdyb3dpbmcgPT09IGZhbHNlKSAmJiAoc2VsZi5fc2xvd0dyb3d0aCA9PT0gdHJ1ZSkgJiYgKHNlbGYuX29wZW5pbmdDb25uZWN0aW9ucyA9PT0gMCkpIHtcbiAgICAgIHNlbGYuX2NvbnNlY3V0aXZlRmFpbHMrKztcbiAgICAgIHNlbGYuX3Nsb3dseUdyb3dpbmcgPSB0cnVlO1xuICAgICAgc2VsZi50aW1lb3V0UmVjb25uZWN0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5jcmVhdGVDb25uZWN0aW9uKCk7XG4gICAgICAgIC8vc2VsZi5fZXhwYW5kQnVmZmVyKCk7XG4gICAgICB9LCAoMTw8TWF0aC5taW4oc2VsZi5vcHRpb25zLm1heEV4cG9uZW50LCBzZWxmLl9jb25zZWN1dGl2ZUZhaWxzKSkqc2VsZi5vcHRpb25zLnRpbWVvdXRFcnJvcik7XG4gICAgfVxuICAgIC8vIE5lZWQgYW5vdGhlciBmbGFnXG4gICAgZWxzZSBpZiAoKHNlbGYuX3Nsb3dseUdyb3dpbmcgPT09IHRydWUpICYmIChzZWxmLl9zbG93R3Jvd3RoID09PSB0cnVlKSAmJiAoc2VsZi5fY29uc2VjdXRpdmVGYWlscyA+IDApKSB7XG4gICAgICBzZWxmLl9sb2coJ0V4aXRpbmcgc2xvdyBncm93dGggbW9kZScpO1xuICAgICAgc2VsZi5fY29uc2VjdXRpdmVGYWlscyA9IDA7XG4gICAgICBzZWxmLl9zbG93R3Jvd3RoID0gZmFsc2U7XG4gICAgICBzZWxmLl9zbG93bHlHcm93aW5nID0gZmFsc2U7XG4gICAgICBzZWxmLl9hZ2dyZXNzaXZlbHlFeHBhbmRCdWZmZXIoKTtcbiAgICB9XG5cblxuXG4gICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGNsb3NlIGNvbm5lY3Rpb24sIGJ1dCB3ZSBkb24ndCB3YW50IGFub3RoZXIgcHJvY2VzcyB0byB1c2UgaXQgYmVmb3JlXG4gICAgICAvLyBTbyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbCBub3cgKGlmIGl0J3MgaW5zaWRlKVxuICAgICAgc2VsZi5fbG9nKCdFcnJvciBlbWl0dGVkIGJ5IGEgY29ubmVjdGlvbjogJytKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgZm9yKHZhciBpPTA7IGk8c2VsZi5nZXRBdmFpbGFibGVMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9wb29sLmdldChpKSA9PT0gdGhpcykge1xuICAgICAgICAgIHNlbGYuX3Bvb2wuZGVsZXRlKGkpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnYXZhaWxhYmxlLXNpemUnLCBzZWxmLl9wb29sLmdldExlbmd0aCgpKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2F2YWlsYWJsZS1zaXplLWRpZmYnLCAtMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBub3QgZ29pbmcgdG8gdHJ5IHRvIHJlY29ubmVjdFxuICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb24udGltZW91dCk7XG5cbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgaGFwcGVuZWQgaGVyZSwgc28gbGV0J3MgYmUgc2FmZSBhbmQgY2xvc2UgdGhpcyBjb25uZWN0aW9uLlxuICAgICAgY29ubmVjdGlvbi5jbG9zZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9leHBhbmRCdWZmZXIoKTtcbiAgICAgIH0pLmVycm9yKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gV2UgZmFpbGVkIHRvIGNsb3NlIHRoaXMgY29ubmVjdGlvbiwgYnV0IHdlIHJlbW92ZWQgaXQgZnJvbSB0aGUgcG9vbC4uLiBzbyBlcnIsIGxldCdzIGp1c3QgaWdub3JlIHRoYXQuXG4gICAgICAgIHNlbGYuX2V4cGFuZEJ1ZmZlcigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbignZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gVGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBieSB0aGUgc2VydmVyLCBsZXQncyBjbGVhbi4uLlxuICAgICAgZm9yKHZhciBpPTA7IGk8c2VsZi5nZXRBdmFpbGFibGVMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9wb29sLmdldChpKSA9PT0gdGhpcykge1xuICAgICAgICAgIHNlbGYuX3Bvb2wuZGVsZXRlKGkpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnYXZhaWxhYmxlLXNpemUnLCBzZWxmLl9wb29sLmdldExlbmd0aCgpKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2F2YWlsYWJsZS1zaXplLWRpZmYnLCAtMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb24udGltZW91dCk7XG4gICAgICBzZWxmLl9kZWNyZWFzZU51bUNvbm5lY3Rpb25zKCk7XG4gICAgICBzZWxmLl9leHBhbmRCdWZmZXIoKTtcbiAgICB9KTtcbiAgICBjb25uZWN0aW9uLm9uKCd0aW1lb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICBmb3IodmFyIGk9MDsgaTxzZWxmLmdldEF2YWlsYWJsZUxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Bvb2wuZ2V0KGkpID09PSB0aGlzKSB7XG4gICAgICAgICAgc2VsZi5fcG9vbC5kZWxldGUoaSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdhdmFpbGFibGUtc2l6ZScsIHNlbGYuX3Bvb2wuZ2V0TGVuZ3RoKCkpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnYXZhaWxhYmxlLXNpemUtZGlmZicsIC0xKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbi50aW1lb3V0KTtcbiAgICAgIHNlbGYuX2RlY3JlYXNlTnVtQ29ubmVjdGlvbnMoKTtcbiAgICAgIHNlbGYuX2V4cGFuZEJ1ZmZlcigpO1xuICAgIH0pO1xuICAgIGNvbm5lY3Rpb24ub24oJ3JlbGVhc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9pc09wZW4oKSkgc2VsZi5wdXRDb25uZWN0aW9uKHRoaXMpO1xuICAgIH0pO1xuICAgIHNlbGYucHV0Q29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBXZSBmYWlsZWQgdG8gY3JlYXRlIGEgY29ubmVjdGlvbiwgd2UgYXJlIG5vdyBnb2luZyB0byBjcmVhdGUgY29ubmVjdGlvbnMgb25lIGJ5IG9uZVxuICAgIHNlbGYuX29wZW5pbmdDb25uZWN0aW9ucy0tO1xuICAgIHNlbGYuX2RlY3JlYXNlTnVtQ29ubmVjdGlvbnMoKTtcblxuICAgIHNlbGYuX3Nsb3dHcm93dGggPSB0cnVlO1xuICAgIGlmIChzZWxmLl9zbG93bHlHcm93aW5nID09PSBmYWxzZSkge1xuICAgICAgc2VsZi5fbG9nKCdFbnRlcmluZyBzbG93IGdyb3d0aCBtb2RlJyk7XG4gICAgfVxuICAgIHNlbGYuX3Nsb3dseUdyb3dpbmcgPSB0cnVlO1xuXG4gICAgLy8gTG9nIGFuIGVycm9yXG4gICAgc2VsZi5fbG9nKCdGYWlsIHRvIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uIGZvciB0aGUgY29ubmVjdGlvbiBwb29sLiBFcnJvcjonK0pTT04uc3RyaW5naWZ5KGVycm9yKSk7XG5cbiAgICBpZiAoc2VsZi5fb3BlbmluZ0Nvbm5lY3Rpb25zID09PSAwKSB7XG4gICAgICBzZWxmLl9jb25zZWN1dGl2ZUZhaWxzKys7XG4gICAgICBzZWxmLnRpbWVvdXRSZWNvbm5lY3QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3NlbGYuX2V4cGFuZEJ1ZmZlcigpO1xuICAgICAgICBzZWxmLmNyZWF0ZUNvbm5lY3Rpb24oKTtcbiAgICAgIH0sICgxPDxNYXRoLm1pbihzZWxmLm9wdGlvbnMubWF4RXhwb25lbnQsIHNlbGYuX2NvbnNlY3V0aXZlRmFpbHMpKSpzZWxmLm9wdGlvbnMudGltZW91dEVycm9yKTtcbiAgICB9XG4gIH0pXG59O1xuXG5Qb29sLnByb3RvdHlwZS5fYWdncmVzc2l2ZWx5RXhwYW5kQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaT0wOyBpPHRoaXMub3B0aW9ucy5idWZmZXI7IGkrKykge1xuICAgIHRoaXMuX2V4cGFuZEJ1ZmZlcigpO1xuICB9XG59XG5Qb29sLnByb3RvdHlwZS5fZXhwYW5kQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICgodGhpcy5fZHJhaW5pbmcgPT09IGZhbHNlKSAmJlxuICAgICAgKHRoaXMuX3Bvb2wuZ2V0TGVuZ3RoKCkgPCB0aGlzLm9wdGlvbnMuYnVmZmVyK3RoaXMuX2xvY2FsaG9zdFRvRHJhaW4pICYmXG4gICAgICAodGhpcy5fbnVtQ29ubmVjdGlvbnMgPCB0aGlzLm9wdGlvbnMubWF4K3RoaXMuX2xvY2FsaG9zdFRvRHJhaW4pKSB7XG4gICAgdGhpcy5jcmVhdGVDb25uZWN0aW9uKCk7XG4gIH1cbn1cblxuUG9vbC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9udW1Db25uZWN0aW9ucztcbn1cblBvb2wucHJvdG90eXBlLmdldEF2YWlsYWJsZUxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcG9vbC5nZXRMZW5ndGgoKTtcbn1cblxuUG9vbC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgZm9yKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLm9wdGlvbnM7XG59XG5Qb29sLnByb3RvdHlwZS5kcmFpbkxvY2FsaG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIEFsbCB0aGUgY29ubmVjdGlvbnMgYXJlIHRvIGxvY2FsaG9zdCwgbGV0J3MgY3JlYXRlIG5ldyBvbmVzIChub3QgdG8gbG9jYWxob3N0KVxuICBzZWxmLl9jb25uZWN0aW9uVG9SZXBsYWNlID0gc2VsZi5fbnVtQ29ubmVjdGlvbnM7XG4gIDtcbiAgZm9yKHZhciBpPTAsIG51bUNvbm5lY3Rpb25zPXNlbGYuX251bUNvbm5lY3Rpb25zOyBpPG51bUNvbm5lY3Rpb25zOyBpKyspIHtcbiAgICBzZWxmLmNyZWF0ZUNvbm5lY3Rpb24oKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fbG9jYWxob3N0VG9EcmFpbisrO1xuICAgICAgc2VsZi5fY29ubmVjdGlvblRvUmVwbGFjZS0tO1xuICAgICAgaWYgKChzZWxmLl9jb25uZWN0aW9uVG9SZXBsYWNlID09PSAwKSAmJiAoc2VsZi5fbG9jYWxob3N0VG9EcmFpbiA+IDApKSB7XG4gICAgICAgIHZhciBsZW4gPSBzZWxmLl9wb29sLmdldExlbmd0aCgpO1xuICAgICAgICBmb3IodmFyIGo9MDsgajxsZW47IGorKykge1xuICAgICAgICAgIGlmIChzZWxmLl9sb2NhbGhvc3RUb0RyYWluID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9jb25uZWN0aW9uID0gc2VsZi5fcG9vbC5zaGlmdCgpO1xuICAgICAgICAgIGlmIChoZWxwZXIubG9jYWxob3N0QWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShfY29ubmVjdGlvbi5ob3N0KSkge1xuICAgICAgICAgICAgc2VsZi5fbG9jYWxob3N0VG9EcmFpbi0tO1xuICAgICAgICAgICAgX2Nvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfY29ubmVjdGlvbi50aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLl9wb29sLnB1c2goX2Nvbm5lY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cbn1cblxuUG9vbC5wcm90b3R5cGUuZHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9kcmFpbmluZyA9IHRydWU7XG4gIHNlbGYuX2xvZygnRHJhaW5pbmcgdGhlIHBvb2wgY29ubmVjdGVkIHRvICcrdGhpcy5nZXRBZGRyZXNzKCkpO1xuICBzZWxmLmVtaXQoJ2RyYWluaW5nJyk7XG4gIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGNvbm5lY3Rpb24gPSBzZWxmLl9wb29sLnBvcCgpO1xuICAgIHNlbGYuZW1pdCgnYXZhaWxhYmxlLXNpemUnLCBzZWxmLl9wb29sLmdldExlbmd0aCgpKTtcbiAgICBzZWxmLmVtaXQoJ2F2YWlsYWJsZS1zaXplLWRpZmYnLCAtMSk7XG4gICAgd2hpbGUoY29ubmVjdGlvbikge1xuICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb24udGltZW91dCk7XG4gICAgICBjb25uZWN0aW9uID0gc2VsZi5fcG9vbC5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHNlbGYudGltZW91dFJlY29ubmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0UmVjb25uZWN0KTtcbiAgICAgIHNlbGYudGltZW91dFJlY29ubmVjdCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzZWxmLmdldExlbmd0aCgpID09PSAwKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZi5fZHJhaW5pbmdIYW5kbGVycyA9IHtcbiAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcDtcbn1cblxuXG5Qb29sLnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbi5ob3N0Kyc6Jyt0aGlzLm9wdGlvbnMuY29ubmVjdGlvbi5wb3J0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBQb29sO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG52YXIgRGVxdWV1ZSA9IHJlcXVpcmUoX19kaXJuYW1lKycvZGVxdWV1ZS5qcycpO1xudmFyIFBvb2wgPSByZXF1aXJlKF9fZGlybmFtZSsnL3Bvb2wuanMnKTtcbnZhciBoZWxwZXIgPSByZXF1aXJlKF9fZGlybmFtZSsnL2hlbHBlci5qcycpO1xudmFyIEVyciA9IHJlcXVpcmUoX19kaXJuYW1lKycvZXJyb3IuanMnKTtcbnZhciBVTktOT1dOX1BPT0xTID0gJ3Vua25vd25Qb29scyc7XG52YXIgU0VQQVJBVE9SID0gJ2ZlZWRTZXBhcmF0b3InO1xuZnVuY3Rpb24gUG9vbE1hc3RlcihyLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbGluZUxlbmd0aCA9IG9wdGlvbnMuYnVmZmVyIHx8IDUwO1xuXG4gIHNlbGYuX3IgPSByO1xuICBzZWxmLl9saW5lID0gbmV3IERlcXVldWUobGluZUxlbmd0aCk7XG4gIHNlbGYuX3Bvb2xzID0ge307XG4gIHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdID0gW107IC8vIHBvb2xzIGZvciB3aGljaCB3ZSBkbyBub3Qga25vdyB0aGUgc2VydmVyJ2lkXG4gIHNlbGYuX2hlYWx0aHlQb29scyA9IFtdO1xuICBzZWxmLl9oZWFsdGh5ID0gZmFsc2U7XG4gIHNlbGYuX2luaXQgPSBmYWxzZTtcbiAgc2VsZi5faW5kZXggPSAwOyAvLyBuZXh0IHBvb2wgdG8gdXNlZFxuICBzZWxmLl9pbmRleFVua25vd24gPSAgMCAvLyBuZXh0IHVua25vd24gcG9vbCB0byB1c2VkXG4gIHNlbGYuX2Rpc2NvdmVyeSA9ICh0eXBlb2Ygb3B0aW9ucy5kaXNjb3ZlcnkgPT09ICdib29sZWFuJykgPyBvcHRpb25zLmRpc2NvdmVyeTogZmFsc2U7IC8vIFdoZXRoZXIgdGhlIHBvb2wgbWFzdGVyIGlzIGluIGRpc2NvdmVyeSBtb2RlIG9yIG5vdFxuICAvL3NlbGYuX3JlZnJlc2ggPSAodHlwZW9mIG9wdGlvbnMucmVmcmVzaCA9PT0gJ251bWJlcicpID8gb3B0aW9ucy5yZWZyZXNoOiAxMDAwKjYwKjYwOyAvLyBSZWZyZXNoIHJhdGUgZm9yIHRoZSBsaXN0IG9mIHNlcnZlcnNcbiAgc2VsZi5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHNlbGYuX29wdGlvbnMuYnVmZmVyID0gb3B0aW9ucy5idWZmZXIgfHwgNTA7XG4gIHNlbGYuX29wdGlvbnMubWF4ID0gb3B0aW9ucy5tYXggfHwgMTAwMDtcbiAgc2VsZi5fbG9nID0gaGVscGVyLmNyZWF0ZUxvZ2dlcihzZWxmLCBvcHRpb25zLnNpbGVudCB8fCBmYWxzZSk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2cgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYub24oJ2xvZycsIG9wdGlvbnMubG9nKTtcbiAgfVxuICBzZWxmLl9kcmFpbmluZyA9IGZhbHNlO1xuICBzZWxmLl9udW1Db25uZWN0aW9ucyA9IDA7XG4gIHNlbGYuX251bUF2YWlsYWJsZUNvbm5lY3Rpb25zID0gMDtcbiAgc2VsZi5faGFzUHJpbnRXYXJuaW5nTG9jYWxob3N0ID0gZmFsc2U7XG4gIHNlbGYuX2ZlZWQgPSBudWxsO1xuICBzZWxmLl9jb25zZWN1dGl2ZUZhaWxzID0gLTE7XG4gIHNlbGYuX3RpbWVvdXRFcnJvciA9IG9wdGlvbnMudGltZW91dEVycm9yIHx8IDEwMDA7IC8vIEhvdyBsb25nIHNob3VsZCB3ZSB3YWl0IGJlZm9yZSByZWNyZWF0aW5nIGEgY29ubmVjdGlvbiB0aGF0IGZhaWxlZD9cbiAgc2VsZi5fbWF4RXhwb25lbnQgPSBvcHRpb25zLm1heEV4cG9uZW50IHx8IDY7IC8vIE1heGltdW0gdGltZW91dCBpcyAyXm1heEV4cG9uZW50KnRpbWVvdXRFcnJvclxuXG4gIC8vVE9ET1xuICAvL3NlbGYuX3VzaW5nUG9vbCA9IHRydWU7IC8vIElmIHdlIGhhdmUgdXNlZCB0aGUgcG9vbFxuICBzZWxmLl9zZWVkID0gMDtcblxuICB2YXIgcG9vbDtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5zZXJ2ZXJzKSkge1xuICAgIGlmIChvcHRpb25zLnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZi5fc2VydmVycyA9IG9wdGlvbnMuc2VydmVycztcbiAgICAgIGZvcih2YXIgaT0wOyBpPG9wdGlvbnMuc2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBzZWxmLmNyZWF0ZVBvb2xTZXR0aW5ncyhvcHRpb25zLCBvcHRpb25zLnNlcnZlcnNbaV0sIHNlbGYuX2xvZyk7XG4gICAgICAgIHBvb2wgPSBuZXcgUG9vbChzZWxmLl9yLCBzZXR0aW5ncyk7XG4gICAgICAgIHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdLnB1c2gocG9vbCk7XG4gICAgICAgIC8vIEEgcG9vbCBpcyBjb25zaWRlcmVkIGhlYWx0aHkgYnkgZGVmYXVsdCBzdWNoIHRoYXQgcGVvcGxlIGNhbiBkb1xuICAgICAgICAvLyB2YXIgPSByZXF1aXJlKC4uLikoKTsgcXVlcnkucnVuKCk7XG4gICAgICAgIHNlbGYuX2hlYWx0aHlQb29scy5wdXNoKHBvb2wpO1xuICAgICAgICBzZWxmLmVtaXRTdGF0dXMoKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnIuUmVxbERyaXZlckVycm9yKFwiSWYgYHNlcnZlcnNgIGlzIGFuIGFycmF5LCBpdCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHNlcnZlclwiKVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBzZWxmLl9zZXJ2ZXJzID0gW3tcbiAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdCB8fCAnbG9jYWxob3N0JyxcbiAgICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCAyODAxNVxuICAgIH1dXG4gICAgdmFyIHNldHRpbmdzID0gc2VsZi5jcmVhdGVQb29sU2V0dGluZ3Mob3B0aW9ucywge30sIHNlbGYuX2xvZyk7XG4gICAgcG9vbCA9IG5ldyBQb29sKHNlbGYuX3IsIHNldHRpbmdzKTtcbiAgICBzZWxmLl9wb29sc1tVTktOT1dOX1BPT0xTXS5wdXNoKHBvb2wpO1xuICAgIHNlbGYuX2hlYWx0aHlQb29scy5wdXNoKHBvb2wpO1xuICAgIHNlbGYuZW1pdFN0YXR1cygpXG4gIH1cblxuICAvLyBJbml0aWFsaXplIGFsbCB0aGUgcG9vbHMgLSBiaW5kIGxpc3RlbmVyc1xuICBmb3IodmFyIGk9MDsgaTxzZWxmLl9wb29sc1tVTktOT1dOX1BPT0xTXS5sZW5ndGg7IGkrKykge1xuICAgIHNlbGYuaW5pdFBvb2woc2VsZi5fcG9vbHNbVU5LTk9XTl9QT09MU11baV0pO1xuICB9XG4gIGlmICgoc2VsZi5fZGlzY292ZXJ5ID09PSB0cnVlKSkge1xuICAgIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxmLmZldGNoU2VydmVycygpIH0sIDApO1xuICB9XG59XG51dGlsLmluaGVyaXRzKFBvb2xNYXN0ZXIsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG5Qb29sTWFzdGVyLnByb3RvdHlwZS5nZXRQb29scyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGhlbHBlci5sb29wS2V5cyh0aGlzLl9wb29scywgZnVuY3Rpb24ocG9vbHMsIGtleSkge1xuICAgIGlmIChrZXkgPT09IFVOS05PV05fUE9PTFMpIHtcbiAgICAgIGZvcih2YXIgaT0wO2k8cG9vbHNba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChwb29sc1trZXldW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChwb29sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSZWplY3QgYWxsIHByb21pc2VzIGluIHRoaXMuX2xpbmVcblBvb2xNYXN0ZXIucHJvdG90eXBlLl9mbHVzaEVycm9ycyA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSh0aGlzLl9saW5lLmdldExlbmd0aCgpID4gMCkge1xuICAgIHRoaXMuX2xpbmUuc2hpZnQoKS5yZWplY3QobmV3IEVyci5SZXFsRHJpdmVyRXJyb3IoJ05vbmUgb2YgdGhlIHBvb2xzIGhhdmUgYW4gb3BlbmVkIGNvbm5lY3Rpb24gYW5kIGZhaWxlZCB0byBvcGVuIGEgbmV3IG9uZScpLnNldE9wZXJhdGlvbmFsKCkpO1xuICAgIHRoaXMuZW1pdCgncXVldWVpbmcnLCB0aGlzLl9saW5lLmdldExlbmd0aCgpKVxuICB9XG59XG5cblBvb2xNYXN0ZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBGaW5kIGEgcG9vbCB3aXRoIGF2YWlsYWJsZSBjb25uZWN0aW9uc1xuICB2YXIgcmVzdWx0O1xuICBmb3IodmFyIGk9MDsgaTxzZWxmLl9oZWFsdGh5UG9vbHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2VsZi5faW5kZXggPj0gc2VsZi5faGVhbHRoeVBvb2xzLmxlbmd0aCkge1xuICAgICAgc2VsZi5faW5kZXggPSAwO1xuICAgIH1cbiAgICBpZiAoc2VsZi5faGVhbHRoeVBvb2xzW3NlbGYuX2luZGV4XS5nZXRBdmFpbGFibGVMZW5ndGgoKSA+IDApIHtcbiAgICAgIHJlc3VsdCA9IHNlbGYuX2hlYWx0aHlQb29sc1tzZWxmLl9pbmRleF0uZ2V0Q29ubmVjdGlvbigpO1xuICAgIH1cbiAgICBzZWxmLl9pbmRleCsrO1xuICAgIGlmIChzZWxmLl9pbmRleCA9PT0gc2VsZi5faGVhbHRoeVBvb2xzLmxlbmd0aCkge1xuICAgICAgc2VsZi5faW5kZXggPSAwO1xuICAgIH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBpZiAoc2VsZi5faGVhbHRoeVBvb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyLlJlcWxEcml2ZXJFcnJvcignTm9uZSBvZiB0aGUgcG9vbHMgaGF2ZSBhbiBvcGVuZWQgY29ubmVjdGlvbiBhbmQgZmFpbGVkIHRvIG9wZW4gYSBuZXcgb25lJykuc2V0T3BlcmF0aW9uYWwoKSk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gQWxsIHBvb2wgYXJlIGJ1c3ksIGJ1ZmZlciB0aGUgcmVxdWVzdFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNlbGYuX2xpbmUucHVzaCh7XG4gICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5lbWl0KCdxdWV1ZWluZycsIHNlbGYuX2xpbmUuZ2V0TGVuZ3RoKCkpXG4gICAgICAvLyBXZSBjb3VsZCBhZGQgYSBjb25kaXRpb24gdG8gYmUgbGVzcyBncmVlZHkgKGZvciBlYXJseSBzdGFydClcbiAgICAgIHNlbGYuX2V4cGFuZEFsbCgpO1xuICAgIH0pO1xuXG4gIH1cbn1cblBvb2xNYXN0ZXIucHJvdG90eXBlLl9leHBhbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpPTA7IGk8dGhpcy5faGVhbHRoeVBvb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5faGVhbHRoeVBvb2xzW2ldLl9leHBhbmRCdWZmZXIoKTtcbiAgfVxufVxuXG4vLyBGZXRjaCBhbGwgdGhlIHNlcnZlcnMgb25jZVxuUG9vbE1hc3Rlci5wcm90b3R5cGUuaGFuZGxlQWxsU2VydmVyc1Jlc3BvbnNlID0gZnVuY3Rpb24oc2VydmVycykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9kcmFpbmluZyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBGaWxsIGFsbCB0aGUga25vd24gc2VydmVyIGZyb20gUmV0aGlua0RCXG4gIHZhciBrbm93blNlcnZlciA9IHt9O1xuICBmb3IodmFyIGk9MDsgaTxzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlcnZlciA9IHNlcnZlcnNbaV07XG4gICAga25vd25TZXJ2ZXJbc2VydmVyLmlkXSA9IHtjb3VudDogMCwgc2VydmVyOiBzZXJ2ZXJ9O1xuICAgIGlmIChzZWxmLl9wb29sc1tzZXJ2ZXIuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFdlIHBvdGVudGlhbGx5IGhhdmUgYSBuZXcgc2VydmVyIGluIHRoZSBjbHVzdGVyLCBvciB3ZSBhbHJlYWR5IGhhdmUgYSBwb29sIGZvciB0aGlzIHNlcnZlclxuICAgICAgLy8gaW4gb25lIG9mIHRoZSBVTktOT1dOX1BPT0xTXG4gICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgIGZvcih2YXIgaj0wOyBqPHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChmb3VuZCkgYnJlYWs7XG4gICAgICAgIHZhciBwb29sID0gc2VsZi5fcG9vbHNbVU5LTk9XTl9QT09MU11bal07IFxuICAgICAgICAvLyBJZiBhIHBvb2wgaXMgY3JlYXRlZCB3aXRoIGxvY2FsaG9zdCwgaXQgd2lsbCBwcm9iYWJseSBtYXRjaCB0aGUgZmlyc3Qgc2VydmVyIGV2ZW4gdGhvdWdoIGl0IG1heSBub3QgdGhlIHRoZSBvbmVcbiAgICAgICAgLy8gU28gaXQgZ2V0cyBhbiBpZFxuICAgICAgICBmb3IodmFyIGs9MDsgazxzZXJ2ZXIubmV0d29yay5jYW5vbmljYWxfYWRkcmVzc2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzYW1lIGhvc3QgKG9yIGlmIHRoZXkgYXJlIGJvdGggbG9jYWxob3N0KSBhbmQgcG9ydFxuICAgICAgICAgIGlmICgoKHNlcnZlci5uZXR3b3JrLmNhbm9uaWNhbF9hZGRyZXNzZXNba10uaG9zdCA9PT0gcG9vbC5vcHRpb25zLmNvbm5lY3Rpb24uaG9zdCkgfHxcbiAgICAgICAgICAgICAgIChzZXJ2ZXIubmV0d29yay5ob3N0bmFtZSA9PT0gcG9vbC5vcHRpb25zLmNvbm5lY3Rpb24uaG9zdCkgfHxcbiAgICAgICAgICAgIChoZWxwZXIubG9jYWxob3N0QWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShzZXJ2ZXIubmV0d29yay5jYW5vbmljYWxfYWRkcmVzc2VzW2tdLmhvc3QpICYmXG4gICAgICAgICAgICBoZWxwZXIubG9jYWxob3N0QWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShwb29sLm9wdGlvbnMuY29ubmVjdGlvbi5ob3N0KSkpICYmXG4gICAgICAgICAgICAoc2VydmVyLm5ldHdvcmsucmVxbF9wb3J0ID09PSBwb29sLm9wdGlvbnMuY29ubmVjdGlvbi5wb3J0KSkge1xuXG4gICAgICAgICAgICBzZWxmLl9wb29sc1tzZXJ2ZXIuaWRdID0gc2VsZi5fcG9vbHNbVU5LTk9XTl9QT09MU10uc3BsaWNlKGosIDEpWzBdO1xuICAgICAgICAgICAgLy8gV2UgbWF5IGFzc2lnbiB0aGUgd3JvbmcgcG9vbCB0byB0aGlzIHNlcnZlciBpZiBpdCdzIG1hY2hpbmcgb24gbG9jYWxob3N0XG4gICAgICAgICAgICBpZiAoaGVscGVyLmxvY2FsaG9zdEFsaWFzZXMuaGFzT3duUHJvcGVydHkoc2VydmVyLm5ldHdvcmsuY2Fub25pY2FsX2FkZHJlc3Nlc1trXS5ob3N0KSkge1xuICAgICAgICAgICAgICBzZWxmLl9wb29sc1tzZXJ2ZXIuaWRdLm9wdGlvbnMuY29ubmVjdGlvbi5ob3N0ID0gaGVscGVyLmdldENhbm9uaWNhbEFkZHJlc3Moc2VydmVyLm5ldHdvcmsuY2Fub25pY2FsX2FkZHJlc3NlcykuaG9zdDtcbiAgICAgICAgICAgICAgc2VsZi5fcG9vbHNbc2VydmVyLmlkXS5kcmFpbkxvY2FsaG9zdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFdlIGp1c3QgZm91bmQgYSBuZXcgc2VydmVyLCBsZXQncyBleHRyYWN0IHRoZSBjYW5vbmljYWwgYWRkcmVzcyBhbmQgY29ubmVjdCB0byBpdFxuICAgICAgICBzZWxmLmNyZWF0ZVBvb2woc2VydmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gRWFjaCBzZXJ2ZXIga25vdyBoYXMgYSBwb29sXG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byByZW1vdmUgcG9vbHNcbiAgaGVscGVyLmxvb3BLZXlzKHNlbGYuX3Bvb2xzLCBmdW5jdGlvbihwb29scywga2V5KSB7IC8vIGFtb25nIHRoZSBwb29scyB3aXRoIGEgc2VydmVyIGlkXG4gICAgaWYgKGtleSAhPT0gVU5LTk9XTl9QT09MUykge1xuICAgICAgaWYgKGtub3duU2VydmVyLmhhc093blByb3BlcnR5KGtleSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGYuZGVsZXRlUG9vbChrZXkpOyAvLyBXZSBqdXN0IGZvdW5kIGEgcG9vbCB0aGF0IGRvZXNuJ3QgbWFwIHRvIGFueSBrbm93biBSZXRoaW5rREIgc2VydmVyXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAga25vd25TZXJ2ZXJba2V5XS5jb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGZvcih2YXIgaT0wO2k8c2VsZi5fcG9vbHNbVU5LTk9XTl9QT09MU10ubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBUaGVzZSBwb29scyBkb2VzIG5vdCBtYXRjaCBhbnkgc2VydmVyIHJldHVybmVkIGJ5IFJldGhpbmtEQi5cbiAgICB2YXIgcG9vbCA9IHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdLnNwbGljZShpLCAxKVswXTtcbiAgICBzZWxmLl9sb2coJ1JlbW92aW5nIHBvb2wgY29ubmVjdGVkIHRvOiAnK3Bvb2wuZ2V0QWRkcmVzcygpKVxuICAgIHBvb2wuZHJhaW4oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcG9vbC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZi5fbG9nKCdQb29sIGNvbm5lY3RlZCB0bzogJytzZWxmLl9wb29sc1tVTktOT1dOX1BPT0xTXVtpXS5nZXRBZGRyZXNzKCkrJyBjb3VsZCBub3QgYmUgcHJvcGVybHkgZHJhaW5lZC4nKVxuICAgICAgc2VsZi5fbG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgc2VsZi5fbG9nKGVycm9yLnN0YWNrKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgdGhlIHNldHRpbmdzIGZvciBhIGdpdmVuIHBvb2wuIE1lcmdlIHRoZSBnbG9iYWwgb3B0aW9ucyArIHRoZSBzZXJ2ZXJzJ3Mgb25lLlxuUG9vbE1hc3Rlci5wcm90b3R5cGUuY3JlYXRlUG9vbFNldHRpbmdzID0gZnVuY3Rpb24oZ2xvYmFsT3B0aW9ucywgc2VydmVyT3B0aW9ucywgbG9nKSB7XG4gIHZhciBzZXR0aW5ncyA9IHt9O1xuICB2YXIgbnVtU2VydmVycyA9IEFycmF5LmlzQXJyYXkoZ2xvYmFsT3B0aW9ucy5zZXJ2ZXJzKSA/IGdsb2JhbE9wdGlvbnMuc2VydmVycy5sZW5ndGg6IDE7XG4gIGhlbHBlci5sb29wS2V5cyhnbG9iYWxPcHRpb25zLCBmdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcbiAgICBpZiAoKGtleSA9PT0gJ2J1ZmZlcicpIHx8IChrZXkgPT09ICdtYXgnKSkge1xuICAgICAgc2V0dGluZ3Nba2V5XSA9IE1hdGguY2VpbChvcHRpb25zW2tleV0vbnVtU2VydmVycyk7XG4gICAgICBzZXR0aW5nc1trZXldID0gTWF0aC5jZWlsKG9wdGlvbnNba2V5XS9udW1TZXJ2ZXJzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ICE9PSAnc2VydmVycycpIHtcbiAgICAgIHNldHRpbmdzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9KTtcbiAgaWYgKHNlcnZlck9wdGlvbnMpIHtcbiAgICBoZWxwZXIubG9vcEtleXMoc2VydmVyT3B0aW9ucywgZnVuY3Rpb24ob3B0aW9ucywga2V5KSB7XG4gICAgICBzZXR0aW5nc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH0pO1xuICB9XG4gIHNldHRpbmdzLl9sb2cgPSBsb2c7XG4gIHJldHVybiBzZXR0aW5ncztcbn1cblxuLy8gQ3JlYXRlIGEgbmV3IHBvb2xcblBvb2xNYXN0ZXIucHJvdG90eXBlLmNyZWF0ZVBvb2wgPSBmdW5jdGlvbihzZXJ2ZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYWRkcmVzcyA9IGhlbHBlci5nZXRDYW5vbmljYWxBZGRyZXNzKHNlcnZlci5uZXR3b3JrLmNhbm9uaWNhbF9hZGRyZXNzZXMpO1xuICB2YXIgc2V0dGluZ3MgPSBzZWxmLmNyZWF0ZVBvb2xTZXR0aW5ncyhzZWxmLl9vcHRpb25zLCB7XG4gICAgcG9ydDogc2VydmVyLm5ldHdvcmsucmVxbF9wb3J0LFxuICAgIGhvc3Q6IGFkZHJlc3MuaG9zdFxuICB9LCBzZWxmLl9sb2cpO1xuICB2YXIgcG9vbCA9IG5ldyBQb29sKHNlbGYuX3IsIHNldHRpbmdzKTtcbiAgc2VsZi5fcG9vbHNbc2VydmVyLmlkXSA9IHBvb2xcbiAgc2VsZi5pbml0UG9vbChwb29sKTtcbiAgc2VsZi5faGVhbHRoeVBvb2xzLnB1c2gocG9vbCk7XG4gIHNlbGYuZW1pdFN0YXR1cygpXG4gIHNlbGYucmVzZXRCdWZmZXJQYXJhbWV0ZXJzKCk7XG59XG5cbi8vIERlbGV0ZSBhIGtub3duIHBvb2xcblBvb2xNYXN0ZXIucHJvdG90eXBlLmRlbGV0ZVBvb2wgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9vbCA9IHNlbGYuX3Bvb2xzW2tleV07XG4gIHNlbGYuX2xvZygnUmVtb3ZpbmcgcG9vbCBjb25uZWN0ZWQgdG86ICcrcG9vbC5nZXRBZGRyZXNzKCkpXG4gIHBvb2wuZHJhaW4oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHBvb2wucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0pLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fbG9nKCdQb29sIGNvbm5lY3RlZCB0bzogJytzZWxmLl9wb29sc1trZXldLmdldEFkZHJlc3MoKSsnIGNvdWxkIG5vdCBiZSBwcm9wZXJseSBkcmFpbmVkLicpXG4gICAgc2VsZi5fbG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgIHNlbGYuX2xvZyhlcnJvci5zdGFjayk7XG4gIH0pO1xuICBkZWxldGUgc2VsZi5fcG9vbHNba2V5XTtcbiAgc2VsZi5yZXNldEJ1ZmZlclBhcmFtZXRlcnMoKTtcbn1cblxuLy8gIENyZWF0ZSB0aGUgZmVlZCBvbiBzZXJ2ZXJfc3RhdHVzIGFuZCBiaW5kIHRoZSBsaXN0ZW5lciB0byB0aGUgZmVlZFxuUG9vbE1hc3Rlci5wcm90b3R5cGUuZmV0Y2hTZXJ2ZXJzID0gZnVuY3Rpb24odXNlU2VlZHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcXVlcnkgPSBzZWxmLl9yLmRiKCdyZXRoaW5rZGInKS50YWJsZSgnc2VydmVyX3N0YXR1cycpXG4gICAgICAudW5pb24oW1NFUEFSQVRPUl0pXG4gICAgICAudW5pb24oc2VsZi5fci5kYigncmV0aGlua2RiJykudGFibGUoJ3NlcnZlcl9zdGF0dXMnKS5jaGFuZ2VzKCkpXG4gIC8vIEluIGNhc2UgdXNlU2VlZHMgaXMgdHJ1ZSwgd2Ugcm90YXRlIHRocm91Z2ggYWxsIHRoZSBzZWVkcyArIHRoZSBwb29sIG1hc3RlclxuICBpZiAoIXVzZVNlZWRzIHx8IHNlbGYuX3NlZWQgPT09IHNlbGYuX3NlcnZlcnMubGVuZ3RoKSB7XG4gICAgaWYgKHVzZVNlZWRzICYmIHNlbGYuX3NlZWQgPT09IHNlbGYuX3NlcnZlcnMubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBpbmNyZWFzZSB0aGUgYmFjayBvZmYgb25seSB3aGVuIHdlIHdlbnQgdGhyb3VnaCBhbGwgdGhlIHNlZWRzXG4gICAgICBzZWxmLl9jb25zZWN1dGl2ZUZhaWxzKys7XG4gICAgfVxuXG4gICAgc2VsZi5fc2VlZCA9IDA7XG4gICAgdmFyIHByb21pc2UgPSBxdWVyeS5ydW4oe2N1cnNvcjogdHJ1ZX0pXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHNldHRpbmdzID0gc2VsZi5fc2VydmVyc1tzZWxmLl9zZWVkXTtcbiAgICBzZWxmLl9zZWVkKys7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLl9yLmNvbm5lY3Qoc2V0dGluZ3MpLnRoZW4oZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuIHF1ZXJ5LnJ1bihjb25uZWN0aW9uLCB7Y3Vyc29yOiB0cnVlfSlcbiAgICB9KTtcbiAgfVxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZmVlZCkge1xuICAgIGlmIChzZWxmLl9kcmFpbmluZyA9PT0gdHJ1ZSkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjbG9zZSB0aGUgZmVlZCBoZXJlIGFzIHdlJ2xsIGNsb3NlIHRoZSBjb25uZWN0aW9uc1xuICAgICAgcmV0dXJuIGZlZWQuY2xvc2UoKTtcbiAgICB9XG4gICAgc2VsZi5fZmVlZCA9IGZlZWQ7XG4gICAgdmFyIGluaXRpYWxpemluZyA9IHRydWU7XG4gICAgdmFyIHNlcnZlcnMgPSBbXTtcbiAgICBmZWVkLmVhY2goZnVuY3Rpb24oZXJyLCBjaGFuZ2UpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5fbG9nKCdUaGUgY2hhbmdlZmVlZCBvbiBzZXJ2ZXJfc3RhdHVzIHJldHVybmVkIGFuIGVycm9yOiAnK2Vyci50b1N0cmluZygpKTtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byByZWZldGNoIGV2ZXJ5dGhpbmcgYXMgdGhlIHNlcnZlciB0aGF0IHdhcyBzZXJ2aW5nIHRoZSBmZWVkIG1heVxuICAgICAgICAvLyBoYXZlIGRpZWQuXG4gICAgICAgIGlmICghc2VsZi5fZHJhaW5pbmcpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5mZXRjaFNlcnZlcnMoKTtcbiAgICAgICAgICB9LCAwKTsgLy8gR2l2ZSBhIHRpbWVvdXQgdG8gbGV0IHRoZSBkcml2ZXIgY2xlYW4gdGhlIHBvb2xzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGluaXRpYWxpemluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoY2hhbmdlID09PSBTRVBBUkFUT1IpIHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmhhbmRsZUFsbFNlcnZlcnNSZXNwb25zZShzZXJ2ZXJzKTtcbiAgICAgICAgICAvLyBSZXJ1biB0aGUgd2hvbGUgcXVlcnkgYWZ0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgYSBjaGFuZ2UgZGlkIG5vdCBza2lwL3NuZWFrIGJldHdlZW4gdGhlIHVuaW9uLiBBcyBsb25nXG4gICAgICAgICAgLy8gYXMgUmV0aGlua0RCIGRvZXMgbm90IHByb3ZpZGUgaW5pdGlhbCByZXN1bHRzXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX3IuZGIoJ3JldGhpbmtkYicpLnRhYmxlKCdzZXJ2ZXJfc3RhdHVzJykucnVuKHtjdXJzb3I6IGZhbHNlfSkudGhlbihmdW5jdGlvbihzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgIHNlbGYuaGFuZGxlQWxsU2VydmVyc1Jlc3BvbnNlKHNlcnZlcnMpO1xuICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgc2VsZi5fbG9nKCdGYWlsIHRvIHJldHJpZXZlIGEgc2Vjb25kIGNvcHkgb2Ygc2VydmVyX3N0YXR1cycpO1xuICAgICAgICAgICAgICAvL1RPRE8gUmV0cnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlcnZlcnMucHVzaChjaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZS5uZXdfdmFsICE9PSBudWxsICYmIGNoYW5nZS5vbGRfdmFsID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5ldyBzZXJ2ZXJcbiAgICAgICAgc2VsZi5jcmVhdGVQb29sKGNoYW5nZS5uZXdfdmFsKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNoYW5nZS5uZXdfdmFsID09PSBudWxsICYmIGNoYW5nZS5vbGRfdmFsICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEEgc2VydmVyIHdhcyByZW1vdmVkXG4gICAgICAgIHZhciBzZXJ2ZXIgPSBjaGFuZ2Uub2xkX3ZhbDtcbiAgICAgICAgaWYgKHNlbGYuX3Bvb2xzW3NlcnZlci5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgIHNlbGYuZGVsZXRlUG9vbChzZXJ2ZXIuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKChzZXJ2ZXIubmV0d29yay5jYW5vbmljYWxfYWRkcmVzc2VzW2tdLmhvc3QgPT09IHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdW2ldLm9wdGlvbnMuY29ubmVjdGlvbi5ob3N0KSB8fFxuICAgICAgICAgICAgICAoaGVscGVyLmxvY2FsaG9zdEFsaWFzZXMuaGFzT3duUHJvcGVydHkoc2VydmVyLm5ldHdvcmsuY2Fub25pY2FsX2FkZHJlc3Nlc1trXS5ob3N0KSAmJiAoaGVscGVyLmxvY2FsaG9zdEFsaWFzZXMuaGFzT3duUHJvcGVydHkoc2VsZi5fcG9vbHNbVU5LTk9XTl9QT09MU11baV0ub3B0aW9ucy5jb25uZWN0aW9uLmhvc3QpKSkpICYmXG4gICAgICAgICAgICAgIChzZXJ2ZXIubmV0d29yay5yZXFsX3BvcnQgPT09IHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdW2ldLm9wdGlvbnMuY29ubmVjdGlvbi5wb3J0KSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgKGZ1bmN0aW9uIChwb29sKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fbG9nKCdSZW1vdmluZyBwb29sIGNvbm5lY3RlZCB0bzogJytwb29sLmdldEFkZHJlc3MoKSlcbiAgICAgICAgICAgICAgICB2YXIgcG9vbCA9IHNlbGYuX3Bvb2xzW1VOS05PV05fUE9PTFNdLnNwbGljZShpLCAxKVswXTtcbiAgICAgICAgICAgICAgICBwb29sLmRyYWluKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHBvb2wucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9vcHRpb25zLnNpbGVudCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2coJ1Bvb2wgY29ubmVjdGVkIHRvOiAnK3Bvb2wuZ2V0QWRkcmVzcygpKycgY291bGQgbm90IGJlIHByb3Blcmx5IGRyYWluZWQuJylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2coZXJyb3Iuc3RhY2spO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KShzZWxmLl9wb29sc1tVTktOT1dOX1BPT0xTXVtpXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi5fbG9nKCdBIHNlcnZlciB3YXMgcmVtb3ZlZCBidXQgbm8gcG9vbCBmb3IgdGhpcyBzZXJ2ZXIgZXhpc3RzLi4uJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgaWdub3JlIHRoaXMgY2hhbmdlIHNpbmNlIHRoaXMgaXQgZG9lc24ndCBhZmZlY3Qgd2hldGhlciB0aGUgc2VydmVyXG4gICAgICAvLyBpcyBhdmFpbGFibGUgb3Igbm90LlxuICAgICAgLy8gZWxzZSBpZiAoY2hhbmdlLm5ld192YWwgIT09IG51bGwgJiYgY2hhbmdlLm9sZF92YWwgIT09IG51bGwpIHt9XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fbG9nKCdDb3VsZCBub3QgcmV0cmlldmUgdGhlIGRhdGEgZnJvbSBzZXJ2ZXJfc3RhdHVzOiAnK0pTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgXG4gICAgdmFyIHRpbWVvdXQ7XG4gICAgaWYgKHNlbGYuX2NvbnNlY3V0aXZlRmFpbHMgPT09IC0xKSB7XG4gICAgICB0aW1lb3V0ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gKDE8PE1hdGgubWluKHNlbGYuX21heEV4cG9uZW50LCBzZWxmLl9jb25zZWN1dGl2ZUZhaWxzKSkqc2VsZi5fdGltZW91dEVycm9yO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5mZXRjaFNlcnZlcnModHJ1ZSk7XG4gICAgfSwgdGltZW91dCk7XG4gIH0pO1xufVxuXG4vLyBCaW5kIGxpc3RlbmVycyBvbiB0aGUgcG9vbHNcblBvb2xNYXN0ZXIucHJvdG90eXBlLmluaXRQb29sID0gZnVuY3Rpb24ocG9vbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcG9vbC5vbignc2l6ZS1kaWZmJywgZnVuY3Rpb24oZGlmZikge1xuICAgIHNlbGYuX251bUNvbm5lY3Rpb25zICs9IGRpZmY7XG4gICAgc2VsZi5lbWl0KCdzaXplJywgc2VsZi5fbnVtQ29ubmVjdGlvbnMpXG4gIH0pO1xuICBwb29sLm9uKCdhdmFpbGFibGUtc2l6ZS1kaWZmJywgZnVuY3Rpb24oZGlmZikge1xuICAgIHNlbGYuX251bUF2YWlsYWJsZUNvbm5lY3Rpb25zICs9IGRpZmY7XG4gICAgc2VsZi5lbWl0KCdhdmFpbGFibGUtc2l6ZScsIHNlbGYuX251bUF2YWlsYWJsZUNvbm5lY3Rpb25zKVxuICB9KTtcblxuICBwb29sLm9uKCduZXctY29ubmVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLl9saW5lLmdldExlbmd0aCgpID4gMCkge1xuICAgICAgdmFyIHAgPSBzZWxmLl9saW5lLnNoaWZ0KCk7XG4gICAgICB0aGlzLmdldENvbm5lY3Rpb24oKS50aGVuKHAucmVzb2x2ZSkuZXJyb3IocC5yZWplY3QpO1xuICAgICAgc2VsZi5lbWl0KCdxdWV1ZWluZycsIHNlbGYuX2xpbmUuZ2V0TGVuZ3RoKCkpXG4gICAgfVxuICB9KTtcbiAgcG9vbC5vbignbm90LWVtcHR5JywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuX2RyYWluaW5nID09PSBmYWxzZSkge1xuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICBmb3IodmFyIGk9MDsgaTxzZWxmLl9oZWFsdGh5UG9vbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX2hlYWx0aHlQb29sc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgIHNlbGYuX2hlYWx0aHlQb29scy5sZW5ndGg7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQgPT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGYuX2hlYWx0aHlQb29scy5wdXNoKHRoaXMpO1xuICAgICAgICBzZWxmLmVtaXRTdGF0dXMoKVxuICAgICAgICBzZWxmLnJlc2V0QnVmZmVyUGFyYW1ldGVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHBvb2wub24oJ2VtcHR5JywgZnVuY3Rpb24oKSB7XG4gICAgLy8gQSBwb29sIHRoYXQgYmVjb21lIGVtcHR5IGlzIGNvbnNpZGVyZWQgdW5oZWFsdGh5XG4gICAgZm9yKHZhciBpPTA7IGk8c2VsZi5faGVhbHRoeVBvb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc2VsZi5faGVhbHRoeVBvb2xzW2ldID09PSB0aGlzKSB7XG4gICAgICAgIHNlbGYuX2hlYWx0aHlQb29scy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHNlbGYuZW1pdFN0YXR1cygpXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZi5faGVhbHRoeVBvb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fZmx1c2hFcnJvcnMoKTtcbiAgICB9XG5cbiAgICBzZWxmLnJlc2V0QnVmZmVyUGFyYW1ldGVycygpO1xuICB9KTtcbiAgcG9vbC5vbignZHJhaW5pbmcnLCBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIGk9MDsgaTxzZWxmLl9oZWFsdGh5UG9vbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWxmLl9oZWFsdGh5UG9vbHNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgc2VsZi5faGVhbHRoeVBvb2xzLnNwbGljZShpLCAxKTtcbiAgICAgICAgc2VsZi5lbWl0U3RhdHVzKClcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2hlYWx0aHlQb29scyA9PT0gMCkge1xuICAgICAgc2VsZi5fZmx1c2hFcnJvcnMoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5Qb29sTWFzdGVyLnByb3RvdHlwZS5nZXROdW1Db25uZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VtID0gMDtcbiAgZm9yKHZhciBpPTA7IGk8dGhpcy5faGVhbHRoeVBvb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtICs9IHRoaXMuX2hlYWx0aHlQb29sc1tpXS5nZXRMZW5ndGgoKTtcbiAgfVxuICByZXR1cm4gc3VtO1xufVxuUG9vbE1hc3Rlci5wcm90b3R5cGUuZ2V0TnVtQXZhaWxhYmxlQ29ubmVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1bSA9IDA7XG4gIGZvcih2YXIgaT0wOyBpPHRoaXMuX2hlYWx0aHlQb29scy5sZW5ndGg7IGkrKykge1xuICAgIHN1bSArPSB0aGlzLl9oZWFsdGh5UG9vbHNbaV0uZ2V0QXZhaWxhYmxlTGVuZ3RoKCk7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuLy8gUmVzZXQgYnVmZmVyIGFuZCBtYXggZm9yIGVhY2ggcG9vbFxuUG9vbE1hc3Rlci5wcm90b3R5cGUucmVzZXRCdWZmZXJQYXJhbWV0ZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtYXggPSBNYXRoLmZsb29yKHRoaXMuX29wdGlvbnMubWF4L3RoaXMuX2hlYWx0aHlQb29scy5sZW5ndGgpXG4gIHZhciBidWZmZXIgPSBNYXRoLmZsb29yKHRoaXMuX29wdGlvbnMuYnVmZmVyL3RoaXMuX2hlYWx0aHlQb29scy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPHRoaXMuX2hlYWx0aHlQb29scy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLl9oZWFsdGh5UG9vbHNbaV0uZ2V0TGVuZ3RoKCkgPiBtYXgpIHtcbiAgICAgIHRoaXMuX2hlYWx0aHlQb29sc1tpXS5fZXh0cmFDb25uZWN0aW9ucyA9IHRoaXMuX2hlYWx0aHlQb29sc1tpXS5nZXRMZW5ndGgoKS1tYXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5faGVhbHRoeVBvb2xzW2ldLl9leHRyYUNvbm5lY3Rpb25zID0gMDtcbiAgICB9XG4gICAgdGhpcy5faGVhbHRoeVBvb2xzW2ldLm9wdGlvbnMubWF4ID0gbWF4XG4gICAgdGhpcy5faGVhbHRoeVBvb2xzW2ldLm9wdGlvbnMuYnVmZmVyID0gYnVmZmVyO1xuICB9XG59XG5cblBvb2xNYXN0ZXIucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbnVtQ29ubmVjdGlvbnM7XG59XG5Qb29sTWFzdGVyLnByb3RvdHlwZS5nZXRBdmFpbGFibGVMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX251bUF2YWlsYWJsZUNvbm5lY3Rpb25zO1xufVxuXG5Qb29sTWFzdGVyLnByb3RvdHlwZS5kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2RyYWluaW5nJyk7XG4gIGlmICh0aGlzLl9kaXNjb3ZlcnkgPT09IHRydWUpIHtcbiAgICB0aGlzLl9kaXNjb3ZlcnkgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fZmVlZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9mZWVkLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX2RyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIHByb21pc2VzID0gW107XG4gIHZhciBwb29scyA9IHRoaXMuZ2V0UG9vbHMoKTtcbiAgZm9yKHZhciBpPTA7IGk8cG9vbHMubGVuZ3RoOyBpKyspIHtcbiAgICBwcm9taXNlcy5wdXNoKHBvb2xzW2ldLmRyYWluKCkpO1xuICB9XG4gIHRoaXMuX2hlYWx0aHlQb29scyA9IFtdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIGk9MDsgaTxwb29scy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9vbHNbaV0ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChzZWxmLl9vcHRpb25zLnNpbGVudCAhPT0gdHJ1ZSkge1xuICAgICAgc2VsZi5fbG9nKCdGYWlsZWQgdG8gZHJhaW4gYWxsIHRoZSBwb29sczonKTtcbiAgICAgIHNlbGYuX2xvZyhlcnJvci5tZXNzYWdlKTtcbiAgICAgIHNlbGYuX2xvZyhlcnJvci5zdGFjayk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gRW1pdCB0aGUgaGVhbHRoeSBldmVudCB3aXRoIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBvb2wgbWFzdGVyXG4vLyBpcyBoZWFsdGh5IG9yIG5vdFxuUG9vbE1hc3Rlci5wcm90b3R5cGUuZW1pdFN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGVhbHRoeSA9IHRoaXMuX2hlYWx0aHlQb29scy5sZW5ndGggIT09IDA7XG4gIGlmICh0aGlzLl9oZWFsdGh5ICE9PSBoZWFsdGh5KSB7XG4gICAgdGhpcy5faGVhbHRoeSA9IGhlYWx0aHk7XG4gICAgdGhpcy5lbWl0KCdoZWFsdGh5JywgaGVhbHRoeSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xNYXN0ZXI7XG4iLCIvLyBETyBOT1QgRURJVFxuLy8gQXV0b2dlbmVyYXRlZCBieSBjb252ZXJ0X3Byb3RvZmlsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0VmVyc2lvbkR1bW15OiB7XG5cdFx0VmVyc2lvbjoge1xuXHRcdFx0VjBfMTogMTA2MzM2OTI3MCxcblx0XHRcdFYwXzI6IDE5MTU3ODE2MDEsXG5cdFx0XHRWMF8zOiAxNjAxNTYyNjg2LFxuXHRcdFx0VjBfNDogMTA3NDUzOTgwOCxcblx0XHRcdFYxXzA6IDg4NTE3Nzc5NVxuXHRcdH0sXG5cdFx0XG5cdFx0UHJvdG9jb2w6IHtcblx0XHRcdFBST1RPQlVGOiA2NTY0MDc2MTcsXG5cdFx0XHRKU09OOiAyMTIwODM5MzY3XG5cdFx0fVxuXHR9LFxuXHRcblx0UXVlcnk6IHtcblx0XHRRdWVyeVR5cGU6IHtcblx0XHRcdFNUQVJUOiAxLFxuXHRcdFx0Q09OVElOVUU6IDIsXG5cdFx0XHRTVE9QOiAzLFxuXHRcdFx0Tk9SRVBMWV9XQUlUOiA0LFxuXHRcdFx0U0VSVkVSX0lORk86IDVcblx0XHR9LFxuXHRcdFxuXHRcdEFzc29jUGFpcjoge31cblx0fSxcblx0XG5cdEZyYW1lOiB7XG5cdFx0RnJhbWVUeXBlOiB7XG5cdFx0XHRQT1M6IDEsXG5cdFx0XHRPUFQ6IDJcblx0XHR9XG5cdH0sXG5cdFxuXHRCYWNrdHJhY2U6IHt9LFxuXHRcblx0UmVzcG9uc2U6IHtcblx0XHRSZXNwb25zZVR5cGU6IHtcblx0XHRcdFNVQ0NFU1NfQVRPTTogMSxcblx0XHRcdFNVQ0NFU1NfU0VRVUVOQ0U6IDIsXG5cdFx0XHRTVUNDRVNTX1BBUlRJQUw6IDMsXG5cdFx0XHRXQUlUX0NPTVBMRVRFOiA0LFxuXHRcdFx0U0VSVkVSX0lORk86IDUsXG5cdFx0XHRDTElFTlRfRVJST1I6IDE2LFxuXHRcdFx0Q09NUElMRV9FUlJPUjogMTcsXG5cdFx0XHRSVU5USU1FX0VSUk9SOiAxOFxuXHRcdH0sXG5cdFx0XG5cdFx0RXJyb3JUeXBlOiB7XG5cdFx0XHRJTlRFUk5BTDogMTAwMDAwMCxcblx0XHRcdFJFU09VUkNFX0xJTUlUOiAyMDAwMDAwLFxuXHRcdFx0UVVFUllfTE9HSUM6IDMwMDAwMDAsXG5cdFx0XHROT05fRVhJU1RFTkNFOiAzMTAwMDAwLFxuXHRcdFx0T1BfRkFJTEVEOiA0MTAwMDAwLFxuXHRcdFx0T1BfSU5ERVRFUk1JTkFURTogNDIwMDAwMCxcblx0XHRcdFVTRVI6IDUwMDAwMDAsXG5cdFx0XHRQRVJNSVNTSU9OX0VSUk9SOiA2MDAwMDAwXG5cdFx0fSxcblx0XHRcblx0XHRSZXNwb25zZU5vdGU6IHtcblx0XHRcdFNFUVVFTkNFX0ZFRUQ6IDEsXG5cdFx0XHRBVE9NX0ZFRUQ6IDIsXG5cdFx0XHRPUkRFUl9CWV9MSU1JVF9GRUVEOiAzLFxuXHRcdFx0VU5JT05FRF9GRUVEOiA0LFxuXHRcdFx0SU5DTFVERVNfU1RBVEVTOiA1XG5cdFx0fVxuXHR9LFxuXHRcblx0RGF0dW06IHtcblx0XHREYXR1bVR5cGU6IHtcblx0XHRcdFJfTlVMTDogMSxcblx0XHRcdFJfQk9PTDogMixcblx0XHRcdFJfTlVNOiAzLFxuXHRcdFx0Ul9TVFI6IDQsXG5cdFx0XHRSX0FSUkFZOiA1LFxuXHRcdFx0Ul9PQkpFQ1Q6IDYsXG5cdFx0XHRSX0pTT046IDdcblx0XHR9LFxuXHRcdFxuXHRcdEFzc29jUGFpcjoge31cblx0fSxcblx0XG5cdFRlcm06IHtcblx0XHRUZXJtVHlwZToge1xuXHRcdFx0REFUVU06IDEsXG5cdFx0XHRNQUtFX0FSUkFZOiAyLFxuXHRcdFx0TUFLRV9PQko6IDMsXG5cdFx0XHRWQVI6IDEwLFxuXHRcdFx0SkFWQVNDUklQVDogMTEsXG5cdFx0XHRVVUlEOiAxNjksXG5cdFx0XHRIVFRQOiAxNTMsXG5cdFx0XHRFUlJPUjogMTIsXG5cdFx0XHRJTVBMSUNJVF9WQVI6IDEzLFxuXHRcdFx0REI6IDE0LFxuXHRcdFx0VEFCTEU6IDE1LFxuXHRcdFx0R0VUOiAxNixcblx0XHRcdEdFVF9BTEw6IDc4LFxuXHRcdFx0RVE6IDE3LFxuXHRcdFx0TkU6IDE4LFxuXHRcdFx0TFQ6IDE5LFxuXHRcdFx0TEU6IDIwLFxuXHRcdFx0R1Q6IDIxLFxuXHRcdFx0R0U6IDIyLFxuXHRcdFx0Tk9UOiAyMyxcblx0XHRcdEFERDogMjQsXG5cdFx0XHRTVUI6IDI1LFxuXHRcdFx0TVVMOiAyNixcblx0XHRcdERJVjogMjcsXG5cdFx0XHRNT0Q6IDI4LFxuXHRcdFx0RkxPT1I6IDE4Myxcblx0XHRcdENFSUw6IDE4NCxcblx0XHRcdFJPVU5EOiAxODUsXG5cdFx0XHRBUFBFTkQ6IDI5LFxuXHRcdFx0UFJFUEVORDogODAsXG5cdFx0XHRESUZGRVJFTkNFOiA5NSxcblx0XHRcdFNFVF9JTlNFUlQ6IDg4LFxuXHRcdFx0U0VUX0lOVEVSU0VDVElPTjogODksXG5cdFx0XHRTRVRfVU5JT046IDkwLFxuXHRcdFx0U0VUX0RJRkZFUkVOQ0U6IDkxLFxuXHRcdFx0U0xJQ0U6IDMwLFxuXHRcdFx0U0tJUDogNzAsXG5cdFx0XHRMSU1JVDogNzEsXG5cdFx0XHRPRkZTRVRTX09GOiA4Nyxcblx0XHRcdENPTlRBSU5TOiA5Myxcblx0XHRcdEdFVF9GSUVMRDogMzEsXG5cdFx0XHRLRVlTOiA5NCxcblx0XHRcdFZBTFVFUzogMTg2LFxuXHRcdFx0T0JKRUNUOiAxNDMsXG5cdFx0XHRIQVNfRklFTERTOiAzMixcblx0XHRcdFdJVEhfRklFTERTOiA5Nixcblx0XHRcdFBMVUNLOiAzMyxcblx0XHRcdFdJVEhPVVQ6IDM0LFxuXHRcdFx0TUVSR0U6IDM1LFxuXHRcdFx0QkVUV0VFTl9ERVBSRUNBVEVEOiAzNixcblx0XHRcdEJFVFdFRU46IDE4Mixcblx0XHRcdFJFRFVDRTogMzcsXG5cdFx0XHRNQVA6IDM4LFxuXHRcdFx0Rk9MRDogMTg3LFxuXHRcdFx0RklMVEVSOiAzOSxcblx0XHRcdENPTkNBVF9NQVA6IDQwLFxuXHRcdFx0T1JERVJfQlk6IDQxLFxuXHRcdFx0RElTVElOQ1Q6IDQyLFxuXHRcdFx0Q09VTlQ6IDQzLFxuXHRcdFx0SVNfRU1QVFk6IDg2LFxuXHRcdFx0VU5JT046IDQ0LFxuXHRcdFx0TlRIOiA0NSxcblx0XHRcdEJSQUNLRVQ6IDE3MCxcblx0XHRcdElOTkVSX0pPSU46IDQ4LFxuXHRcdFx0T1VURVJfSk9JTjogNDksXG5cdFx0XHRFUV9KT0lOOiA1MCxcblx0XHRcdFpJUDogNzIsXG5cdFx0XHRSQU5HRTogMTczLFxuXHRcdFx0SU5TRVJUX0FUOiA4Mixcblx0XHRcdERFTEVURV9BVDogODMsXG5cdFx0XHRDSEFOR0VfQVQ6IDg0LFxuXHRcdFx0U1BMSUNFX0FUOiA4NSxcblx0XHRcdENPRVJDRV9UTzogNTEsXG5cdFx0XHRUWVBFX09GOiA1Mixcblx0XHRcdFVQREFURTogNTMsXG5cdFx0XHRERUxFVEU6IDU0LFxuXHRcdFx0UkVQTEFDRTogNTUsXG5cdFx0XHRJTlNFUlQ6IDU2LFxuXHRcdFx0REJfQ1JFQVRFOiA1Nyxcblx0XHRcdERCX0RST1A6IDU4LFxuXHRcdFx0REJfTElTVDogNTksXG5cdFx0XHRUQUJMRV9DUkVBVEU6IDYwLFxuXHRcdFx0VEFCTEVfRFJPUDogNjEsXG5cdFx0XHRUQUJMRV9MSVNUOiA2Mixcblx0XHRcdENPTkZJRzogMTc0LFxuXHRcdFx0U1RBVFVTOiAxNzUsXG5cdFx0XHRXQUlUOiAxNzcsXG5cdFx0XHRSRUNPTkZJR1VSRTogMTc2LFxuXHRcdFx0UkVCQUxBTkNFOiAxNzksXG5cdFx0XHRTWU5DOiAxMzgsXG5cdFx0XHRHUkFOVDogMTg4LFxuXHRcdFx0SU5ERVhfQ1JFQVRFOiA3NSxcblx0XHRcdElOREVYX0RST1A6IDc2LFxuXHRcdFx0SU5ERVhfTElTVDogNzcsXG5cdFx0XHRJTkRFWF9TVEFUVVM6IDEzOSxcblx0XHRcdElOREVYX1dBSVQ6IDE0MCxcblx0XHRcdElOREVYX1JFTkFNRTogMTU2LFxuXHRcdFx0RlVOQ0FMTDogNjQsXG5cdFx0XHRCUkFOQ0g6IDY1LFxuXHRcdFx0T1I6IDY2LFxuXHRcdFx0QU5EOiA2Nyxcblx0XHRcdEZPUl9FQUNIOiA2OCxcblx0XHRcdEZVTkM6IDY5LFxuXHRcdFx0QVNDOiA3Myxcblx0XHRcdERFU0M6IDc0LFxuXHRcdFx0SU5GTzogNzksXG5cdFx0XHRNQVRDSDogOTcsXG5cdFx0XHRVUENBU0U6IDE0MSxcblx0XHRcdERPV05DQVNFOiAxNDIsXG5cdFx0XHRTQU1QTEU6IDgxLFxuXHRcdFx0REVGQVVMVDogOTIsXG5cdFx0XHRKU09OOiA5OCxcblx0XHRcdFRPX0pTT05fU1RSSU5HOiAxNzIsXG5cdFx0XHRJU084NjAxOiA5OSxcblx0XHRcdFRPX0lTTzg2MDE6IDEwMCxcblx0XHRcdEVQT0NIX1RJTUU6IDEwMSxcblx0XHRcdFRPX0VQT0NIX1RJTUU6IDEwMixcblx0XHRcdE5PVzogMTAzLFxuXHRcdFx0SU5fVElNRVpPTkU6IDEwNCxcblx0XHRcdERVUklORzogMTA1LFxuXHRcdFx0REFURTogMTA2LFxuXHRcdFx0VElNRV9PRl9EQVk6IDEyNixcblx0XHRcdFRJTUVaT05FOiAxMjcsXG5cdFx0XHRZRUFSOiAxMjgsXG5cdFx0XHRNT05USDogMTI5LFxuXHRcdFx0REFZOiAxMzAsXG5cdFx0XHREQVlfT0ZfV0VFSzogMTMxLFxuXHRcdFx0REFZX09GX1lFQVI6IDEzMixcblx0XHRcdEhPVVJTOiAxMzMsXG5cdFx0XHRNSU5VVEVTOiAxMzQsXG5cdFx0XHRTRUNPTkRTOiAxMzUsXG5cdFx0XHRUSU1FOiAxMzYsXG5cdFx0XHRNT05EQVk6IDEwNyxcblx0XHRcdFRVRVNEQVk6IDEwOCxcblx0XHRcdFdFRE5FU0RBWTogMTA5LFxuXHRcdFx0VEhVUlNEQVk6IDExMCxcblx0XHRcdEZSSURBWTogMTExLFxuXHRcdFx0U0FUVVJEQVk6IDExMixcblx0XHRcdFNVTkRBWTogMTEzLFxuXHRcdFx0SkFOVUFSWTogMTE0LFxuXHRcdFx0RkVCUlVBUlk6IDExNSxcblx0XHRcdE1BUkNIOiAxMTYsXG5cdFx0XHRBUFJJTDogMTE3LFxuXHRcdFx0TUFZOiAxMTgsXG5cdFx0XHRKVU5FOiAxMTksXG5cdFx0XHRKVUxZOiAxMjAsXG5cdFx0XHRBVUdVU1Q6IDEyMSxcblx0XHRcdFNFUFRFTUJFUjogMTIyLFxuXHRcdFx0T0NUT0JFUjogMTIzLFxuXHRcdFx0Tk9WRU1CRVI6IDEyNCxcblx0XHRcdERFQ0VNQkVSOiAxMjUsXG5cdFx0XHRMSVRFUkFMOiAxMzcsXG5cdFx0XHRHUk9VUDogMTQ0LFxuXHRcdFx0U1VNOiAxNDUsXG5cdFx0XHRBVkc6IDE0Nixcblx0XHRcdE1JTjogMTQ3LFxuXHRcdFx0TUFYOiAxNDgsXG5cdFx0XHRTUExJVDogMTQ5LFxuXHRcdFx0VU5HUk9VUDogMTUwLFxuXHRcdFx0UkFORE9NOiAxNTEsXG5cdFx0XHRDSEFOR0VTOiAxNTIsXG5cdFx0XHRBUkdTOiAxNTQsXG5cdFx0XHRCSU5BUlk6IDE1NSxcblx0XHRcdEdFT0pTT046IDE1Nyxcblx0XHRcdFRPX0dFT0pTT046IDE1OCxcblx0XHRcdFBPSU5UOiAxNTksXG5cdFx0XHRMSU5FOiAxNjAsXG5cdFx0XHRQT0xZR09OOiAxNjEsXG5cdFx0XHRESVNUQU5DRTogMTYyLFxuXHRcdFx0SU5URVJTRUNUUzogMTYzLFxuXHRcdFx0SU5DTFVERVM6IDE2NCxcblx0XHRcdENJUkNMRTogMTY1LFxuXHRcdFx0R0VUX0lOVEVSU0VDVElORzogMTY2LFxuXHRcdFx0RklMTDogMTY3LFxuXHRcdFx0R0VUX05FQVJFU1Q6IDE2OCxcblx0XHRcdFBPTFlHT05fU1VCOiAxNzEsXG5cdFx0XHRNSU5WQUw6IDE4MCxcblx0XHRcdE1BWFZBTDogMTgxXG5cdFx0fSxcblx0XHRcblx0XHRBc3NvY1BhaXI6IHt9XG5cdH1cbn1cbiIsInZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3N0cmVhbScpLlJlYWRhYmxlO1xudmFyIEN1cnNvciA9IHJlcXVpcmUoX19kaXJuYW1lKycvY3Vyc29yLmpzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLy8gRXhwZXJpbWVudGFsLCBidXQgc2hvdWxkIHdvcmsgZmluZS5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtKG9wdGlvbnMsIGN1cnNvcikge1xuICBpZiAoY3Vyc29yKSB0aGlzLl9jdXJzb3IgPSBjdXJzb3I7XG4gIHRoaXMuX3BlbmRpbmcgPSAwOyAvLyBIb3cgbWFueSB0aW1lIHdlIGNhbGxlZCBfcmVhZCB3aGlsZSBubyBjdXJzb3Igd2FzIGF2YWlsYWJsZVxuICB0aGlzLl9pbmRleCA9IDA7XG4gIHRoaXMuX21heFJlY3Vyc2lvbiA9IDEwMDA7IC8vIEhhcmRjb2RlZFxuICB0aGlzLl9oaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIGhpZ2hXYXRlck1hcms6IHRoaXMuX2hpZ2hXYXRlck1hcmtcbiAgfSk7XG59O1xudXRpbC5pbmhlcml0cyhSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGUpO1xuXG5cblJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5fc2V0Q3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gIGlmIChjdXJzb3IgaW5zdGFuY2VvZiBDdXJzb3IgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhIHN0cmVhbSBvbiBhIHNpbmdsZSB2YWx1ZS4nKSk7XG4gICAgdGhpcy5wdXNoKG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2N1cnNvciA9IGN1cnNvcjtcbiAgdGhpcy5fZmV0Y2hBbmREZWNyZW1lbnQoKTtcbn1cblJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdGhpcy5fY291bnQrKztcbiAgaWYgKHRoaXMuX2N1cnNvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fcGVuZGluZysrO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3JlY3Vyc2lvbiA9IDA7XG4gIHRoaXMuX2ZldGNoKCk7XG59XG5cbi8vVE9ETzogUmVmYWN0b3Igd2l0aCBfZmV0Y2g/XG5SZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuX2ZldGNoQW5kRGVjcmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fcGVuZGluZy0tO1xuICBpZiAoc2VsZi5fcGVuZGluZyA8IDAgfHwgc2VsZi5fY2xvc2VkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNlbGYuX2N1cnNvci5fY2xvc2VkID09PSB0cnVlKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlbGYuX2N1cnNvci5fbmV4dCgpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgLy8gU2lsZW50bHkgZHJvcCBudWxsIHZhbHVlcyBmb3Igbm93XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc2VsZi5fcmVjdXJzaW9uKysgPT09IHNlbGYuX21heFJlY3Vyc2lvbikge1xuICAgICAgICAgIC8vQXZvaWQgbWF4aW11bSBjYWxsIHN0YWNrIGVycm9yc1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9mZXRjaEFuZERlY3JlbWVudCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuX2ZldGNoQW5kRGVjcmVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi5wdXNoKGRhdGEpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChzZWxmLl9yZWN1cnNpb24rKyA9PT0gc2VsZi5fbWF4UmVjdXJzaW9uKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLl9mZXRjaEFuZERlY3JlbWVudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5fZmV0Y2hBbmREZWNyZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZS5tYXRjaCgvTm8gbW9yZSByb3dzIGluIHRoZS8pKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdZb3UgY2Fubm90IHJldHJpZXZlIGRhdGEgZnJvbSBhIGN1cnNvciB0aGF0IGlzIGNsb3NlZC4nKSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGNhbGwgYGNsb3NlYCwgdGhlIGN1cnNvciBtYXkgcmVqZWN0IHBlbmRpbmcgcmVxdWVzdHMuIFdlIGp1c3RcbiAgICAgICAgLy8gaWdub3JlIHRoZW0gaGVyZS5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLl9mZXRjaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9jbG9zZWQgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNlbGYuX2N1cnNvci5fY2xvc2VkID09PSB0cnVlKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlbGYuX2N1cnNvci5fbmV4dCgpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKHNlbGYuX2Nsb3NlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTaWxlbnRseSBkcm9wIG51bGwgdmFsdWVzIGZvciBub3dcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzZWxmLl9yZWN1cnNpb24rKyA9PT0gc2VsZi5fbWF4UmVjdXJzaW9uKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX2ZldGNoKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5fZmV0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWxmLnB1c2goZGF0YSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHNlbGYuX3JlY3Vyc2lvbisrID09PSBzZWxmLl9tYXhSZWN1cnNpb24pIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2ZldGNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLl9mZXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLm1hdGNoKC9ObyBtb3JlIHJvd3MgaW4gdGhlLykpIHtcbiAgICAgICAgc2VsZi5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1lvdSBjYW5ub3QgcmV0cmlldmUgZGF0YSBmcm9tIGEgY3Vyc29yIHRoYXQgaXMgY2xvc2VkLicpIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgY2FsbCBgY2xvc2VgLCB0aGUgY3Vyc29yIG1heSByZWplY3QgcGVuZGluZyByZXF1ZXN0cy4gV2UganVzdFxuICAgICAgICAvLyBpZ25vcmUgdGhlbSBoZXJlLlxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5cblJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHJldHVybiB0aGlzLl9jdXJzb3IuY2xvc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZVN0cmVhbTtcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciBwcm90b2RlZiA9IHJlcXVpcmUoX19kaXJuYW1lKycvcHJvdG9kZWYuanMnKTtcbnZhciB0ZXJtVHlwZXMgPSBwcm90b2RlZi5UZXJtLlRlcm1UeXBlO1xuXG52YXIgRXJyb3IgPSByZXF1aXJlKF9fZGlybmFtZSsnL2Vycm9yLmpzJyk7XG52YXIgaGVscGVyID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9oZWxwZXIuanMnKTtcbnZhciBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoX19kaXJuYW1lKycvc3RyZWFtLmpzJyk7XG52YXIgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKF9fZGlybmFtZSsnL3dyaXRhYmxlX3N0cmVhbS5qcycpO1xudmFyIFRyYW5zZm9ybVN0cmVhbSA9IHJlcXVpcmUoX19kaXJuYW1lKycvdHJhbnNmb3JtX3N0cmVhbS5qcycpO1xuXG5mdW5jdGlvbiBUZXJtKHIsIHZhbHVlLCBlcnJvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0ZXJtID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgICBpZiAoVGVybS5wcm90b3R5cGUuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICAgIFRlcm0ucHJvdG90eXBlLl9hcml0eShfYXJncywgMSwgJyguLi4pJywgc2VsZik7XG4gICAgfVxuICAgIHJldHVybiB0ZXJtLmJyYWNrZXQoZmllbGQpO1xuICB9XG4gIGhlbHBlci5jaGFuZ2VQcm90byh0ZXJtLCBzZWxmKTtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRlcm0uX3F1ZXJ5ID0gW107XG4gIH1cbiAgZWxzZSB7XG4gICAgdGVybS5fcXVlcnkgPSB2YWx1ZTtcbiAgfVxuICB0ZXJtLl9yID0gcjsgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byByIGZvciBnbG9iYWwgc2V0dGluZ3NcblxuICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHRlcm0uX2Vycm9yID0gZXJyb3I7XG4gICAgdGVybS5fZnJhbWVzID0gW107XG4gIH1cblxuICByZXR1cm4gdGVybTtcbn1cblxuLy8gcnVuKFtjb25uZWN0aW9uXVssIG9wdGlvbnNdWywgY2FsbGJhY2tdKVxuVGVybS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChzZWxmLl9lcnJvciAhPSBudWxsKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yLlJlcWxSdW50aW1lRXJyb3Ioc2VsZi5fZXJyb3IsIHNlbGYuX3F1ZXJ5LCB7Yjogc2VsZi5fZnJhbWVzfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChjb25uZWN0aW9uKSAmJiAodHlwZW9mIGNvbm5lY3Rpb24uX2lzQ29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykgJiYgKGNvbm5lY3Rpb24uX2lzQ29ubmVjdGlvbigpID09PSB0cnVlKSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghaGVscGVyLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdGlvbi5faXNPcGVuKCkgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ2BydW5gIHdhcyBjYWxsZWQgd2l0aCBhIGNsb3NlZCBjb25uZWN0aW9uJywgc2VsZi5fcXVlcnkpLnNldE9wZXJhdGlvbmFsKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdG9rZW4gPSBjb25uZWN0aW9uLl9nZXRUb2tlbigpO1xuXG4gICAgICB2YXIgcXVlcnkgPSBbcHJvdG9kZWYuUXVlcnkuUXVlcnlUeXBlLlNUQVJUXTtcbiAgICAgIHF1ZXJ5LnB1c2goc2VsZi5fcXVlcnkpO1xuXG4gICAgICB2YXIgX29wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBzZW5kT3B0aW9ucyA9IGZhbHNlO1xuICAgICAgaWYgKGNvbm5lY3Rpb24uZGIgIT0gbnVsbCkge1xuICAgICAgICBzZW5kT3B0aW9ucyA9IHRydWU7XG4gICAgICAgIF9vcHRpb25zLmRiID0gc2VsZi5fci5kYihjb25uZWN0aW9uLmRiKS5fcXVlcnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLl9yLmFycmF5TGltaXQgIT0gbnVsbCkge1xuICAgICAgICBzZW5kT3B0aW9ucyA9IHRydWU7XG4gICAgICAgIF9vcHRpb25zW3NlbGYuX3RyYW5zbGF0ZUFyZ3NbJ2FycmF5TGltaXQnXV0gPSBzZWxmLl9yLmFycmF5TGltaXQ7XG4gICAgICB9O1xuXG5cbiAgICAgIHZhciBrZWVwR29pbmcgPSB0cnVlOyAvLyB3ZSBuZWVkIGl0IGp1c3QgdG8gYXZvaXIgY2FsbGluZyByZXNvbHZlL3JlamVjdCBtdWx0aXBsZSB0aW1lc1xuICAgICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbnMsIGtleSkge1xuICAgICAgICBpZiAoa2VlcEdvaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKChrZXkgPT09ICdyZWFkTW9kZScpIHx8IChrZXkgPT09ICdkdXJhYmlsaXR5JykgfHwgKGtleSA9PT0gJ2RiJykgfHxcbiAgICAgICAgICAgIChrZXkgPT09ICdub3JlcGx5JykgfHwgKGtleSA9PT0gJ2FycmF5TGltaXQnKSB8fCAoa2V5ID09PSAncHJvZmlsZScpIHx8XG4gICAgICAgICAgICAoa2V5ID09PSAnbWluQmF0Y2hSb3dzJykgfHwgKGtleSA9PT0gJ21heEJhdGNoUm93cycpIHx8IChrZXkgPT09ICdtYXhCYXRjaEJ5dGVzJykgfHxcbiAgICAgICAgICAgIChrZXkgPT09ICdtYXhCYXRjaFNlY29uZHMnKSB8fCAoa2V5ID09PSAnZmlyc3RCYXRjaFNjYWxlZG93bkZhY3RvcicpKSB7XG5cbiAgICAgICAgICAgIHNlbmRPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdkYicpIHtcbiAgICAgICAgICAgICAgX29wdGlvbnNba2V5XSA9IHNlbGYuX3IuZGIob3B0aW9uc1trZXldKS5fcXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLl90cmFuc2xhdGVBcmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgX29wdGlvbnNbc2VsZi5fdHJhbnNsYXRlQXJnc1trZXldXSA9IG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIob3B0aW9uc1trZXldKS5fcXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgX29wdGlvbnNba2V5XSA9IG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIob3B0aW9uc1trZXldKS5fcXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChrZXkgIT09ICd0aW1lRm9ybWF0JykgJiYgKGtleSAhPT0gJ2dyb3VwRm9ybWF0JykgJiZcbiAgICAgICAgICAgICAgKGtleSAhPT0gJ2JpbmFyeUZvcm1hdCcpICYmIChrZXkgIT09ICdjdXJzb3InKSAmJlxuICAgICAgICAgICAgICAoa2V5ICE9PSAncmVhZGFibGUnKSAmJiAoa2V5ICE9PSAnd3JpdGFibGUnKSAmJlxuICAgICAgICAgICAgICAoa2V5ICE9PSAndHJhbnNmb3JtJykgJiYgKGtleSAhPT0gJ3N0cmVhbScpICYmXG4gICAgICAgICAgICAgIChrZXkgIT09ICdoaWdoV2F0ZXJNYXJrJykpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgcnVuYC4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHJlYWRNb2RlIDxzdHJpbmc+LCBkdXJhYmlsaXR5IDxzdHJpbmc+LCBub3JlcGx5IDxib29sPiwgdGltZUZvcm1hdCA8c3RyaW5nPiwgZ3JvdXBGb3JtYXQ6IDxzdHJpbmc+LCBwcm9maWxlIDxib29sPiwgYmluYXJ5Rm9ybWF0IDxib29sPiwgY3Vyc29yIDxib29sPiwgc3RyZWFtIDxib29sPicpKTtcbiAgICAgICAgICAgIGtlZXBHb2luZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChrZWVwR29pbmcgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uZW1pdCgncmVsZWFzZScpO1xuICAgICAgICByZXR1cm4gLy8gVGhlIHByb21pc2Ugd2FzIHJlamVjdGVkIGluIHRoZSBsb29wS2V5c1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VuZE9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgcXVlcnkucHVzaChfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uLl9zZW5kKHF1ZXJ5LCB0b2tlbiwgcmVzb2x2ZSwgcmVqZWN0LCBzZWxmLl9xdWVyeSwgb3B0aW9ucyk7XG4gICAgfSkubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHBvb2xNYXN0ZXIgPSBzZWxmLl9yLmdldFBvb2xNYXN0ZXIoKTsgLy8gaWYgc2VsZi5fciBpcyBkZWZpbmVkLCBzbyBpcyBzZWxmLl9yLmdldFBvb2woKVxuICAgIGlmICghcG9vbE1hc3Rlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignYHJ1bmAgd2FzIGNhbGxlZCB3aXRob3V0IGEgY29ubmVjdGlvbiBhbmQgbm8gcG9vbCBoYXMgYmVlbiBjcmVhdGVkJywgc2VsZi5fcXVlcnkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgY29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBydW4oY2FsbGJhY2spO1xuICAgICAgICBjYWxsYmFjayA9IGNvbm5lY3Rpb247XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KGNvbm5lY3Rpb24pKSB7XG4gICAgICAgIC8vIHJ1bihvcHRpb25zWywgY2FsbGJhY2tdKVxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBjb25uZWN0aW9uO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuXG4gICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwb29sTWFzdGVyLmdldENvbm5lY3Rpb24oKS50aGVuKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBjb25uZWN0aW9uLl9nZXRUb2tlbigpO1xuICAgICAgICAgIHZhciBxdWVyeSA9IFtwcm90b2RlZi5RdWVyeS5RdWVyeVR5cGUuU1RBUlRdO1xuICAgICAgICAgIHF1ZXJ5LnB1c2goc2VsZi5fcXVlcnkpO1xuXG4gICAgICAgICAgdmFyIF9vcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIHNlbmRPcHRpb25zID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VuZE9wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgX29wdGlvbnMuZGIgPSBzZWxmLl9yLmRiKGNvbm5lY3Rpb24uZGIpLl9xdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuX3IuYXJyYXlMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZW5kT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICBfb3B0aW9uc1tzZWxmLl90cmFuc2xhdGVBcmdzWydhcnJheUxpbWl0J11dID0gc2VsZi5fci5hcnJheUxpbWl0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIga2VlcEdvaW5nID0gdHJ1ZTtcbiAgICAgICAgICBoZWxwZXIubG9vcEtleXMob3B0aW9ucywgZnVuY3Rpb24ob3B0aW9ucywga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2VlcEdvaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGlmICgoa2V5ID09PSAncmVhZE1vZGUnKSB8fCAoa2V5ID09PSAnZHVyYWJpbGl0eScpIHx8IChrZXkgPT09ICdkYicpIHx8XG4gICAgICAgICAgICAgICAgICAoa2V5ID09PSAnbm9yZXBseScpIHx8IChrZXkgPT09ICdhcnJheUxpbWl0JykgfHwgKGtleSA9PT0gJ3Byb2ZpbGUnKSB8fFxuICAgICAgICAgICAgICAgICAgKGtleSA9PT0gJ21pbkJhdGNoUm93cycpIHx8IChrZXkgPT09ICdtYXhCYXRjaFJvd3MnKSB8fCAoa2V5ID09PSAnbWF4QmF0Y2hCeXRlcycpIHx8XG4gICAgICAgICAgICAgICAgICAoa2V5ID09PSAnbWF4QmF0Y2hTZWNvbmRzJykgfHwgKGtleSA9PT0gJ2ZpcnN0QmF0Y2hTY2FsZWRvd25GYWN0b3InKSkge1xuXG5cbiAgICAgICAgICAgICAgICBzZW5kT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2RiJykge1xuICAgICAgICAgICAgICAgICAgX29wdGlvbnNba2V5XSA9IHNlbGYuX3IuZGIob3B0aW9uc1trZXldKS5fcXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuX3RyYW5zbGF0ZUFyZ3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgX29wdGlvbnNbc2VsZi5fdHJhbnNsYXRlQXJnc1trZXldXSA9IG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIob3B0aW9uc1trZXldKS5fcXVlcnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfb3B0aW9uc1trZXldID0gbmV3IFRlcm0oc2VsZi5fcikuZXhwcihvcHRpb25zW2tleV0pLl9xdWVyeVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICgoa2V5ICE9PSAndGltZUZvcm1hdCcpICYmIChrZXkgIT09ICdncm91cEZvcm1hdCcpICYmXG4gICAgICAgICAgICAgICAgICAoa2V5ICE9PSAnYmluYXJ5Rm9ybWF0JykgJiYgKGtleSAhPT0gJ2N1cnNvcicpICYmXG4gICAgICAgICAgICAgICAgICAoa2V5ICE9PSAncmVhZGFibGUnKSAmJiAoa2V5ICE9PSAnd3JpdGFibGUnKSAmJlxuICAgICAgICAgICAgICAgICAgKGtleSAhPT0gJ3RyYW5zZm9ybScpICYmIChrZXkgIT09ICdzdHJlYW0nKSAmJlxuICAgICAgICAgICAgICAgICAgKGtleSAhPT0gJ2hpZ2hXYXRlck1hcmsnKSkge1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVW5yZWNvZ25pemVkIG9wdGlvbiBgJytrZXkrJ2AgaW4gYHJ1bmAuIEF2YWlsYWJsZSBvcHRpb25zIGFyZSByZWFkTW9kZSA8c3RyaW5nPiwgZHVyYWJpbGl0eSA8c3RyaW5nPiwgbm9yZXBseSA8Ym9vbD4sIHRpbWVGb3JtYXQgPHN0cmluZz4sIGdyb3VwRm9ybWF0OiA8c3RyaW5nPiwgcHJvZmlsZSA8Ym9vbD4sIGJpbmFyeUZvcm1hdCA8c3RyaW5nPiwgY3Vyc29yIDxib29sPiwgc3RyZWFtIDxib29sPicpKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChrZWVwR29pbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmVtaXQoJ3JlbGVhc2UnKTtcbiAgICAgICAgICAgIHJldHVybiAvLyBUaGUgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgaW4gdGhlIGxvb3BLZXlzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbmRPcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICBxdWVyeS5wdXNoKF9vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29ubmVjdGlvbi5fc2VuZChxdWVyeSwgdG9rZW4sIHJlc29sdmUsIHJlamVjdCwgc2VsZi5fcXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSkubm9kZWlmeShjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgLy9pZiAob3B0aW9ucy5ub3JlcGx5KSByZXR1cm4gc2VsZjsgLy8gRG8gbm90IHJldHVybiBhIHByb21pc2UgaWYgdGhlIHVzZXIgYXNrIGZvciBubyByZXBseS5cblxuICByZXR1cm4gcDtcbn1cblxuVGVybS5wcm90b3R5cGUudG9TdHJlYW0gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChjb25uZWN0aW9uKSAmJiAodHlwZW9mIGNvbm5lY3Rpb24uX2lzQ29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykgJiYgKGNvbm5lY3Rpb24uX2lzQ29ubmVjdGlvbigpID09PSB0cnVlKSkge1xuICAgIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b1JlYWRhYmxlU3RyZWFtKGNvbm5lY3Rpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLndyaXRhYmxlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9Xcml0YWJsZVN0cmVhbShjb25uZWN0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy50cmFuc2Zvcm0gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b1RyYW5zZm9ybVN0cmVhbShjb25uZWN0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9SZWFkYWJsZVN0cmVhbShjb25uZWN0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgb3B0aW9ucyA9IGNvbm5lY3Rpb247XG4gICAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvUmVhZGFibGVTdHJlYW0ob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b1dyaXRhYmxlU3RyZWFtKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnRyYW5zZm9ybSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvVHJhbnNmb3JtU3RyZWFtKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl90b1JlYWRhYmxlU3RyZWFtKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuXG5UZXJtLnByb3RvdHlwZS5fdG9SZWFkYWJsZVN0cmVhbSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHN0cmVhbTtcblxuICB2YXIgX29wdGlvbnMgPSB7fTtcbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KGNvbm5lY3Rpb24pICYmICh0eXBlb2YgY29ubmVjdGlvbi5faXNDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSAmJiAoY29ubmVjdGlvbi5faXNDb25uZWN0aW9uKCkgPT09IHRydWUpKSB7XG4gICAgLy90b1N0cmVhbSBtYWtlIHN1cmUgdGhhdCBvcHRpb25zIGlzIGFuIG9iamVjdFxuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgX29wdGlvbnNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIF9vcHRpb25zLmN1cnNvciA9IHRydWU7XG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKF9vcHRpb25zKTtcbiAgICB0aGlzLnJ1bihjb25uZWN0aW9uLCBfb3B0aW9ucykudGhlbihmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgIHN0cmVhbS5fc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGhlbHBlci5sb29wS2V5cyhjb25uZWN0aW9uLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgX29wdGlvbnNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIF9vcHRpb25zLmN1cnNvciA9IHRydWU7XG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKF9vcHRpb25zKTtcbiAgICB0aGlzLnJ1bihfb3B0aW9ucykudGhlbihmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgIHN0cmVhbS5fc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdHJlYW07XG59XG5cblRlcm0ucHJvdG90eXBlLl90b1dyaXRhYmxlU3RyZWFtID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICBpZiAodGhpcy5fcXVlcnlbMF0gIT09IHRlcm1UeXBlcy5UQUJMRSkge1xuICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgYSB3cml0YWJsZSBzdHJlYW0gb24gc29tZXRoaW5nIGVsc2UgdGhhbiBhIHRhYmxlLicpO1xuICB9XG5cbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KGNvbm5lY3Rpb24pICYmICh0eXBlb2YgY29ubmVjdGlvbi5faXNDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSAmJiAoY29ubmVjdGlvbi5faXNDb25uZWN0aW9uKCkgPT09IHRydWUpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbSh0aGlzLCBvcHRpb25zLCBjb25uZWN0aW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtKHRoaXMsIGNvbm5lY3Rpb24pO1xuICB9XG59XG5UZXJtLnByb3RvdHlwZS5fdG9UcmFuc2Zvcm1TdHJlYW0gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLl9xdWVyeVswXSAhPT0gdGVybVR5cGVzLlRBQkxFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignQ2Fubm90IGNyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSBvbiBzb21ldGhpbmcgZWxzZSB0aGFuIGEgdGFibGUuJyk7XG4gIH1cblxuICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3QoY29ubmVjdGlvbikgJiYgKHR5cGVvZiBjb25uZWN0aW9uLl9pc0Nvbm5lY3Rpb24gPT09ICdmdW5jdGlvbicpICYmIChjb25uZWN0aW9uLl9pc0Nvbm5lY3Rpb24oKSA9PT0gdHJ1ZSkpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh0aGlzLCBvcHRpb25zLCBjb25uZWN0aW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh0aGlzLCBjb25uZWN0aW9uKTtcbiAgfVxufVxuXG5cbi8vIE1hbmlwdWxhdGluZyBkYXRhYmFzZXNcblRlcm0ucHJvdG90eXBlLmRiQ3JlYXRlID0gZnVuY3Rpb24oZGIpIHtcbiAgLy8gQ2hlY2sgZm9yIGFyaXR5IGlzIGRvbmUgaW4gci5wcm90b3R5cGUuZGJDcmVhdGVcbiAgdGhpcy5fbm9QcmVmaXgodGhpcywgJ2RiQ3JlYXRlJyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuREJfQ1JFQVRFKTtcbiAgdmFyIGFyZ3MgPSBbbmV3IFRlcm0odGhpcy5fcikuZXhwcihkYikuX3F1ZXJ5XVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5kYkRyb3AgPSBmdW5jdGlvbihkYikge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAnZGJEcm9wJyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuREJfRFJPUCk7XG4gIHZhciBhcmdzID0gW25ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZGIpLl9xdWVyeV1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZGJMaXN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdkYkxpc3QnKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5EQl9MSVNUKVxuICByZXR1cm4gdGVybTtcbn1cblxuLy8gTWFuaXB1bGF0aW5nIFRhYmxlc1xuVGVybS5wcm90b3R5cGUudGFibGVDcmVhdGUgPSBmdW5jdGlvbih0YWJsZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ3RhYmxlQ3JlYXRlJywgc2VsZik7XG4gIH1cblxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlRBQkxFX0NSRUFURSlcblxuICB2YXIgYXJncyA9IFtdO1xuICBpZiAoQXJyYXkuaXNBcnJheShzZWxmLl9xdWVyeSkgJiYgKHNlbGYuX3F1ZXJ5Lmxlbmd0aCA+IDApKSB7XG4gICAgYXJncy5wdXNoKHNlbGYpOyAvLyBQdXNoIGRiXG4gIH1cbiAgYXJncy5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodGFibGUpKVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAvLyBDaGVjayBmb3Igbm9uIHZhbGlkIGtleVxuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdwcmltYXJ5S2V5JylcbiAgICAgICAgICAmJiAoa2V5ICE9PSAnZHVyYWJpbGl0eScpXG4gICAgICAgICAgJiYgKGtleSAhPT0gJ3NoYXJkcycpXG4gICAgICAgICAgJiYgKGtleSAhPT0gJ3JlcGxpY2FzJylcbiAgICAgICAgICAmJiAoa2V5ICE9PSAncHJpbWFyeVJlcGxpY2FUYWcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgdGFibGVDcmVhdGVgJywgc2VsZi5fcXVlcnksICdBdmFpbGFibGUgb3B0aW9ucyBhcmUgcHJpbWFyeUtleSA8c3RyaW5nPiwgZHVyYWJpbGl0eSA8c3RyaW5nPiwgc2hhcmRzIDxudW1iZXI+LCByZXBsaWNhcyA8bnVtYmVyL29iamVjdD4sIHByaW1hcnlSZXBsaWNhVGFnIDxvYmplY3Q+Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucykpLl9xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5cblRlcm0ucHJvdG90eXBlLnRhYmxlRHJvcCA9IGZ1bmN0aW9uKHRhYmxlKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAndGFibGVEcm9wJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5UQUJMRV9EUk9QKVxuXG4gIHZhciBhcmdzID0gW107XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl9xdWVyeSkgfHwgKHRoaXMuX3F1ZXJ5Lmxlbmd0aCA+IDApKSB7XG4gICAgYXJncy5wdXNoKHRoaXMpOyAvLyBwdXNoIGRiXG4gIH1cbiAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIodGFibGUpKVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS50YWJsZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAwKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDAsICd0YWJsZUxpc3QnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlRBQkxFX0xJU1QpO1xuXG4gIHZhciBhcmdzID0gW107XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl9xdWVyeSkgfHwgKHRoaXMuX3F1ZXJ5Lmxlbmd0aCA+IDApKSB7XG4gICAgYXJncy5wdXNoKHRoaXMpO1xuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmluZGV4TGlzdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ2luZGV4TGlzdCcsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSU5ERVhfTElTVCk7XG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5pbmRleENyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAzKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMSwgMywgJ2luZGV4Q3JlYXRlJywgdGhpcyk7XG4gIH1cblxuICBpZiAoKG9wdGlvbnMgPT0gbnVsbCkgJiYgKGhlbHBlci5pc1BsYWluT2JqZWN0KGZuKSkpIHtcbiAgICBvcHRpb25zID0gZm47XG4gICAgZm4gPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5JTkRFWF9DUkVBVEUpO1xuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIobmFtZSkpO1xuICBpZiAodHlwZW9mIGZuICE9PSAndW5kZWZpbmVkJykgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZm4pLl93cmFwKCkpO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHRyYW5zbGF0ZSBoZXJlXG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoKGtleSAhPT0gJ211bHRpJykgJiYgKGtleSAhPT0gJ2dlbycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGBpbmRleENyZWF0ZWAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb24gaXMgbXVsdGkgPGJvb2w+IGFuZCBnZW8gPGJvb2w+Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKG9wdGlvbnMpLl9xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5pbmRleERyb3AgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnaW5kZXhEcm9wJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5JTkRFWF9EUk9QKTtcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihuYW1lKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUuaW5kZXhTdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5JTkRFWF9TVEFUVVMpO1xuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuaW5kZXhXYWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSU5ERVhfV0FJVCk7XG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5pbmRleFJlbmFtZSA9IGZ1bmN0aW9uKG9sZE5hbWUsIG5ld05hbWUsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMiwgMykgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHNlbGYuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIDMsICdpbmRleFJlbmFtZScsIHNlbGYpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSU5ERVhfUkVOQU1FKTtcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihvbGROYW1lKSwgbmV3IFRlcm0odGhpcy5fcikuZXhwcihuZXdOYW1lKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKGtleSAhPT0gJ292ZXJ3cml0ZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVW5yZWNvZ25pemVkIG9wdGlvbiBgJytrZXkrJ2AgaW4gYGluZGV4UmVuYW1lYCcsIHNlbGYuX3F1ZXJ5LCAnQXZhaWxhYmxlIG9wdGlvbnMgYXJlIG92ZXJ3cml0ZSA8Ym9vbD4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zKSkuX3F1ZXJ5KTtcbiAgfVxuXG5cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5jaGFuZ2VzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAwLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMCwgMSwgJ2NoYW5nZXMnLCBzZWxmKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkNIQU5HRVMpO1xuICB2YXIgYXJncyA9IFtzZWxmXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdzcXVhc2gnKSAmJiAoa2V5ICE9PSAnaW5jbHVkZVN0YXRlcycpICYmIChrZXkgIT09ICdpbmNsdWRlVHlwZXMnKVxuICAgICAgICAgICYmIChrZXkgIT09ICdpbmNsdWRlSW5pdGlhbCcpICYmIChrZXkgIT09ICdpbmNsdWRlT2Zmc2V0cycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGBjaGFuZ2VzYCcsIHNlbGYuX3F1ZXJ5LFxuICAgICAgICAgICAgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSBzcXVhc2ggPGJvb2w+LCBpbmNsdWRlSW5pdGlhbCA8Ym9vbD4sIGluY2x1ZGVTdGF0ZXMgPGJvb2w+LCBpbmNsdWRlT2Zmc2V0cyA8Ym9vbD4sIGluY2x1ZGVUeXBlcyA8Ym9vbD4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zKSkuX3F1ZXJ5KTtcbiAgfVxuICByZXR1cm4gdGVybTtcbn1cblxuLy8gV3JpdGluZyBkYXRhXG5UZXJtLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihkb2N1bWVudHMsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMSwgMikgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHNlbGYuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIDIsICdpbnNlcnQnLCBzZWxmKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLklOU0VSVCk7XG4gIHZhciBhcmdzID0gW3NlbGYsIG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIoZG9jdW1lbnRzKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdyZXR1cm5DaGFuZ2VzJykgJiYgKGtleSAhPT0gJ2R1cmFiaWxpdHknKSAmJiAoa2V5ICE9PSAnY29uZmxpY3QnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgaW5zZXJ0YCcsIHNlbGYuX3F1ZXJ5LCAnQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHJldHVybkNoYW5nZXMgPGJvb2w+LCBkdXJhYmlsaXR5IDxzdHJpbmc+LCBjb25mbGljdCA8c3RyaW5nPicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obmV3VmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMSwgMikgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHNlbGYuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIDIsICd1cGRhdGUnLCBzZWxmKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlVQREFURSk7XG4gIHZhciBhcmdzID0gW3NlbGYsIG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIobmV3VmFsdWUpLl93cmFwKCldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBoZWxwZXIubG9vcEtleXMob3B0aW9ucywgZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgIGlmICgoa2V5ICE9PSAncmV0dXJuQ2hhbmdlcycpICYmIChrZXkgIT09ICdkdXJhYmlsaXR5JykgJiYgKGtleSAhPT0gJ25vbkF0b21pYycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGB1cGRhdGVgJywgc2VsZi5fcXVlcnksICdBdmFpbGFibGUgb3B0aW9ucyBhcmUgcmV0dXJuQ2hhbmdlcyA8Ym9vbD4sIGR1cmFiaWxpdHkgPHN0cmluZz4sIG5vbkF0b21pYyA8Ym9vbD4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zKSkuX3F1ZXJ5KTtcbiAgfVxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihuZXdWYWx1ZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ3JlcGxhY2UnLCBzZWxmKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlJFUExBQ0UpO1xuICB2YXIgYXJncyA9IFtzZWxmLCBuZXcgVGVybShzZWxmLl9yKS5leHByKG5ld1ZhbHVlKS5fd3JhcCgpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG5cbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoKGtleSAhPT0gJ3JldHVybkNoYW5nZXMnKSAmJiAoa2V5ICE9PSAnZHVyYWJpbGl0eScpICYmIChrZXkgIT09ICdub25BdG9taWMnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgcmVwbGFjZWAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSByZXR1cm5DaGFuZ2VzIDxib29sPiwgZHVyYWJpbGl0eSA8c3RyaW5nPiwgbm9uQXRvbWljIDxib29sPicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMCwgMSwgJ2RlbGV0ZScsIHNlbGYpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybShzZWxmLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuREVMRVRFKTtcbiAgdmFyIGFyZ3MgPSBbc2VsZl07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdyZXR1cm5DaGFuZ2VzJykgJiYgKGtleSAhPT0gJ2R1cmFiaWxpdHknKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgZGVsZXRlYCcsIHNlbGYuX3F1ZXJ5LCAnQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHJldHVybkNoYW5nZXMgPGJvb2w+LCBkdXJhYmlsaXR5IDxzdHJpbmc+Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucykpLl9xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnc3luYycsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuU1lOQylcbiAgdmFyIGFyZ3MgPSBbdGhpcy5fcXVlcnldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5cbi8vIFNlbGVjdGluZyBkYXRhXG5UZXJtLnByb3RvdHlwZS5kYiA9IGZ1bmN0aW9uKGRiKSB7XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdkYicpO1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2RiJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5EQilcbiAgdmFyIGFyZ3MgPSBbbmV3IFRlcm0odGhpcy5fcikuZXhwcihkYildO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKHRhYmxlLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBzZWxmLl9hcml0eVJhbmdlKF9hcmdzLCAxLCAyLCAndGFibGUnLCBzZWxmKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlRBQkxFKVxuXG4gIHZhciBhcmdzID0gW107XG4gIGlmIChBcnJheS5pc0FycmF5KHNlbGYuX3F1ZXJ5KSAmJiAoc2VsZi5fcXVlcnkubGVuZ3RoID4gMCkpIHtcbiAgICBhcmdzLnB1c2goc2VsZik7XG4gIH1cbiAgYXJncy5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodGFibGUpKVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBoZWxwZXIubG9vcEtleXMob3B0aW9ucywgZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgIGlmIChrZXkgIT09ICdyZWFkTW9kZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVW5yZWNvZ25pemVkIG9wdGlvbiBgJytrZXkrJ2AgaW4gYHRhYmxlYCcsIHNlbGYuX3F1ZXJ5LCAnQXZhaWxhYmxlIG9wdGlvbiBpcyByZWFkTW9kZSA8c3RyaW5nPicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocHJpbWFyeUtleSkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2dldCcsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuR0VUKTtcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihwcmltYXJ5S2V5KV1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24oKSB7XG4gIC8vIFdlIGV4cGxpY2l0bHkgX2FyZ3MgaGVyZSwgc28gZmFzdEFyaXR5UmFuZ2UgaXMgbm90IHVzZWZ1bFxuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuR0VUX0FMTCk7XG5cbiAgdmFyIGFyZ3MgPSBbXTtcbiAgYXJncy5wdXNoKHRoaXMpO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIGlmICgoX2FyZ3MubGVuZ3RoID4gMCkgJiYgKGhlbHBlci5pc1BsYWluT2JqZWN0KF9hcmdzW19hcmdzLmxlbmd0aC0xXSkpICYmIChfYXJnc1tfYXJncy5sZW5ndGgtMV0uaW5kZXggIT09IHVuZGVmaW5lZCkpIHtcbiAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhfYXJnc1tfYXJncy5sZW5ndGgtMV0pKS5fcXVlcnkpO1xuICB9XG4gIGVsc2UgaWYgKF9hcmdzLmxlbmd0aCA+IDApIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tfYXJncy5sZW5ndGgtMV0pKVxuICAgIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuYmV0d2VlbiA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMiwgMykgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHNlbGYuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIDMsICdiZXR3ZWVuJywgc2VsZik7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHNlbGYuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5CRVRXRUVOKTtcbiAgdmFyIGFyZ3MgPSBbc2VsZiwgbmV3IFRlcm0oc2VsZi5fcikuZXhwcihzdGFydCksIG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIoZW5kKV1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG5cbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoKGtleSAhPT0gJ2luZGV4JykgJiYgKGtleSAhPT0gJ2xlZnRCb3VuZCcpICYmIChrZXkgIT09ICdyaWdodEJvdW5kJykpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgYmV0d2VlbmAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSBpbmRleCA8c3RyaW5nPiwgbGVmdEJvdW5kIDxzdHJpbmc+LCByaWdodEJvdW5kIDxzdHJpbmc+Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucykpLl9xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5taW52YWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTUlOVkFMKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5tYXh2YWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTUFYVkFMKTtcbiAgcmV0dXJuIHRlcm07XG59XG5cblRlcm0ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlciwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ2ZpbHRlcicsIHNlbGYpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybShzZWxmLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRklMVEVSKTtcbiAgdmFyIGFyZ3MgPSBbc2VsZiwgbmV3IFRlcm0oc2VsZi5fcikuZXhwcihmaWx0ZXIpLl93cmFwKCldXG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKGtleSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGBmaWx0ZXJgJywgc2VsZi5fcXVlcnksICdBdmFpbGFibGUgb3B0aW9uIGlzIGZpbHRlcicpO1xuICAgICAgfVxuICAgIH0pXG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucykpLl9xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5cbi8vIEpvaW5zXG5UZXJtLnByb3RvdHlwZS5pbm5lckpvaW4gPSBmdW5jdGlvbihzZXF1ZW5jZSwgcHJlZGljYXRlKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMikgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAyLCAnaW5uZXJKb2luJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5JTk5FUl9KT0lOKTtcbiAgdmFyIGFyZ3MgPSBbdGhpcy5fcXVlcnldO1xuICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihzZXF1ZW5jZSkuX3F1ZXJ5KTtcbiAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIocHJlZGljYXRlKS5fd3JhcCgpLl9xdWVyeSk7XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUub3V0ZXJKb2luID0gZnVuY3Rpb24oc2VxdWVuY2UsIHByZWRpY2F0ZSkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMiwgJ291dGVySm9pbicsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuT1VURVJfSk9JTik7XG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihzZXF1ZW5jZSkpO1xuICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihwcmVkaWNhdGUpLl93cmFwKCkpO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmVxSm9pbiA9IGZ1bmN0aW9uKHJpZ2h0S2V5LCBzZXF1ZW5jZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAyLCAzKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMiwgMywgJ2VxSm9pbicsIHNlbGYpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybShzZWxmLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRVFfSk9JTik7XG4gIHZhciBhcmdzID0gW3NlbGZdO1xuICBhcmdzLnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcihyaWdodEtleSkuX3dyYXAoKSk7XG4gIGFyZ3MucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHNlcXVlbmNlKSk7XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdpbmRleCcpICYmIChrZXkgIT09ICdvcmRlcmVkJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVW5yZWNvZ25pemVkIG9wdGlvbiBgJytrZXkrJ2AgaW4gYGVxSm9pbmAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSBpbmRleCA8c3RyaW5nPiwgb3JkZXJlZCA8Ym9vbGVhbj4nKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuemlwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnemlwJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5aSVApO1xuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuXG5cblxuLy8gVHJhbnNmb3JtYXRpb25cblRlcm0ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnbWFwJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTUFQKTtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuX3F1ZXJ5KSB8fCAodGhpcy5fcXVlcnkubGVuZ3RoID4gMCkpIHtcbiAgICBhcmdzLnB1c2godGhpcyk7XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoLTE7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBwdXNoIHVuZGVmaW5lZCBpZiBubyBhcmd1bWVudCBpcyBwYXNzZWQgdG8gbWFwLFxuICAvLyBpbiB3aGljaCBjYXNlIHRoZSBzZXJ2ZXIgd2lsbCBoYW5kbGUgdGhlIGNhc2UgYW5kIHJldHVybiBhbiBlcnJvci5cbiAgaWYgKF9hcmdzLmxlbmd0aD4gMCkge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW19hcmdzLmxlbmd0aC0xXSkuX3dyYXAoKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLndpdGhGaWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ3dpdGhGaWVsZHMnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5XSVRIX0ZJRUxEUyk7XG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmNvbmNhdE1hcCA9IGZ1bmN0aW9uKHRyYW5zZm9ybWF0aW9uKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnY29uY2F0TWFwJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5DT05DQVRfTUFQKTtcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKHRyYW5zZm9ybWF0aW9uKS5fd3JhcCgpKVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLm9yZGVyQnkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ29yZGVyQnknLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5PUkRFUl9CWSk7XG5cbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aC0xOyBpKyspIHtcbiAgICBpZiAoKF9hcmdzW2ldIGluc3RhbmNlb2YgVGVybSkgJiZcbiAgICAgICAgKChfYXJnc1tpXS5fcXVlcnlbMF0gPT09IHRlcm1UeXBlcy5ERVNDKSB8fCAoX2FyZ3NbaV0uX3F1ZXJ5WzBdID09PSB0ZXJtVHlwZXMuQVNDKSkpIHtcbiAgICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkuX3dyYXAoKSlcbiAgICB9XG4gIH1cbiAgLy8gV2UgYWN0dWFsbHkgZG9uJ3QgbmVlZCB0byBtYWtlIHRoZSBkaWZmZXJlbmNlIGhlcmUsIGJ1dC4uLlxuICBpZiAoKF9hcmdzLmxlbmd0aCA+IDApICYmIChoZWxwZXIuaXNQbGFpbk9iamVjdChfYXJnc1tfYXJncy5sZW5ndGgtMV0pKSAmJiAoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdLmluZGV4ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdKSkuX3F1ZXJ5KTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoKF9hcmdzW19hcmdzLmxlbmd0aC0xXSBpbnN0YW5jZW9mIFRlcm0pICYmXG4gICAgICAoKF9hcmdzW19hcmdzLmxlbmd0aC0xXS5fcXVlcnlbMF0gPT09IHRlcm1UeXBlcy5ERVNDKSB8fCAoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdLl9xdWVyeVswXSA9PT0gdGVybVR5cGVzLkFTQykpKSB7XG4gICAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tfYXJncy5sZW5ndGgtMV0pKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW19hcmdzLmxlbmd0aC0xXSkuX3dyYXAoKSlcbiAgICB9XG4gICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG5cbn1cblRlcm0ucHJvdG90eXBlLmRlc2MgPSBmdW5jdGlvbihmaWVsZCkge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAnZGVzYycpO1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2Rlc2MnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkRFU0MpXG4gIHZhciBhcmdzID0gW25ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZmllbGQpLl93cmFwKCldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5hc2MgPSBmdW5jdGlvbihmaWVsZCkge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAnYXNjJyk7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnYXNjJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5BU0MpXG4gIHZhciBhcmdzID0gW25ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZmllbGQpLl93cmFwKCldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdza2lwJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5TS0lQKVxuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKHZhbHVlKV1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2xpbWl0JywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5MSU1JVClcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcih2YWx1ZSldXG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMSwgMikgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIDMsICdzbGljZScsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuU0xJQ0UpO1xuXG4gIHZhciBhcmdzID0gW107XG4gIGFyZ3MucHVzaCh0aGlzKTtcbiAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoc3RhcnQpKTtcblxuICBpZiAoKGVuZCAhPT0gdW5kZWZpbmVkKSAmJiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSkge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKGVuZCkpO1xuICAgIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIGVsc2UgaWYgKChlbmQgIT09IHVuZGVmaW5lZCkgJiYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3QoZW5kKSA9PT0gZmFsc2UpIHtcbiAgICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKGVuZCkpO1xuICAgICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gICAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhlbmQpKS5fcXVlcnkpO1xuICAgIH1cbiAgfVxuICBlbHNlIHsgLy8gZW5kIGFuZCBvcHRpb25zIGFyZSBib3RoIHVuZGVmaW5lZFxuICAgIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUubnRoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdudGgnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk5USClcbiAgdmFyIGFyZ3MgPSBbdGhpcy5fcXVlcnksIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIodmFsdWUpXVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5vZmZzZXRzT2YgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdpbmRleGVzT2YnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk9GRlNFVFNfT0YpXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIocHJlZGljYXRlKS5fd3JhcCgpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuaW5kZXhlc09mID0gVGVybS5wcm90b3R5cGUub2Zmc2V0c09mO1xuXG5UZXJtLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnaXNFbXB0eScsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSVNfRU1QVFkpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuVU5JT04pXG4gIHZhciBhcmdzID0gW107XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl9xdWVyeSkgfHwgKHRoaXMuX3F1ZXJ5Lmxlbmd0aCA+IDApKSB7XG4gICAgYXJncy5wdXNoKHRoaXMpO1xuICB9XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aC0xOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgaWYgKChfYXJncy5sZW5ndGggPiAxKSAmJiAoaGVscGVyLmlzUGxhaW5PYmplY3QoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdKSkgJiYgKF9hcmdzW19hcmdzLmxlbmd0aC0xXS5pbnRlcmxlYXZlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdKSkuX3F1ZXJ5KTtcbiAgfVxuICBlbHNlIGlmIChfYXJncy5sZW5ndGggPiAwKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdKSlcbiAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgfVxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdzYW1wbGUnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlNBTVBMRSlcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihzaXplKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuLy8gQWdncmVnYXRpb25zXG5UZXJtLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAncmVkdWNlJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5SRURVQ0UpXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZnVuYykuX3dyYXAoKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAwLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMCwgMSwgJ2NvdW50JywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5DT1VOVCk7XG4gIHZhciBhcmdzID0gW107XG4gIGFyZ3MucHVzaCh0aGlzKTtcbiAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZmlsdGVyKS5fd3JhcCgpKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmRpc3RpbmN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgc2VsZj0gdGhpcztcbiAgaWYgKHNlbGYuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDAsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBzZWxmLl9hcml0eVJhbmdlKF9hcmdzLCAwLCAxLCAnZGlzdGluY3QnLCBzZWxmKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkRJU1RJTkNUKVxuICB2YXIgYXJncyA9IFtzZWxmXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG5cbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdmFyIGtlZXBHb2luZyA9IHRydWU7XG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoKGtlZXBHb2luZyA9PT0gdHJ1ZSkgJiYgKGtleSAhPT0gJ2luZGV4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVW5yZWNvZ25pemVkIG9wdGlvbiBgJytrZXkrJ2AgaW4gYGRpc3RpbmN0YCcsIHNlbGYuX3F1ZXJ5LCAnQXZhaWxhYmxlIG9wdGlvbiBpcyBpbmRleDogPHN0cmluZz4nKTtcbiAgICAgICAga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGtlZXBHb2luZyA9PT0gdHJ1ZSkge1xuICAgICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucykpLl9xdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMSwgSW5maW5pdHksICdncm91cCcsIHNlbGYpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkdST1VQKTtcbiAgdmFyIGFyZ3MgPSBbc2VsZl07XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aC0xOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcihfYXJnc1tpXSkuX3dyYXAoKSlcbiAgfVxuICBpZiAoX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChfYXJnc1tfYXJncy5sZW5ndGgtMV0pKSB7XG4gICAgICBoZWxwZXIubG9vcEtleXMoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICAgaWYgKChrZXkgIT09ICdpbmRleCcpXG4gICAgICAgICYmIChrZXkgIT09ICAnbXVsdGknKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGBncm91cGAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSBpbmRleDogPHN0cmluZz4sIG11bHRpIDxib29sZWFuPicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICAgICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMoX2FyZ3NbX2FyZ3MubGVuZ3RoLTFdKSkuX3F1ZXJ5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhcmdzLnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcihfYXJnc1tfYXJncy5sZW5ndGgtMV0pLl93cmFwKCkpXG4gICAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIH1cblxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBtYXgpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDAsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAwLCAyLCAnc3BsaXQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlNQTElUKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgaWYgKHNlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoc2VwYXJhdG9yKSlcbiAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKG1heCkpXG4gICAgfVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS51bmdyb3VwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAndW5ncm91cCcsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuVU5HUk9VUClcbiAgdmFyIGFyZ3MgPSBbdGhpcy5fcXVlcnldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnY29udGFpbnMnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5DT05UQUlOUylcbiAgdmFyIGFyZ3MgPSBbdGhpcy5fcXVlcnldO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKS5fd3JhcCgpKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAwLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMCwgMSwgJ3N1bScsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuU1VNKTtcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGlmIChmaWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZmllbGQpLl93cmFwKCkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuYXZnID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDAsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAwLCAxLCAnYXZnJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5BVkcpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBpZiAoZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKGZpZWxkKS5fd3JhcCgpKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAwLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMCwgMSwgJ21pbicsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTUlOKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgaWYgKGZpZWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3QoZmllbGQpKSB7XG4gICAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKGZpZWxkKSkuX3F1ZXJ5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihmaWVsZCkuX3dyYXAoKSk7XG4gICAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDAsIDEsICdtYXgnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk1BWClcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGlmIChmaWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KGZpZWxkKSkge1xuICAgICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gICAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhmaWVsZCkpLl9xdWVyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZmllbGQpLl93cmFwKCkpXG4gICAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oYmFzZSwgZnVuYywgb3B0aW9ucykge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMiwgMykgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDIsIDMsICdyYW5nZScsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRk9MRClcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihiYXNlKSwgbmV3IFRlcm0odGhpcy5fcikuZXhwcihmdW5jKS5fd3JhcCgpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdlbWl0JykgJiYgKGtleSAhPT0gJ2ZpbmFsRW1pdCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGBmb2xkYC4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIGVtaXQgPGZ1bmN0aW9uPiwgZmluYWxFbWl0IDxmdW5jdGlvbj4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zKSkuX3F1ZXJ5KTtcbiAgfVxuICByZXR1cm4gdGVybTtcbn1cblxuXG5cbi8vIERvY3VtZW50IG1hbmlwdWxhdGlvblxuVGVybS5wcm90b3R5cGUucm93ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdyb3cnKTtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAwKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDAsICdyLnJvdycsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSU1QTElDSVRfVkFSKVxuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnBsdWNrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMSwgSW5maW5pdHksICdwbHVjaycsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlBMVUNLKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUud2l0aG91dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnd2l0aG91dCcsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLldJVEhPVVQpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKGFyZykge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnbWVyZ2UnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5NRVJHRSlcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pLl93cmFwKCkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUubGl0ZXJhbCA9IGZ1bmN0aW9uKG9iaikge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAnbGl0ZXJhbCcpO1xuICAvLyBUaGUgdGVzdCBmb3IgYXJpdHkgaXMgcGVyZm9ybWVkIGluIHIubGl0ZXJhbFxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkxJVEVSQUwpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYXJncyA9IFtuZXcgVGVybSh0aGlzLl9yKS5leHByKG9iaildO1xuICAgIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdhcHBlbmQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkFQUEVORClcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcih2YWx1ZSldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdwcmVwZW5kJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5QUkVQRU5EKVxuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKHZhbHVlKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2RpZmZlcmVuY2UnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkRJRkZFUkVOQ0UpXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIob3RoZXIpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc2V0SW5zZXJ0ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdzZXRJbnNlcnQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlNFVF9JTlNFUlQpXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIob3RoZXIpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc2V0VW5pb24gPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ3NldFVuaW9uJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5TRVRfVU5JT04pXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIob3RoZXIpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc2V0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdzZXRJbnRlcnNlY3Rpb24nLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlNFVF9JTlRFUlNFQ1RJT04pXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIob3RoZXIpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc2V0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnc2V0RGlmZmVyZW5jZScsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuU0VUX0RJRkZFUkVOQ0UpXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIob3RoZXIpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJyguLi4pJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5HRVRfRklFTEQpXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZmllbGQpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuYnJhY2tldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnKC4uLiknLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkJSQUNLRVQpXG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZmllbGQpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS5oYXNGaWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ2hhc0ZpZWxkcycsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkhBU19GSUVMRFMpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG5cbn1cblRlcm0ucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMikgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAyLCAnaW5zZXJ0QXQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLklOU0VSVF9BVClcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihpbmRleCksIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIodmFsdWUpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc3BsaWNlQXQgPSBmdW5jdGlvbihpbmRleCwgYXJyYXkpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCAyLCAnc3BsaWNlQXQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlNQTElDRV9BVClcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihpbmRleCksIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoYXJyYXkpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZGVsZXRlQXQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ2RlbGV0ZUF0JywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5ERUxFVEVfQVQpO1xuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKHN0YXJ0KV07XG4gIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKGVuZCkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuY2hhbmdlQXQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCAyLCAnY2hhbmdlQXQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkNIQU5HRV9BVCk7XG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihpbmRleCkpXG4gIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKHZhbHVlKSlcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ2tleXMnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLktFWVMpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5cblRlcm0ucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ2tleXMnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlZBTFVFUylcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUub2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdGhpcy5fbm9QcmVmaXgodGhpcywgJ29iamVjdCcpO1xuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAwLCBJbmZpbml0eSwgJ29iamVjdCcsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk9CSkVDVClcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuXG5cblxuLy8gU3RyaW5nXG5UZXJtLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHJlZ2V4KSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnbWF0Y2gnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk1BVENIKVxuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKHJlZ2V4KV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnVwY2FzZSA9IGZ1bmN0aW9uKHJlZ2V4KSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAndXBjYXNlJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5VUENBU0UpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5kb3duY2FzZSA9IGZ1bmN0aW9uKHJlZ2V4KSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAndXBjYXNlJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5ET1dOQ0FTRSlcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuXG5cblxuLy8gTWF0aCBhbmQgTG9naWNcblRlcm0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnYWRkJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuQUREKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMSwgSW5maW5pdHksICdzdWInLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5TVUIpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ211bCcsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk1VTClcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnZGl2JywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRElWKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24oYikge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ21vZCcsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTU9EKVxuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKGIpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5BTkQpXG4gIHZhciBhcmdzID0gW107XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl9xdWVyeSkgfHwgKHRoaXMuX3F1ZXJ5Lmxlbmd0aCA+IDApKSB7XG4gICAgYXJncy5wdXNoKHRoaXMpO1xuICB9XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5PUilcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuX3F1ZXJ5KSB8fCAodGhpcy5fcXVlcnkubGVuZ3RoID4gMCkpIHtcbiAgICBhcmdzLnB1c2godGhpcyk7XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ2VxJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRVEpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5uZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnbmUnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5ORSlcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ2d0JywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuR1QpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5nZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMSwgSW5maW5pdHksICdnZScsIHRoaXMpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkdFKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUubHQgPSBmdW5jdGlvbihvdGhlcikge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDEsIEluZmluaXR5LCAnbHQnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5MVClcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmxlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCBJbmZpbml0eSwgJ2xlJywgdGhpcyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTEUpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAwKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDAsICdub3QnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk5PVClcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnJhbmRvbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fbm9QcmVmaXgodGhpcywgJ3JhbmRvbScpO1xuICBzZWxmLl9hcml0eVJhbmdlKF9hcmdzLCAwLCAzLCAncmFuZG9tJywgc2VsZik7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybShzZWxmLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuUkFORE9NKTtcblxuICB2YXIgYXJncyA9IFtdO1xuICBmb3IodmFyIGk9MDsgaTxfYXJncy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIGlmIChfYXJncy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KF9hcmdzW19hcmdzLmxlbmd0aC0xXSkpIHtcbiAgICAgIGhlbHBlci5sb29wS2V5cyhfYXJnc1tfYXJncy5sZW5ndGgtMV0sIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdmbG9hdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgcmFuZG9tYCcsIHNlbGYuX3F1ZXJ5LCAnQXZhaWxhYmxlIG9wdGlvbiBpcyBmbG9hdDogPGJvb2xlYW4+Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gICAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhfYXJnc1tfYXJncy5sZW5ndGgtMV0pKS5fcXVlcnkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFyZ3MucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKF9hcmdzW19hcmdzLmxlbmd0aC0xXSkpXG4gICAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDAsIDEsICdmbG9vcicsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRkxPT1IpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAwLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMCwgMSwgJ2NlaWwnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkNFSUwpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5UmFuZ2UoX2FyZ3MsIDAsIDEsICdyb3VuZCcsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuUk9VTkQpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5cbi8vIERhdGVzIGFuZCB0aW1lc1xuVGVybS5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdub3cnKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5OT1cpXG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUudGltZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICd0aW1lJyk7XG4gIC8vIFNwZWNpYWwgY2hlY2sgZm9yIGFyaXR5XG4gIHZhciBmb3VuZEFyZ3MgPSBmYWxzZTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKF9hcmdzW2ldIGluc3RhbmNlb2YgVGVybSkgJiYgKF9hcmdzW2ldLl9xdWVyeVswXSA9PT0gdGVybVR5cGVzLkFSR1MpKSB7XG4gICAgICBmb3VuZEFyZ3MgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChmb3VuZEFyZ3MgPT09IGZhbHNlKSB7XG4gICAgaWYgKChfYXJncy5sZW5ndGggIT09IDQpICYmIChfYXJncy5sZW5ndGggIT09IDcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdgci50aW1lYCBjYWxsZWQgd2l0aCAnK19hcmdzLmxlbmd0aCsnIGFyZ3VtZW50JysoKF9hcmdzLmxlbmd0aD4xKT8ncyc6JycpLCBudWxsLCAnYHIudGltZWAgdGFrZXMgNCBvciA3IGFyZ3VtZW50cycpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlRJTUUpXG4gIHZhciBhcmdzID0gW107XG4gIGZvcih2YXIgaT0wOyBpPF9hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmVwb2NoVGltZSA9IGZ1bmN0aW9uKGVwb2NoVGltZSkge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAnZXBvY2hUaW1lJyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRVBPQ0hfVElNRSlcbiAgdmFyIGFyZ3MgPSBbbmV3IFRlcm0odGhpcy5fcikuZXhwcihlcG9jaFRpbWUpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuSVNPODYwMSA9IGZ1bmN0aW9uKGlzb1RpbWUsIG9wdGlvbnMpIHtcbiAgdGhpcy5fbm9QcmVmaXgodGhpcywgJ0lTTzg2MDEnKTtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCAyLCAnSVNPODYwMScsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSVNPODYwMSlcbiAgdmFyIGFyZ3MgPSBbbmV3IFRlcm0odGhpcy5fcikuZXhwcihpc29UaW1lKS5fcXVlcnldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoa2V5ICE9PSAnZGVmYXVsdFRpbWV6b25lJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgSVNPODYwMWAuIEF2YWlsYWJsZSBvcHRpb25zIGFyZSBwcmltYXJ5S2V5IDxzdHJpbmc+LCBkdXJhYmlsaXR5IDxzdHJpbmc+LCBkYXRhbmNlbnRlciA8c3RyaW5nPicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5pblRpbWV6b25lID0gZnVuY3Rpb24odGltZXpvbmUpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdpblRpbWV6b25lJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5JTl9USU1FWk9ORSlcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcih0aW1lem9uZSldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS50aW1lem9uZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ3RpbWV6b25lJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5USU1FWk9ORSlcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmR1cmluZyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAyLCAzKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMiwgMywgJ2R1cmluZycsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRFVSSU5HKTtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgYXJncy5wdXNoKHRoaXMpO1xuICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihsZWZ0KSk7XG4gIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKHJpZ2h0KSk7XG5cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ2RhdGUnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkRBVEUpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS50aW1lT2ZEYXkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAwKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDAsICd0aW1lT2ZEYXknLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlRJTUVfT0ZfREFZKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUueWVhciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ3llYXInLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLllFQVIpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5tb250aCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ21vbnRoJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5NT05USClcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmRheSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ2RheScsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuREFZKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZGF5T2ZZZWFyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnZGF5T2ZZZWFyJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5EQVlfT0ZfWUVBUilcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmRheU9mV2VlayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ2RheU9mV2VlaycsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuREFZX09GX1dFRUspXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5ob3VycyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ2hvdXJzJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5IT1VSUylcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLm1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAwKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDAsICdtaW51dGVzJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5NSU5VVEVTKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ3NlY29uZHMnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlNFQ09ORFMpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS50b0lTTzg2MDEgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAwKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDAsICd0b0lTTzg2MDEnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlRPX0lTTzg2MDEpXG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS50b0Vwb2NoVGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ3RvRXBvY2hUaW1lJywgdGhpcyk7XG4gIH1cblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5UT19FUE9DSF9USU1FKVxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUubW9uZGF5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk1PTkRBWSk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUudHVlc2RheSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5UVUVTREFZKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS53ZWRuZXNkYXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuV0VETkVTREFZKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS50aHVyc2RheSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5USFVSU0RBWSk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZnJpZGF5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkZSSURBWSk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc2F0dXJkYXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuU0FUVVJEQVkpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnN1bmRheSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5TVU5EQVkpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUuamFudWFyeSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5KQU5VQVJZKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5mZWJydWFyeSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5GRUJSVUFSWSk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUubWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTUFSQ0gpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmFwcmlsID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkFQUklMKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5tYXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTUFZKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5qdW5lID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkpVTkUpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmp1bHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSlVMWSk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuYXVndXN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkFVR1VTVCk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuc2VwdGVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlNFUFRFTUJFUik7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUub2N0b2JlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5PQ1RPQkVSKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5ub3ZlbWJlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5OT1ZFTUJFUik7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZGVjZW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuREVDRU1CRVIpO1xuICByZXR1cm4gdGVybTtcbn1cblxuXG5UZXJtLnByb3RvdHlwZS5hcmdzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdGhpcy5fbm9QcmVmaXgodGhpcywgJ2FyZ3MnKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5BUkdTKTtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZG8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkZVTkNBTEwpO1xuICB2YXIgYXJncyA9IFtdO1xuICBpZiAoX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW19hcmdzLmxlbmd0aC0xXSkuX3dyYXAoKS5fcXVlcnkpO1xuICB9XG4gIGFyZ3MucHVzaCh0aGlzKTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoLTE7IGkrKykge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKF9hcmdzW2ldKSlcbiAgfVxuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5cblxuVGVybS5wcm90b3R5cGUuYnJhbmNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMiwgSW5maW5pdHksICcnLCB0aGlzKTtcblxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5CUkFOQ0gpXG4gIHZhciBhcmdzID0gW107XG4gIGFyZ3MucHVzaCh0aGlzKTtcbiAgZm9yKHZhciBpPTA7IGk8X2xlbjsgaSsrKSB7XG4gICAgYXJncy5wdXNoKG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoX2FyZ3NbaV0pKVxuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmdW5jKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnZm9yRWFjaCcsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRk9SX0VBQ0gpO1xuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKGZ1bmMpLl93cmFwKCldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2RlZmF1bHQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkRFRkFVTFQpO1xuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKGV4cHJlc3Npb24pXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZXhwciA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIG5lc3RpbmdMZXZlbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX25vUHJlZml4KHNlbGYsICdleHByJyk7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ2V4cHInLCBzZWxmKTtcbiAgfVxuXG4gIC8vIHVuZGVmaW5lZCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgbGFzdCBlbHNlXG4gIHZhciBhciwgb2JqO1xuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXJyb3IgPSAnQ2Fubm90IGNvbnZlcnQgYHVuZGVmaW5lZGAgd2l0aCByLmV4cHIoKSc7XG4gICAgcmV0dXJuIG5ldyBUZXJtKHNlbGYuX3IsIGV4cHJlc3Npb24sIGVycm9yKTtcbiAgfVxuXG4gIHZhciBfbmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsO1xuICBpZiAoX25lc3RpbmdMZXZlbCA9PSBudWxsKSB7XG4gICAgX25lc3RpbmdMZXZlbCA9IHNlbGYuX3IubmVzdGluZ0xldmVsO1xuICB9XG4gIC8vaWYgKG5lc3RpbmdMZXZlbCA9PSBudWxsKSBuZXN0aW5nTGV2ZWwgPSBzZWxmLl9yLm5lc3RpbmdMZXZlbDtcbiAgaWYgKF9uZXN0aW5nTGV2ZWwgPCAwKSB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdOZXN0aW5nIGRlcHRoIGxpbWl0IGV4Y2VlZGVkLlxcbllvdSBwcm9iYWJseSBoYXZlIGEgY2lyY3VsYXIgcmVmZXJlbmNlIHNvbWV3aGVyZScpXG5cbiAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBUZXJtKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG4gIH1cbiAgZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jKHNlbGYuX3IsIGV4cHJlc3Npb24pO1xuICB9XG4gIGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtKHNlbGYuX3IpLklTTzg2MDEoZXhwcmVzc2lvbi50b0lTT1N0cmluZygpKVxuICB9XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikpIHtcbiAgICB2YXIgdGVybSA9IG5ldyBUZXJtKHNlbGYuX3IpO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLk1BS0VfQVJSQVkpO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcihleHByZXNzaW9uW2ldLCBfbmVzdGluZ0xldmVsLTEpKVxuICAgIH1cbiAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgICByZXR1cm4gdGVybTtcbiAgfVxuICBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgcmV0dXJuIHNlbGYuX3IuYmluYXJ5KGV4cHJlc3Npb24pO1xuICB9XG4gIGVsc2UgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KGV4cHJlc3Npb24pKSB7XG4gICAgdmFyIHRlcm0gPSBuZXcgVGVybShzZWxmLl9yKTtcbiAgICB2YXIgb3B0QXJncyA9IHt9O1xuICAgIHZhciBmb3VuZEVycm9yID0gZmFsc2U7XG4gICAgaGVscGVyLmxvb3BLZXlzKGV4cHJlc3Npb24sIGZ1bmN0aW9uKGV4cHJlc3Npb24sIGtleSkge1xuICAgICAgaWYgKGV4cHJlc3Npb25ba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcHRBcmcgPSBuZXcgVGVybShzZWxmLl9yKS5leHByKGV4cHJlc3Npb25ba2V5XSwgX25lc3RpbmdMZXZlbC0xKTtcbiAgICAgICAgaWYgKG9wdEFyZyBpbnN0YW5jZW9mIFRlcm0gJiYgIWZvdW5kRXJyb3IgJiYgb3B0QXJnLl9lcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgICAgdGVybS5fZXJyb3IgPSBvcHRBcmcuX2Vycm9yO1xuICAgICAgICAgIHRlcm0uX2ZyYW1lcyA9IFtrZXldLmNvbmNhdChvcHRBcmcuX2ZyYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0QXJnc1trZXldID0gb3B0QXJnLl9xdWVyeTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXJtLl9xdWVyeSA9IG9wdEFyZ3M7XG4gICAgcmV0dXJuIHRlcm07XG4gIH1cbiAgZWxzZSB7IC8vIFByaW1pdGl2ZVxuICAgIGlmIChleHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm0oc2VsZi5fciwgbnVsbCwgZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKHNlbGYuX3IsIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChleHByZXNzaW9uICE9PSBleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBlcnJvciA9ICdDYW5ub3QgY29udmVydCBgTmFOYCB0byBKU09OJztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKHNlbGYuX3IsIGV4cHJlc3Npb24sIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc0Zpbml0ZShleHByZXNzaW9uKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSAnQ2Fubm90IGNvbnZlcnQgYEluZmluaXR5YCB0byBKU09OJztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtKHNlbGYuX3IsIGV4cHJlc3Npb24sIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVGVybShzZWxmLl9yLCBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIG5ldyBUZXJtKHNlbGYuX3IsIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNlbGYuX2Vycm9yID0gbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignQ2Fubm90IGNvbnZlcnQgYCcrZXhwcmVzc2lvbisnYCB0byBkYXR1bS4nKTtcbiAgICAgIHNlbGYuX2ZyYW1lcyA9IFtdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cblxuVGVybS5wcm90b3R5cGUuYmluYXJ5ID0gZnVuY3Rpb24oYmluKSB7XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdiaW5hcnknKTtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdiaW5hcnknLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtO1xuICBpZiAoYmluIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgLy8gV2UgY291bGQgdXNlIEJJTkFSWSwgYW5kIGNvZXJjZSBgYmluYCB0byBhbiBBU0NJSSBzdHJpbmcsIGJ1dCB0aGF0XG4gICAgLy8gd2lsbCBicmVhayBpZiB0aGVyZSBpcyBhIG51bGwgY2hhclxuICAgIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yLCB7XG4gICAgICAkcmVxbF90eXBlJDogJ0JJTkFSWScsXG4gICAgICBkYXRhOiBiaW4udG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkJJTkFSWSlcbiAgICB2YXIgYXJncyA9IFtuZXcgVGVybSh0aGlzLl9yKS5leHByKGJpbildO1xuICAgIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS5qcyA9IGZ1bmN0aW9uKGFyZywgb3B0aW9ucykge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAnanMnKTtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eVJhbmdlKGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eVJhbmdlKF9hcmdzLCAxLCAyLCAnanMnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkpBVkFTQ1JJUFQpXG4gIHZhciBhcmdzID0gW25ldyBUZXJtKHRoaXMuX3IpLmV4cHIoYXJnKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuY29lcmNlVG8gPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnY29lcmNlVG8nLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkNPRVJDRV9UTylcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcih0eXBlKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnR5cGVPZiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ3R5cGVPZicsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuVFlQRV9PRik7XG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnaW5mbycsIHRoaXMpO1xuICB9XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSU5GTyk7XG4gIHZhciBhcmdzID0gW3RoaXNdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24oanNvbikge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAnanNvbicpO1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2luZm8nLCB0aGlzKTtcbiAgfVxuICAvKlxuICBpZiAoKC9cXFxcdTAwMDAvLnRlc3QoanNvbikpIHx8ICgvXFwwLy50ZXN0KGpzb24pKSkge1xuICAgIHRoaXMuX2Vycm9yID0gbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVGhlIG51bGwgY2hhcmFjdGVyIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGJ5IFJldGhpbmtEQicpO1xuICB9XG4gICovXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkpTT04pO1xuXG4gIHZhciBhcmdzID0gW25ldyBUZXJtKHRoaXMuX3IpLmV4cHIoanNvbildO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5odHRwID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdodHRwJyk7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ2h0dHAnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkhUVFApO1xuICB2YXIgYXJncyA9IFtuZXcgVGVybSh0aGlzLl9yKS5leHByKHVybCldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoKGtleSAhPT0gJ3RpbWVvdXQnKVxuICAgICAgICAmJiAoa2V5ICE9PSAgJ2F0dGVtcHRzJylcbiAgICAgICAgJiYgKGtleSAhPT0gICdyZWRpcmVjdHMnKVxuICAgICAgICAmJiAoa2V5ICE9PSAgJ3ZlcmlmeScpXG4gICAgICAgICYmIChrZXkgIT09ICAncmVzdWx0Rm9ybWF0JylcbiAgICAgICAgJiYgKGtleSAhPT0gICdtZXRob2QnKVxuICAgICAgICAmJiAoa2V5ICE9PSAgJ2F1dGgnKVxuICAgICAgICAmJiAoa2V5ICE9PSAgJ3BhcmFtcycpXG4gICAgICAgICYmIChrZXkgIT09ICAnaGVhZGVyJylcbiAgICAgICAgJiYgKGtleSAhPT0gICdkYXRhJylcbiAgICAgICAgJiYgKGtleSAhPT0gICdwYWdlJylcbiAgICAgICAgJiYgKGtleSAhPT0gICdwYWdlTGltaXQnKVxuICAgICAgICAmJiAoa2V5ICE9PSAgJycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGBodHRwYC4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIGF0dGVtcHRzIDxudW1iZXI+LCByZWRpcmVjdHMgPG51bWJlcj4sIHZlcmlmeSA8Ym9vbGVhbj4sIHJlc3VsdEZvcm1hdDogPHN0cmluZz4sIG1ldGhvZDogPHN0cmluZz4sIGF1dGg6IDxvYmplY3Q+LCBwYXJhbXM6IDxvYmplY3Q+LCBoZWFkZXI6IDxzdHJpbmc+LCBkYXRhOiA8c3RyaW5nPiwgcGFnZTogPHN0cmluZy9mdW5jdGlvbj4sIHBhZ2VMaW1pdDogPG51bWJlcj4nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUudXVpZCA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLl9ub1ByZWZpeCh0aGlzLCAndXVpZCcpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlVVSUQpXG5cbiAgaWYgKHN0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGFyZ3MgPSBbbmV3IFRlcm0odGhpcy5fcikuZXhwcihzdHIpXTtcbiAgICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgfVxuICByZXR1cm4gdGVybTtcbn1cblxuXG5UZXJtLnByb3RvdHlwZS5jaXJjbGUgPSBmdW5jdGlvbihjZW50ZXIsIHJhZGl1cywgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gQXJpdHkgY2hlY2sgaXMgZG9uZSBieSByLmNpcmNsZVxuICBzZWxmLl9ub1ByZWZpeChzZWxmLCAnY2lyY2xlJyk7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkNJUkNMRSk7XG4gIHZhciBhcmdzID0gW25ldyBUZXJtKHNlbGYuX3IpLmV4cHIoY2VudGVyKSwgbmV3IFRlcm0oc2VsZi5fcikuZXhwcihyYWRpdXMpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG5cbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB0cmFuc2xhdGUgaGVyZVxuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdudW1WZXJ0aWNlcycpICYmIChrZXkgIT09ICdnZW9TeXN0ZW0nKSAmJiAoa2V5ICE9PSAndW5pdCcpICYmIChrZXkgIT09ICdmaWxsJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignVW5yZWNvZ25pemVkIG9wdGlvbiBgJytrZXkrJ2AgaW4gYGNpcmNsZWAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSBudW1WZXJ0aWNlcyA8bnVtYmVyPiwgZ2VvU3N5c3RlbSA8c3RyaW5nPiwgdW5pdCA8c3RyaW5nPiBhbmQgZmlsbCA8Ym9vbD4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zKSkuX3F1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiB0ZXJtO1xufVxuVGVybS5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihnZW9tZXRyeSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ2Rpc3RhbmNlJywgc2VsZik7XG4gIH1cbiAgdmFyIHRlcm0gPSBuZXcgVGVybShzZWxmLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuRElTVEFOQ0UpO1xuICB2YXIgYXJncyA9IFtzZWxmLCBuZXcgVGVybShzZWxmLl9yKS5leHByKGdlb21ldHJ5KV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICBpZiAoaGVscGVyLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBoZWxwZXIubG9vcEtleXMob3B0aW9ucywgZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgIGlmICgoa2V5ICE9PSAnZ2VvU3lzdGVtJykgJiYgKGtleSAhPT0gJ3VuaXQnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgZGlzdGFuY2VgJywgc2VsZi5fcXVlcnksICdBdmFpbGFibGUgb3B0aW9ucyBhcmUgZ2VvU3lzdGVtIDxzdHJpbmc+LCB1bml0IDxzdHJpbmc+Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucykpLl9xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG59XG5UZXJtLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnZmlsbCcsIHRoaXMpO1xuICB9XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkZJTEwpO1xuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS5nZW9qc29uID0gZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDEsICdnZW9qc29uJywgdGhpcyk7XG4gIH1cbiAgdGhpcy5fbm9QcmVmaXgodGhpcywgJ2dlb2pzb24nKTtcbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuR0VPSlNPTik7XG4gIHZhciBhcmdzID0gW25ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZ2VvbWV0cnkpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS50b0dlb2pzb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAwKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDAsICd0b0dlb2pzb24nLCB0aGlzKTtcbiAgfVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5UT19HRU9KU09OKTtcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW5nID0gZnVuY3Rpb24oZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgaWYgKHRoaXMuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHkoX2FyZ3MsIDIsICdnZXRJbnRlcnNlY3RpbmcnLCB0aGlzKTtcbiAgfVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5HRVRfSU5URVJTRUNUSU5HKTtcbiAgdmFyIGFyZ3MgPSBbdGhpcywgbmV3IFRlcm0odGhpcy5fcikuZXhwcihnZW9tZXRyeSldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoa2V5ICE9PSAnaW5kZXgnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGBkaXN0YW5jZWAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSBpbmRleCA8c3RyaW5nPicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS5nZXROZWFyZXN0ID0gZnVuY3Rpb24oZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDIpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICBzZWxmLl9hcml0eShfYXJncywgMiwgJ2dldE5lYXJlc3QnLCBzZWxmKTtcbiAgfVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHNlbGYuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5HRVRfTkVBUkVTVCk7XG4gIHZhciBhcmdzID0gW3NlbGYsIG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIoZ2VvbWV0cnkpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgaWYgKChrZXkgIT09ICdpbmRleCcpICYmIChrZXkgIT09ICdtYXhSZXN1bHRzJykgJiYgKGtleSAhPT0gJ21heERpc3QnKSAmJiAoa2V5ICE9PSAndW5pdCcpICYmIChrZXkgIT09ICdnZW9TeXN0ZW0nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgZ2V0TmVhcmVzdGAnLCBzZWxmLl9xdWVyeSwgJ0F2YWlsYWJsZSBvcHRpb25zIGFyZSBpbmRleCA8c3RyaW5nPiwgbWF4UmVzdWx0cyA8bnVtYmVyPiwgbWF4RGlzdCA8bnVtYmVyPiwgdW5pdCA8c3RyaW5nPiwgZ2VvU3lzdGVtIDxzdHJpbmc+Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGVybS5fcXVlcnkucHVzaChuZXcgVGVybShzZWxmLl9yKS5leHByKHRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucykpLl9xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIHRlcm07XG5cbn1cblxuVGVybS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbihnZW9tZXRyeSkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ2luY2x1ZGVzJywgdGhpcyk7XG4gIH1cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuSU5DTFVERVMpO1xuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKGdlb21ldHJ5KV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAxLCAnaW50ZXJzZWN0cycsIHRoaXMpO1xuICB9XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLklOVEVSU0VDVFMpO1xuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKGdlb21ldHJ5KV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUubGluZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIC8vIEFyaXR5IGNoZWNrIGlzIGRvbmUgYnkgci5saW5lXG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdsaW5lJyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuTElORSk7XG5cbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKGxvbmdpdHVkZSwgbGF0aXR1ZGUpIHtcbiAgLy8gQXJpdHkgY2hlY2sgaXMgZG9uZSBieSByLnBvaW50XG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdwb2ludCcpO1xuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlBPSU5UKTtcbiAgdmFyIGFyZ3MgPSBbbmV3IFRlcm0odGhpcy5fcikuZXhwcihsb25naXR1ZGUpLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKGxhdGl0dWRlKV07XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUucG9seWdvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gIC8vIEFyaXR5IGNoZWNrIGlzIGRvbmUgYnkgci5wb2x5Z29uXG4gIHRoaXMuX25vUHJlZml4KHRoaXMsICdwb2x5Z29uJyk7XG5cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuUE9MWUdPTik7XG5cbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8X2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzLnB1c2gobmV3IFRlcm0odGhpcy5fcikuZXhwcihfYXJnc1tpXSkpXG4gIH1cbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cblRlcm0ucHJvdG90eXBlLnBvbHlnb25TdWIgPSBmdW5jdGlvbihnZW9tZXRyeSkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDEpID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMSwgJ3BvbHlnb25TdWInLCB0aGlzKTtcbiAgfVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5QT0xZR09OX1NVQik7XG4gIHZhciBhcmdzID0gW3RoaXMsIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZ2VvbWV0cnkpXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIHJldHVybiB0ZXJtO1xufVxuXG5UZXJtLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5fbm9QcmVmaXgodGhpcywgJ3JhbmdlJyk7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHlSYW5nZShhcmd1bWVudHMubGVuZ3RoLCAxLCAyKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgdGhpcy5fYXJpdHlSYW5nZShfYXJncywgMSwgMiwgJ3IucmFuZ2UnLCB0aGlzKTtcbiAgfVxuICB2YXIgdGVybSA9IG5ldyBUZXJtKHRoaXMuX3IpO1xuICB0ZXJtLl9xdWVyeS5wdXNoKHRlcm1UeXBlcy5SQU5HRSk7XG4gIHZhciBhcmdzID0gW107XG4gIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKHN0YXJ0KSk7XG4gIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFyZ3MucHVzaChuZXcgVGVybSh0aGlzLl9yKS5leHByKGVuZCkpO1xuICB9XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnRvSnNvblN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmFzdEFyaXR5KGFyZ3VtZW50cy5sZW5ndGgsIDApID09PSBmYWxzZSkge1xuICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbik7IGZvcih2YXIgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO31cbiAgICB0aGlzLl9hcml0eShfYXJncywgMCwgJ3RvSlNPTicsIHRoaXMpO1xuICB9XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlRPX0pTT05fU1RSSU5HKTtcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLnRvSlNPTiA9IFRlcm0ucHJvdG90eXBlLnRvSnNvblN0cmluZztcblxuVGVybS5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnY29uZmlnJywgdGhpcyk7XG4gIH1cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuQ09ORklHKTtcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAnc3RhdHVzJywgdGhpcyk7XG4gIH1cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuU1RBVFVTKTtcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUud2FpdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fZmFzdEFyaXR5UmFuZ2UoYXJndW1lbnRzLmxlbmd0aCwgMCwgMSkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHNlbGYuX2FyaXR5UmFuZ2UoX2FyZ3MsIDAsIDEsICd3YWl0Jywgc2VsZik7XG4gIH1cbiAgdmFyIHRlcm0gPSBuZXcgVGVybShzZWxmLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuV0FJVCk7XG4gIHZhciBhcmdzID0gW3NlbGZdO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgaWYgKGhlbHBlci5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaGVscGVyLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgICBpZiAoKGtleSAhPT0gJ3dhaXRGb3InKSAmJiAoa2V5ICE9PSAndGltZW91dCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ1VucmVjb2duaXplZCBvcHRpb24gYCcra2V5KydgIGluIGB3YWl0YCcsIHNlbGYuX3F1ZXJ5LCAnQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHdhaXRGb3I6IDxzdHJpbmc+LCB0aW1lb3V0OiA8bnVtYmVyPicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRlcm0uX3F1ZXJ5LnB1c2gobmV3IFRlcm0oc2VsZi5fcikuZXhwcih0cmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpKS5fcXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cblRlcm0ucHJvdG90eXBlLnJlY29uZmlndXJlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuX2Zhc3RBcml0eShhcmd1bWVudHMubGVuZ3RoLCAxKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pOyBmb3IodmFyIF9pID0gMDsgX2kgPCBfbGVuOyBfaSsrKSB7X2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTt9XG4gICAgc2VsZi5fYXJpdHkoX2FyZ3MsIDEsICdyZWNvbmZpZ3VyZScsIHNlbGYpO1xuICB9XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0oc2VsZi5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlJFQ09ORklHVVJFKTtcblxuICB2YXIgYXJncyA9IFt0aGlzXTtcbiAgdGVybS5fZmlsbEFyZ3MoYXJncyk7XG4gIGlmIChoZWxwZXIuaXNQbGFpbk9iamVjdChjb25maWcpKSB7XG4gICAgaGVscGVyLmxvb3BLZXlzKGNvbmZpZywgZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgIGlmICgoa2V5ICE9PSAnc2hhcmRzJykgJiYgKGtleSAhPT0gJ3JlcGxpY2FzJykgJiZcbiAgICAgICAgKGtleSAhPT0gJ2RyeVJ1bicpICYmIChrZXkgIT09ICdwcmltYXJ5UmVwbGljYVRhZycpICYmXG4gICAgICAgIChrZXkgIT09ICdub252b3RpbmdSZXBsaWNhVGFncycpICYmIChrZXkgIT09ICdlbWVyZ2VuY3lSZXBhaXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdVbnJlY29nbml6ZWQgb3B0aW9uIGAnK2tleSsnYCBpbiBgcmVjb25maWd1cmVgJywgc2VsZi5fcXVlcnksICdBdmFpbGFibGUgb3B0aW9ucyBhcmUgc2hhcmRzOiA8bnVtYmVyPiwgcmVwbGljYXM6IDxudW1iZXI+LCBwcmltYXJ5UmVwbGljYVRhZzogPG9iamVjdD4sIGRyeVJ1biA8Ym9vbGVhbj4sIGVtZXJnZW5jeVJlcGFpcjogPHN0cmluZz4sIG5vbnZvdGluZ1JlcGxpY2FUYWdzOiA8YXJyYXk8c3RyaW5nPj4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXJtLl9xdWVyeS5wdXNoKG5ldyBUZXJtKHNlbGYuX3IpLmV4cHIodHJhbnNsYXRlT3B0aW9ucyhjb25maWcpKS5fcXVlcnkpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG9mIGByZWNvbmZpZ3VyZWAgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICByZXR1cm4gdGVybTtcbn1cblxuVGVybS5wcm90b3R5cGUucmViYWxhbmNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMCkgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAwLCAncmViYWxhbmNlJywgdGhpcyk7XG4gIH1cbiAgdmFyIHRlcm0gPSBuZXcgVGVybSh0aGlzLl9yKTtcbiAgdGVybS5fcXVlcnkucHVzaCh0ZXJtVHlwZXMuUkVCQUxBTkNFKTtcbiAgdmFyIGFyZ3MgPSBbdGhpc107XG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuICByZXR1cm4gdGVybTtcbn1cblRlcm0ucHJvdG90eXBlLmdyYW50ID0gZnVuY3Rpb24obmFtZSwgYWNjZXNzKSB7XG4gIGlmICh0aGlzLl9mYXN0QXJpdHkoYXJndW1lbnRzLmxlbmd0aCwgMikgPT09IGZhbHNlKSB7XG4gICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBfYXJncyA9IG5ldyBBcnJheShfbGVuKTsgZm9yKHZhciBfaSA9IDA7IF9pIDwgX2xlbjsgX2krKykge19hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07fVxuICAgIHRoaXMuX2FyaXR5KF9hcmdzLCAyLCAnZ3JhbnQnLCB0aGlzKTtcbiAgfVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0odGhpcy5fcik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkdSQU5UKVxuICB2YXIgYXJncyA9IFt0aGlzLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKG5hbWUpLCBuZXcgVGVybSh0aGlzLl9yKS5leHByKGFjY2VzcyldO1xuICB0ZXJtLl9maWxsQXJncyhhcmdzKTtcbiAgcmV0dXJuIHRlcm07XG59XG5cblxuVGVybS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5ydW4oKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59XG5UZXJtLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5ydW4oKS5lcnJvcihyZWplY3QpO1xufVxuVGVybS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihyZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMucnVuKCkuY2F0Y2gocmVqZWN0KTtcbn1cblRlcm0ucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIHJldHVybiB0aGlzLnJ1bigpLmZpbmFsbHkoaGFuZGxlcik7XG59XG5UZXJtLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uKG1zZWNzKSB7XG4gIHJldHVybiB0aGlzLnJ1bigpLmRlbGF5KG1zZWNzKTtcbn1cblxuVGVybS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEVycm9yLmdlbmVyYXRlQmFja3RyYWNlKHRoaXMuX3F1ZXJ5LCAwLCBudWxsLCBbXSwge2luZGVudDogMCwgZXh0cmE6IDB9KS5zdHI7XG59XG5cblRlcm0ucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKGhlbHBlci5oYXNJbXBsaWNpdCh0aGlzLl9xdWVyeSkpIHtcbiAgICBpZiAodGhpcy5fcXVlcnlbMF0gPT09IHRlcm1UeXBlcy5BUkdTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdJbXBsaWNpdCB2YXJpYWJsZSBgci5yb3dgIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBgci5hcmdzYCcpXG4gICAgfVxuICAgIC8vTXVzdCBwYXNzIGF0IGxlYXN0IG9uZSB2YXJpYWJsZSB0byB0aGUgZnVuY3Rpb24gb3IgaXQgd29uJ3QgYWNjZXB0IHIucm93XG4gICAgcmV0dXJuIG5ldyBUZXJtKHRoaXMuX3IpLmV4cHIoZnVuY3Rpb24oZG9jKSB7IHJldHVybiBzZWxmOyB9KVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG59XG5cblRlcm0ucHJvdG90eXBlLl9maWxsQXJncyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgdmFyIGZvdW5kRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGludGVybmFsQXJncyA9IFtdO1xuICBmb3IodmFyIGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gIGlmIChhcmdzW2ldIGluc3RhbmNlb2YgVGVybSkge1xuICAgIGludGVybmFsQXJncy5wdXNoKGFyZ3NbaV0uX3F1ZXJ5KTtcbiAgICBpZiAoIWZvdW5kRXJyb3IgJiYgKGFyZ3NbaV0uX2Vycm9yICE9IG51bGwpKSB7XG4gICAgdGhpcy5fZXJyb3IgPSBhcmdzW2ldLl9lcnJvcjtcbiAgICB0aGlzLl9mcmFtZXMgPSBhcmdzW2ldLl9mcmFtZXM7XG4gICAgdGhpcy5fZnJhbWVzLnVuc2hpZnQoaSk7XG4gICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGludGVybmFsQXJncy5wdXNoKGFyZ3NbaV0pO1xuICB9XG4gIH1cbiAgdGhpcy5fcXVlcnkucHVzaChpbnRlcm5hbEFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn1cblxuVGVybS5wcm90b3R5cGUuX3RyYW5zbGF0ZUFyZ3MgPSB7XG4gIHJldHVybkNoYW5nZXM6ICdyZXR1cm5fY2hhbmdlcycsXG4gIGluY2x1ZGVJbml0aWFsOiAnaW5jbHVkZV9pbml0aWFsJyxcbiAgcHJpbWFyeUtleTogJ3ByaW1hcnlfa2V5JyxcbiAgcmVhZE1vZGU6ICdyZWFkX21vZGUnLFxuICBub25BdG9taWM6ICdub25fYXRvbWljJyxcbiAgbGVmdEJvdW5kOiAnbGVmdF9ib3VuZCcsXG4gIHJpZ2h0Qm91bmQ6ICdyaWdodF9ib3VuZCcsXG4gIGRlZmF1bHRUaW1lem9uZTogJ2RlZmF1bHRfdGltZXpvbmUnLFxuICBub1JlcGx5OiAnbm9yZXBseScsXG4gIHJlc3VsdEZvcm1hdDogJ3Jlc3VsdF9mb3JtYXQnLFxuICBwYWdlTGltaXQ6ICdwYWdlX2xpbWl0JyxcbiAgYXJyYXlMaW1pdDogJ2FycmF5X2xpbWl0JyxcbiAgbnVtVmVydGljZXM6ICdudW1fdmVydGljZXMnLFxuICBnZW9TeXN0ZW06ICdnZW9fc3lzdGVtJyxcbiAgbWF4UmVzdWx0czogJ21heF9yZXN1bHRzJyxcbiAgbWF4RGlzdDogJ21heF9kaXN0JyxcbiAgZHJ5UnVuOiAnZHJ5X3J1bicsXG4gIHdhaXRGb3I6ICd3YWl0X2ZvcicsXG4gIGluY2x1ZGVTdGF0ZXM6ICdpbmNsdWRlX3N0YXRlcycsXG4gIHByaW1hcnlSZXBsaWNhVGFnOiAncHJpbWFyeV9yZXBsaWNhX3RhZycsXG4gIGVtZXJnZW5jeVJlcGFpcjogJ2VtZXJnZW5jeV9yZXBhaXInLFxuICBtaW5CYXRjaFJvd3M6ICdtaW5fYmF0Y2hfcm93cycsXG4gIG1heEJhdGNoUm93czogJ21heF9iYXRjaF9yb3dzJyxcbiAgbWF4QmF0Y2hCeXRlczogJ21heF9iYXRjaF9ieXRlcycsXG4gIG1heEJhdGNoU2Vjb25kczogJ21heF9iYXRjaF9zZWNvbmRzJyxcbiAgZmlyc3RCYXRjaFNjYWxlZG93bkZhY3RvcjogJ2ZpcnN0X2JhdGNoX3NjYWxlZG93bl9mYWN0b3InLFxuICBpbmNsdWRlT2Zmc2V0czogJ2luY2x1ZGVfb2Zmc2V0cycsXG4gIGluY2x1ZGVUeXBlczogJ2luY2x1ZGVfdHlwZXMnLFxuICBmaW5hbEVtaXQ6ICdmaW5hbF9lbWl0J1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciB0cmFuc2xhdGVkT3B0ID0ge307XG4gIGhlbHBlci5sb29wS2V5cyhvcHRpb25zLCBmdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcbiAgICB2YXIga2V5U2VydmVyID0gVGVybS5wcm90b3R5cGUuX3RyYW5zbGF0ZUFyZ3Nba2V5XSB8fCBrZXk7XG4gICAgdHJhbnNsYXRlZE9wdFtrZXlTZXJ2ZXJdID0gb3B0aW9uc1trZXldO1xuICB9KTtcbiAgcmV0dXJuIHRyYW5zbGF0ZWRPcHQ7XG59XG5UZXJtLnByb3RvdHlwZS5fc2V0TmVzdGluZ0xldmVsID0gZnVuY3Rpb24obmVzdGluZ0xldmVsKSB7XG4gIFRlcm0ucHJvdG90eXBlLl9uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG59XG5UZXJtLnByb3RvdHlwZS5fc2V0QXJyYXlMaW1pdCA9IGZ1bmN0aW9uKGFycmF5TGltaXQpIHtcbiAgVGVybS5wcm90b3R5cGUuX2FycmF5TGltaXQgPSBhcnJheUxpbWl0O1xufVxuXG5cblRlcm0ucHJvdG90eXBlLl9ub1ByZWZpeCA9IGZ1bmN0aW9uKHRlcm0sIG1ldGhvZCkge1xuICBpZiAoKCFBcnJheS5pc0FycmF5KHRlcm0uX3F1ZXJ5KSkgfHwgKHRlcm0uX3F1ZXJ5Lmxlbmd0aCA+IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yLlJlcWxEcml2ZXJFcnJvcignYCcrbWV0aG9kKydgIGlzIG5vdCBkZWZpbmVkJywgdGVybS5fcXVlcnkpO1xuICB9XG59XG5UZXJtLnByb3RvdHlwZS5fYXJpdHlSYW5nZSA9IGZ1bmN0aW9uKGFyZ3MsIG1pbiwgbWF4LCBtZXRob2QsIHRlcm0pIHtcbiAgdmFyIGZvdW5kQXJncyA9IGZhbHNlO1xuICBpZiAoYXJncy5sZW5ndGggPCBtaW4pIHtcbiAgICBmb3IodmFyIGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKGFyZ3NbaV0gaW5zdGFuY2VvZiBUZXJtKSAmJiAoYXJnc1tpXS5fcXVlcnlbMF0gPT09IHRlcm1UeXBlcy5BUkdTKSkge1xuICAgICAgICBmb3VuZEFyZ3MgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kQXJncyA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ2AnK21ldGhvZCsnYCB0YWtlcyBhdCBsZWFzdCAnK21pbisnIGFyZ3VtZW50JysoKG1pbj4xKT8ncyc6JycpKycsICcrYXJncy5sZW5ndGgrJyBwcm92aWRlZCcsIHRlcm0uX3F1ZXJ5KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYXJncy5sZW5ndGggPiBtYXgpIHtcbiAgICBmb3IodmFyIGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKGFyZ3NbaV0gaW5zdGFuY2VvZiBUZXJtKSAmJiAoYXJnc1tpXS5fcXVlcnlbMF0gPT09IHRlcm1UeXBlcy5BUkdTKSkge1xuICAgICAgICBmb3VuZEFyZ3MgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kQXJncyA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ2AnK21ldGhvZCsnYCB0YWtlcyBhdCBtb3N0ICcrbWF4KycgYXJndW1lbnQnKygobWF4PjEpPydzJzonJykrJywgJythcmdzLmxlbmd0aCsnIHByb3ZpZGVkJywgdGVybS5fcXVlcnkpO1xuICAgIH1cbiAgfVxufVxuVGVybS5wcm90b3R5cGUuX2FyaXR5ID0gZnVuY3Rpb24oYXJncywgbnVtLCBtZXRob2QsIHRlcm0pIHtcbiAgdmFyIGZvdW5kQXJncyA9IGZhbHNlO1xuICBmb3IodmFyIGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChhcmdzW2ldIGluc3RhbmNlb2YgVGVybSkgJiYgKGFyZ3NbaV0uX3F1ZXJ5WzBdID09PSB0ZXJtVHlwZXMuQVJHUykpIHtcbiAgICAgIGZvdW5kQXJncyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGZvdW5kQXJncyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IuUmVxbERyaXZlckVycm9yKCdgJyttZXRob2QrJ2AgdGFrZXMgJytudW0rJyBhcmd1bWVudCcrKChudW0+MSk/J3MnOicnKSsnLCAnK2FyZ3MubGVuZ3RoKycgcHJvdmlkZWQnLCB0ZXJtLl9xdWVyeSk7XG4gIH1cbn1cbi8vIENoZWFwIGFyaXR5IGNoZWNrLiBJZiBpdCBmYWlscywgcmV0dXJuIGZhbHNlLCBhbmQgdGhlbiB3ZSBhcmUgZXhwZWN0ZWQgdG8gY2FsbCBfYXJpdHkvX2FyaXR5UmFuZ2VcblRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHkgPSBmdW5jdGlvbihsZW4sIG51bSkge1xuICByZXR1cm4gKGxlbiA9PT0gbnVtKTtcbn1cblRlcm0ucHJvdG90eXBlLl9mYXN0QXJpdHlSYW5nZSA9IGZ1bmN0aW9uKGxlbiwgbWluLCBtYXgpIHtcbiAgcmV0dXJuICgobGVuID49IG1pbikgJiYgKGxlbiA8PSBtYXgpKTtcbn1cblxuXG4vLyBEYXR1bXNcbmZ1bmN0aW9uIEZ1bmMociwgZnVuYykge1xuICAvLyBXZSBjYW4gcmV0cmlldmUgdGhlIG5hbWVzIG9mIHRoZSBhcmd1bWVudHMgd2l0aFxuICAvLyBmdW5jLnRvU3RyaW5nKCkubWF0Y2goL1xcKChbXlxcKV0qKVxcKS8pWzFdLnNwbGl0KC9cXHMqLFxccyovKVxuXG4gIHZhciB0ZXJtID0gbmV3IFRlcm0ocik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLkZVTkMpO1xuICB2YXIgYXJncyA9IFtdO1xuICB2YXIgYXJnVmFycyA9IFtdO1xuICB2YXIgYXJnTnVtcyA9IFtdO1xuXG4gIGZvcih2YXIgaT0wOyBpPGZ1bmMubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdWYXJzLnB1c2gobmV3IFZhcihyLCByLm5leHRWYXJJZCkpO1xuICAgIGFyZ051bXMucHVzaChyLm5leHRWYXJJZCk7XG5cbiAgICBpZiAoci5uZXh0VmFySWQgPT09IDkwMDcxOTkyNTQ3NDA5OTIpIHsgLy8gVGhhdCBzZWVtcyBsaWtlIG92ZXJkb2luZyBpdC4uLiBidXQgd2VsbCBtYXliZS4uLlxuICAgICAgci5uZXh0VmFySWQgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHIubmV4dFZhcklkKys7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvZHkgPSBmdW5jLmFwcGx5KGZ1bmMsIGFyZ1ZhcnMpXG4gIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvci5SZXFsRHJpdmVyRXJyb3IoJ0Fub255bW91cyBmdW5jdGlvbiByZXR1cm5lZCBgdW5kZWZpbmVkYC4gRGlkIHlvdSBmb3JnZXQgYSBgcmV0dXJuYD8gSW46XFxuJytmdW5jLnRvU3RyaW5nKCksIHRoaXMuX3F1ZXJ5KTtcbiAgYm9keSA9IG5ldyBUZXJtKHIpLmV4cHIoYm9keSk7XG4gIGFyZ3MucHVzaChuZXcgVGVybShyKS5leHByKGFyZ051bXMpKTtcbiAgYXJncy5wdXNoKGJvZHkpO1xuXG4gIHRlcm0uX2ZpbGxBcmdzKGFyZ3MpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuRnVuYy5wcm90b3R5cGUubmV4dFZhcklkID0gMTtcblxuZnVuY3Rpb24gVmFyKHIsIGlkKSB7XG4gIHZhciB0ZXJtID0gbmV3IFRlcm0ocik7XG4gIHRlcm0uX3F1ZXJ5LnB1c2godGVybVR5cGVzLlZBUilcbiAgdGVybS5fcXVlcnkucHVzaChbbmV3IFRlcm0ocikuZXhwcihpZCkuX3F1ZXJ5XSlcbiAgcmV0dXJuIHRlcm07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVybTtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG52YXIgQ3Vyc29yID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9jdXJzb3IuanMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBFeHBlcmltZW50YWwsIGJ1dCBzaG91bGQgd29yayBmaW5lLlxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKHRhYmxlLCBvcHRpb25zLCBjb25uZWN0aW9uKSB7XG4gIHRoaXMuX3RhYmxlID0gdGFibGU7XG4gIHRoaXMuX3IgPSB0YWJsZS5fcjtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuX2NhY2hlID0gW107XG4gIHRoaXMuX3BlbmRpbmdDYWxsYmFjayA9IG51bGw7XG4gIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gIHRoaXMuX2luc2VydGluZyA9IGZhbHNlO1xuICB0aGlzLl9kZWxheWVkID0gZmFsc2U7XG4gIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICB0aGlzLl9oaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIHx8IDEwMDtcbiAgdGhpcy5faW5zZXJ0T3B0aW9ucyA9IHt9O1xuICB0aGlzLl9pbnNlcnRPcHRpb25zLmR1cmFiaWxpdHkgPSBvcHRpb25zLmR1cmFiaWxpdHkgfHwgJ2hhcmQnO1xuICB0aGlzLl9pbnNlcnRPcHRpb25zLmNvbmZsaWN0ID0gb3B0aW9ucy5jb25mbGljdCB8fCAnZXJyb3InO1xuICB0aGlzLl9pbnNlcnRPcHRpb25zLnJldHVybkNoYW5nZXMgPSBvcHRpb25zLnJldHVybkNoYW5nZXMgfHwgdHJ1ZTtcblxuICAvLyBJbnRlcm5hbCBvcHRpb24gdG8gcnVuIHNvbWUgdGVzdHNcbiAgaWYgKG9wdGlvbnMuZGVidWcgPT09IHRydWUpIHtcbiAgICB0aGlzLl9zZXF1ZW5jZSA9IFtdO1xuICB9XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywge1xuICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgaGlnaFdhdGVyTWFyazogdGhpcy5faGlnaFdhdGVyTWFya1xuICB9KTtcbn07XG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybVN0cmVhbSwgVHJhbnNmb3JtKTtcblxuVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nLCBkb25lKSB7XG4gIHRoaXMuX2NhY2hlLnB1c2godmFsdWUpO1xuICB0aGlzLl9uZXh0KHZhbHVlLCBlbmNvZGluZywgZG9uZSk7XG59XG5cbi8vIEV2ZXJ5dGltZSB3ZSB3YW50IHRvIGluc2VydCBidXQgZG8gbm90IGhhdmUgYSBmdWxsIGJ1ZmZlcixcbi8vIHdlIHJlY3Vyc2Ugd2l0aCBzZXRJbW1lZGlhdGUgdG8gZ2l2ZSBhIGNoYW5jZSB0byB0aGUgaW5wdXRcbi8vIHN0cmVhbSB0byBwdXNoIGEgZmV3IG1vcmUgZWxlbWVudHNcblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RpbmcsIGRvbmUpIHtcbiAgaWYgKCh0aGlzLl93cml0YWJsZVN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgIT0gbnVsbCkgJiYgKHRoaXMuX3dyaXRhYmxlU3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdC5jaHVuayAhPT0gdmFsdWUpKSB7XG4gICAgLy8gVGhlcmUncyBtb3JlIGRhdGEgdG8gYnVmZmVyXG4gICAgaWYgKHRoaXMuX2NhY2hlLmxlbmd0aCA8IHRoaXMuX2hpZ2hXYXRlck1hcmspIHtcbiAgICAgIHRoaXMuX2RlbGF5ZWQgPSBmYWxzZTtcbiAgICAgIC8vIENhbGwgZG9uZSBub3csIGFuZCBtb3JlIGRhdGEgd2lsbCBiZSBwdXQgaW4gdGhlIGNhY2hlXG4gICAgICBkb25lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2luc2VydGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlbGF5ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIGZsdXNoXG4gICAgICAgICAgdGhpcy5fZGVsYXllZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2luc2VydCgpO1xuICAgICAgICAgIC8vIEZpbGwgdGhlIGJ1ZmZlciB3aGlsZSB3ZSBhcmUgaW5zZXJ0aW5nIGRhdGFcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2RlbGF5ZWQgPSB0cnVlO1xuICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX25leHQodmFsdWUsIGVuY29kaW5nLCBkb25lKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0byBjYWxsIHdoZW4gd2UgYXJlIGRvbmcgaW5zZXJ0aW5nIHRvIGtlZXAgYnVmZmVyaW5nXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFjayA9IGRvbmU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgeyAvLyBXZSBqdXN0IHB1c2hlZCB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBpbnRlcm5hbCBidWZmZXJcbiAgICBpZiAodGhpcy5faW5zZXJ0aW5nID09PSBmYWxzZSkge1xuICAgICAgaWYgKHRoaXMuX2RlbGF5ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZGVsYXllZCA9IGZhbHNlO1xuICAgICAgICAvLyB0byBjYWxsIHdoZW4gd2UgYXJlIGRvbmcgaW5zZXJ0aW5nIHRvIG1heWJlIGZsYWcgdGhlIGVuZFxuICAgICAgICB0aGlzLl9pbnNlcnQoKTtcbiAgICAgICAgLy8gV2UgY2FuIGNhbGwgZG9uZSBub3csIGJlY2F1c2Ugd2UgaGF2ZSBfZmx1c2ggdG8gY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9kZWxheWVkID0gdHJ1ZTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuX25leHQodmFsdWUsIGVuY29kaW5nLCBkb25lKTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9kZWxheWVkID0gZmFsc2U7XG4gICAgICAvLyBUaGVyZSBpcyBub3RoaW5nIGxlZnQgaW4gdGhlIGludGVybmFsIGJ1ZmZlclxuICAgICAgLy8gQnV0IHNvbWV0aGluZyBpcyBhbHJlYWR5IGluc2VydGluZyBzdHVmZi5cbiAgICAgIGlmICh0aGlzLl9jYWNoZS5sZW5ndGggPCB0aGlzLl9oaWdoV2F0ZXJNYXJrLTEpIHtcbiAgICAgICAgLy8gQ2FsbCBkb25lLCB0byBhdHRlbXB0IHRvIGJ1ZmZlciBtb3JlXG4gICAgICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgX2ZsdXNoXG4gICAgICAgIC8vdGhpcy5fcGVuZGluZ0NhbGxiYWNrID0gZG9uZTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFjayA9IGRvbmU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX2luc2VydGluZyA9IHRydWU7XG5cbiAgdmFyIGNhY2hlID0gc2VsZi5fY2FjaGU7XG4gIHNlbGYuX2NhY2hlID0gW107XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZi5fc2VxdWVuY2UpKSB7XG4gICAgc2VsZi5fc2VxdWVuY2UucHVzaChjYWNoZS5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdDYWxsYmFjayA9IHNlbGYuX3BlbmRpbmdDYWxsYmFjaztcbiAgc2VsZi5fcGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgaWYgKHR5cGVvZiBwZW5kaW5nQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwZW5kaW5nQ2FsbGJhY2soKTtcbiAgfVxuXG4gIHZhciBxdWVyeSA9IHNlbGYuX3RhYmxlLmluc2VydChjYWNoZSwgc2VsZi5faW5zZXJ0T3B0aW9ucyk7XG4gIGlmIChzZWxmLl9vcHRpb25zLmZvcm1hdCA9PT0gJ3ByaW1hcnlLZXknKSB7XG4gICAgcXVlcnkgPSBxdWVyeS5kbyhmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJldHVybiBzZWxmLl9yLmJyYW5jaChcbiAgICAgICAgcmVzdWx0KCdlcnJvcnMnKS5lcSgwKSxcbiAgICAgICAgc2VsZi5fdGFibGUuY29uZmlnKCkoJ3ByaW1hcnlfa2V5JykuZG8oZnVuY3Rpb24ocHJpbWFyeUtleSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQoJ2NoYW5nZXMnKSgnbmV3X3ZhbCcpKHByaW1hcnlLZXkpXG4gICAgICAgIH0pLFxuICAgICAgICByZXN1bHQoc2VsZi5fci5lcnJvcihyZXN1bHQoJ2Vycm9ycycpLmNvZXJjZVRvKCdTVFJJTkcnKS5hZGQoJyBlcnJvcnMgcmV0dXJuZWQuIEZpcnN0IGVycm9yOlxcbicpLmFkZChyZXN1bHQoJ2ZpcnN0X2Vycm9yJykpKSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgcXVlcnkucnVuKHNlbGYuX2Nvbm5lY3Rpb24pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgc2VsZi5faW5zZXJ0aW5nID0gZmFsc2U7XG4gICAgaWYgKHNlbGYuX29wdGlvbnMuZm9ybWF0ID09PSAncHJpbWFyeUtleScpIHtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAocmVzdWx0LmVycm9ycyA+IDApIHtcbiAgICAgICAgc2VsZi5faW5zZXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbnNlcnQgc29tZSBkb2N1bWVudHM6JytKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNlbGYuX2luc2VydE9wdGlvbnMucmV0dXJuQ2hhbmdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHJlc3VsdC5jaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2gocmVzdWx0LmNoYW5nZXNbaV0ubmV3X3ZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGVuZGluZ0NhbGxiYWNrID0gc2VsZi5fcGVuZGluZ0NhbGxiYWNrXG4gICAgc2VsZi5fcGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gTWVhbiB0aGF0IHdlIGNhbiBidWZmZXIgbW9yZVxuICAgICAgcGVuZGluZ0NhbGxiYWNrKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGYuX2VuZGVkICE9PSB0cnVlKSB7XG4gICAgICBpZiAoKCgoKHNlbGYuX3dyaXRhYmxlU3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCkgfHxcbiAgICAgICAgICBzZWxmLl93cml0YWJsZVN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QuY2h1bmsgPT09IHNlbGYuX2NhY2hlW3NlbGYuX2NhY2hlLmxlbmd0aC0xXSkpKVxuICAgICAgICAmJiAoc2VsZi5fY2FjaGUubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICBzZWxmLl9pbnNlcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZi5fZW5kZWQgPT09IHRydWUpIHtcbiAgICAgIGlmIChzZWxmLl9jYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuX2luc2VydCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5fZmx1c2hDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNlbGYuX2ZsdXNoQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgIHNlbGYuX2luc2VydGluZyA9IGZhbHNlO1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICBpZiAoKHRoaXMuX2NhY2hlLmxlbmd0aCA9PT0gMCkgJiYgKHRoaXMuX2luc2VydGluZyA9PT0gZmFsc2UpKSB7XG4gICAgZG9uZSgpO1xuICB9XG4gIGVsc2UgeyAvLyB0aGlzLl9pbnNlcnRpbmcgPT09IHRydWVcbiAgICBpZiAodGhpcy5faW5zZXJ0aW5nID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fZmx1c2hDYWxsYmFjayA9IGRvbmU7XG4gICAgICB0aGlzLl9pbnNlcnQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gZG9uZTtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybVN0cmVhbTtcbiIsInZhciBXcml0YWJsZSA9IHJlcXVpcmUoJ3N0cmVhbScpLldyaXRhYmxlO1xudmFyIEN1cnNvciA9IHJlcXVpcmUoX19kaXJuYW1lKycvY3Vyc29yLmpzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLy8gRXhwZXJpbWVudGFsLCBidXQgc2hvdWxkIHdvcmsgZmluZS5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtKHRhYmxlLCBvcHRpb25zLCBjb25uZWN0aW9uKSB7XG4gIHRoaXMuX3RhYmxlID0gdGFibGU7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLl9jYWNoZSA9IFtdO1xuICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sgPSBudWxsO1xuICB0aGlzLl9pbnNlcnRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fZGVsYXllZCA9IGZhbHNlO1xuICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgdGhpcy5faGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyayB8fCAxMDA7XG5cbiAgdGhpcy5faW5zZXJ0T3B0aW9ucyA9IHt9O1xuICB0aGlzLl9pbnNlcnRPcHRpb25zLmR1cmFiaWxpdHkgPSBvcHRpb25zLmR1cmFiaWxpdHkgfHwgJ2hhcmQnO1xuICB0aGlzLl9pbnNlcnRPcHRpb25zLmNvbmZsaWN0ID0gb3B0aW9ucy5jb25mbGljdCB8fCAnZXJyb3InO1xuXG4gIC8vIEludGVybmFsIG9wdGlvbiB0byBydW4gc29tZSB0ZXN0c1xuICBpZiAob3B0aW9ucy5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgIHRoaXMuX3NlcXVlbmNlID0gW107XG4gIH1cblxuICBXcml0YWJsZS5jYWxsKHRoaXMsIHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIGhpZ2hXYXRlck1hcms6IHRoaXMuX2hpZ2hXYXRlck1hcmtcbiAgfSk7XG4gIHRoaXMuX2kgPSAwO1xufTtcbnV0aWwuaW5oZXJpdHMoV3JpdGFibGVTdHJlYW0sIFdyaXRhYmxlKTtcblxuV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGluZywgZG9uZSkge1xuICB0aGlzLl9pKys7XG4gIHRoaXMuX2NhY2hlLnB1c2godmFsdWUpO1xuICB0aGlzLl9uZXh0KHZhbHVlLCBlbmNvZGluZywgZG9uZSk7XG59XG5cbi8vIEV2ZXJ5dGltZSB3ZSB3YW50IHRvIGluc2VydCBidXQgZG8gbm90IGhhdmUgYSBmdWxsIGJ1ZmZlcixcbi8vIHdlIHJlY3Vyc2Ugd2l0aCBzZXRJbW1lZGlhdGUgdG8gZ2l2ZSBhIGNoYW5jZSB0byB0aGUgaW5wdXRcbi8vIHN0cmVhbSB0byBwdXNoIGEgZmV3IG1vcmUgZWxlbWVudHNcbldyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGluZywgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICgodGhpcy5fd3JpdGFibGVTdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ICE9IG51bGwpICYmICh0aGlzLl93cml0YWJsZVN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QuY2h1bmsgIT09IHZhbHVlKSkge1xuICAgIC8vIFRoZXJlJ3MgbW9yZSBkYXRhIHRvIGJ1ZmZlclxuICAgIGlmICh0aGlzLl9jYWNoZS5sZW5ndGggPCB0aGlzLl9oaWdoV2F0ZXJNYXJrKSB7XG4gICAgICB0aGlzLl9kZWxheWVkID0gZmFsc2U7XG4gICAgICAvLyBDYWxsIGRvbmUgbm93LCBhbmQgbW9yZSBkYXRhIHdpbGwgYmUgcHV0IGluIHRoZSBjYWNoZVxuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9pbnNlcnRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWxheWVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fZGVsYXllZCA9IGZhbHNlO1xuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZmx1c2hcbiAgICAgICAgICB0aGlzLl9pbnNlcnQoKTtcbiAgICAgICAgICAvLyBGaWxsIHRoZSBidWZmZXIgd2hpbGUgd2UgYXJlIGluc2VydGluZyBkYXRhXG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9kZWxheWVkID0gdHJ1ZTtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9uZXh0KHZhbHVlLCBlbmNvZGluZywgZG9uZSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVsYXllZCA9IGZhbHNlO1xuICAgICAgICAvLyB0byBjYWxsIHdoZW4gd2UgYXJlIGRvbmcgaW5zZXJ0aW5nIHRvIGtlZXAgYnVmZmVyaW5nXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFjayA9IGRvbmU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgeyAvLyBXZSBqdXN0IHB1c2hlZCB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBpbnRlcm5hbCBidWZmZXJcbiAgICBpZiAodGhpcy5faW5zZXJ0aW5nID09PSBmYWxzZSkge1xuICAgICAgaWYgKHRoaXMuX2RlbGF5ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZGVsYXllZCA9IGZhbHNlO1xuICAgICAgICAvLyB0byBjYWxsIHdoZW4gd2UgYXJlIGRvbmcgaW5zZXJ0aW5nIHRvIG1heWJlIGZsYWcgdGhlIGVuZFxuICAgICAgICAvLyBXZSBjYW5ub3QgY2FsbCBkb25lIGhlcmUgYXMgd2UgbWF5IGJlIGluc2VydGluZyB0aGUgbGFzdCBiYXRjaFxuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sgPSBkb25lO1xuICAgICAgICB0aGlzLl9pbnNlcnQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2RlbGF5ZWQgPSB0cnVlO1xuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5fbmV4dCh2YWx1ZSwgZW5jb2RpbmcsIGRvbmUpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2RlbGF5ZWQgPSBmYWxzZTtcbiAgICAgIC8vIFdlIGNhbm5vdCBjYWxsIGRvbmUgaGVyZSBhcyB3ZSBtYXkgYmUgaW5zZXJ0aW5nIHRoZSBsYXN0IGJhdGNoXG4gICAgICAvL3RoaXMuX3BlbmRpbmdDYWxsYmFjayA9IGRvbmU7XG4gICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fbmV4dCh2YWx1ZSwgZW5jb2RpbmcsIGRvbmUpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLl9pbnNlcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9pbnNlcnRpbmcgPSB0cnVlO1xuXG4gIHZhciBjYWNoZSA9IHNlbGYuX2NhY2hlO1xuICBzZWxmLl9jYWNoZSA9IFtdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHNlbGYuX3NlcXVlbmNlKSkge1xuICAgIHNlbGYuX3NlcXVlbmNlLnB1c2goY2FjaGUubGVuZ3RoKTtcbiAgfVxuXG4gIHNlbGYuX3RhYmxlLmluc2VydChjYWNoZSwgc2VsZi5faW5zZXJ0T3B0aW9ucykucnVuKHNlbGYuX2Nvbm5lY3Rpb24pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgc2VsZi5faW5zZXJ0aW5nID0gZmFsc2U7XG4gICAgaWYgKHJlc3VsdC5lcnJvcnMgPiAwKSB7XG4gICAgICBzZWxmLl9pbnNlcnRpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbnNlcnQgc29tZSBkb2N1bWVudHM6JytKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZi5fcGVuZGluZ0NhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcGVuZGluZ0NhbGxiYWNrID0gc2VsZi5fcGVuZGluZ0NhbGxiYWNrO1xuICAgICAgc2VsZi5fcGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICAgIHBlbmRpbmdDYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBzZWxmLl9pbnNlcnRpbmcgPSBmYWxzZTtcbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICB9KTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlU3RyZWFtO1xuIiwidmFyIHNjaGVtYVV0aWwgPSAgICByZXF1aXJlKF9fZGlybmFtZSsnL3NjaGVtYS5qcycpO1xudmFyIHR5cGUgPSAgICAgICAgICByZXF1aXJlKF9fZGlybmFtZSsnL3R5cGUvaW5kZXguanMnKTtcbnZhciB1dGlsID0gICAgICAgICAgcmVxdWlyZShfX2Rpcm5hbWUrJy91dGlsLmpzJyk7XG52YXIgUHJvbWlzZSA9ICAgICAgIHJlcXVpcmUoJ2JsdWViaXJkJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gIHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBFcnJvcnMgPSAgICAgICAgcmVxdWlyZShfX2Rpcm5hbWUrJy9lcnJvcnMuanMnKTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIGRvY3VtZW50IG9mIGEgbW9kZWwgKHJldHVybmVkIGJ5IGB0aGlua3kuY3JlYXRlTW9kZWxgKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGVsIFRoZSBtb2RlbCBvZiB0aGlzIGRvY3VtZW50XG4gKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgT3B0aW9ucyB0aGF0IGNhbiBvdmVyd3JpdGUgdGhlIG9uZXMgb2YgdGhlIG1vZGVsXG4gKi9cbmZ1bmN0aW9uIERvY3VtZW50KG1vZGVsLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpczsgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuXG4gIHRoaXMuY29uc3RydWN0b3IgPSBtb2RlbDsgIC8vIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyBtb2RlbFxuICB0aGlzLl9tb2RlbCA9IG1vZGVsLl9nZXRNb2RlbCgpOyAvLyBUaGUgaW5zdGFuY2Ugb2YgTW9kZWxcblxuICAvLyBXZSBkb24ndCB3YW50IHRvIHN0b3JlIG9wdGlvbnMgaWYgdGhleSBhcmUgZGlmZmVyZW50XG4gIC8vIHRoYW4gdGhlIG9uZSBwcm92aWRlZCBieSB0aGUgbW9kZWxcbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIHRoaXMuX3NjaGVtYU9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9zY2hlbWFPcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9XG4gICAgICAgIChvcHRpb25zLmVuZm9yY2VfbWlzc2luZyAhPSBudWxsKSA/IG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nIDogbW9kZWwuZ2V0T3B0aW9ucygpLmVuZm9yY2VfbWlzc2luZztcbiAgICB0aGlzLl9zY2hlbWFPcHRpb25zLmVuZm9yY2VfZXh0cmEgPVxuICAgICAgICAob3B0aW9ucy5lbmZvcmNlX2V4dHJhICE9IG51bGwpID8gb3B0aW9ucy5lbmZvcmNlX2V4dHJhIDogbW9kZWwuZ2V0T3B0aW9ucygpLmVuZm9yY2VfZXh0cmE7XG4gICAgdGhpcy5fc2NoZW1hT3B0aW9ucy5lbmZvcmNlX3R5cGUgPVxuICAgICAgICAob3B0aW9ucy5lbmZvcmNlX3R5cGUgIT0gbnVsbCkgPyBvcHRpb25zLmVuZm9yY2VfdHlwZSA6IG1vZGVsLmdldE9wdGlvbnMoKS5lbmZvcmNlX3R5cGU7XG4gIH1cblxuICAvL1RPRE86IFdlIGRvIG5vdCBuZWVkIHRvIG1ha2UgYSBkZWVwIGNvcHkuIFdlIGNhbiBkbyB0aGUgc2FtZSBhcyBmb3IgdGhpcy5fc2NoZW1hT3B0aW9ucy5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX29wdGlvbnMgPSB7fTtcbiAgdGhpcy5fb3B0aW9ucy50aW1lRm9ybWF0ID0gKG9wdGlvbnMudGltZUZvcm1hdCAhPSBudWxsKSA/IG9wdGlvbnMudGltZUZvcm1hdCA6IG1vZGVsLmdldE9wdGlvbnMoKS50aW1lRm9ybWF0O1xuICB0aGlzLl9vcHRpb25zLnZhbGlkYXRlID0gKG9wdGlvbnMudmFsaWRhdGUgIT0gbnVsbCkgPyBvcHRpb25zLnZhbGlkYXRlIDogbW9kZWwuZ2V0T3B0aW9ucygpLnZhbGlkYXRlO1xuXG4gIHRoaXMuX3NhdmVkID0gb3B0aW9ucy5zYXZlZCB8fCBmYWxzZTsgIC8vIFdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIHNhdmVkIG9yIG5vdFxuXG4gIHV0aWwuYmluZEVtaXR0ZXIoc2VsZik7ICAvLyBDb3B5IG1ldGhvZHMgZnJvbSBldmVudEVtaXR0ZXJcblxuICAvLyBsaW5rcyB0byBoYXNPbmUvaGFzTWFueSBkb2N1bWVudHNcbiAgLy8gV2UgdXNlIGl0IHRvIGtub3cgaWYgc29tZSBsaW5rcyBoYXZlIGJlZW4gcmVtb3ZlZC9hZGRlZCBiZWZvcmUgc2F2aW5nLlxuICAvLyBFeGFtcGxlOiB7IGtleTogZG9jIH0gb3IgeyBrZXk6IFtkb2NzXSB9XG4gIHRoaXMuX2JlbG9uZ3NUbyA9IHt9O1xuICB0aGlzLl9oYXNPbmUgPSB7fTtcbiAgdGhpcy5faGFzTWFueSA9IHt9O1xuICAvLyBFeGFtcGxlOiB7IDxsaW5rVGFibGVOYW1lPjogeyA8dmFsdWVPZlJpZ2h0S2V5PjogdHJ1ZSwgLi4uIH0sIC4uLiB9XG4gIHRoaXMuX2xpbmtzID0ge31cblxuICAvLyBLZWVwIHJlZmVyZW5jZSBvZiBhbnkgZG9jIGhhdmluZyBhIGxpbmsgcG9pbnRpbmcgdG8gdGhpc1xuICAvLyBTbyB3ZSBjYW4gY2xlYW4gd2hlbiB1c2VycyBkbyBkb2MuYmVsb25nc1RvRG9jLmRlbGV0ZSgpXG4gIHRoaXMuX3BhcmVudHMgPSB7XG4gICAgX2hhc09uZToge30sICAgICAgLy8gPHRhYmxlTmFtZT46IFt7ZG9jLCBrZXl9XVxuICAgIF9oYXNNYW55OiB7fSwgICAgIC8vIDx0YWJsZU5hbWU+OiBbe2RvYywga2V5fV1cbiAgICBfYmVsb25nc1RvOiB7fSwgICAvLyA8dGFibGVOYW1lPjogW3tkb2MsIGtleSwgZm9yZWlnbktleX1dXG4gICAgX2JlbG9uZ3NMaW5rczoge30gLy8gPHRhYmxlTmFtZT46IFt7ZG9jLCBrZXl9XVxuICB9XG5cbiAgLy8gQmluZCBsaXN0ZW5lcnMgb2YgdGhlIG1vZGVsIHRvIHRoaXMgZG9jdW1lbnRzLlxuICB1dGlsLmxvb3BLZXlzKG1vZGVsLl9saXN0ZW5lcnMsIGZ1bmN0aW9uKGxpc3RlbmVycywgZXZlbnRLZXkpIHtcbiAgICBmb3IodmFyIGo9MDsgajxsaXN0ZW5lcnNbZXZlbnRLZXldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2V2ZW50S2V5XVtqXS5vbmNlID09PSBmYWxzZSkge1xuICAgICAgICBzZWxmLmFkZExpc3RlbmVyKGV2ZW50S2V5LCBsaXN0ZW5lcnNbZXZlbnRLZXldW2pdLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxpc3RlbmVyc1tldmVudEtleV1bal0ub25jZSA9PT0gdHJ1ZSkge1xuICAgICAgICBzZWxmLm9uY2UoZXZlbnRLZXksIGxpc3RlbmVyc1tldmVudEtleV1bal0ubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cblxuICAvLyBBdG9tIGZlZWRcbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2ZlZWQgPSBudWxsO1xuXG4gIC8vIEFkZCBjdXN0b21pemVkIG1ldGhvZHMgb2YgdGhlIG1vZGVsIG9uIHRoaXMgZG9jdW1lbnQuXG4gIHV0aWwubG9vcEtleXMobW9kZWwuX21ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZHMsIGtleSkge1xuICAgIGlmIChzZWxmW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VsZltrZXldID0gbWV0aG9kc1trZXldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vVE9ETzogU2hvdWxkIHdlIHdhcm4gdGhlIHVzZXJzPyBUaHJvdyBhbiBlcnJvcj9cbiAgICAgIGNvbnNvbGUubG9nKHNlbGZba2V5XSk7XG4gICAgICBjb25zb2xlLmxvZyhcIkEgcHJvcGVydHkgXCIra2V5K1wiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLiBTa2lwcGluZy5cIik7XG4gICAgfVxuICB9KTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB0aGUgb3B0aW9ucyBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgaW5zdGFuY2Ugb2YgRG9jdW1lbnQuXG4gKiBAcmV0dXJuIHtPYmplY3Q9fVxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX2dldE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wcm90b19fLl9vcHRpb25zO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBvcHRpb25zIGZvciB0aGUgc2NoZW1hIG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBpbnN0YW5jZSBvZiBEb2N1bWVudC5cbiAqIEByZXR1cm4ge09iamVjdD19XG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5fZ2V0U2NoZW1hT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Byb3RvX18uX3NjaGVtYU9wdGlvbnM7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBpbnN0YW5jZSBvZiBEb2N1bWVudC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0TW9kZWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wcm90b19fLmNvbnN0cnVjdG9yO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBtb2RlbCwgdGhlIGluc3RhbmNlIG9mIE1vZGVsXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9nZXRNb2RlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Byb3RvX18uX21vZGVsO1xufVxuXG5cbi8qKlxuICogU2F2ZSB0aGUgdmlydHVhbCBmaWVsZHMgb2YgdGhlIGRvY3VtZW50IHRvIGJlIHJlLWluamVjdGVkIGxhdGVyLlxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX3NhdmVWaXJ0dWFsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3B5ID0ge307XG4gIHZhciBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKCk7IC8vIGluc3RhbmNlIG9mIE1vZGVsXG5cbiAgLy8gVE9ETyBXZSBjb3VsZCBkbyBiZXR0ZXIgYW5kIGNvcHkgbGVzcyB0aGluZ3MsIGJ1dCB0aGluZ3MgZ2V0IGEgYml0IHRyaWNreVxuICAvLyB3aGVuIHZpcnR1YWwgZmllbGRzIGFyZSBuZXN0ZWQgaW4gYXJyYXlzLlxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHN0aWxsIGFsbG93cyBubyBvdmVyaGVhZCBpZiBubyB2aXJ0dWFsIGZpZWxkcyBleGlzdCxcbiAgLy8gd2hpY2ggc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiBjYXNlXG4gIGZvcih2YXIgaT0wOyBpPHRoaXMuX2dldE1vZGVsKCkudmlydHVhbEZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSB0aGlzLl9nZXRNb2RlbCgpLnZpcnR1YWxGaWVsZHNbaV0ucGF0aFswXTtcbiAgICBjb3B5W2tleV0gPSB0aGlzW2tleV07XG4gIH1cbiAgdGhpcy5fX3Byb3RvX18udmlydHVhbFZhbHVlID0gdXRpbC5kZWVwQ29weShjb3B5KTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgdmlydHVhbCBmaWVsZHMgc2F2ZWQgYnkgYF9zYXZlVmlydHVhbGAuXG4gKiBAcmV0dXJuIHtPYmplY3Q9fVxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX2dldFZpcnR1YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wcm90b19fLnZpcnR1YWxWYWx1ZTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmlydHVhbCB2YWx1ZXMgZm9yIHRoZSBkb2N1bWVudCwgb3IgcmUtaW5qZWN0IHRoZSBvbmVzXG4gKiBwcmV2aW91c2x5IHNhdmVkLlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkICoqYWZ0ZXIqKiBgX2dlbmVyYXRlRGVmYXVsdGAuXG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5nZW5lcmF0ZVZpcnR1YWxWYWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpPTA7IGk8dGhpcy5fZ2V0TW9kZWwoKS52aXJ0dWFsRmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2NoZW1hVXRpbC5nZW5lcmF0ZVZpcnR1YWwodGhpcywgdGhpcy5fZ2V0TW9kZWwoKS52aXJ0dWFsRmllbGRzW2ldLCB0aGlzLCB0aGlzLl9nZXRWaXJ0dWFsKCkpO1xuICB9XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBkb2N1bWVudCwgZmlyc3QgdGhlIG5vbiB2aXJ0dWFsIGZpZWxkcywgYW5kIHRoZW5cbiAqIHRoZSB2aXJ0dWFsIGZpZWxkcy5cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9nZW5lcmF0ZURlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpPTA7IGk8dGhpcy5fZ2V0TW9kZWwoKS5kZWZhdWx0RmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2NoZW1hVXRpbC5nZW5lcmF0ZURlZmF1bHQodGhpcywgdGhpcy5fZ2V0TW9kZWwoKS5kZWZhdWx0RmllbGRzW2ldLCB0aGlzKTtcbiAgfVxuICBpZiAodGhpcy5fZ2V0TW9kZWwoKS52aXJ0dWFsRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmdlbmVyYXRlVmlydHVhbFZhbHVlcygpO1xuICB9XG59XG5cblxuLypcbiAqIFZhbGlkYXRlIHRoaXMgZG9jdW1lbnQgYWdhaW5zdCB0aGUgc2NoZW1hIG9mIGl0cyBtb2RlbCBhbmQgdHJpZ2dlcnMgYWxsIHRoZSBob29rcy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIHRvIG92ZXJ3cml0ZSB0aGUgb25lcyBvZiB0aGUgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdD19IG1vZGVsVG9WYWxpZGF0ZSBJbnRlcm5hbCBwYXJhbWV0ZXIsIG1vZGVsIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB2YWxpZGF0ZUFsbCBJbnRlcm5hbCBwYXJhbWV0ZXIsIE9wdGlvbiB0byBrZWVwIHJlY3Vyc2luZyBhcyBsb25nIGFzIG5vIG5vbi1jaXJjdWxhciBtb2RlbCBoYXZlIGJlZW4gZm91bmQuXG4gKiBAcGFyYW0ge09iamVjdD19IHZhbGlkYXRlZE1vZGVsIEludGVybmFsIHBhcmFtZXRlciwgQWxsIHRoZSBtb2RlbHMgZm9yIHdoaWNoIHdlIGFscmVhZHkgdmFsaWRhdGVkIGF0IGxlYXN0IG9uZSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gcHJlZml4IEludGVybmFsIHBhcmFtZXRlciwgVGhlIGN1cnJlbnQgcGF0aCB0byB0aGlzIHBhdGggKHVzZWQgaW4gY2FzZSBvZiBqb2luZWQgZG9jdW1lbnRzKS5cbiAqIEByZXR1cm4ge1Byb21pc2U9fSByZXR1cm4gYSBwcm9taXNlIGlmIHRoZSB2YWxpZGF0aW9uIGlzIGFzeW5jaHJvbmUsIGVsc2UgdW5kZWZpbmVkLlxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihvcHRpb25zLCBtb2RlbFRvVmFsaWRhdGUsIHZhbGlkYXRlQWxsLCB2YWxpZGF0ZWRNb2RlbCwgcHJlZml4KSB7XG4gIG1vZGVsVG9WYWxpZGF0ZSA9IG1vZGVsVG9WYWxpZGF0ZSB8fCB7fTtcbiAgdmFsaWRhdGVBbGwgPSB2YWxpZGF0ZUFsbCB8fCBmYWxzZTtcbiAgdmFsaWRhdGVkTW9kZWwgPSB2YWxpZGF0ZWRNb2RlbCB8fCB7fTtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHZhbGlkYXRlZE1vZGVsQ29weSA9IHV0aWwuZGVlcENvcHkodmFsaWRhdGVkTW9kZWwpO1xuXG4gIC8vVE9ETzogQ2FuIHdlIG5vdCBhbHdheXMgY2FsbCB0aGlzP1xuICB2YXIgYXN5bmMgPSBzZWxmLl92YWxpZGF0ZUlzQXN5bmMobW9kZWxUb1ZhbGlkYXRlLCB2YWxpZGF0ZUFsbCwgdmFsaWRhdGVkTW9kZWxDb3B5KTtcblxuICByZXR1cm4gdXRpbC5ob29rKHtcbiAgICBwcmVIb29rczogc2VsZi5fZ2V0TW9kZWwoKS5fcHJlLnZhbGlkYXRlLFxuICAgIHBvc3RIb29rczogc2VsZi5fZ2V0TW9kZWwoKS5fcG9zdC52YWxpZGF0ZSxcbiAgICBkb2M6IHNlbGYsXG4gICAgYXN5bmM6IGFzeW5jLFxuICAgIGZuOiBzZWxmLl92YWxpZGF0ZUhvb2ssXG4gICAgZm5BcmdzOiBbb3B0aW9ucywgbW9kZWxUb1ZhbGlkYXRlLCB2YWxpZGF0ZUFsbCwgdmFsaWRhdGVkTW9kZWwsIHByZWZpeF1cbiAgfSlcbn1cblxuXG4vKlxuICogVmFsaWRhdGUgdGhpcyBkb2N1bWVudCBhZ2FpbnN0IHRoZSBzY2hlbWEgb2YgaXRzIG1vZGVsIGFuZCBhbGwgaXRzIGpvaW5lZCBkb2N1bWVudHMgYW5kIHRyaWdnZXJzIGFsbCB0aGUgaG9va3NcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIHRvIG92ZXJ3cml0ZSB0aGUgb25lcyBvZiB0aGUgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdD19IG1vZGVsVG9WYWxpZGF0ZSBJbnRlcm5hbCBwYXJhbWV0ZXIsIG1vZGVsIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJuIHtQcm9taXNlPX0gcmV0dXJuIGEgcHJvbWlzZSBpZiB0aGUgdmFsaWRhdGlvbiBpcyBhc3luY2hyb25lLCBlbHNlIHVuZGVmaW5lZC5cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlQWxsID0gZnVuY3Rpb24ob3B0aW9ucywgbW9kZWxUb1ZhbGlkYXRlKSB7XG4gIHZhciB2YWxpZGF0ZUFsbCA9IG1vZGVsVG9WYWxpZGF0ZSA9PT0gdW5kZWZpbmVkO1xuICBtb2RlbFRvVmFsaWRhdGUgPSBtb2RlbFRvVmFsaWRhdGUgfHwge307XG5cbiAgcmV0dXJuIHRoaXMudmFsaWRhdGUob3B0aW9ucywgbW9kZWxUb1ZhbGlkYXRlLCB2YWxpZGF0ZUFsbCwge30sICcnLCB0cnVlKTtcbn1cblxuXG4vKlxuICogSW50ZXJuYWwgbWV0aG9kcyB0aGF0IHdpbGwgdmFsaWRhdGUgdGhlIGRvY3VtZW50IChidXQgdGhhdCB3aWxsIG5vdCBleGVjdXRlIHRoZSBob29rcykuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT3B0aW9ucyB0byBvdmVyd3JpdGUgdGhlIG9uZXMgb2YgdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHtPYmplY3Q9fSBtb2RlbFRvVmFsaWRhdGUgSW50ZXJuYWwgcGFyYW1ldGVyLCBtb2RlbCB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHtib29sZWFuPX0gdmFsaWRhdGVBbGwgSW50ZXJuYWwgcGFyYW1ldGVyLCBPcHRpb24gdG8ga2VlcCByZWN1cnNpbmcgYXMgbG9uZyBhcyBubyBub24tY2lyY3VsYXIgbW9kZWwgaGF2ZSBiZWVuIGZvdW5kLlxuICogQHBhcmFtIHtPYmplY3Q9fSB2YWxpZGF0ZWRNb2RlbCBJbnRlcm5hbCBwYXJhbWV0ZXIsIEFsbCB0aGUgbW9kZWxzIGZvciB3aGljaCB3ZSBhbHJlYWR5IHZhbGlkYXRlZCBhdCBsZWFzdCBvbmUgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZz19IHByZWZpeCBJbnRlcm5hbCBwYXJhbWV0ZXIsIFRoZSBjdXJyZW50IHBhdGggdG8gdGhpcyBwYXRoICh1c2VkIGluIGNhc2Ugb2Ygam9pbmVkIGRvY3VtZW50cykuXG4gKiBAcmV0dXJuIHtQcm9taXNlPX0gcmV0dXJuIGEgcHJvbWlzZSBpZiB0aGUgdmFsaWRhdGlvbiBpcyBhc3luY2hyb25lLCBlbHNlIHVuZGVmaW5lZC5cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl92YWxpZGF0ZUhvb2sgPSBmdW5jdGlvbihvcHRpb25zLCBtb2RlbFRvVmFsaWRhdGUsIHZhbGlkYXRlQWxsLCB2YWxpZGF0ZWRNb2RlbCwgcHJlZml4KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb21pc2VzID0gW107XG4gIHZhciBlcnJvcjtcblxuICB2YXIgc2NoZW1hT3B0aW9ucyA9IHNlbGYuX2dldFNjaGVtYU9wdGlvbnMoKTtcbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChzY2hlbWFPcHRpb25zKSkge1xuICAgIHNjaGVtYU9wdGlvbnMgPSB1dGlsLm1lcmdlT3B0aW9ucyhzY2hlbWFPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBlbHNlIHtcbiAgICBzY2hlbWFPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG5cbiAgaWYgKHR5cGVvZiBzZWxmLl9nZXRNb2RlbCgpLl92YWxpZGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2VsZi5fZ2V0TW9kZWwoKS5fdmFsaWRhdG9yLmNhbGwoc2VsZiwgc2VsZikgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIkRvY3VtZW50J3MgdmFsaWRhdG9yIHJldHVybmVkIGBmYWxzZWAuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHRoaXMgZG9jdW1lbnRcbiAgc2VsZi5fZ2V0TW9kZWwoKS5fc2NoZW1hLnZhbGlkYXRlKHNlbGYsIHByZWZpeCwgc2NoZW1hT3B0aW9ucylcblxuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG1vZGVsVG9WYWxpZGF0ZSkgPT09IGZhbHNlKSB7XG4gICAgbW9kZWxUb1ZhbGlkYXRlID0ge307XG4gIH1cblxuICB2YXIgY29uc3RydWN0b3IgPSBzZWxmLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcjtcbiAgdmFsaWRhdGVkTW9kZWxbY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKCldID0gdHJ1ZTtcblxuICAvLyBWYWxpZGF0ZSBqb2luZWQgZG9jdW1lbnRzXG4gIHV0aWwubG9vcEtleXMoc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnMsIGZ1bmN0aW9uKGpvaW5zLCBrZXkpIHtcbiAgICBpZiAodXRpbC5yZWN1cnNlKGtleSwgam9pbnMsIG1vZGVsVG9WYWxpZGF0ZSwgdmFsaWRhdGVBbGwsIHZhbGlkYXRlZE1vZGVsKSkge1xuICAgICAgc3dpdGNoIChqb2luc1trZXldLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaGFzT25lJzpcbiAgICAgICAgY2FzZSAnYmVsb25nc1RvJzpcbiAgICAgICAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHNlbGZba2V5XSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxmW2tleV0gaW5zdGFuY2VvZiBEb2N1bWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc2VsZltrZXldID0gbmV3IHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ubW9kZWwoc2VsZltrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBwcm9wYWdhdGUgdGhlIG9wdGlvbnMgb2YgdGhpcyBkb2N1bWVudCwgYnV0IG9ubHkgdGhvc2UgZ2l2ZW4gdG8gdmFsaWRhdGVcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZltrZXldLnZhbGlkYXRlKG9wdGlvbnMsIG1vZGVsVG9WYWxpZGF0ZVtrZXldLCB2YWxpZGF0ZUFsbCwgdmFsaWRhdGVkTW9kZWwsIHByZWZpeCsnWycra2V5KyddJyk7XG4gICAgICAgICAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNlbGZba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIkpvaW5lZCBmaWVsZCBcIitwcmVmaXgrXCJbXCIra2V5K1wiXSBzaG91bGQgYmUgYHVuZGVmaW5lZGAsIGBudWxsYCBvciBhbiBgT2JqZWN0YFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoYXNNYW55JzpcbiAgICAgICAgY2FzZSAnaGFzQW5kQmVsb25nc1RvTWFueSc6XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZltrZXldKSkge1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8c2VsZltrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qoc2VsZltrZXldW2ldKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmW2tleV1baV0gaW5zdGFuY2VvZiBEb2N1bWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGZba2V5XVtpXSA9IG5ldyBzZWxmLl9nZXRNb2RlbCgpLl9qb2luc1trZXldLm1vZGVsKHNlbGZba2V5XVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBzZWxmW2tleV1baV0udmFsaWRhdGUob3B0aW9ucywgbW9kZWxUb1ZhbGlkYXRlW2tleV0sIHZhbGlkYXRlQWxsLCB2YWxpZGF0ZWRNb2RlbCwgcHJlZml4KydbJytrZXkrJ11bJytpKyddJyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiSm9pbmVkIGZpZWxkIFwiK3ByZWZpeCtcIltcIitrZXkrXCJdW1wiK2krXCJdIHNob3VsZCBiZSBgdW5kZWZpbmVkYCwgYG51bGxgIG9yIGFuIGBBcnJheWBcIilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChzZWxmW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJKb2luZWQgZmllbGQgXCIrcHJlZml4K1wiW1wiK2tleStcIl0gc2hvdWxkIGJlIGB1bmRlZmluZWRgLCBgbnVsbGAgb3IgYW4gYEFycmF5YFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAocHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cbn1cblxuXG4vKlxuICogUmV0dXJuIHdoZXRoZXIgdGhlIHZhbGlkYXRpb24gcnVuIHdpdGggdGhlIHNhbWUgb3B0aW9ucyB3aWxsIGJlIGFzeW5jaHJvbm91cyBvciBub3QuXG4gKiBAcGFyYW0ge09iamVjdD19IG1vZGVsVG9WYWxpZGF0ZSBJbnRlcm5hbCBwYXJhbWV0ZXIsIG1vZGVsIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB2YWxpZGF0ZUFsbCBJbnRlcm5hbCBwYXJhbWV0ZXIsIE9wdGlvbiB0byBrZWVwIHJlY3Vyc2luZyBhcyBsb25nIGFzIG5vIG5vbi1jaXJjdWxhciBtb2RlbCBoYXZlIGJlZW4gZm91bmQuXG4gKiBAcGFyYW0ge09iamVjdD19IHZhbGlkYXRlZE1vZGVsIEludGVybmFsIHBhcmFtZXRlciwgQWxsIHRoZSBtb2RlbHMgZm9yIHdoaWNoIHdlIGFscmVhZHkgdmFsaWRhdGVkIGF0IGxlYXN0IG9uZSBkb2N1bWVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5fdmFsaWRhdGVJc0FzeW5jID0gZnVuY3Rpb24obW9kZWxUb1ZhbGlkYXRlLCB2YWxpZGF0ZUFsbCwgdmFsaWRhdGVkTW9kZWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChzZWxmLl9nZXRNb2RlbCgpLl9hc3luYy52YWxpZGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBhc3luYyA9IGZhbHNlO1xuICB1dGlsLmxvb3BLZXlzKHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zLCBmdW5jdGlvbihqb2lucywga2V5KSB7XG4gICAgaWYgKHV0aWwucmVjdXJzZShrZXksIGpvaW5zLCBtb2RlbFRvVmFsaWRhdGUsIHZhbGlkYXRlQWxsLCB2YWxpZGF0ZWRNb2RlbCkpIHtcbiAgICAgIGlmICgoKGpvaW5zW2tleV0udHlwZSA9PT0gJ2hhc09uZScpIHx8IChqb2luc1trZXldLnR5cGUgPT09ICdiZWxvbmdzVG8nKSkpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChzZWxmW2tleV0pKSB7XG4gICAgICAgICAgaWYgKHNlbGZba2V5XSBpbnN0YW5jZW9mIERvY3VtZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZltrZXldID0gbmV3IHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ubW9kZWwoc2VsZltrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gV2UgZG8gbm90IHByb3BhZ2F0ZSB0aGUgb3B0aW9ucyBvZiB0aGlzIGRvY3VtZW50LCBidXQgb25seSB0aG9zZSBnaXZlbiB0byB2YWxpZGF0ZVxuICAgICAgICAgIGlmIChzZWxmW2tleV0uX2dldE1vZGVsKCkuX2FzeW5jLnZhbGlkYXRlIHx8IHNlbGZba2V5XS5fdmFsaWRhdGVJc0FzeW5jKG1vZGVsVG9WYWxpZGF0ZSwgdmFsaWRhdGVBbGwsIHZhbGlkYXRlZE1vZGVsKSkge1xuICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSAgaWYgKCgoam9pbnNba2V5XS50eXBlID09PSAnaGFzTWFueScpIHx8IChqb2luc1trZXldLnR5cGUgPT09ICdoYXNBbmRCZWxvbmdzVG9NYW55JykpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGZba2V5XSkpIHtcbiAgICAgICAgICBmb3IodmFyIGk9MDsgaTxzZWxmW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qoc2VsZltrZXldW2ldKSkge1xuICAgICAgICAgICAgICBpZiAoc2VsZltrZXldW2ldIGluc3RhbmNlb2YgRG9jdW1lbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZltrZXldW2ldID0gbmV3IHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ubW9kZWwoc2VsZltrZXldW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2VsZltrZXldW2ldLl9nZXRNb2RlbCgpLl9hc3luYy52YWxpZGF0ZSB8fCBzZWxmW2tleV1baV0uX3ZhbGlkYXRlSXNBc3luYyhtb2RlbFRvVmFsaWRhdGUsIHZhbGlkYXRlQWxsLCB2YWxpZGF0ZWRNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiBhc3luYztcbn1cblxuXG4vKipcbiAqIFNhdmUgdGhlIGRvY3VtZW50IGFuZCBleGVjdXRlIHRoZSBob29rcy4gUmV0dXJuIGEgcHJvbWlzZSBpZiB0aGUgY2FsbGJhY2tcbiAqIGlzIG5vdCBwcm92aWRlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb249fSBjYWxsYmFjayB0byBleGVjdXRlXG4gKiBAcmV0dXJuIHtQcm9taXNlPX1cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fc2F2ZSh7fSwgZmFsc2UsIHt9LCBjYWxsYmFjayk7XG59XG5cblxuLyoqXG4gKiBTYXZlIHRoZSBkb2N1bWVudCBhbmQgaXRzIGpvaW5lZCBkb2N1bWVudHMuIEl0IHdpbGwgYWxzbyBleGVjdXRlIHRoZSBob29rcy5cbiAqIFJldHVybiBhIHByb21pc2UgaWYgdGhlIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZC5cbiAqIEl0IHdpbGwgc2F2ZSBqb2luZWQgZG9jdW1lbnRzIGFzIGxvbmcgYXMgYSBkb2N1bWVudCBvZiB0aGUgc2FtZSBtb2RlbCBoYXMgbm90XG4gKiBiZWVuIHNhdmVkLlxuICogQHBhcmFtIHtmdW5jdGlvbj19IGNhbGxiYWNrIHRvIGV4ZWN1dGVcbiAqIEByZXR1cm4ge1Byb21pc2U9fVxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuc2F2ZUFsbCA9IGZ1bmN0aW9uKGRvY1RvU2F2ZSwgY2FsbGJhY2spIHtcbiAgdmFyIHNhdmVBbGw7XG4gIGlmICh0eXBlb2YgZG9jVG9TYXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkb2NUb1NhdmU7XG4gICAgc2F2ZUFsbCA9IHRydWU7XG4gICAgZG9jVG9TYXZlID0ge307XG4gIH1cbiAgZWxzZSB7XG4gICAgc2F2ZUFsbCA9IGRvY1RvU2F2ZSA9PT0gdW5kZWZpbmVkO1xuICAgIGRvY1RvU2F2ZSA9IGRvY1RvU2F2ZSB8fCB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9zYXZlKGRvY1RvU2F2ZSwgc2F2ZUFsbCx7fSwgY2FsbGJhY2spO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIGEgc2F2YWJsZSBjb3B5IG9mIHRoZSBkb2N1bWVudCBieSByZW1vdmluZyB0aGUgZXh0cmEgZmllbGRzLFxuICogZ2VuZXJhdGluZyB0aGUgZGVmYXVsdCBhbmQgdmlydHVhbCBmaWVsZHMuXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5fbWFrZVNhdmFibGVDb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKCk7IC8vIGluc3RhbmNlIG9mIE1vZGVsXG4gIHZhciBzY2hlbWEgPSB0aGlzLl9nZXRNb2RlbCgpLl9zY2hlbWE7XG5cbiAgdmFyIHIgPSB0aGlzLl9nZXRNb2RlbCgpLl90aGlua3kucjtcblxuICBpZiAodGhpcy5fZ2V0TW9kZWwoKS5uZWVkVG9HZW5lcmF0ZUZpZWxkcyA9PT0gdHJ1ZSl7XG4gICAgdGhpcy5fZ2VuZXJhdGVEZWZhdWx0KCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX21ha2VTYXZhYmxlQ29weSh0aGlzLCBzY2hlbWEsIHRoaXMuX2dldE9wdGlvbnMoKSwgbW9kZWwsIHIpXG59XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZm9yIF9tYWtlU2F2YWJsZUNvcHkuXG4gKiBnZW5lcmF0aW5nIHRoZSBkZmF1bHQgYW5kIHZpcnR1YWwgZmllbGRzLlxuICogQHJldHVybiB7YW55fSB0aGUgY29weSBvZiB0aGUgZmllbGQvb2JqZWN0LlxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX19tYWtlU2F2YWJsZUNvcHkgPSBmdW5jdGlvbihkb2MsIHNjaGVtYSwgb3B0aW9ucywgbW9kZWwsIHIpIHtcbiAgdmFyIGxvY2FsT3B0aW9uczsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICBsb2NhbE9wdGlvbnMgPSBzY2hlbWEuX29wdGlvbnM7XG4gIH1cblxuICAvLyBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBhIE1vZGVsIChmb3IgdGhlIHRvcCBsZXZlbCBmaWVsZHMpLCBvciB1bmRlZmluZWRcbiAgdmFyIHJlc3VsdCwga2V5LCBrZXlzLCBuZXh0U2NoZW1hLCBjb3B5RmxhZztcbiAgaWYgKHR5cGUuaXNEYXRlKHNjaGVtYSkgJiYgKHR5cGVvZiBkb2MgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkb2MgPT09ICdudW1iZXInKSkge1xuICAgIGlmICh0eXBlb2YgZG9jID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG51bWVyaWNEYXRlID0gcGFyc2VJbnQoZG9jLCAxMCk7XG4gICAgICBpZighaXNOYU4obnVtZXJpY0RhdGUpKSB7XG4gICAgICAgIGRvYyA9IG51bWVyaWNEYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZG9jKTsgLy8gVXNlIHIuSVNPODYwMSBhbmQgbm90IGBuZXcgRGF0ZSgpYCB0byBrZWVwIHRpbWV6b25lXG4gIH1cbiAgZWxzZSBpZiAodHlwZS5pc1BvaW50KHNjaGVtYSkpIHtcbiAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGRvYykgJiYgKGRvY1snJHJlcWxfdHlwZSQnXSAhPT0gXCJHRU9NRVRSWVwiKSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkb2MpLnNvcnQoKTtcbiAgICAgIGlmICgoa2V5cy5sZW5ndGggPT09IDIpICYmIChrZXlzWzBdID09PSAnbGF0aXR1ZGUnKSAmJiAoa2V5c1sxXSA9PT0gJ2xvbmdpdHVkZScpICYmICh0eXBlb2YgZG9jLmxhdGl0dWRlID09PSBcIm51bWJlclwiKSAmJiAodHlwZW9mIGRvYy5sb25naXR1ZGUgPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIHJldHVybiByLnBvaW50KGRvYy5sb25naXR1ZGUsIGRvYy5sYXRpdHVkZSlcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChkb2MudHlwZSA9PT0gXCJQb2ludFwiKSAmJiAoQXJyYXkuaXNBcnJheShkb2MuY29vcmRpbmF0ZXMpKSAmJiAoZG9jLmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMikpIHsgLy8gR2VvanNvblxuICAgICAgICByZXR1cm4gci5nZW9qc29uKGRvYylcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkb2MpKSB7XG4gICAgICBpZiAoKGRvYy5sZW5ndGggPT09IDIpICYmICh0eXBlb2YgZG9jWzBdID09PSBcIm51bWJlclwiKSAmJiAodHlwZW9mIGRvY1sxXSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIHIucG9pbnQoZG9jWzBdLCBkb2NbMV0pXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyBubyB0cmFuc2Zvcm1hdGlvbiBhcmUgcmVxdWlyZWQgaGVyZSwgcmV0dXJuIGRvY1xuICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZS5pc051bWJlcihzY2hlbWEpICYmICh0eXBlb2YgZG9jID09PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgbnVtZXJpY1N0cmluZyA9IHBhcnNlRmxvYXQoZG9jKTtcbiAgICBpZighaXNOYU4obnVtZXJpY1N0cmluZykpe1xuICAgICAgcmV0dXJuIG51bWVyaWNTdHJpbmc7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3QoZG9jKSAmJiAoZG9jIGluc3RhbmNlb2YgQnVmZmVyID09PSBmYWxzZSkpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgICB1dGlsLmxvb3BLZXlzKGRvYywgZnVuY3Rpb24oZG9jLCBrZXkpIHtcbiAgICAgIGNvcHlGbGFnID0gdHJ1ZTtcbiAgICAgIGlmICgodXRpbC5pc1BsYWluT2JqZWN0KG1vZGVsKSA9PT0gZmFsc2UpIHx8IChtb2RlbC5fam9pbnNba2V5XSA9PT0gdW5kZWZpbmVkKSkgeyAvLyBXZSBkbyBub3QgY29weSBqb2luZWQgZG9jdW1lbnRzXG4gICAgICAgIGlmICgoc2NoZW1hICE9PSB1bmRlZmluZWQpICYmIChzY2hlbWEuX3NjaGVtYSAhPT0gdW5kZWZpbmVkKSAmJiAodHlwZS5pc1ZpcnR1YWwoc2NoZW1hLl9zY2hlbWFba2V5XSkgPT09IHRydWUpKSB7XG4gICAgICAgICAgLy8gV2UgZG8gbm90IGNvcHkgdmlydHVhbFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoc2NoZW1hID09PSB1bmRlZmluZWQpIHx8IChzY2hlbWEuX3NjaGVtYSA9PT0gdW5kZWZpbmVkKSB8fCAoc2NoZW1hLl9zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSkgJiZcbiAgICAgICAgICAgIChsb2NhbE9wdGlvbnMgIT09IHVuZGVmaW5lZCkgJiYgKGxvY2FsT3B0aW9ucy5lbmZvcmNlX2V4dHJhID09PSBcInJlbW92ZVwiKSkge1xuICAgICAgICAgIC8vIFdlIGRvIG5vdCBjb3B5IGZpZWxkcyBpZiBlbmZyb2NlX2V4dHJhIGlzIFwicmVtb3ZlXCJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSAmJiAoc2NoZW1hLl9zY2hlbWEgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIG5leHRTY2hlbWEgPSBzY2hlbWEuX3NjaGVtYVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdFtrZXldID0gRG9jdW1lbnQucHJvdG90eXBlLl9fbWFrZVNhdmFibGVDb3B5KGRvY1trZXldLCBuZXh0U2NoZW1hLCBsb2NhbE9wdGlvbnMsIHVuZGVmaW5lZCwgcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENvcHkgdGhlIGZpZWxkcyB0aGF0IGFyZSB1c2VkIGFzIGZvcmVpZ24ga2V5c1xuICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3QobW9kZWwpID09PSB0cnVlKSB7XG4gICAgICB1dGlsLmxvb3BLZXlzKG1vZGVsLl9sb2NhbEtleXMsIGZ1bmN0aW9uKGxvY2FsS2V5cywgbG9jYWxLZXkpIHtcbiAgICAgICAgaWYgKGRvY1tsb2NhbEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV4dFNjaGVtYSA9IHNjaGVtYS5fc2NoZW1hW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9UT0RPOiBEbyB3ZSB3YW50IHRvIGNvcHkgdGhlIGZvcmVpZ24ga2V5IHZhbHVlPyBJZiB5ZXMsIHRoZXJlJ3Mgbm8gbmVlZCBmb3IgdGhpcyBsb29wXG4gICAgICAgICAgLy9EbyB3ZSB3YW50IHRvIGNvcHkgdGhlIGtleSBmcm9tIHRoZSBqb2luZWQgZG9jdW1lbnQ/IElmIHllcyB3ZSBuZWVkIHRvIHJlcGxhY2UgZG9jW2xvY2FsS2V5XVxuICAgICAgICAgIHJlc3VsdFtsb2NhbEtleV0gPSBEb2N1bWVudC5wcm90b3R5cGUuX19tYWtlU2F2YWJsZUNvcHkoZG9jW2xvY2FsS2V5XSwgbmV4dFNjaGVtYSwgbG9jYWxPcHRpb25zLCB1bmRlZmluZWQsIHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgICBjb3B5RmxhZyA9IHRydWU7XG5cbiAgICAvLyBOZXh0IHNjaGVtYVxuICAgIGlmICh0eXBlLmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgbmV4dFNjaGVtYSA9IHNjaGVtYS5fc2NoZW1hO1xuICAgIH1cbiAgICBlbHNlIGlmICgodXRpbC5pc1BsYWluT2JqZWN0KHNjaGVtYSkpICYmIChzY2hlbWEuX3R5cGUgIT09IHVuZGVmaW5lZCkgJiYgKHNjaGVtYS5fc2NoZW1hICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBuZXh0U2NoZW1hID0gc2NoZW1hLl9zY2hlbWFcbiAgICAgIGlmIChzY2hlbWEuX3R5cGUgPT09IFwidmlydHVhbFwiKSB7XG4gICAgICAgIGNvcHlGbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV4dFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGNvcHlGbGFnID09PSB0cnVlKSB7XG4gICAgICBmb3IodmFyIGk9MDsgaTxkb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goRG9jdW1lbnQucHJvdG90eXBlLl9fbWFrZVNhdmFibGVDb3B5KGRvY1tpXSwgbmV4dFNjaGVtYSwgbG9jYWxPcHRpb25zLCB1bmRlZmluZWQsIHIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyBlbHNlLCBkb2MgaXMgYSBwcmltaXRpdmUgKG9yIGEgYnVmZmVyKVxuICByZXR1cm4gZG9jO1xufVxuXG5cbi8qKlxuICogU2F2ZSB0aGUgZG9jdW1lbnQsIGl0cyBqb2luZWQgZG9jdW1lbnRzIGFuZCBleGVjdXRlIHRoZSBob29rcy4gUmV0dXJuIGFcbiAqIHByb21pc2UgaWYgdGhlIGNhbGxiYWNrIGlzIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gZG9jVG9TYXZlIERvY3VtZW50cyB0byBzYXZlIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBmaWVsZC0+dHJ1ZVxuICogQHBhcmFtIHtib29sZWFufSBzYXZlQWxsIFdoZXRoZXIgX3NhdmUgc2hvdWxkIHJlY3Vyc2UgYnkgZGVmYXVsdCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2F2ZWRNb2RlbCBNb2RlbHMgc2F2ZWQgaW4gdGhpcyBjYWxsXG4gKiBAcGFyYW0ge09iamVjdD19IGNhbGxiYWNrIHRvIGV4ZWN1dGVcbiAqIEByZXR1cm4ge1Byb21pc2U9fVxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX3NhdmUgPSBmdW5jdGlvbihkb2NUb1NhdmUsIHNhdmVBbGwsIHNhdmVkTW9kZWwsIGNhbGxiYWNrKSB7XG4gIC8vVE9JTVBST1ZFPyBIb3cgc2hvdWxkIHdlIGhhbmRsZSBjaXJjdWxhciByZWZlcmVuY2VzIG91dHNpZGVzIG9mIGpvaW5lZCBmaWVsZHM/IE5vdyB3ZSB0aHJvdyB3aXRoIGEgbWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lbWl0KCdzYXZpbmcnLCBzZWxmKTtcblxuICByZXR1cm4gdXRpbC5ob29rKHtcbiAgICBwcmVIb29rczogc2VsZi5fZ2V0TW9kZWwoKS5fcHJlLnNhdmUsXG4gICAgcG9zdEhvb2tzOiBzZWxmLl9nZXRNb2RlbCgpLl9wb3N0LnNhdmUsXG4gICAgZG9jOiBzZWxmLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGZuOiBzZWxmLl9zYXZlSG9vayxcbiAgICBmbkFyZ3M6IFtkb2NUb1NhdmUsIHNhdmVBbGwsIHNhdmVkTW9kZWxdXG4gIH0pLm5vZGVpZnkoY2FsbGJhY2spO1xufVxuXG5cbi8qKlxuICogU2F2ZSB0aGUgZG9jdW1lbnQgYW5kIGV4ZWN1dGUgdGhlIGhvb2tzLiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZCB1c2VkIHdpdGhcbiAqIE1vZGVsLnNhdmUuIFRoaXMgbGV0IHVzIHVzZSBhIHNpbWlsYXIgY29kZSBwYXRoIGZvciBgZG9jdW1lbnQuc2F2ZWAgYW5kIGBNb2RlbC5zYXZlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dGVJbnNlcnQgdGhlIG1ldGhvZCB0aGF0IHdpbGwgZXhlY3V0ZSB0aGUgYmF0Y2ggaW5zZXJ0XG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX2JhdGNoU2F2ZSA9IGZ1bmN0aW9uKGV4ZWN1dGVJbnNlcnQpIHtcbiAgLy8gS2VlcCBpbiBzeW5jIHdpdGggX3NhdmVcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVtaXQoJ3NhdmluZycsIHNlbGYpO1xuXG4gIHJldHVybiB1dGlsLmhvb2soe1xuICAgIHByZUhvb2tzOiBzZWxmLl9nZXRNb2RlbCgpLl9wcmUuc2F2ZSxcbiAgICBwb3N0SG9va3M6IHNlbGYuX2dldE1vZGVsKCkuX3Bvc3Quc2F2ZSxcbiAgICBkb2M6IHNlbGYsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgZm46IHNlbGYuX2JhdGNoU2F2ZVNlbGYsXG4gICAgZm5BcmdzOiBbZXhlY3V0ZUluc2VydF1cbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDYWxsIGV4ZWN1dGVJbnNlcnQgd2hlbiB0aGUgbW9kZWwgaXMgcmVhZHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dGVJbnNlcnQgdGhlIG1ldGhvZCB0aGF0IHdpbGwgZXhlY3V0ZSB0aGUgYmF0Y2ggaW5zZXJ0XG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX2JhdGNoU2F2ZVNlbGYgPSBmdW5jdGlvbihleGVjdXRlSW5zZXJ0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgc2VsZi5nZXRNb2RlbCgpLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGV4ZWN1dGVJbnNlcnQocmVzb2x2ZSwgcmVqZWN0KVxuICAgIH0pO1xuICB9KVxufVxuXG5cbi8qKlxuICogU2F2ZSB0aGUgZG9jdW1lbnQgYW5kIG1heWJlIGl0cyBqb2luZWQgZG9jdW1lbnRzLiBIb29rcyBoYXZlIGJlZW4gZGVhbHQgd2l0aFxuICogaW4gX3NhdmUuXG4gKiBAcGFyYW0geyFPYmplY3R9IGNvcHkgVGhlIHNhdmFibGUgY29weSBvZiB0aGUgb3JpZ2luYWwgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3Q9fSBkb2NUb1NhdmUgRG9jdW1lbnRzIHRvIHNhdmUgcmVwcmVzZW50ZWQgYnkgYW4gb2JqZWN0IGZpZWxkLT50cnVlXG4gKiBAcGFyYW0ge09iamVjdD19IGJlbG9uZ3NUb0tleXNTYXZlZCBUaGUga2V5cyB0aGF0IG1heSBjb250YWlucyBhIGRvY3VtZW50IHRvIHNhdmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2F2ZUFsbCBXaGV0aGVyIF9zYXZlIHNob3VsZCByZWN1cnNlIGJ5IGRlZmF1bHQgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdD19IHNhdmVkTW9kZWwgTW9kZWxzIHNhdmVkIGluIHRoaXMgY2FsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gc2F2ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiBhbiBlcnJvciBoYXBwZW5lZFxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX3NhdmVIb29rID0gZnVuY3Rpb24oZG9jVG9TYXZlLCBzYXZlQWxsLCBzYXZlZE1vZGVsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG1vZGVsID0gc2VsZi5fZ2V0TW9kZWwoKTsgLy8gaW5zdGFuY2Ugb2YgTW9kZWxcbiAgdmFyIGNvbnN0cnVjdG9yID0gc2VsZi5nZXRNb2RlbCgpO1xuICB2YXIgciA9IG1vZGVsLl90aGlua3kucjtcblxuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGRvY1RvU2F2ZSkgPT09IGZhbHNlKSB7XG4gICAgZG9jVG9TYXZlID0ge307XG4gIH1cblxuICBzYXZlZE1vZGVsW2NvbnN0cnVjdG9yLmdldFRhYmxlTmFtZSgpXSA9IHRydWU7XG5cblxuICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIFN0ZXBzOlxuICAgIC8vIC0gU2F2ZSBiZWxvbmdzVG9cbiAgICAvLyAtIFNhdmUgdGhpc1xuICAgIC8vIC0gU2F2ZSBoYXNPbmUsIGhhc01hbnkgYW5kIGhhc0FuZEJlbG9uZ3NUb01hbnkgZG9jc1xuICAgIC8vIC0gU2F2ZSBsaW5rc1xuXG4gICAgLy8gV2UnbGwgdXNlIGl0IHRvIGtub3cgd2hpY2ggYGJlbG9uZ3NUb2AgZG9jcyB3ZXJlIHNhdmVkXG4gICAgdmFyIGJlbG9uZ3NUb0tleXNTYXZlZCA9IHt9O1xuXG4gICAgdmFyIGNvcHkgPSBzZWxmLl9tYWtlU2F2YWJsZUNvcHkoKTtcbiAgICBzZWxmLl9zYXZlVmlydHVhbCgpO1xuXG4gICAgLy8gU2F2ZSB0aGUgam9pbmVkIGRvY3VtZW50cyB2aWEgYmVsb25nc1RvIGZpcnN0XG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgdXRpbC5sb29wS2V5cyhtb2RlbC5fam9pbnMsIGZ1bmN0aW9uKGpvaW5zLCBrZXkpIHtcbiAgICAgIGlmICgoZG9jVG9TYXZlLmhhc093blByb3BlcnR5KGtleSkgfHwgKHNhdmVBbGwgPT09IHRydWUpKSAmJlxuICAgICAgICAgIChqb2luc1trZXldLnR5cGUgPT09ICdiZWxvbmdzVG8nKSAmJiAoKHNhdmVBbGwgPT09IGZhbHNlKSB8fCAoc2F2ZWRNb2RlbFtqb2luc1trZXldLm1vZGVsLmdldFRhYmxlTmFtZSgpXSAhPT0gdHJ1ZSkpKSB7XG5cbiAgICAgICAgYmVsb25nc1RvS2V5c1NhdmVkW2tleV0gPSB0cnVlO1xuICAgICAgICBpZiAoc2VsZltrZXldICE9IG51bGwpIHtcbiAgICAgICAgICBzYXZlZE1vZGVsW2pvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCldID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoc2F2ZUFsbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmW2tleV0uX3NhdmUoe30sIHRydWUsIHNhdmVkTW9kZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZltrZXldLl9zYXZlKGRvY1RvU2F2ZVtqb2luc1trZXldLm1vZGVsLmdldFRhYmxlTmFtZSgpXSwgZmFsc2UsIHNhdmVkTW9kZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9UT0RPIFJlbW92ZSBvbmNlXG4gICAgc2VsZi5nZXRNb2RlbCgpLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9vblNhdmVkQmVsb25nc1RvKGNvcHksIGRvY1RvU2F2ZSwgYmVsb25nc1RvS2V5c1NhdmVkLCBzYXZlQWxsLCBzYXZlZE1vZGVsLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBwO1xufVxuXG5cbi8qKlxuICogU2F2ZSB0aGUgam9pbmVkIGRvY3VtZW50cyBsaW5rZWQgd2l0aCBhIEJlbG9uZ3NUbyByZWxhdGlvbi4gVGhpcyBzaG91bGQgYmVcbiAqIGNhbGxlZCBiZWZvcmUgX3NhdmVTZWxmIGFzIHdlIHdpbGwgaGF2ZSB0byBjb3B5IHRoZSBmb3JlaWduIGtleXMgaW4gYHNlbGZgLlxuICogQHBhcmFtIHshT2JqZWN0fSBjb3B5IFRoZSBzYXZhYmxlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gZG9jVG9TYXZlIERvY3VtZW50cyB0byBzYXZlIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBmaWVsZC0+dHJ1ZVxuICogQHBhcmFtIHtPYmplY3Q9fSBiZWxvbmdzVG9LZXlzU2F2ZWQgVGhlIGtleXMgdGhhdCBtYXkgY29udGFpbnMgYSBkb2N1bWVudCB0byBzYXZlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNhdmVBbGwgV2hldGhlciBfc2F2ZSBzaG91bGQgcmVjdXJzZSBieSBkZWZhdWx0IG9yIG5vdFxuICogQHBhcmFtIHtPYmplY3Q9fSBzYXZlZE1vZGVsIE1vZGVscyBzYXZlZCBpbiB0aGlzIGNhbGxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVyeXRoaW5nIGhhcyBiZWVuIHNhdmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgYW4gZXJyb3IgaGFwcGVuZWRcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9vblNhdmVkQmVsb25nc1RvID0gZnVuY3Rpb24oXG4gICAgY29weSwgZG9jVG9TYXZlLCBiZWxvbmdzVG9LZXlzU2F2ZWQsIHNhdmVBbGwsIHNhdmVkTW9kZWwsIHJlc29sdmUsIHJlamVjdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBtb2RlbCA9IHNlbGYuX2dldE1vZGVsKCk7XG4gIHZhciBjb25zdHJ1Y3RvciA9IHNlbGYuX19wcm90b19fLmNvbnN0cnVjdG9yO1xuICB2YXIgciA9IHRoaXMuX2dldE1vZGVsKCkuX3RoaW5reS5yO1xuXG4gIHV0aWwubG9vcEtleXMoYmVsb25nc1RvS2V5c1NhdmVkLCBmdW5jdGlvbihqb2lucywga2V5KSB7XG4gICAgdmFyIGpvaW5zID0gbW9kZWwuX2pvaW5zO1xuICAgIGlmIChzZWxmW2tleV0gIT0gbnVsbCkge1xuXG4gICAgICBzZWxmLl9fcHJvdG9fXy5fYmVsb25nc1RvW2tleV0gPSB0cnVlO1xuXG4gICAgICAvLyBDb3B5IGZvcmVpZ24ga2V5XG4gICAgICBpZiAoc2VsZltrZXldW2pvaW5zW2tleV0ucmlnaHRLZXldID09IG51bGwpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkoam9pbnNba2V5XS5sZWZ0S2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2pvaW5zW2tleV1bam9pbnNba2V5XS5sZWZ0S2V5XV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkuaGFzT3duUHJvcGVydHkoam9pbnNba2V5XS5sZWZ0S2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSBjb3B5W2pvaW5zW2tleV1bam9pbnNba2V5XS5sZWZ0S2V5XV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0gPSBzZWxmW2tleV1bam9pbnNba2V5XS5yaWdodEtleV07XG4gICAgICAgIGNvcHlbam9pbnNba2V5XS5sZWZ0S2V5XSA9IHNlbGZba2V5XVtqb2luc1trZXldLnJpZ2h0S2V5XTsgLy8gV2UgbmVlZCB0byBwdXQgaXQgaW4gY29weSBiZWZvcmUgc2F2aW5nIGl0XG4gICAgICB9XG5cbiAgICAgIC8vIFNhdmUgdGhlIGRvY3VtZW50IHRoYXQgYmVsb25ncyB0byBzZWxmW2tleV1cbiAgICAgIGlmIChzZWxmW2tleV0uX19wcm90b19fLl9wYXJlbnRzLl9iZWxvbmdzVG9bY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKCldID09IG51bGwpIHtcbiAgICAgICAgc2VsZltrZXldLl9fcHJvdG9fXy5fcGFyZW50cy5fYmVsb25nc1RvW2NvbnN0cnVjdG9yLmdldFRhYmxlTmFtZSgpXSA9IFtdO1xuICAgICAgfVxuICAgICAgc2VsZltrZXldLl9fcHJvdG9fXy5fcGFyZW50cy5fYmVsb25nc1RvW2NvbnN0cnVjdG9yLmdldFRhYmxlTmFtZSgpXS5wdXNoKHtcbiAgICAgICAgZG9jOiBzZWxmLFxuICAgICAgICBmb3JlaWduS2V5OiBqb2luc1trZXldLmxlZnRLZXksXG4gICAgICAgIGtleToga2V5IC8vIGZvcmVpZ25Eb2NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHNlbGYuX3NhdmVTZWxmKGNvcHksIGRvY1RvU2F2ZSwgYmVsb25nc1RvS2V5c1NhdmVkLCBzYXZlQWxsLCBzYXZlZE1vZGVsLCByZXNvbHZlLCByZWplY3QpXG59XG5cblxuLyoqXG4gKiBTYXZlIHRoZSBkb2N1bWVudCBvbiB3aGljaCBgc2F2ZWAgd2FzIGNhbGxlZC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29weSBUaGUgc2F2YWJsZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBkb2N1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdD19IGRvY1RvU2F2ZSBEb2N1bWVudHMgdG8gc2F2ZSByZXByZXNlbnRlZCBieSBhbiBvYmplY3QgZmllbGQtPnRydWVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gYmVsb25nc1RvS2V5c1NhdmVkIFRoZSBrZXlzIHRoYXQgbWF5IGNvbnRhaW5zIGEgZG9jdW1lbnQgdG8gc2F2ZVxuICogQHBhcmFtIHtib29sZWFufSBzYXZlQWxsIFdoZXRoZXIgX3NhdmUgc2hvdWxkIHJlY3Vyc2UgYnkgZGVmYXVsdCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2F2ZWRNb2RlbCBNb2RlbHMgc2F2ZWQgaW4gdGhpcyBjYWxsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlcnl0aGluZyBoYXMgYmVlbiBzYXZlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIGFuIGVycm9yIGhhcHBlbmVkXG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5fc2F2ZVNlbGYgPSBmdW5jdGlvbihcbiAgICBjb3B5LCBkb2NUb1NhdmUsIGJlbG9uZ3NUb0tleXNTYXZlZCwgc2F2ZUFsbCwgc2F2ZWRNb2RlbCwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG1vZGVsID0gc2VsZi5fZ2V0TW9kZWwoKTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gc2VsZi5fX3Byb3RvX18uY29uc3RydWN0b3I7XG4gIHZhciByID0gdGhpcy5fZ2V0TW9kZWwoKS5fdGhpbmt5LnI7XG5cbiAgLy8gQmVsb25nc1RvIGRvY3VtZW50cyB3ZXJlIHNhdmVkIGJlZm9yZS4gV2UganVzdCBuZWVkIHRvIGNvcHkgdGhlIGZvcmVpZ25cbiAgLy8ga2V5cy5cbiAgdXRpbC5sb29wS2V5cyhtb2RlbC5fam9pbnMsIGZ1bmN0aW9uKGpvaW5zLCBrZXkpIHtcbiAgICBpZiAoKGpvaW5zW2tleV0udHlwZSA9PT0gJ2JlbG9uZ3NUbycpICYmIChiZWxvbmdzVG9LZXlzU2F2ZWRba2V5XSA9PT0gdHJ1ZSkpIHtcbiAgICAgIGlmIChzZWxmW2tleV0gIT0gbnVsbCkge1xuICAgICAgICBzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0gPSBzZWxmW2tleV1bam9pbnNba2V5XS5yaWdodEtleV1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYuX19wcm90b19fLl9iZWxvbmdzVG9ba2V5XSkge1xuICAgICAgICBkZWxldGUgc2VsZltqb2luc1trZXldLmxlZnRLZXldO1xuICAgICAgICBkZWxldGUgY29weVtqb2luc1trZXldLmxlZnRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHF1ZXJ5U2F2ZVNlbGY7IC8vIFRoZSBxdWVyeSB0byBzYXZlIHRoZSBkb2N1bWVudCBvbiB3aGljaCBgc2F2ZWAvYHNhdmVBbGxgIHdhcyBjYWxsZWQuXG4gIC8vIFdlIGhhdmVuJ3QgdmFsaWRhdGVkIHRoZSBkb2N1bWVudCB5ZXQsIHNvIGJ1aWxkaW5nIHRoZSBxdWVyeSB3aXRoIGBjb3B5YFxuICAvLyBtYXkgdGhyb3cgYW4gZXJyb3IgKGZvciBleGFtcGxlIGlmIGEgRGF0ZSBoYXMgbm90IGEgdmFsaWQgdGltZSkuXG4gIHZhciBidWlsZFF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9fcHJvdG9fXy5fc2F2ZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcXVlcnlTYXZlU2VsZiA9IHIudGFibGUoY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKCkpXG4gICAgICAgIC5pbnNlcnQoY29weSwge3JldHVybkNoYW5nZXM6ICdhbHdheXMnfSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY29weVttb2RlbC5fcGtdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRvY3VtZW50IHdhcyBwcmV2aW91c2x5IHNhdmVkLCBidXQgaXRzIHByaW1hcnkga2V5IGlzIHVuZGVmaW5lZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnlTYXZlU2VsZiA9IHIudGFibGUoY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKCkpXG4gICAgICAgIC5nZXQoY29weVttb2RlbC5fcGtdKS5yZXBsYWNlKGNvcHksIHtyZXR1cm5DaGFuZ2VzOiAnYWx3YXlzJ30pXG4gICAgfVxuICB9XG5cbiAgc2VsZi5nZXRNb2RlbCgpLnJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICB1dGlsLnRyeUNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvY3VtZW50IGJlZm9yZSBzYXZpbmcgaXRcbiAgICAgIHZhciBwcm9taXNlID0gc2VsZi52YWxpZGF0ZSgpO1xuICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBxdWVyeVNhdmVTZWxmID0gYnVpbGRRdWVyeSgpO1xuICAgICAgICAgIHF1ZXJ5U2F2ZVNlbGYucnVuKCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHNlbGYuX29uU2F2ZWQocmVzdWx0LCBkb2NUb1NhdmUsIHNhdmVBbGwsIHNhdmVkTW9kZWwsIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICB9KS5lcnJvcihyZWplY3QpXG4gICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcXVlcnlTYXZlU2VsZiA9IGJ1aWxkUXVlcnkoKTtcbiAgICAgICAgcXVlcnlTYXZlU2VsZi5ydW4oKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHNlbGYuX29uU2F2ZWQocmVzdWx0LCBkb2NUb1NhdmUsIHNhdmVBbGwsIHNhdmVkTW9kZWwsIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgfSkuZXJyb3IocmVqZWN0KVxuICAgICAgfVxuICAgIH0sIHJlamVjdCk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHRoZSBpbnNlcnQgcXVlcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSByZXN1bHQgZnJvbSB0aGUgaW5zZXJ0IHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdD19IGRvY1RvU2F2ZSBEb2N1bWVudHMgdG8gc2F2ZSByZXByZXNlbnRlZCBieSBhbiBvYmplY3QgZmllbGQtPnRydWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2F2ZUFsbCBXaGV0aGVyIF9zYXZlIHNob3VsZCByZWN1cnNlIGJ5IGRlZmF1bHQgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdD19IHNhdmVkTW9kZWwgTW9kZWxzIHNhdmVkIGluIHRoaXMgY2FsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gc2F2ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiBhbiBlcnJvciBoYXBwZW5lZFxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX29uU2F2ZWQgPSBmdW5jdGlvbihyZXN1bHQsIGRvY1RvU2F2ZSwgc2F2ZUFsbCwgc2F2ZWRNb2RlbCwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIC8vIEtlZXAgaW4gc3luYyB3aXRoIE1vZGVsLnNhdmVcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChyZXN1bHQuZmlyc3RfZXJyb3IgIT0gbnVsbCkge1xuICAgIHJldHVybiByZWplY3QoRXJyb3JzLmNyZWF0ZShyZXN1bHQuZmlyc3RfZXJyb3IpKTtcbiAgfVxuXG4gIHV0aWwudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7IC8vIFZhbGlkYXRlIHRoZSBkb2MsIHJlcGxhY2UgaXQsIGFuZCB0YWcgaXQgYXMgc2F2ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQuY2hhbmdlcykgJiYgcmVzdWx0LmNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZi5fbWVyZ2UocmVzdWx0LmNoYW5nZXNbMF0ubmV3X3ZhbCk7XG4gICAgICBzZWxmLl9zZXRPbGRWYWx1ZSh1dGlsLmRlZXBDb3B5KHJlc3VsdC5jaGFuZ2VzWzBdLm9sZF92YWwpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZ2V0TW9kZWwoKS5uZWVkVG9HZW5lcmF0ZUZpZWxkcyA9PT0gdHJ1ZSkge1xuICAgICAgc2VsZi5fZ2VuZXJhdGVEZWZhdWx0KCk7XG4gICAgfVxuICAgIHNlbGYuc2V0U2F2ZWQoKTtcbiAgICBzZWxmLmVtaXQoJ3NhdmVkJywgc2VsZik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYudmFsaWRhdGUoKTtcbiAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fc2F2ZU1hbnkoZG9jVG9TYXZlLCBzYXZlQWxsLCBzYXZlZE1vZGVsLCByZXNvbHZlLCByZWplY3QpXG4gICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNlbGYuX3NhdmVNYW55KGRvY1RvU2F2ZSwgc2F2ZUFsbCwgc2F2ZWRNb2RlbCwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgIH1cbiAgfSwgcmVqZWN0KTtcbn1cblxuXG4vKipcbiAqIFNhdmUgdGhlIGpvaW5lZCBkb2N1bWVudHMgbGlua2VkIHdpdGggYSBoYXNPbmUgb3IgaGFzTWFueSBvclxuICogaGFzQW5kQmVsb25nc1RvTWFueSByZWxhdGlvbi4gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGBfc2F2ZVNlbGZgIGFzIHdlXG4gKiB3aWxsIGhhdmUgdG8gY29weSB0aGUgZm9yZWlnbiBrZXlzIGluIHRoZSBqb2luZWQgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgcmVzdWx0IGZyb20gdGhlIGluc2VydCBxdWVyeVxuICogQHBhcmFtIHtPYmplY3Q9fSBkb2NUb1NhdmUgRG9jdW1lbnRzIHRvIHNhdmUgcmVwcmVzZW50ZWQgYnkgYW4gb2JqZWN0IGZpZWxkLT50cnVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNhdmVBbGwgV2hldGhlciBfc2F2ZSBzaG91bGQgcmVjdXJzZSBieSBkZWZhdWx0IG9yIG5vdFxuICogQHBhcmFtIHtPYmplY3Q9fSBzYXZlZE1vZGVsIE1vZGVscyBzYXZlZCBpbiB0aGlzIGNhbGxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVyeXRoaW5nIGhhcyBiZWVuIHNhdmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgYW4gZXJyb3IgaGFwcGVuZWRcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9zYXZlTWFueSA9IGZ1bmN0aW9uKGRvY1RvU2F2ZSwgc2F2ZUFsbCwgc2F2ZWRNb2RlbCwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG1vZGVsID0gc2VsZi5fZ2V0TW9kZWwoKTtcblxuICB2YXIgcHJvbWlzZXNNYW55ID0gW107XG4gIHV0aWwubG9vcEtleXMobW9kZWwuX2pvaW5zLCBmdW5jdGlvbihqb2lucywga2V5KSB7XG4gICAgaWYgKCgoa2V5IGluIGRvY1RvU2F2ZSkgfHwgKHNhdmVBbGwgPT09IHRydWUpKSAmJlxuICAgICAgICAoam9pbnNba2V5XS50eXBlID09PSAnaGFzT25lJykgJiYgKChzYXZlQWxsID09PSBmYWxzZSkgfHwgKHNhdmVkTW9kZWxbam9pbnNba2V5XS5tb2RlbC5nZXRUYWJsZU5hbWUoKV0gIT09IHRydWUpKSkge1xuICAgICAgc2F2ZWRNb2RlbFtqb2luc1trZXldLm1vZGVsLmdldFRhYmxlTmFtZSgpXSA9IHRydWU7XG5cbiAgICAgIGlmIChzZWxmW2tleV0gIT0gbnVsbCkge1xuICAgICAgICBzZWxmW2tleV1bam9pbnNba2V5XS5yaWdodEtleV0gPSBzZWxmW2pvaW5zW2tleV0ubGVmdEtleV07XG4gICAgICAgIChmdW5jdGlvbihfa2V5KSB7XG4gICAgICAgICAgcHJvbWlzZXNNYW55LnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmW19rZXldLl9zYXZlKGRvY1RvU2F2ZVtfa2V5XSwgc2F2ZUFsbCwgc2F2ZWRNb2RlbCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5fX3Byb3RvX18uX2hhc09uZVtfa2V5XSA9IHtcbiAgICAgICAgICAgICAgICBkb2M6IHNlbGZbX2tleV0sXG4gICAgICAgICAgICAgICAgZm9yZWlnbktleTogc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnNbX2tleV0ucmlnaHRLZXlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKHNlbGZbX2tleV0uX19wcm90b19fLl9wYXJlbnRzLl9oYXNPbmVbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGZbX2tleV0uX19wcm90b19fLl9wYXJlbnRzLl9oYXNPbmVbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmW19rZXldLl9fcHJvdG9fXy5fcGFyZW50cy5faGFzT25lW3NlbGYuX2dldE1vZGVsKCkuX25hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgIGRvYzogc2VsZixcbiAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkoa2V5KVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKHNlbGZba2V5XSA9PSBudWxsKSAmJiAoc2VsZi5fX3Byb3RvX18uX2hhc09uZVtrZXldICE9IG51bGwpKSB7XG4gICAgICAgIHZhciBkb2MgPSBzZWxmLl9fcHJvdG9fXy5faGFzT25lW2tleV0uZG9jO1xuICAgICAgICBkZWxldGUgZG9jW3NlbGYuX19wcm90b19fLl9oYXNPbmVba2V5XS5mb3JlaWduS2V5XTtcbiAgICAgICAgcHJvbWlzZXNNYW55LnB1c2goZG9jLl9zYXZlKGRvY1RvU2F2ZVtrZXldLCBzYXZlQWxsLCBzYXZlZE1vZGVsKSlcbiAgICAgICAgc2VsZi5fX3Byb3RvX18uX2hhc09uZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB1dGlsLmxvb3BLZXlzKG1vZGVsLl9qb2lucywgZnVuY3Rpb24oam9pbnMsIGtleSkge1xuICAgIGlmICgoKGtleSBpbiBkb2NUb1NhdmUpIHx8IChzYXZlQWxsID09PSB0cnVlKSkgJiZcbiAgICAgICAgKGpvaW5zW2tleV0udHlwZSA9PT0gJ2hhc01hbnknKSAmJiAoKHNhdmVBbGwgPT09IGZhbHNlKSB8fCAoc2F2ZWRNb2RlbFtqb2luc1trZXldLm1vZGVsLmdldFRhYmxlTmFtZSgpXSAhPT0gdHJ1ZSkpXG4gICAgICAgICYmIChBcnJheS5pc0FycmF5KHNlbGZba2V5XSkpKSB7XG5cbiAgICAgIHNhdmVkTW9kZWxbam9pbnNba2V5XS5tb2RlbC5nZXRUYWJsZU5hbWUoKV0gPSB0cnVlO1xuXG4gICAgICAvL0dvIHRocm91Z2ggX2hhc01hbnkgYW5kIGZpbmQgZWxlbWVudCB0aGF0IHdlcmUgcmVtb3ZlZFxuICAgICAgdmFyIHBrTWFwID0ge307XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmW2tleV0pKSB7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHNlbGZba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWxmW2tleV1baV1bam9pbnNba2V5XS5tb2RlbC5fcGtdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBrTWFwW3NlbGZba2V5XVtpXVtqb2luc1trZXldLm1vZGVsLl9wa11dID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuX19wcm90b19fLl9oYXNNYW55W2tleV0gIT0gbnVsbCkge1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxzZWxmLl9fcHJvdG9fXy5faGFzTWFueVtrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBrTWFwW3NlbGYuX19wcm90b19fLl9oYXNNYW55W2tleV1baV0uZG9jW1tqb2luc1trZXldLm1vZGVsLl9wa11dXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5fX3Byb3RvX18uX2hhc01hbnlba2V5XVtpXS5kb2Nbc2VsZi5fX3Byb3RvX18uX2hhc01hbnlba2V5XVtpXS5mb3JlaWduS2V5XTtcbiAgICAgICAgICAgIHByb21pc2VzTWFueS5wdXNoKHNlbGYuX19wcm90b19fLl9oYXNNYW55W2tleV1baV0uZG9jLl9zYXZlKGRvY1RvU2F2ZVtrZXldLCBzYXZlQWxsLCBzYXZlZE1vZGVsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLl9fcHJvdG9fXy5faGFzTWFueVtrZXldID0gW107XG5cbiAgICAgIGZvcih2YXIgaT0wOyBpPHNlbGZba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmW2tleV1baV1bam9pbnNba2V5XS5yaWdodEtleV0gPSBzZWxmW2pvaW5zW2tleV0ubGVmdEtleV07XG4gICAgICAgIChmdW5jdGlvbihrZXksIGkpIHtcbiAgICAgICAgICBwcm9taXNlc01hbnkucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICghKHNlbGZba2V5XVtpXSBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICAgICAgICBzZWxmW2tleV1baV0gPSBuZXcgam9pbnNba2V5XS5tb2RlbChzZWxmW2tleV1baV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZltrZXldW2ldLl9zYXZlKGRvY1RvU2F2ZVtrZXldLCBzYXZlQWxsLCBzYXZlZE1vZGVsKS50aGVuKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZWxmLl9fcHJvdG9fXy5faGFzTWFueVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5fX3Byb3RvX18uX2hhc01hbnlba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLl9fcHJvdG9fXy5faGFzTWFueVtrZXldLnB1c2goe1xuICAgICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgICBmb3JlaWduS2V5OiBzZWxmLl9nZXRNb2RlbCgpLl9qb2luc1trZXldLnJpZ2h0S2V5XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZltrZXldW2ldLl9fcHJvdG9fXy5fcGFyZW50cy5faGFzTWFueVtzZWxmLl9nZXRNb2RlbCgpLl9uYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmW2tleV1baV0uX19wcm90b19fLl9wYXJlbnRzLl9oYXNNYW55W3NlbGYuX2dldE1vZGVsKCkuX25hbWVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGZba2V5XVtpXS5fX3Byb3RvX18uX3BhcmVudHMuX2hhc01hbnlbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBkb2M6IHNlbGYsXG4gICAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZltrZXldW2ldIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICBzZWxmW2tleV1baV0udGhlbihjYWxsYmFjaykuZXJyb3IocmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdXRpbC5sb29wS2V5cyhtb2RlbC5fam9pbnMsIGZ1bmN0aW9uKGpvaW5zLCBrZXkpIHtcbiAgICAvLyBDb21wYXJlIHRvIG51bGxcbiAgICBpZiAoKChrZXkgaW4gZG9jVG9TYXZlKSB8fCAoc2F2ZUFsbCA9PT0gdHJ1ZSkpICYmXG4gICAgICAgIChqb2luc1trZXldLnR5cGUgPT09ICdoYXNBbmRCZWxvbmdzVG9NYW55JykgJiYgKChzYXZlQWxsID09PSBmYWxzZSkgfHwgKHNhdmVkTW9kZWxbam9pbnNba2V5XS5tb2RlbC5nZXRUYWJsZU5hbWUoKV0gIT09IHRydWUpKSkge1xuXG4gICAgICBzYXZlZE1vZGVsW2pvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCldID0gdHJ1ZTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZltrZXldKSkge1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxzZWxmW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHNlbGZba2V5XVtpXSkpIHsgLy8gU2F2ZSBvbmx5IGlmIHdlIGhhdmUgYSBmdWxsIG9iamVjdCwgYW5kIG5vdCBqdXN0IGEga2V5XG4gICAgICAgICAgICAoZnVuY3Rpb24oa2V5LCBpKSB7XG4gICAgICAgICAgICAgIHByb21pc2VzTWFueS5wdXNoKG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghKHNlbGZba2V5XVtpXSBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgc2VsZltrZXldW2ldID0gbmV3IGpvaW5zW2tleV0ubW9kZWwoc2VsZltrZXldW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmW2tleV1baV0uX3NhdmUoZG9jVG9TYXZlW2tleV0sIHNhdmVBbGwsIHNhdmVkTW9kZWwpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYuX19wcm90b19fLl9saW5rcyB3aWxsIGJlIHNhdmVkIGluIHNhdmVMaW5rc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZltrZXldW2ldLl9fcHJvdG9fXy5fcGFyZW50cy5fYmVsb25nc0xpbmtzW3NlbGYuX2dldE1vZGVsKCkuX25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxmW2tleV1baV0uX19wcm90b19fLl9wYXJlbnRzLl9iZWxvbmdzTGlua3Nbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2tleV1baV0uX19wcm90b19fLl9wYXJlbnRzLl9iZWxvbmdzTGlua3Nbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgZG9jOiBzZWxmLFxuICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmW2tleV1baV0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmW2tleV1baV0udGhlbihjYWxsYmFjaykuZXJyb3IocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9KShrZXksIGkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAocHJvbWlzZXNNYW55Lmxlbmd0aCA+IDApIHtcbiAgICBQcm9taXNlLmFsbChwcm9taXNlc01hbnkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9zYXZlTGlua3MoZG9jVG9TYXZlLCBzYXZlQWxsLCByZXNvbHZlLCByZWplY3QpXG4gICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWxmLl9zYXZlTGlua3MoZG9jVG9TYXZlLCBzYXZlQWxsLCByZXNvbHZlLCByZWplY3QpXG4gIH1cbn1cblxuXG4vKipcbiAqIFNhdmUgdGhlIGxpbmtzIGZvciBoYXNBbmRCZWxvbmdzVG9NYW55IGpvaW5lZCBkb2N1bWVudHMuXG4gKiBjYWxsZWQgYmVmb3JlIF9zYXZlU2VsZiBhcyB3ZSB3aWxsIGhhdmUgdG8gY29weSB0aGUgZm9yZWlnbiBrZXlzIGluIGBzZWxmYC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gZG9jVG9TYXZlIERvY3VtZW50cyB0byBzYXZlIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBmaWVsZC0+dHJ1ZVxuICogQHBhcmFtIHtib29sZWFufSBzYXZlQWxsIFdoZXRoZXIgX3NhdmUgc2hvdWxkIHJlY3Vyc2UgYnkgZGVmYXVsdCBvciBub3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBldmVyeXRoaW5nIGhhcyBiZWVuIHNhdmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgYW4gZXJyb3IgaGFwcGVuZWRcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9zYXZlTGlua3MgPSBmdW5jdGlvbihkb2NUb1NhdmUsIHNhdmVBbGwsIHJlc29sdmUsIHJlamVjdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBtb2RlbCA9IHNlbGYuX2dldE1vZGVsKCk7XG4gIHZhciBjb25zdHJ1Y3RvciA9IHNlbGYuZ2V0TW9kZWwoKTtcbiAgdmFyIHIgPSBtb2RlbC5fdGhpbmt5LnI7XG5cbiAgdmFyIHByb21pc2VzTGluayA9IFtdO1xuXG4gIHV0aWwubG9vcEtleXMobW9kZWwuX2pvaW5zLCBmdW5jdGlvbihqb2lucywga2V5KSB7XG4gICAgLy8gV3JpdGUgdGVzdHMgYWJvdXQgdGhhdCFcbiAgICBpZiAoKChrZXkgaW4gZG9jVG9TYXZlKSB8fCAoc2F2ZUFsbCA9PT0gdHJ1ZSkpICYmXG4gICAgICAgIChqb2luc1trZXldLnR5cGUgPT09ICdoYXNBbmRCZWxvbmdzVG9NYW55JykpIHtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZltrZXldKSkge1xuICAgICAgICB2YXIgbmV3S2V5cyA9IHt9XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHNlbGZba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qoc2VsZltrZXldW2ldKSkge1xuICAgICAgICAgICAgaWYgKHNlbGZba2V5XVtpXS5pc1NhdmVkKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbmV3S2V5c1tzZWxmW2tleV1baV1bam9pbnNba2V5XS5yaWdodEtleV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7IC8vIHNlbGZba2V5XVtpXSBpcyBqdXN0IHRoZSBrZXlcbiAgICAgICAgICAgIG5ld0tleXNbc2VsZltrZXldW2ldXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuX19wcm90b19fLl9saW5rc1tqb2luc1trZXldLmxpbmtdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmLl9fcHJvdG9fXy5fbGlua3Nbam9pbnNba2V5XS5saW5rXSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZEtleXMgPSBzZWxmLl9fcHJvdG9fXy5fbGlua3Nbam9pbnNba2V5XS5saW5rXTtcblxuICAgICAgICB1dGlsLmxvb3BLZXlzKG5ld0tleXMsIGZ1bmN0aW9uKG5ld0tleXMsIGxpbmspIHtcbiAgICAgICAgICBpZiAob2xkS2V5c1tsaW5rXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5ld0xpbmsgPSB7fTtcblxuICAgICAgICAgICAgaWYgKChjb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUoKSA9PT0gam9pbnNba2V5XS5tb2RlbC5nZXRUYWJsZU5hbWUoKSlcbiAgICAgICAgICAgICAgJiYgKGpvaW5zW2tleV0ubGVmdEtleSA9PT0gam9pbnNba2V5XS5yaWdodEtleSkpIHtcblxuICAgICAgICAgICAgICAvLyBXZSBsaW5rIG9uIHRoZSBzYW1lIG1vZGVsIGFuZCBzYW1lIGtleVxuICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHNhdmUgcmVkdW5kYW50IGZpZWxkXG4gICAgICAgICAgICAgIGlmIChsaW5rIDwgc2VsZltqb2luc1trZXldLmxlZnRLZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3TGluay5pZCA9IGxpbmsrXCJfXCIrc2VsZltqb2luc1trZXldLmxlZnRLZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0xpbmsuaWQgPSBzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0rXCJfXCIrbGluaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXdMaW5rW2pvaW5zW2tleV0ubGVmdEtleStcIl9cIitqb2luc1trZXldLmxlZnRLZXldID0gW2xpbmssIHNlbGZbam9pbnNba2V5XS5sZWZ0S2V5XV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3TGlua1tjb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUoKStcIl9cIitqb2luc1trZXldLmxlZnRLZXldID0gc2VsZltqb2luc1trZXldLmxlZnRLZXldO1xuICAgICAgICAgICAgICBuZXdMaW5rW2pvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNba2V5XS5yaWdodEtleV0gPSBsaW5rO1xuXG4gICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcHJpbWFyeSBrZXlcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZSgpIDwgam9pbnNba2V5XS5tb2RlbC5nZXRUYWJsZU5hbWUoKSkge1xuICAgICAgICAgICAgICAgIG5ld0xpbmsuaWQgPSBzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0rXCJfXCIrbGluaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChjb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUoKSA+IGpvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICBuZXdMaW5rLmlkID0gbGluaytcIl9cIitzZWxmW2pvaW5zW2tleV0ubGVmdEtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgPCBzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0pIHtcbiAgICAgICAgICAgICAgICAgIG5ld0xpbmsuaWQgPSBsaW5rK1wiX1wiK3NlbGZbam9pbnNba2V5XS5sZWZ0S2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXdMaW5rLmlkID0gc2VsZltqb2luc1trZXldLmxlZnRLZXldK1wiX1wiK2xpbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIChmdW5jdGlvbihrZXksIGxpbmspIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXNMaW5rLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgci50YWJsZShzZWxmLl9nZXRNb2RlbCgpLl9qb2luc1trZXldLmxpbmspLmluc2VydChuZXdMaW5rLCB7Y29uZmxpY3Q6IFwicmVwbGFjZVwiLCByZXR1cm5DaGFuZ2VzOiAnYWx3YXlzJ30pLnJ1bigpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQuY2hhbmdlcykgJiYgcmVzdWx0LmNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9fcHJvdG9fXy5fbGlua3Nbam9pbnNba2V5XS5saW5rXVtyZXN1bHQuY2hhbmdlc1swXS5uZXdfdmFsW2pvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNba2V5XS5yaWdodEtleV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9fcHJvdG9fXy5fbGlua3Nbam9pbnNba2V5XS5saW5rXVtuZXdMaW5rW2pvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNba2V5XS5yaWdodEtleV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0pKGtleSwgbGluayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIga2V5c1RvRGVsZXRlID0gW11cbiAgICAgICAgdXRpbC5sb29wS2V5cyhvbGRLZXlzLCBmdW5jdGlvbihvbGRLZXlzLCBsaW5rKSB7XG4gICAgICAgICAgaWYgKG5ld0tleXNbbGlua10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZSgpIDwgam9pbnNba2V5XS5tb2RlbC5nZXRUYWJsZU5hbWUoKSkge1xuICAgICAgICAgICAgICBrZXlzVG9EZWxldGUucHVzaChzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0rXCJfXCIrbGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAga2V5c1RvRGVsZXRlLnB1c2gobGluaytcIl9cIitzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrZXlzVG9EZWxldGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0YWJsZSA9IHIudGFibGUoam9pbnNba2V5XS5saW5rKTtcbiAgICAgICAgICBwcm9taXNlc0xpbmsucHVzaCh0YWJsZS5nZXRBbGwuYXBwbHkodGFibGUsIGtleXNUb0RlbGV0ZSkuZGVsZXRlKCkucnVuKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGtleXNUb0RlbGV0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzZWxmLl9fcHJvdG9fXy5fbGlua3Nbam9pbnNba2V5XS5saW5rXVtrZXlzVG9EZWxldGVbaV1dID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAocHJvbWlzZXNMaW5rLmxlbmd0aCA+IDApIHtcbiAgICBQcm9taXNlLmFsbChwcm9taXNlc0xpbmspLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHNlbGYpO1xuICAgIH0pLmVycm9yKHJlamVjdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVzb2x2ZShzZWxmKTtcbiAgfVxufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBzYXZlZCBpbiBfX3Byb3RvX18ub2xkVmFsdWVcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLmdldE9sZFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcHJvdG9fXy5vbGRWYWx1ZTtcbn1cblxuXG4vKipcbiAqIFNhdmUgYSByZWZlcmVuY2Ugb2YgYHZhbHVlYCB0aGF0IHdpbGwgYmUgbGF0ZXIgYWNjZXNzaWJsZSB3aXRoIGBnZXRPbGRWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNhdmVcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9zZXRPbGRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fcHJvdG9fXy5vbGRWYWx1ZSA9IHZhbHVlO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgdGhpcyBkb2N1bWVudCB3YXMgc2F2ZWQgb3Igbm90LlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLmlzU2F2ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wcm90b19fLl9zYXZlZDtcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgZG9jdW1lbnQgKGFuZCBtYXliZSBpdHMgam9pbmVkIGRvY3VtZW50cykgYXMgc2F2ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBhbGwgUmVjdXJzaXZlbHkgc2V0IGFsbCB0aGUgam9pbmVkIGRvY3VtZW50cyBhcyBzYXZlZFxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuc2V0U2F2ZWQgPSBmdW5jdGlvbihhbGwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9fcHJvdG9fXy5fc2F2ZWQgPSB0cnVlO1xuICBpZiAoYWxsICE9PSB0cnVlKSByZXR1cm47XG4gICAgdXRpbC5sb29wS2V5cyhzZWxmLl9nZXRNb2RlbCgpLl9qb2lucywgZnVuY3Rpb24oam9pbnMsIGtleSkge1xuICAgICAgc3dpdGNoIChqb2luc1trZXldLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaGFzT25lJzpcbiAgICAgICAgICBpZiAoc2VsZltrZXldIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XS5zZXRTYXZlZCh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYmVsb25nc1RvJzpcbiAgICAgICAgICBpZiAoc2VsZltrZXldIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XS5zZXRTYXZlZCh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaGFzTWFueSc6XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZltrZXldKSkge1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8c2VsZltrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmW2tleV1baV0gaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHNlbGZba2V5XVtpXS5zZXRTYXZlZCh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoYXNBbmRCZWxvbmdzVG9NYW55JzpcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmW2tleV0pKSB7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxzZWxmW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGZba2V5XVtpXSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZltrZXldW2ldLnNldFNhdmVkKHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTWFrZSBqb2lucywgd2Ugc2hvdWxkIGtlZXAgcmVmZXJlbmNlcyBvbmx5IG9mIHRoZSBzYXZlZCBkb2N1bWVudHNcbiAgICB1dGlsLmxvb3BLZXlzKHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zLCBmdW5jdGlvbihqb2lucywga2V5KSB7XG4gICAgICBpZiAoc2VsZltrZXldID09IG51bGwpIHJldHVybjtcbiAgICAgIHN3aXRjaCAoam9pbnNba2V5XS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2hhc09uZSc6XG4gICAgICAgICAgaWYgKHNlbGZba2V5XS5pc1NhdmVkKCkpIHtcbiAgICAgICAgICAgIHNlbGYuX19wcm90b19fLl9oYXNPbmVba2V5XSA9IHtcbiAgICAgICAgICAgICAgZG9jOiBzZWxmW2tleV0sXG4gICAgICAgICAgICAgIGZvcmVpZ25LZXk6IHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ucmlnaHRLZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZltrZXldLl9fcHJvdG9fXy5fcGFyZW50cy5faGFzT25lW3NlbGYuX2dldE1vZGVsKCkuX25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XS5fX3Byb3RvX18uX3BhcmVudHMuX2hhc09uZVtzZWxmLl9nZXRNb2RlbCgpLl9uYW1lXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmW2tleV0uX19wcm90b19fLl9wYXJlbnRzLl9oYXNPbmVbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0ucHVzaCh7XG4gICAgICAgICAgICBkb2M6IHNlbGYsXG4gICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JlbG9uZ3NUbyc6XG4gICAgICAgICAgaWYgKHNlbGZba2V5XS5fX3Byb3RvX18uX3BhcmVudHMuX2JlbG9uZ3NUb1tzZWxmLl9nZXRNb2RlbCgpLl9uYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmW2tleV0uX19wcm90b19fLl9wYXJlbnRzLl9iZWxvbmdzVG9bc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZltrZXldLl9fcHJvdG9fXy5fcGFyZW50cy5fYmVsb25nc1RvW3NlbGYuX2dldE1vZGVsKCkuX25hbWVdLnB1c2goe1xuICAgICAgICAgICAgZG9jOiBzZWxmLFxuICAgICAgICAgICAgZm9yZWlnbktleTogc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnNba2V5XS5sZWZ0S2V5LFxuICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLl9fcHJvdG9fXy5fYmVsb25nc1RvW2tleV0gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hhc01hbnknOlxuICAgICAgICAgIHNlbGYuX19wcm90b19fLl9oYXNNYW55W2tleV0gPSBbXVxuXG4gICAgICAgICAgZm9yKHZhciBpPTA7IGk8c2VsZltrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZltrZXldW2ldLmlzU2F2ZWQoKSkge1xuICAgICAgICAgICAgICBzZWxmLl9fcHJvdG9fXy5faGFzTWFueVtrZXldLnB1c2goe1xuICAgICAgICAgICAgICAgIGRvYzogc2VsZltrZXldW2ldLFxuICAgICAgICAgICAgICAgIGZvcmVpZ25LZXk6IHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ucmlnaHRLZXlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGZba2V5XVtpXS5fX3Byb3RvX18uX3BhcmVudHMuX2hhc01hbnlbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZWxmW2tleV1baV0uX19wcm90b19fLl9wYXJlbnRzLl9oYXNNYW55W3NlbGYuX2dldE1vZGVsKCkuX25hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmW2tleV1baV0uX19wcm90b19fLl9wYXJlbnRzLl9oYXNNYW55W3NlbGYuX2dldE1vZGVsKCkuX25hbWVdLnB1c2goe1xuICAgICAgICAgICAgICBkb2M6IHNlbGYsXG4gICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoYXNBbmRCZWxvbmdzVG9NYW55JzpcbiAgICAgICAgICBpZiAoc2VsZi5fX3Byb3RvX18uX2xpbmtzW3NlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ubGlua10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZi5fX3Byb3RvX18uX2xpbmtzW3NlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ubGlua10gPSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHNlbGZba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNlbGZba2V5XVtpXS5pc1NhdmVkKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5fX3Byb3RvX18uX2xpbmtzW3NlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ubGlua11bc2VsZltrZXldW2ldW3NlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2tleV0ucmlnaHRLZXldXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmW2tleV1baV0uX19wcm90b19fLl9wYXJlbnRzLl9iZWxvbmdzTGlua3Nbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZWxmW2tleV1baV0uX19wcm90b19fLl9wYXJlbnRzLl9iZWxvbmdzTGlua3Nbc2VsZi5fZ2V0TW9kZWwoKS5fbmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGZba2V5XVtpXS5fX3Byb3RvX18uX3BhcmVudHMuX2JlbG9uZ3NMaW5rc1tzZWxmLl9nZXRNb2RlbCgpLl9uYW1lXS5wdXNoKHtcbiAgICAgICAgICAgICAgZG9jOiBzZWxmLFxuICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbn1cblxuXG4vKipcbiAqIFNldCB0aGUgZG9jdW1lbnQgYXMgdW5zYXZlZFxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuX3NldFVuU2F2ZWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Byb3RvX18uX3NhdmVkID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBEZWxldGUgdGhlIGRvY3VtZW50IGZyb20gdGhlIGRhdGFiYXNlLiBVcGRhdGUgdGhlIGpvaW5lZCBkb2N1bWVudHMgYnlcbiAqIHJlbW92aW5nIHRoZSBmb3JlaWduIGtleSBmb3IgaGFzT25lL2hhc01hbnkgam9pbmVkIGRvY3VtZW50cywgYW5kIHJlbW92ZSB0aGVcbiAqIGxpbmtzIGZvciBoYXNBbmRCZWxvbmdzVG9NYW55IGpvaW5lZCBkb2N1bWVudHMgaWYgdGhlIGxpbmsgaXMgYnVpbHQgb24gdGhlXG4gKiBwcmltYXJ5IGtleS5cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFja1xuICogQHJldHVybiB7UHJvbWlzZT19IFJldHVybiBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9kZWxldGUoe30sIGZhbHNlLCBbXSwgdHJ1ZSwgdHJ1ZSwgY2FsbGJhY2spXG59XG5cblxuLyoqXG4gKiBEZWxldGUgdGhlIGRvY3VtZW50IGZyb20gdGhlIGRhdGFiYXNlIGFuZCB0aGUgam9pbmVkIGRvY3VtZW50cy4gSWZcbiAqIGBkb2NUb0RlbGV0ZWAgaXMgdW5kZWZpbmVkLCBpdCB3aWxsIGRlbGV0ZSBhbGwgdGhlIGpvaW5lZCBkb2N1bWVudHMsIGVsc2UgaXRcbiAqIHdpbGwgbGltaXRzIGl0c2VsZiB0byB0aGUgb25lIHN0b3JlZCBpbiB0aGUga2V5cyBkZWZpbmVkIGluIGBkb2NUb0RlbGV0ZWAuXG4gKiBJdCB3aWxsIGFsc28gdXBkYXRlIHRoZSBqb2luZWQgZG9jdW1lbnRzIGJ5IHJlbW92aW5nIHRoZSBmb3JlaWduIGtleSBmb3JcbiAqIGBoYXNPbmVgL2BoYXNNYW55YCBqb2luZWQgZG9jdW1lbnRzLCBhbmQgcmVtb3ZlIHRoZSBsaW5rcyBmb3JcbiAqIGBoYXNBbmRCZWxvbmdzVG9NYW55YCBqb2luZWQgZG9jdW1lbnRzIGlmIHRoZSBsaW5rIGlzIGJ1aWx0IG9uIHRoZSBwcmltYXJ5XG4gKiBrZXkuXG4gKiBAcGFyYW0ge09iamVjdD19IGRvY1RvRGVsZXRlIEFuIG9iamVjdCB3aGVyZSBhIGZpZWxkIG1hcHMgdG8gYHRydWVgIGlmIHRoZVxuICogZG9jdW1lbnQgc3RvcmVkIGluIHRoaXMgZmllbGQgc2hvdWxkIGJlIGRlbGV0ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2U9fSBSZXR1cm4gYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbihkb2NUb0RlbGV0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGRlbGV0ZUFsbDtcbiAgaWYgKHR5cGVvZiBkb2NUb0RlbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZG9jVG9EZWxldGU7XG4gICAgZGVsZXRlQWxsID0gdHJ1ZTtcbiAgICBkb2NUb0RlbGV0ZSA9IHt9O1xuICB9XG4gIGVsc2Uge1xuICAgIGRlbGV0ZUFsbCA9IGRvY1RvRGVsZXRlID09PSB1bmRlZmluZWQ7XG4gICAgZG9jVG9EZWxldGUgPSBkb2NUb0RlbGV0ZSB8fCB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZGVsZXRlKGRvY1RvRGVsZXRlLCBkZWxldGVBbGwsIFtdLCB0cnVlLCB0cnVlLCBjYWxsYmFjaylcbn1cblxuXG4vKipcbiAqIERlbGV0ZSB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgZGF0YWJhc2UgYW5kIHRoZSBqb2luZWQgZG9jdW1lbnRzLiBJZlxuICogYGRvY1RvRGVsZXRlYCBpcyBgdW5kZWZpbmVkYCBhbmQgYGRlbGV0ZUFsbGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGV0ZSBhbGxcbiAqIHRoZSBqb2luZWQgZG9jdW1lbnRzLCBlbHNlIGl0IHdpbGwgbGltaXRzIGl0c2VsZiB0byB0aGUgb25lIHN0b3JlZCBpbiB0aGVcbiAqIGtleXMgZGVmaW5lZCBpbiBgZG9jVG9EZWxldGVgLiBJdCB3aWxsIGFsc28gdXBkYXRlIHRoZSBqb2luZWQgZG9jdW1lbnRzIGJ5XG4gKiByZW1vdmluZyB0aGUgZm9yZWlnbiBrZXkgZm9yIGBoYXNPbmVgL2BoYXNNYW55YCBqb2luZWQgZG9jdW1lbnRzLCBhbmRcbiAqIHJlbW92ZSB0aGUgbGlua3MgZm9yIGBoYXNBbmRCZWxvbmdzVG9NYW55YCBqb2luZWQgZG9jdW1lbnRzIGlmIHRoZSBsaW5rIGlzXG4gKiBidWlsdCBvbiB0aGUgcHJpbWFyeSBrZXkuXG4gKiBIb29rcyB3aWxsIGFsc28gYmUgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge09iamVjdD19IGRvY1RvRGVsZXRlIEV4cGxpY2l0IG1hcHMgb2YgdGhlIGRvY3VtZW50cyB0byBkZWxldGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVsZXRlQWxsIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgdGhlIGRvY3VtZW50cyBpZlxuICogICAgIGBkb2NUb0RlbGV0ZWAgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0ge0FycmF5fSBkZWxldGVkRG9jcyBBcnJheSBvZiBkb2NzIGFscmVhZHkgZGVsZXRlZCwgdXNlZCB0byBtYWtlIHN1cmVcbiAqICAgICB0aGF0IHdlIGRvIG5vdCB0cnkgdG8gZGVsZXRlIG11bHRpcGxlIHRpbWVzIHRoZSBzYW1lIGRvY3VtZW50c1xuICogQHBhcmFtIHtib29sZWFufSBkZWxldGVTZWxmIFdoZXRoZXIgaXQgc2hvdWxkIGRlbGV0ZSBzZWxmXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVBhcmVudHMgV2hldGhlciBpdCBzaG91bGQgdXBkYXRlIHRoZSBrZXlzIGZvciB0aGVcbiAqICAgICBwYXJlbnRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2U9fSBSZXR1cm4gYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5fZGVsZXRlID0gZnVuY3Rpb24oZG9jVG9EZWxldGUsIGRlbGV0ZUFsbCwgZGVsZXRlZERvY3MsIGRlbGV0ZVNlbGYsIHVwZGF0ZVBhcmVudHMsIGNhbGxiYWNrKSB7XG4gIC8vVE9ETyBTZXQgYSAoc3RyaW5nKSBpZCBwZXIgZG9jdW1lbnQgYW5kIHVzZSBpdCB0byBwZXJmb3JtIGZhc3RlciBsb29rdXBcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3QoZG9jVG9EZWxldGUpID09PSBmYWxzZSkge1xuICAgIGRvY1RvRGVsZXRlID0ge307XG4gIH1cblxuICBkZWxldGVTZWxmID0gKGRlbGV0ZVNlbGYgPT09IHVuZGVmaW5lZCkgPyB0cnVlOiBkZWxldGVTZWxmO1xuXG4gIHJldHVybiB1dGlsLmhvb2soe1xuICAgIHByZUhvb2tzOiBzZWxmLl9nZXRNb2RlbCgpLl9wcmUuZGVsZXRlLFxuICAgIHBvc3RIb29rczogc2VsZi5fZ2V0TW9kZWwoKS5fcG9zdC5kZWxldGUsXG4gICAgZG9jOiBzZWxmLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGZuOiBzZWxmLl9kZWxldGVIb29rLFxuICAgIGZuQXJnczogW2RvY1RvRGVsZXRlLCBkZWxldGVBbGwsIGRlbGV0ZWREb2NzLCBkZWxldGVTZWxmLCB1cGRhdGVQYXJlbnRzLCBjYWxsYmFja11cbiAgfSk7XG59XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBtZXRob2RzIHVzZWQgaW4gYF9kZWxldGVgLiBEb2VzIHRoZSBzYW1lIGFzIGBfZGVsZXRlYCBidXQgd2l0aG91dFxuICogdGhlIGhvb2tzLlxuICogQHBhcmFtIHtPYmplY3Q9fSBkb2NUb0RlbGV0ZSBFeHBsaWNpdCBtYXBzIG9mIHRoZSBkb2N1bWVudHMgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlbGV0ZUFsbCBSZWN1cnNpdmVseSBkZWxldGUgYWxsIHRoZSBkb2N1bWVudHMgaWZcbiAqICAgICBgZG9jVG9EZWxldGVgIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHtBcnJheX0gZGVsZXRlZERvY3MgQXJyYXkgb2YgZG9jcyBhbHJlYWR5IGRlbGV0ZWQsIHVzZWQgdG8gbWFrZSBzdXJlXG4gKiAgICAgdGhhdCB3ZSBkbyBub3QgdHJ5IHRvIGRlbGV0ZSBtdWx0aXBsZSB0aW1lcyB0aGUgc2FtZSBkb2N1bWVudHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVsZXRlU2VsZiBXaGV0aGVyIGl0IHNob3VsZCBkZWxldGUgc2VsZlxuICogQHBhcmFtIHtib29sZWFufSB1cGRhdGVQYXJlbnRzIFdoZXRoZXIgaXQgc2hvdWxkIHVwZGF0ZSB0aGUga2V5cyBmb3IgdGhlXG4gKiAgICAgcGFyZW50c1xuICogQHJldHVybiB7UHJvbWlzZT19IFJldHVybiBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9kZWxldGVIb29rID0gZnVuY3Rpb24oZG9jVG9EZWxldGUsIGRlbGV0ZUFsbCwgZGVsZXRlZERvY3MsIGRlbGV0ZVNlbGYsIHVwZGF0ZVBhcmVudHMsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG1vZGVsID0gc2VsZi5fZ2V0TW9kZWwoKTsgLy8gaW5zdGFuY2Ugb2YgTW9kZWxcbiAgdmFyIGNvbnN0cnVjdG9yID0gc2VsZi5nZXRNb2RlbCgpO1xuICB2YXIgciA9IG1vZGVsLl90aGlua3kucjtcblxuICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICBkZWxldGVkRG9jcy5wdXNoKHNlbGYpO1xuICB1dGlsLmxvb3BLZXlzKHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zLCBmdW5jdGlvbihqb2lucywga2V5KSB7XG4gICAgaWYgKChqb2luc1trZXldLnR5cGUgPT09ICdoYXNPbmUnKSAmJiAoc2VsZltrZXldIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICBpZiAoKHNlbGZba2V5XS5pc1NhdmVkKCkgPT09IHRydWUpICYmXG4gICAgICAgICgoa2V5IGluIGRvY1RvRGVsZXRlKSB8fCAoKGRlbGV0ZUFsbCA9PT0gdHJ1ZSkgJiYgKGRlbGV0ZWREb2NzLmluZGV4T2Yoc2VsZltrZXldKSA9PT0gLTEpKSkpIHtcblxuICAgICAgICAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XS5fZGVsZXRlKGRvY1RvRGVsZXRlW2tleV0sIGRlbGV0ZUFsbCwgZGVsZXRlZERvY3MsIHRydWUsIGZhbHNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgICAgICAgIH0pKVxuICAgICAgICB9KShrZXkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKGRlbGV0ZVNlbGYgPT09IHRydWUpICYmIChkZWxldGVkRG9jcy5pbmRleE9mKHNlbGZba2V5XSkgPT09IC0xKSkge1xuICAgICAgICBkZWxldGUgc2VsZltrZXldW2pvaW5zW2tleV0ucmlnaHRLZXldO1xuICAgICAgICBpZiAoc2VsZltrZXldLmlzU2F2ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZltrZXldLnNhdmUoe30sIGZhbHNlLCB7fSwgdHJ1ZSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKGpvaW5zW2tleV0udHlwZSA9PT0gJ2JlbG9uZ3NUbycpICYmIChzZWxmW2tleV0gaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgIGlmICgoc2VsZltrZXldLmlzU2F2ZWQoKSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgKChrZXkgaW4gZG9jVG9EZWxldGUpIHx8ICgoZGVsZXRlQWxsID09PSB0cnVlKSAmJiAoZGVsZXRlZERvY3MuaW5kZXhPZihzZWxmW2tleV0pID09PSAtMSkpKSkge1xuXG4gICAgICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2VsZltrZXldLl9kZWxldGUoZG9jVG9EZWxldGVba2V5XSwgZGVsZXRlQWxsLCBkZWxldGVkRG9jcywgdHJ1ZSwgZmFsc2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KShrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoam9pbnNba2V5XS50eXBlID09PSAnaGFzTWFueScpICYmIChBcnJheS5pc0FycmF5KHNlbGZba2V5XSkpKSB7XG4gICAgICB2YXIgbWFueVByb21pc2VzID0gW107XG4gICAgICBmb3IodmFyIGk9MDsgaTxzZWxmW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoc2VsZltrZXldW2ldIGluc3RhbmNlb2YgRG9jdW1lbnQpICYmIChzZWxmW2tleV1baV0uaXNTYXZlZCgpID09PSB0cnVlKSlcbiAgICAgICAgICAmJiAoKGtleSBpbiBkb2NUb0RlbGV0ZSkgfHwgKChkZWxldGVBbGwgPT09IHRydWUpICYmIChkZWxldGVkRG9jcy5pbmRleE9mKHNlbGZba2V5XVtpXSkgPT09IC0xKSkpKSB7XG5cbiAgICAgICAgICBtYW55UHJvbWlzZXMucHVzaChzZWxmW2tleV1baV0uX2RlbGV0ZShkb2NUb0RlbGV0ZVtrZXldLCBkZWxldGVBbGwsIGRlbGV0ZWREb2NzLCB0cnVlLCBmYWxzZSkpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHNlbGZba2V5XVtpXSBpbnN0YW5jZW9mIERvY3VtZW50KSAmJiAoZGVsZXRlZERvY3MuaW5kZXhPZihzZWxmW2tleV1baV0pID09PSAtMSkpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZltrZXldW2ldW2pvaW5zW2tleV0ucmlnaHRLZXldO1xuICAgICAgICAgIGlmIChzZWxmW2tleV1baV0uaXNTYXZlZCgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGZba2V5XVtpXS5zYXZlKHt9LCBmYWxzZSwge30sIHRydWUsIGZhbHNlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBQcm9taXNlLmFsbChtYW55UHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpO1xuICAgICAgfSkoa2V5KVxuICAgIH1cbiAgICBpZiAoKGpvaW5zW2tleV0udHlwZSA9PT0gJ2hhc0FuZEJlbG9uZ3NUb01hbnknKSAmJiAoQXJyYXkuaXNBcnJheShzZWxmW2tleV0pKSkge1xuICAgICAgLy8gRGVsZXRlIGxpbmtzICsgZG9jc1xuICAgICAgdmFyIHBrcyA9IFtdOyAvLyBwcmltYXJ5IGtleXMgb2YgdGhlIGRvY3VtZW50c1xuICAgICAgdmFyIGxpbmtzUGtzID0gW107IC8vIHByaW1hcnkga2V5cyBvZiB0aGUgbGlua3NcblxuICAgICAgLy8gU3RvcmUgdGhlIGVsZW1lbnQgd2UgYXJlIGdvaW5nIHRvIGRlbGV0ZS5cbiAgICAgIC8vIElmIHRoZSB1c2VyIGZvcmNlIHRoZSBkZWxldGlvbiBvZiB0aGUgc2FtZSBlbGVtZW50IG11bHRpcGxlIHRpbWVzLCB3ZSBjYW4ndCBuYWl2ZWx5IGxvb3BcbiAgICAgIC8vIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoZSBhcnJheS4uLlxuICAgICAgdmFyIGRvY3NUb0RlbGV0ZSA9IFtdO1xuXG5cbiAgICAgIGZvcih2YXIgaT0wOyBpPHNlbGZba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChzZWxmW2tleV1baV0gaW5zdGFuY2VvZiBEb2N1bWVudCkgJiYgKHNlbGZba2V5XVtpXS5pc1NhdmVkKCkgPT09IHRydWUpKVxuICAgICAgICAgICYmICgoa2V5IGluIGRvY1RvRGVsZXRlKSB8fCAoKGRlbGV0ZUFsbCA9PT0gdHJ1ZSkgJiYgKGRlbGV0ZWREb2NzLmluZGV4T2Yoc2VsZltrZXldW2ldKSA9PT0gLTEpKSkpIHtcblxuICAgICAgICAgIC8vcGtzLnB1c2goc2VsZltrZXldW2ldW2pvaW5zW2tleV0ubW9kZWwuX2dldE1vZGVsKCkuX3BrXSk7XG4gICAgICAgICAgZG9jc1RvRGVsZXRlLnB1c2goc2VsZltrZXldW2ldKTtcbiAgICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gZG8gYSByYW5nZSBkZWxldGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIHJlY3Vyc2VcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGZba2V5XVtpXS5fZGVsZXRlKGRvY1RvRGVsZXRlW2tleV0sIGRlbGV0ZUFsbCwgZGVsZXRlZERvY3MsIHRydWUsIGZhbHNlKSlcblxuICAgICAgICAgIGlmIChzZWxmLmdldE1vZGVsKCkuX2dldE1vZGVsKCkuX3BrID09PSBqb2luc1trZXldLmxlZnRLZXkpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0YWJsZSBpcyBjcmVhdGVkIHNpbmNlIHdlIGFyZSBkZWxldGluZyBhbiBlbGVtZW50IGZyb20gaXRcbiAgICAgICAgICAgIGlmIChzZWxmLl9nZXRNb2RlbCgpLl9uYW1lID09PSBqb2luc1trZXldLm1vZGVsLl9nZXRNb2RlbCgpLl9uYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmW2pvaW5zW2tleV0ubGVmdEtleV0gPCBzZWxmW2tleV1baV1bam9pbnNba2V5XS5yaWdodEtleV0pIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gQWRkIHRlc3QgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICBsaW5rc1Brcy5wdXNoKHNlbGZbam9pbnNba2V5XS5sZWZ0S2V5XStcIl9cIitzZWxmW2tleV1baV1bam9pbnNba2V5XS5yaWdodEtleV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmtzUGtzLnB1c2goc2VsZltrZXldW2ldW2pvaW5zW2tleV0ucmlnaHRLZXldK1wiX1wiK3NlbGZbam9pbnNba2V5XS5sZWZ0S2V5XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuX2dldE1vZGVsKCkuX25hbWUgPCBqb2luc1trZXldLm1vZGVsLl9nZXRNb2RlbCgpLl9uYW1lKSB7XG4gICAgICAgICAgICAgIGxpbmtzUGtzLnB1c2goc2VsZltqb2luc1trZXldLmxlZnRLZXldK1wiX1wiK3NlbGZba2V5XVtpXVtqb2luc1trZXldLnJpZ2h0S2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbGlua3NQa3MucHVzaChzZWxmW2tleV1baV1bam9pbnNba2V5XS5yaWdodEtleV0rXCJfXCIrc2VsZltqb2luc1trZXldLmxlZnRLZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHNlbGZba2V5XVtpXSBpbnN0YW5jZW9mIERvY3VtZW50KSAmJiAoZGVsZXRlZERvY3MuaW5kZXhPZihzZWxmW2tleV1baV0pID09PSAtMSkpIHtcbiAgICAgICAgICAvLyBJdCdzIHNhZmUgdG8gZGVzdHJveSBsaW5rcyBvbmx5IGlmIGl0J3MgYSBwcmltYXJ5IGtleVxuICAgICAgICAgIGlmIChzZWxmLmdldE1vZGVsKCkuX2dldE1vZGVsKCkuX3BrID09PSBqb2luc1trZXldLmxlZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9nZXRNb2RlbCgpLl9uYW1lIDwgam9pbnNba2V5XS5tb2RlbC5fZ2V0TW9kZWwoKS5fbmFtZSkge1xuICAgICAgICAgICAgICBsaW5rc1Brcy5wdXNoKHNlbGZbam9pbnNba2V5XS5sZWZ0S2V5XStcIl9cIitzZWxmW2tleV1baV1bam9pbnNba2V5XS5yaWdodEtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGxpbmtzUGtzLnB1c2goc2VsZltrZXldW2ldW2pvaW5zW2tleV0ucmlnaHRLZXldK1wiX1wiK3NlbGZbam9pbnNba2V5XS5sZWZ0S2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGlua3NQa3MubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcXVlcnkgPSByLnRhYmxlKGpvaW5zW2tleV0ubGluayk7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZ2V0QWxsLmFwcGx5KHF1ZXJ5LCBsaW5rc1BrcykuZGVsZXRlKCk7XG4gICAgICAgIHByb21pc2VzLnB1c2gocXVlcnkucnVuKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmICh1cGRhdGVQYXJlbnRzICE9PSBmYWxzZSkge1xuICAgIC8vIENsZWFuIGxpbmtzIHRoYXQgd2UgYXJlIGF3YXJlIG9mXG4gICAgdXRpbC5sb29wS2V5cyhzZWxmLl9fcHJvdG9fXy5fcGFyZW50cy5faGFzT25lLCBmdW5jdGlvbihoYXNPbmUsIGtleSkge1xuICAgICAgdmFyIHBhcmVudHMgPSBoYXNPbmVba2V5XTtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVsZXRlIHBhcmVudHNbaV0uZG9jW3BhcmVudHNbaV0ua2V5XTtcbiAgICAgICAgdXRpbC5sb29wS2V5cyhwYXJlbnRzW2ldLmRvYy5fX3Byb3RvX18uX2hhc09uZSwgZnVuY3Rpb24oam9pbmVkLCBqb2luS2V5KSB7XG4gICAgICAgICAgaWYgKGpvaW5lZFtqb2luS2V5XS5kb2MgPT09IHNlbGYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnRzW2ldLmRvYy5fX3Byb3RvX18uX2hhc09uZVtqb2luS2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgdXRpbC5sb29wS2V5cyhzZWxmLl9fcHJvdG9fXy5fcGFyZW50cy5fYmVsb25nc1RvLCBmdW5jdGlvbihiZWxvbmdzVG8sIGtleSkge1xuICAgICAgdmFyIHBhcmVudHMgPSBiZWxvbmdzVG9ba2V5XTtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVsZXRlIHBhcmVudHNbaV0uZG9jW3BhcmVudHNbaV0ua2V5XTtcbiAgICAgICAgZGVsZXRlIHBhcmVudHNbaV0uZG9jW3BhcmVudHNbaV0uZm9yZWlnbktleV07XG4gICAgICAgIGlmIChkZWxldGVkRG9jcy5pbmRleE9mKHBhcmVudHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocGFyZW50c1tpXS5kb2Muc2F2ZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHV0aWwubG9vcEtleXMoc2VsZi5fX3Byb3RvX18uX3BhcmVudHMuX2hhc01hbnksIGZ1bmN0aW9uKGhhc01hbnksIGtleSkge1xuICAgICAgdmFyIHBhcmVudHMgPSBoYXNNYW55W2tleV07XG4gICAgICBmb3IodmFyIGk9MDsgaTxwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHBhcmVudHNbaV0uZG9jW3BhcmVudHNbaV0ua2V5XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChwYXJlbnRzW2ldLmRvY1twYXJlbnRzW2ldLmtleV1bal0gPT09IHNlbGYpIHtcbiAgICAgICAgICAgIHV0aWwubG9vcEtleXMocGFyZW50c1tpXS5kb2MuX19wcm90b19fLl9oYXNNYW55LCBmdW5jdGlvbihqb2luZWQsIGpvaW5LZXkpIHtcbiAgICAgICAgICAgICAgZm9yKHZhciBrPTA7IGs8am9pbmVkW2pvaW5LZXldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpvaW5lZFtqb2luS2V5XVtrXS5kb2MgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luS2V5XS5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmVudHNbaV0uZG9jW3BhcmVudHNbaV0ua2V5XS5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB1dGlsLmxvb3BLZXlzKHNlbGYuX19wcm90b19fLl9wYXJlbnRzLl9iZWxvbmdzTGlua3MsIGZ1bmN0aW9uKGJlbG9uZ3NMaW5rcywga2V5KSB7XG4gICAgICB2YXIgcGFyZW50cyA9IGJlbG9uZ3NMaW5rc1trZXldO1xuICAgICAgZm9yKHZhciBpPTA7IGk8cGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IodmFyIGo9MDsgajxwYXJlbnRzW2ldLmRvY1twYXJlbnRzW2ldLmtleV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGFyZW50c1tpXS5kb2NbcGFyZW50c1tpXS5rZXldW2pdID09PSBzZWxmKSB7XG4gICAgICAgICAgICBwYXJlbnRzW2ldLmRvY1twYXJlbnRzW2ldLmtleV0uc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGVsZXRlU2VsZiAhPT0gZmFsc2UpIHtcbiAgICBpZiAoc2VsZi5pc1NhdmVkKCkgPT09IHRydWUpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHIudGFibGUobW9kZWwuX25hbWUpLmdldChzZWxmW21vZGVsLl9wa10pLmRlbGV0ZSgpLnJ1bigpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgc2VsZi5fc2V0VW5TYXZlZCgpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZGVsZXRlZCcsIHNlbGYpO1xuICAgICAgICAgIHJlc29sdmUoc2VsZik7XG4gICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICB9KSlcbiAgICB9XG4gICAgLy8gZWxzZSB3ZSBkb24ndCB0aHJvdyBhbiBlcnJvciwgc2hvdWxkIHdlP1xuICB9XG5cbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJlc29sdmUoc2VsZik7XG4gICAgfSkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9KTtcbiAgfSlcbiAgcmV0dXJuIHAubm9kZWlmeShjYWxsYmFjayk7XG59XG5cbi8qXG4gKiBEZWxldGUgdGhpcyBkb2N1bWVudCBhbmQgcHVyZ2UgdGhlIGRhdGFiYXNlIGJ5IGRvaW5nIHJhbmdlIHVwZGF0ZSB0byBjbGVhblxuICogdGhlIGZvcmVpZ24ga2V5cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFja1xuICogQHJldHVybiB7UHJvbWlzZT19IFJldHVybiBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLnB1cmdlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBtb2RlbCA9IHNlbGYuX2dldE1vZGVsKCk7IC8vIGluc3RhbmNlIG9mIE1vZGVsXG4gIHZhciByID0gbW9kZWwuX3RoaW5reS5yO1xuXG4gIC8vIENsZWFuIHBhcmVudCBmb3IgaGFzT25lXG4gIC8vIGRvYy5vdGhlckRvYy5kZWxldGUoKVxuICB1dGlsLmxvb3BLZXlzKHNlbGYuX19wcm90b19fLl9wYXJlbnRzLl9oYXNPbmUsIGZ1bmN0aW9uKGhhc09uZSwga2V5KSB7XG4gICAgZm9yKHZhciBpPTA7IGk8aGFzT25lW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnREb2MgPSBoYXNPbmVba2V5XVtpXS5kb2M7IC8vIEEgZG9jIHRoYXQgYmVsb25ncyB0byBvdGhlckRvYyAoYWthIHRoaXMpXG4gICAgICBkZWxldGUgcGFyZW50RG9jW2hhc09uZVtrZXldW2ldLmtleV0gLy8gRGVsZXRlIHJlZmVyZW5jZSB0byBvdGhlckRvYyAoYWthIHRoaXMpXG4gICAgfVxuICB9KTtcblxuICAvLyBDbGVhbiBwYXJlbnQgZm9yIGJlbG9uZ3NUb1xuICAvLyBkb2Mub3RoZXJEb2MuZGVsZXRlKClcbiAgdXRpbC5sb29wS2V5cyhzZWxmLl9fcHJvdG9fXy5fcGFyZW50cy5fYmVsb25nc1RvLCBmdW5jdGlvbihiZWxvbmdzVG8sIGtleSkge1xuICAgIGZvcih2YXIgaT0wOyBpPGJlbG9uZ3NUb1trZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFyZW50RG9jID0gYmVsb25nc1RvW2tleV1baV0uZG9jO1xuICAgICAgZGVsZXRlIHBhcmVudERvY1tiZWxvbmdzVG9ba2V5XVtpXS5rZXldO1xuICAgICAgZGVsZXRlIHBhcmVudERvY1tiZWxvbmdzVG9ba2V5XVtpXS5mb3JlaWduS2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENsZWFuIHBhcmVudCBmb3IgaGFzTWFueVxuICB1dGlsLmxvb3BLZXlzKHNlbGYuX19wcm90b19fLl9wYXJlbnRzLl9oYXNNYW55LCBmdW5jdGlvbihoYXNNYW55LCBrZXkpIHtcbiAgICBmb3IodmFyIGk9MDsgaTxoYXNNYW55W2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnREb2MgPSBoYXNNYW55W2tleV1baV0uZG9jO1xuICAgICAgdmFyIGZpZWxkID0gaGFzTWFueVtrZXldW2ldLmtleTtcbiAgICAgIGZvcih2YXIgaj0wOyBqPHBhcmVudERvY1tmaWVsZF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBhcmVudERvY1tmaWVsZF1bal0gPT09IHRoaXMpIHtcbiAgICAgICAgICBwYXJlbnREb2NbZmllbGRdLnNwbGljZShqLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cblxuICAvLyBDbGVhbiBwYXJlbnQgZm9yIGhhc0FuZEJlbG9uZ3NUb01hbnlcbiAgdXRpbC5sb29wS2V5cyhzZWxmLl9fcHJvdG9fXy5fcGFyZW50cy5fYmVsb25nc0xpbmtzLCBmdW5jdGlvbihiZWxvbmdzTGlua3MsIGtleSkge1xuICAgIGZvcih2YXIgaT0wOyBpPGJlbG9uZ3NMaW5rc1trZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFyZW50RG9jID0gYmVsb25nc0xpbmtzW2tleV1baV0uZG9jO1xuICAgICAgdmFyIGZpZWxkID0gYmVsb25nc0xpbmtzW2tleV1baV0ua2V5O1xuICAgICAgZm9yKHZhciBqPTA7IGo8cGFyZW50RG9jW2ZpZWxkXS5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocGFyZW50RG9jW2ZpZWxkXVtqXSA9PT0gdGhpcykge1xuICAgICAgICAgIHBhcmVudERvY1tmaWVsZF0uc3BsaWNlKGosIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBQdXJnZSB0aGUgZGF0YWJhc2VcbiAgdmFyIHByb21pc2VzID0gW107XG4gIHV0aWwubG9vcEtleXMoc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnMsIGZ1bmN0aW9uKGpvaW5zLCBmaWVsZCkge1xuICAgIHZhciBqb2luID0gam9pbnNbZmllbGRdO1xuICAgIHZhciBqb2luZWRNb2RlbCA9IGpvaW4ubW9kZWw7XG5cbiAgICBpZiAoKGpvaW4udHlwZSA9PT0gJ2hhc09uZScpIHx8IChqb2luLnR5cGUgPT09ICdoYXNNYW55JykpIHtcbiAgICAgIHByb21pc2VzLnB1c2goci50YWJsZShqb2luZWRNb2RlbC5nZXRUYWJsZU5hbWUoKSkuZ2V0QWxsKHNlbGZbam9pbi5sZWZ0S2V5XSwge2luZGV4OiBqb2luLnJpZ2h0S2V5fSkucmVwbGFjZShmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYy53aXRob3V0KGpvaW4ucmlnaHRLZXkpXG4gICAgICB9KS5ydW4oKSlcbiAgICB9XG4gICAgLy8gbm90aGluZyB0byBkbyBmb3IgXCJiZWxvbmdzVG9cIlxuICAgIGVsc2UgaWYgKGpvaW4udHlwZSA9PT0gJ2hhc0FuZEJlbG9uZ3NUb01hbnknKSB7XG4gICAgICBpZiAoc2VsZi5nZXRNb2RlbCgpLl9nZXRNb2RlbCgpLl9wayA9PT0gam9pbi5sZWZ0S2V5KSB7XG4gICAgICAgIC8vIFsxXVxuICAgICAgICBwcm9taXNlcy5wdXNoKHIudGFibGUoam9pbi5saW5rKS5nZXRBbGwoc2VsZltqb2luLmxlZnRLZXldLCB7aW5kZXg6IHNlbGYuZ2V0TW9kZWwoKS5nZXRUYWJsZU5hbWUoKStcIl9cIitqb2luLmxlZnRLZXl9KS5kZWxldGUoKS5ydW4oKSlcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHV0aWwubG9vcEtleXMoc2VsZi5fZ2V0TW9kZWwoKS5fcmV2ZXJzZUpvaW5zLCBmdW5jdGlvbihyZXZlcnNlSm9pbnMsIGZpZWxkKSB7XG4gICAgdmFyIGpvaW4gPSByZXZlcnNlSm9pbnNbZmllbGRdO1xuICAgIHZhciBqb2luZWRNb2RlbCA9IGpvaW4ubW9kZWw7IC8vIG1vZGVsIHdoZXJlIGJlbG9uZ3NUby9oYXNBbmRCZWxvbmdzVG9NYW55IHdhcyBjYWxsZWRcblxuICAgIGlmIChqb2luLnR5cGUgPT09ICdiZWxvbmdzVG8nKSB7XG4gICAgICAvLyBXaGF0IHdhcyBjYWxsZWQgaXMgam9pbmVkTW9kZWwuYmVsb25nc1RvKHNlbGYsIGZpZWxkRG9jLCBsZWZ0S2V5LCByaWdodEtleSlcbiAgICAgIHByb21pc2VzLnB1c2goci50YWJsZShqb2luZWRNb2RlbC5nZXRUYWJsZU5hbWUoKSkuZ2V0QWxsKHNlbGZbam9pbi5yaWdodEtleV0sIHtpbmRleDogam9pbi5sZWZ0S2V5fSkucmVwbGFjZShmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYy53aXRob3V0KGpvaW4ubGVmdEtleSlcbiAgICAgIH0pLnJ1bigpKVxuICAgIH1cbiAgICAvLyBub3RoaW5nIHRvIGRvIGZvciBcImJlbG9uZ3NUb1wiXG4gICAgZWxzZSBpZiAoam9pbi50eXBlID09PSAnaGFzQW5kQmVsb25nc1RvTWFueScpIHtcbiAgICAgIC8vIFB1cmdlIG9ubHkgaWYgdGhlIGtleSBpcyBhIHByaW1hcnkga2V5XG4gICAgICAvLyBXaGF0IHdhcyBjYWxsZWQgaXMgam9pbmVkTW9kZWwuaGFzQW5kQmVsb25nc1RvTWFueShzZWxmLCBmaWVsZERvYywgbGVmdEtleSwgcmlnaHRLZXkpXG4gICAgICBpZiAoc2VsZi5nZXRNb2RlbCgpLl9nZXRNb2RlbCgpLl9wayA9PT0gam9pbi5sZWZ0S2V5KSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goci50YWJsZShqb2luLmxpbmspLmdldEFsbChzZWxmW2pvaW4ucmlnaHRLZXldLCB7aW5kZXg6IHNlbGYuZ2V0TW9kZWwoKS5nZXRUYWJsZU5hbWUoKStcIl9cIitqb2luLnJpZ2h0S2V5fSkuZGVsZXRlKCkucnVuKCkpXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBEZWxldGUgaXRzZWxmXG4gIHByb21pc2VzLnB1c2goc2VsZi5kZWxldGUoKSlcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHNlbGYpO1xuICAgIH0pLmVycm9yKHJlamVjdCk7XG4gIH0pLm5vZGVpZnkoY2FsbGJhY2spO1xufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuYWRkUmVsYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcGsgPSBzZWxmLl9nZXRNb2RlbCgpLl9waztcblxuICB2YXIgcXVlcnkgPSBzZWxmLmdldE1vZGVsKCkuZ2V0KHRoaXNbcGtdKVxuICByZXR1cm4gcXVlcnkuYWRkUmVsYXRpb24uYXBwbHkocXVlcnksIGFyZ3VtZW50cyk7XG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVSZWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwayA9IHNlbGYuX2dldE1vZGVsKCkuX3BrO1xuXG4gIHZhciBxdWVyeSA9IHNlbGYuZ2V0TW9kZWwoKS5nZXQodGhpc1twa10pXG4gIHJldHVybiBxdWVyeS5yZW1vdmVSZWxhdGlvbi5hcHBseShxdWVyeSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgYG1lcmdlYCBvZiBgb2JqYCBpbiB0aGlzIGRvY3VtZW50LiBFeHRyYSBrZXlzIHdpbGwgYmUgcmVtb3ZlZC5cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9tZXJnZSA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHV0aWwubG9vcEtleXMoc2VsZiwgZnVuY3Rpb24oc2VsZiwga2V5KSB7XG4gICAgaWYgKChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSAmJiAoc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnNba2V5XSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgZGVsZXRlIHNlbGZba2V5XTtcbiAgICB9XG4gIH0pO1xuICB1dGlsLmxvb3BLZXlzKG9iaiwgZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICBzZWxmW2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiBzZWxmO1xufVxuXG5cbi8qKlxuICogUGVyZm9ybSBhIGBtZXJnZWAgb2YgYG9iamAgaW4gdGhpcyBkb2N1bWVudC4gRXh0cmEga2V5cyB3aWxsIG5vdCBiZSByZW1vdmVkLlxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB1dGlsLmxvb3BLZXlzKG9iaiwgZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvbmx5IGlmIGJvdGggZmllbGRzIGFyZSBvYmplY3RzLCBlbHNlIHdlJ2xsIG92ZXJ3cml0ZSB0aGUgZmllbGRcbiAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9ialtrZXldKSAmJiB1dGlsLmlzUGxhaW5PYmplY3Qoc2VsZltrZXldKSkge1xuICAgICAgRG9jdW1lbnQucHJvdG90eXBlLm1lcmdlLmNhbGwoc2VsZltrZXldLCBvYmpba2V5XSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzZWxmW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VsZjtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0b20gZmVlZCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCBmb3IgZWFjaCBjaGFuZ2VcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9zZXRGZWVkID0gZnVuY3Rpb24oZmVlZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5fX3Byb3RvX18uX2ZlZWQgPSBmZWVkO1xuICBzZWxmLl9fcHJvdG9fXy5fYWN0aXZlID0gdHJ1ZTtcbiAgZmVlZC5lYWNoKGZ1bmN0aW9uKGVyciwgY2hhbmdlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5fX3Byb3RvX18uX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNoYW5nZS5uZXdfdmFsID09PSBudWxsKSB7XG4gICAgICAgIC8vIERlbGV0ZSBhbGwgdGhlIGZpZWxkc1xuICAgICAgICBzZWxmLl9tZXJnZSh7fSk7XG4gICAgICAgIHNlbGYuX3NldE9sZFZhbHVlKGNoYW5nZS5vbGRfdmFsKTtcbiAgICAgICAgc2VsZi5fc2V0VW5TYXZlZCgpO1xuICAgICAgICBzZWxmLmVtaXQoJ2NoYW5nZScsIHNlbGYpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYuX21lcmdlKGNoYW5nZS5uZXdfdmFsKTtcbiAgICAgICAgc2VsZi5fc2V0T2xkVmFsdWUoY2hhbmdlLm9sZF92YWwpO1xuICAgICAgICBzZWxmLnNldFNhdmVkKCk7XG4gICAgICAgIHNlbGYuZW1pdCgnY2hhbmdlJywgc2VsZik7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufTtcblxuRG9jdW1lbnQucHJvdG90eXBlLmdldEZlZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wcm90b19fLl9mZWVkO1xufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuY2xvc2VGZWVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcHJvdG9fXy5fZmVlZC5jbG9zZSgpO1xufVxuXG4vKipcbiAqIEhhdmUgdGhlIG1vZGVsIGVtaXQgJ3JldHJpZXZlZCcgd2l0aCB0aGUgY3VycmVudCBkb2N1bWVudCBhbmRcbiAqIHJlY3Vyc2UgdG8gaGF2ZSBhbGwgam9pbmVkIG1vZGVscyBkbyB0aGUgc2FtZS5cbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLl9lbWl0UmV0cmlldmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmdldE1vZGVsKCkuZW1pdCgncmV0cmlldmVkJywgc2VsZik7XG4gIHV0aWwubG9vcEtleXMoc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnMsIGZ1bmN0aW9uKGpvaW5zLCBrZXkpIHtcbiAgICB2YXIgam9pbiA9IGpvaW5zW2tleV07XG4gICAgaWYgKChqb2luc1trZXldLnR5cGUgPT09ICdoYXNPbmUnKSB8fCAoam9pbnNba2V5XS50eXBlID09PSAnYmVsb25nc1RvJykpIHtcbiAgICAgIGlmICgoc2VsZltrZXldICE9IG51bGwpICYmICh0eXBlb2Ygc2VsZltrZXldLl9lbWl0UmV0cmlldmUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHNlbGZba2V5XS5fZW1pdFJldHJpZXZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChqb2luc1trZXldLnR5cGUgPT09ICdoYXNNYW55JykgfHwgKGpvaW5zW2tleV0udHlwZSA9PT0gJ2hhc0FuZEJlbG9uZ3NUb01hbnknKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZltrZXldKSkge1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxzZWxmW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNlbGZba2V5XVtpXS5fZW1pdFJldHJpZXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmW2tleV1baV0uX2VtaXRSZXRyaWV2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBlcnJvcnMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIFRoZSBiYXNlIGVycm9yIHRoYXQgYWxsIHRoaW5reSByZWxhdGVkIGVycm9ycyBkZXJpdmUgZnJvbVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEVycm9yXG4gKi9cbmVycm9ycy5UaGlua3lFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdG1wID0gRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdG1wLm5hbWUgPSB0aGlzLm5hbWUgPSAnVGhpbmt5RXJyb3InO1xuXG4gIHRoaXMubWVzc2FnZSA9IHRtcC5tZXNzYWdlO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG59O1xudXRpbC5pbmhlcml0cyhlcnJvcnMuVGhpbmt5RXJyb3IsIEVycm9yKTtcblxuLyoqXG4gKiBUaHJvd24gb3IgcmV0dXJuZWQgd2hlbiBgZ2V0YCByZXR1cm5zIGBudWxsYC5cbiAqIEBleHRlbmRzIFRoaW5reUVycm9yXG4gKi9cbmVycm9ycy5Eb2N1bWVudE5vdEZvdW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICB2YXIgZXJyb3JNZXNzYWdlID0gbWVzc2FnZSB8fCBcIlRoZSBxdWVyeSBkaWQgbm90IGZpbmQgYSBkb2N1bWVudCBhbmQgcmV0dXJuZWQgbnVsbC5cIjtcbiAgZXJyb3JzLlRoaW5reUVycm9yLmNhbGwodGhpcywgZXJyb3JNZXNzYWdlKTtcbiAgdGhpcy5uYW1lID0gJ0RvY3VtZW50Tm90Rm91bmRFcnJvcic7XG59O1xudXRpbC5pbmhlcml0cyhlcnJvcnMuRG9jdW1lbnROb3RGb3VuZCwgZXJyb3JzLlRoaW5reUVycm9yKTtcblxuLyoqXG4gKiBUaHJvd24gb3IgcmV0dXJuZWQgd2hlbiBhbiBpbiBwbGFjZSB1cGRhdGUvcmVwbGFjZSByZXR1cm5zIGFuIGludmFsaWQgZG9jdW1lbnQuXG4gKiBAZXh0ZW5kcyBUaGlua3lFcnJvclxuICovXG5lcnJvcnMuSW52YWxpZFdyaXRlID0gZnVuY3Rpb24obWVzc2FnZSwgcmF3KSB7XG4gIGVycm9ycy5UaGlua3lFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICB0aGlzLm5hbWUgPSAnSW52YWxpZFdyaXRlRXJyb3InO1xuICB0aGlzLnJhdyA9IHJhdztcbn07XG51dGlsLmluaGVyaXRzKGVycm9ycy5JbnZhbGlkV3JpdGUsIGVycm9ycy5UaGlua3lFcnJvcik7XG5cbi8qKlxuICogVGhyb3duIG9yIHJldHVybmVkIHdoZW4gdmFsaWRhdGlvbiBvZiBhIGRvY3VtZW50IGZhaWxzLlxuICogQGV4dGVuZHMgVGhpbmt5RXJyb3JcbiAqL1xuZXJyb3JzLlZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZXJyb3JzLlRoaW5reUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xufTtcbnV0aWwuaW5oZXJpdHMoZXJyb3JzLlZhbGlkYXRpb25FcnJvciwgZXJyb3JzLlRoaW5reUVycm9yKTtcblxuLyoqXG4gKiBUaHJvd24gb3IgcmV0dXJuZWQgd2hlbiB0aGUgcHJpbWFyeSBrZXkgdW5pcXVlIGRvY3VtZW50IGNvbnN0cmFpbnQgZmFpbHMuXG4gKiBAZXh0ZW5kcyBUaGlua3lFcnJvclxuICovXG5lcnJvcnMuRHVwbGljYXRlUHJpbWFyeUtleSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHByaW1hcnlLZXkpIHtcbiAgZXJyb3JzLlRoaW5reUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gIHRoaXMubmFtZSA9ICdEdXBsaWNhdGVQcmltYXJ5S2V5RXJyb3InO1xuICBpZiAocHJpbWFyeUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wcmltYXJ5S2V5ID0gcHJpbWFyeUtleTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoZXJyb3JzLkR1cGxpY2F0ZVByaW1hcnlLZXksIGVycm9ycy5UaGlua3lFcnJvcik7XG5cbi8qKlxuICogcmVndWxhciBleHByZXNzaW9ucyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBlcnJvcnMgc2hvdWxkIGJlIHRocm93blxuICovXG5lcnJvcnMuRE9DVU1FTlRfTk9UX0ZPVU5EX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlRoZSBxdWVyeSBkaWQgbm90IGZpbmQgYSBkb2N1bWVudCBhbmQgcmV0dXJuZWQgbnVsbC4qJyk7XG5lcnJvcnMuRFVQTElDQVRFX1BSSU1BUllfS0VZX1JFR0VYID0gbmV3IFJlZ0V4cCgnXkR1cGxpY2F0ZSBwcmltYXJ5IGtleSBgKC4qKWAuKicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXBwcm9wcmlhdGUgZXJyb3IgZ2l2ZW4gZWl0aGVyIGFuIGluc3RhbmNlIG9mIEVycm9yIG9yIGEgbWVzc2FnZVxuICogZnJvbSB0aGUgUmV0aGlua0RCIGRyaXZlclxuICovXG5lcnJvcnMuY3JlYXRlID0gZnVuY3Rpb24oZXJyb3JPck1lc3NhZ2UpIHtcbiAgdmFyIG1lc3NhZ2UgPSAoZXJyb3JPck1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgPyBlcnJvck9yTWVzc2FnZS5tZXNzYWdlIDogZXJyb3JPck1lc3NhZ2U7XG4gIGlmIChtZXNzYWdlLm1hdGNoKGVycm9ycy5ET0NVTUVOVF9OT1RfRk9VTkRfUkVHRVgpKSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnMuRG9jdW1lbnROb3RGb3VuZChtZXNzYWdlKTtcbiAgfSBlbHNlIGlmIChtZXNzYWdlLm1hdGNoKGVycm9ycy5EVVBMSUNBVEVfUFJJTUFSWV9LRVlfUkVHRVgpKSB7XG4gICAgdmFyIHByaW1hcnlLZXkgPSBtZXNzYWdlLm1hdGNoKGVycm9ycy5EVVBMSUNBVEVfUFJJTUFSWV9LRVlfUkVHRVgpWzFdO1xuICAgIHJldHVybiBuZXcgZXJyb3JzLkR1cGxpY2F0ZVByaW1hcnlLZXkobWVzc2FnZSwgcHJpbWFyeUtleSk7XG4gIH0gZWxzZSBpZiAoZXJyb3JPck1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvck9yTWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXJyb3JzLlRoaW5reUVycm9yKGVycm9yT3JNZXNzYWdlKTtcbn07XG4iLCJ2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKF9fZGlybmFtZSsnL3V0aWwuanMnKTtcblxuZnVuY3Rpb24gRmVlZChmZWVkLCBtb2RlbCkge1xuICB0aGlzLmZlZWQgPSBmZWVkO1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXG4gIHRoaXMuZWFjaCA9IHRoaXMuX2VhY2g7XG4gIHRoaXMubmV4dCA9IHRoaXMuX25leHQ7XG59XG5cbkZlZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnW29iamVjdCBGZWVkXSdcbn1cblxuXG5GZWVkLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZWxmLmZlZWQubmV4dCgpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdXRpbC50cnlDYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRhdGEubmV3X3ZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgc2VsZi5tb2RlbC5fcGFyc2UoZGF0YS5uZXdfdmFsKS50aGVuKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgZG9jLl9zZXRPbGRWYWx1ZShkYXRhLm9sZF92YWwpO1xuICAgICAgICAgICAgcmVzb2x2ZShkb2MpO1xuICAgICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5vbGRfdmFsICE9IG51bGwpIHsgLy8gbmV3X3ZhbCBpcyBudWxsXG4gICAgICAgICAgc2VsZi5tb2RlbC5fcGFyc2UoZGF0YS5vbGRfdmFsKS50aGVuKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgZG9jLl9zZXRVblNhdmVkKCk7XG4gICAgICAgICAgICByZXNvbHZlKGRvYyk7XG4gICAgICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvL2Vsc2Ugd2UganVzdCBkcm9wIHRoZSBjaGFuZ2UgYXMgaXQncyBhIHN0YXRlL2luaXRpYWxpemluZyBvYmplY3RcbiAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pXG4gICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgfSk7XG59XG5cbkZlZWQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB0b0FycmF5YCBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSBvbiBmZWVkcy5cIik7XG59XG5cbkZlZWQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXMuZmVlZC5jbG9zZShjYWxsYmFjayk7XG59XG5cbkZlZWQucHJvdG90eXBlLl9lYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIG9uRmluaXNoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5mZWVkLmVhY2goZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKHNlbGYuX2Nsb3NlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdXRpbC50cnlDYXRjaChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkYXRhLm5ld192YWwgIT0gbnVsbCkge1xuICAgICAgICBzZWxmLm1vZGVsLl9wYXJzZShkYXRhLm5ld192YWwpLnRoZW4oZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgZG9jLl9zZXRPbGRWYWx1ZShkYXRhLm9sZF92YWwpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGF0YS5vbGRfdmFsICE9IG51bGwpIHsgLy8gbmV3X3ZhbCBpcyBudWxsXG4gICAgICAgIHNlbGYubW9kZWwuX3BhcnNlKGRhdGEub2xkX3ZhbCkudGhlbihmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICBkb2MuX3NldFVuU2F2ZWQoKTtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgICAgICB9KS5lcnJvcihmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vZWxzZSB3ZSBqdXN0IGRyb3AgdGhlIGNoYW5nZSBhcyBpdCdzIGEgc3RhdGUvaW5pdGlhbGl6aW5nIG9iamVjdFxuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KVxuICB9LCBvbkZpbmlzaCk7XG59O1xuXG5GZWVkLnByb3RvdHlwZS5fbWFrZUVtaXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsZWQgYG5leHRgIG9uY2UgeW91IGhhdmUgYm91bmQgbGlzdGVuZXJzIG9uIHRoZSBmZWVkXCIpXG4gIH1cbiAgdGhpcy5lYWNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsZWQgYGVhY2hgIG9uY2UgeW91IGhhdmUgYm91bmQgbGlzdGVuZXJzIG9uIHRoZSBmZWVkXCIpXG4gIH1cbiAgdGhpcy50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsZWQgYHRvQXJyYXlgIG9uY2UgeW91IGhhdmUgYm91bmQgbGlzdGVuZXJzIG9uIHRoZSBmZWVkXCIpXG4gIH1cbiAgdGhpcy5fZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xufVxuXG5GZWVkLnByb3RvdHlwZS5fZWFjaENiID0gZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgaWYgKCh0aGlzLl9jbG9zZWQgIT09IGZhbHNlKSB8fCAoZXJyLm1lc3NhZ2UgIT09IFwiWW91IGNhbm5vdCByZXRyaWV2ZSBkYXRhIGZyb20gYSBjdXJzb3IgdGhhdCBpcyBjbG9zZWRcIikpIHtcbiAgICAgIHNlbGYuX2V2ZW50RW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHV0aWwudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRhdGEubmV3X3ZhbCAhPT0gbnVsbCkge1xuICAgICAgc2VsZi5tb2RlbC5fcGFyc2UoZGF0YS5uZXdfdmFsKS50aGVuKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBkb2MuX3NldE9sZFZhbHVlKGRhdGEub2xkX3ZhbCk7XG4gICAgICAgIHNlbGYuX2V2ZW50RW1pdHRlci5lbWl0KCdkYXRhJywgZG9jKTtcbiAgICAgIH0pLmVycm9yKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBzZWxmLl9ldmVudEVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEub2xkX3ZhbCAhPT0gbnVsbCkgeyAvLyBuZXdfdmFsIGlzIG51bGxcbiAgICAgIHNlbGYubW9kZWwuX3BhcnNlKGRhdGEub2xkX3ZhbCkudGhlbihmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZG9jLl9zZXRVblNhdmVkKCk7XG4gICAgICAgIHNlbGYuX2V2ZW50RW1pdHRlci5lbWl0KCdkYXRhJywgZG9jKTtcbiAgICAgIH0pLmVycm9yKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBzZWxmLl9ldmVudEVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBzZWxmLl9ldmVudEVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9KVxufVxuXG52YXIgbWV0aG9kcyA9IFtcbiAgICAnYWRkTGlzdGVuZXInLFxuICAgICdvbicsXG4gICAgJ29uY2UnLFxuICAgICdyZW1vdmVMaXN0ZW5lcicsXG4gICAgJ3JlbW92ZUFsbExpc3RlbmVycycsXG4gICAgJ3NldE1heExpc3RlbmVycycsXG4gICAgJ2xpc3RlbmVycycsXG4gICAgJ2VtaXQnXG5dO1xuXG5mb3IodmFyIGk9MDsgaTxtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gIChmdW5jdGlvbihuKSB7XG4gICAgdmFyIG1ldGhvZCA9IG1ldGhvZHNbbl07XG4gICAgRmVlZC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKHNlbGYuX2V2ZW50RW1pdHRlciA9PSBudWxsKSB7XG4gICAgICAgIHNlbGYuX21ha2VFbWl0dGVyKCk7XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmZlZWQuX2VhY2goc2VsZi5fZWFjaENiLmJpbmQoc2VsZiksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fZXZlbnRFbWl0dGVyLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuX2V2ZW50RW1pdHRlclttZXRob2RdLmFwcGx5KHNlbGYuX2V2ZW50RW1pdHRlciwgdXRpbC50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pKGkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoX19kaXJuYW1lKycvdXRpbC5qcycpO1xudmFyIF91dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHNjaGVtYVV0aWwgPSByZXF1aXJlKF9fZGlybmFtZSsnL3NjaGVtYS5qcycpO1xudmFyIERvY3VtZW50ID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9kb2N1bWVudC5qcycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBRdWVyeSA9IHJlcXVpcmUoX19kaXJuYW1lKycvcXVlcnkuanMnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciBFcnJvcnMgPSByZXF1aXJlKF9fZGlybmFtZSsnL2Vycm9ycy5qcycpO1xuXG4vKlxuICogQ29uc3RydWN0b3IgZm9yIGEgTW9kZWwuIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCB3aGF0IGB0aGlua3kuY3JlYXRlTW9kZWxgXG4gKiByZXR1cm5zLiBJdCBpcyB0aGUgcHJvdG90eXBlIG9mIHdoYXQgYHRoaW5reS5jcmVhdGVNb2RlbGAgcmV0dXJucy5cbiAqIFRoZSB3aG9sZSBjaGFpbiBiZWluZzpcbiAqIGRvY3VtZW50Ll9fcHJvdG9fXyA9IG5ldyBEb2N1bWVudCguLi4pXG4gKiBkb2N1bWVudC5fX3Byb3RvX18uY29uc3RydWN0b3IgPSBtb2RlbCAocmV0dXJuZWQgYnkgdGhpbmt5LmNyZWF0ZU1vZGVsXG4gKiBkb2N1bWVudC5fX3Byb3RvX18uX21vZGVsID0gaW5zdGFuY2Ugb2YgTW9kZWxcbiAqIGRvY3VtZW50Ll9fcHJvdG9fXy5jb25zdHJ1Y3Rvci5fX3Byb3RvX18gPSBkb2N1bWVudC5fX3Byb3RvX18uX21vZGVsXG4gKi9cbmZ1bmN0aW9uIE1vZGVsKG5hbWUsIHNjaGVtYSwgb3B0aW9ucywgdGhpbmt5KSB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSB0YWJsZSB1c2VkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLl9uYW1lID0gbmFtZTtcblxuICAvLyBXZSB3YW50IGEgZGVlcCBjb3B5XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9vcHRpb25zID0ge307XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gKG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nICE9IG51bGwpID8gb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgOiB0aGlua3kuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nO1xuICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfZXh0cmEgPSAob3B0aW9ucy5lbmZvcmNlX2V4dHJhICE9IG51bGwpID8gb3B0aW9ucy5lbmZvcmNlX2V4dHJhIDogdGhpbmt5Ll9vcHRpb25zLmVuZm9yY2VfZXh0cmE7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gKG9wdGlvbnMuZW5mb3JjZV90eXBlICE9IG51bGwpID8gb3B0aW9ucy5lbmZvcmNlX3R5cGUgOiB0aGlua3kuX29wdGlvbnMuZW5mb3JjZV90eXBlO1xuICB0aGlzLl9vcHRpb25zLnRpbWVGb3JtYXQgPSAob3B0aW9ucy50aW1lRm9ybWF0ICE9IG51bGwpID8gb3B0aW9ucy50aW1lRm9ybWF0IDogdGhpbmt5Ll9vcHRpb25zLnRpbWVGb3JtYXQ7XG4gIHRoaXMuX29wdGlvbnMudmFsaWRhdGUgPSAob3B0aW9ucy52YWxpZGF0ZSAhPSBudWxsKSA/IG9wdGlvbnMudmFsaWRhdGUgOiB0aGlua3kuX29wdGlvbnMudmFsaWRhdGU7XG5cbiAgdGhpcy5fc2NoZW1hID0gc2NoZW1hVXRpbC5wYXJzZShzY2hlbWEsICcnLCB0aGlzLl9vcHRpb25zLCB0aGlzKTtcbiAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSh0aGlzLl9zY2hlbWEsIG51bGwsIDIpKTtcblxuICB0aGlzLnZpcnR1YWxGaWVsZHMgPSBbXTtcbiAgdGhpcy5kZWZhdWx0RmllbGRzID0gW107XG4gIHRoaXMuX3NjaGVtYS5fZ2V0RGVmYXVsdEZpZWxkcyhbXSwgdGhpcy5kZWZhdWx0RmllbGRzLCB0aGlzLnZpcnR1YWxGaWVsZHMpXG5cbiAgdGhpcy5uZWVkVG9HZW5lcmF0ZUZpZWxkcyA9ICh0aGlzLmRlZmF1bHRGaWVsZHMubGVuZ3RoK3RoaXMudmlydHVhbEZpZWxkcy5sZW5ndGgpICE9PSAwO1xuXG4gIHRoaXMuX3BrID0gKG9wdGlvbnMucGsgIT0gbnVsbCkgPyBvcHRpb25zLnBrIDogJ2lkJztcblxuICB0aGlzLl90YWJsZSA9IChvcHRpb25zLnRhYmxlICE9IG51bGwpID8gb3B0aW9ucy50YWJsZSA6IHt9O1xuICB0aGlzLl90YWJsZS5wcmltYXJ5S2V5ID0gdGhpcy5fcGs7XG5cbiAgdGhpcy5fdGhpbmt5ID0gdGhpbmt5O1xuXG4gIHRoaXMuX3ZhbGlkYXRvciA9IG9wdGlvbnMudmFsaWRhdG9yO1xuXG4gIHRoaXMuX2luZGV4ZXMgPSB7fTsgLy8gaW5kZXhOYW1lIC0+IHRydWVcbiAgdGhpcy5fcGVuZGluZ1Byb21pc2VzID0gW107XG5cbiAgdGhpcy5fZXJyb3IgPSBudWxsOyAvLyBJZiBhbiBlcnJvciBvY2N1cmVkLCB3ZSB3b24ndCBsZXQgcGVvcGxlIHNhdmUgdGhpbmdzXG5cbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IDEwO1xuICB0aGlzLl9qb2lucyA9IHt9O1xuICB0aGlzLl9sb2NhbEtleXMgPSB7fTsgLy8ga2V5IHVzZWQgYXMgYSBmb3JlaWduIGtleSBieSBhbm90aGVyIG1vZGVsXG5cbiAgLy8gVGhpcyBpcyB0byB0cmFjayBqb2lucyB0aGF0IHdlcmUgbm90IGRpcmVjdGx5IGNhbGxlZCBieSB0aGlzIG1vZGVsIGJ1dCB0aGF0IHdlIHN0aWxsIG5lZWRcbiAgLy8gdG8gcHVyZ2UgdGhlIGRhdGFiYXNlXG4gIHRoaXMuX3JldmVyc2VKb2lucyA9IHt9O1xuXG4gIHRoaXMuX21ldGhvZHMgPSB7fTtcbiAgdGhpcy5fc3RhdGljTWV0aG9kcyA9IHt9O1xuICB0aGlzLl9hc3luYyA9IHtcbiAgICBpbml0OiBmYWxzZSxcbiAgICByZXRyaWV2ZTogZmFsc2UsXG4gICAgc2F2ZTogZmFsc2UsXG4gICAgdmFsaWRhdGU6IGZhbHNlXG4gIH07XG5cbiAgdGhpcy5fcHJlID0ge1xuICAgIHNhdmU6IFtdLFxuICAgIGRlbGV0ZTogW10sXG4gICAgdmFsaWRhdGU6IFtdXG4gIH07XG4gIHRoaXMuX3Bvc3QgPSB7XG4gICAgaW5pdDogW10sXG4gICAgcmV0cmlldmU6IFtdLFxuICAgIHNhdmU6IFtdLFxuICAgIGRlbGV0ZTogW10sXG4gICAgdmFsaWRhdGU6IFtdXG4gIH07XG59XG5fdXRpbC5pbmhlcml0cyhNb2RlbCwgRXZlbnRFbWl0dGVyKTtcblxuTW9kZWwubmV3ID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zLCB0aGlua3kpIHtcblxuICB2YXIgcHJvdG8gPSBuZXcgTW9kZWwobmFtZSwgc2NoZW1hLCBvcHRpb25zLCB0aGlua3kpO1xuICBwcm90by5faW5pdE1vZGVsID0gb3B0aW9ucy5pbml0ICAhPT0gdW5kZWZpbmVkID8gISFvcHRpb25zLmluaXQgOiB0cnVlO1xuXG4gIHZhciBtb2RlbCA9IGZ1bmN0aW9uIG1vZGVsKGRvYywgb3B0aW9ucykge1xuICAgIGlmICghdXRpbC5pc1BsYWluT2JqZWN0KGRvYykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBidWlsZCBhIG5ldyBpbnN0YW5jZSBvZiBgXCIrcHJvdG8uX25hbWUrXCJgIHdpdGhvdXQgYW4gb2JqZWN0XCIpXG4gICAgfVxuICAgIC8vIFdlIGNyZWF0ZSBhIGRlZXBjb3B5IG9ubHkgaWYgZG9jIHdhcyBhbHJlYWR5IHVzZWQgdG8gY3JlYXRlIGEgZG9jdW1lbnRcbiAgICBpZiAoZG9jIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIGRvYyA9IHV0aWwuZGVlcENvcHkoZG9jKTtcbiAgICB9XG5cbiAgICB1dGlsLmNoYW5nZVByb3RvKGRvYywgbmV3IERvY3VtZW50KG1vZGVsLCBvcHRpb25zKSk7XG5cbiAgICAvLyBDcmVhdGUgam9pbnMgZG9jdW1lbnQuIFdlIGRvIGl0IGhlcmUgYmVjYXVzZSBgb3B0aW9uc2AgYXJlIGVhc2lseSBhdmFpbGFibGVcbiAgICB1dGlsLmxvb3BLZXlzKHByb3RvLl9qb2lucywgZnVuY3Rpb24oam9pbnMsIGtleSkge1xuICAgICAgaWYgKGRvY1trZXldICE9IG51bGwpIHtcbiAgICAgICAgaWYgKChqb2luc1trZXldLnR5cGUgPT09ICdoYXNPbmUnKSAmJiAoZG9jW2tleV0gaW5zdGFuY2VvZiBEb2N1bWVudCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgZG9jW2tleV0gPSBuZXcgam9pbnNba2V5XS5tb2RlbChkb2Nba2V5XSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGpvaW5zW2tleV0udHlwZSA9PT0gJ2JlbG9uZ3NUbycpICYmIChkb2Nba2V5XSBpbnN0YW5jZW9mIERvY3VtZW50ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICBkb2Nba2V5XSA9IG5ldyBqb2luc1trZXldLm1vZGVsKGRvY1trZXldLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqb2luc1trZXldLnR5cGUgPT09ICdoYXNNYW55Jykge1xuICAgICAgICAgIGRvYy5fX3Byb3RvX18uX2hhc01hbnlba2V5XSA9IFtdXG5cbiAgICAgICAgICBmb3IodmFyIGk9MDsgaTxkb2Nba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRvY1trZXldW2ldIGluc3RhbmNlb2YgRG9jdW1lbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGRvY1trZXldW2ldID0gbmV3IGpvaW5zW2tleV0ubW9kZWwoZG9jW2tleV1baV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqb2luc1trZXldLnR5cGUgPT09ICdoYXNBbmRCZWxvbmdzVG9NYW55Jykge1xuICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGRvY1trZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZG9jW2tleV1baV0gaW5zdGFuY2VvZiBEb2N1bWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZG9jW2tleV1baV0gPSBuZXcgam9pbnNba2V5XS5tb2RlbChkb2Nba2V5XVtpXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9jLl9nZXRNb2RlbCgpLl9zY2hlbWEuX3NldE1vZGVsKGRvYy5fZ2V0TW9kZWwoKSk7XG4gICAgaWYgKHByb3RvLm5lZWRUb0dlbmVyYXRlRmllbGRzID09PSB0cnVlKSB7XG4gICAgICBkb2MuX2dlbmVyYXRlRGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmIChwcm90by5fb3B0aW9ucy52YWxpZGF0ZSA9PT0gJ29uY3JlYXRlJykge1xuICAgICAgcHJvbWlzZSA9IGRvYy52YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvdG8uX3Bvc3QuaW5pdC5sZW5ndGggPiAwKSB7XG4gICAgICBwcm9taXNlID0gdXRpbC5ob29rKHtcbiAgICAgICAgcG9zdEhvb2tzOiBkb2MuX2dldE1vZGVsKCkuX3Bvc3QuaW5pdCxcbiAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgIGFzeW5jOiBkb2MuX2dldE1vZGVsKCkuX2FzeW5jLmluaXQsXG4gICAgICAgIGZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oZG9jcykge1xuICAgICAgICByZXR1cm4gZG9jc1swXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xuICB9XG5cbiAgbW9kZWwuX19wcm90b19fID0gcHJvdG87XG5cbiAgaWYgKG9wdGlvbnMuaW5pdCAhPT0gZmFsc2UpIHtcbiAgICAvLyBTZXR1cCB0aGUgbW9kZWwncyB0YWJsZS5cbiAgICBtb2RlbC50YWJsZVJlYWR5KCkudGhlbigpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIFdlIGRvIG5vdCBpbml0aWFsaXplIHRoZSB0YWJsZSBhbmQgc3VwcG9zZSB0aGF0IGl0IGFscmVhZHkgZXhpc3RzIGFuZFxuICAgIC8vIGlzIHJlYWR5LlxuICAgIG1vZGVsLmVtaXQoJ2NyZWF0ZWQnKTtcbiAgICBtb2RlbC5lbWl0KCdyZWFkeScpO1xuICB9XG5cbiAgLy8gU28gcGVvcGxlIGNhbiBkaXJlY3RseSBjYWxsIHRoZSBFdmVudEVtaXR0ZXIgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgLy8gVE9JTVBST1ZFOiBXZSBzaG91bGQgZW1pdCBldmVyeXRoaW5nIGZyb20gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgZW1pdHRpbmcgdGhpbmdzIGZyb21cbiAgLy8gdGhlIGNvbnN0cnVjdG9yIGFuZCB0aGUgaW5zdGFuY2Ugb2YgTW9kZWxcbiAgdXRpbC5sb29wS2V5cyhFdmVudEVtaXR0ZXIucHJvdG90eXBlLCBmdW5jdGlvbihlbWl0dGVyLCBrZXkpIHtcbiAgICAoZnVuY3Rpb24oX2tleSkge1xuICAgICAgbW9kZWxbX2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwuX2dldE1vZGVsKClbX2tleV0uYXBwbHkobW9kZWwuX2dldE1vZGVsKCksIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSkoa2V5KVxuICB9KTtcblxuXG4gIHJldHVybiBtb2RlbFxufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgbW9kZWwncyB0YWJsZS5cbiAqIEByZXR1cm4ge1Byb21pc2U9fSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgdGFibGUgaXMgcmVhZHkuXG4gKi9cbk1vZGVsLnByb3RvdHlwZS50YWJsZVJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwoKTtcbiAgaWYgKCF0aGlzLl9pbml0TW9kZWwpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgaWYgKHRoaXMuX3RhYmxlUmVhZHlQcm9taXNlKSByZXR1cm4gdGhpcy5fdGFibGVSZWFkeVByb21pc2U7XG5cbiAgLy8gQ3JlYXRlIHRoZSB0YWJsZSwgb3IgcHVzaCB0aGUgdGFibGUgbmFtZSBpbiB0aGUgcXVldWUuXG4gIHZhciByID0gbW9kZWwuX3RoaW5reS5yO1xuICB0aGlzLl90YWJsZVJlYWR5UHJvbWlzZSA9IG1vZGVsLl90aGlua3kuZGJSZWFkeSgpXG4gIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiByLnRhYmxlQ3JlYXRlKG1vZGVsLl9uYW1lLCBtb2RlbC5fdGFibGUpLnJ1bigpO1xuICB9KVxuICAuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5tYXRjaCgvVGFibGUgYC4qYCBhbHJlYWR5IGV4aXN0cy8pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vZGVsLl9lcnJvciA9IGVycm9yO1xuICAgIC8vIFNob3VsZCB3ZSB0aHJvdyBoZXJlP1xuICB9KTtcblxuICByZXR1cm4gdGhpcy5fdGFibGVSZWFkeVByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2NyZWF0ZWQnKTtcbiAgICBpZiAoIXNlbGYuX3BlbmRpbmdQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHNlbGYuZW1pdCgncmVhZHknKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIE1vZGVsJ3MgdGFibGUgYW5kXG4gKiBhbGwgaW5kaWNlcyBoYXZlIGJlZW4gY3JlYXRlZC5cbiAqL1xuTW9kZWwucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXF1aXJlbWVudHMgPSBbXTtcblxuICAvLyBFbnN1cmUgdGhlIE1vZGVsJ3MgdGFibGUgaXMgcmVhZHlcbiAgcmVxdWlyZW1lbnRzLnB1c2godGhpcy50YWJsZVJlYWR5KCkpO1xuXG4gIC8vIEVuc3VyZSBhbGwgb3RoZXIgcGVuZGluZyBwcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWRcbiAgcmVxdWlyZW1lbnRzLnB1c2godGhpcy5fcHJvbWlzZXNSZWFkeSgpKTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocmVxdWlyZW1lbnRzKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fcHJvbWlzZXNSZWFkeSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLl9wcm9taXNlc1JlYWR5UHJvbWlzZSkgcmV0dXJuIHRoaXMuX3Byb21pc2VzUmVhZHlQcm9taXNlO1xuXG4gIHZhciB2ZXJpZnlBbGwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2VsZi5fcGVuZGluZ1Byb21pc2VzKVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIGFsbEZ1bGxmaWxsZWQgPSB0cnVlO1xuICAgICAgZm9yIChpPTA7IGk8c2VsZi5fcGVuZGluZ1Byb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICBpZiAoIXNlbGYuX3BlbmRpbmdQcm9taXNlc1tpXS5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgYWxsRnVsbGZpbGxlZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbEZ1bGxmaWxsZWQgPyBQcm9taXNlLnJlc29sdmUoKSA6IHZlcmlmeUFsbCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuX3Byb21pc2VzUmVhZHlQcm9taXNlID0gdmVyaWZ5QWxsKCk7XG4gIHJldHVybiB0aGlzLl9wcm9taXNlc1JlYWR5UHJvbWlzZTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fd2FpdEZvciA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9wZW5kaW5nUHJvbWlzZXMucHVzaChwcm9taXNlKTtcblxuICAvLyBFbWl0ICdyZWFkeScgd2hlbiBhbGwgcGVuZGluZyBwcm9taXNlcyBoYXZlIHJlc29sdmVkXG4gIGlmICghdGhpcy5fcGVuZGluZ1JlYWR5KSB7XG4gICAgdGhpcy5fcGVuZGluZ1JlYWR5ID0gdGhpcy5fcHJvbWlzZXNSZWFkeSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgc2VsZi5fcGVuZGluZ1JlYWR5O1xuICAgICAgc2VsZi5lbWl0KCdyZWFkeScsIHNlbGYpO1xuICAgIH0pO1xuICB9XG59O1xuXG5cbk1vZGVsLnByb3RvdHlwZS5fc2V0RXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICB0aGlzLl9nZXRNb2RlbCgpLl9lcnJvciA9IGVycm9yO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xufVxuXG5cbi8qXG4gKiBSZXR1cm4gdGhlIG9wdGlvbnMgb2YgdGhlIG1vZGVsIC0tIGNhbGwgZnJvbSBhbiBpbnN0YW5jZSBvZiBNb2RlbFxuICovXG5Nb2RlbC5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbn1cblxuXG4vKlxuICogUmV0dXJuIHRoZSBpbnN0YW5jZSBvZiBNb2RlbCAqKndoZW4gY2FsbGVkIG9uIHRoZSBmdW5jdGlvbioqXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5fZ2V0TW9kZWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wcm90b19fO1xufVxuXG4vKlxuICogUmV0dXJuIHRoZSBpbnN0YW5jZSBvZiBNb2RlbFxuICovXG5Nb2RlbC5wcm90b3R5cGUuZ2V0VGFibGVOYW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nZXRNb2RlbCgpLl9uYW1lO1xufVxuXG5cbk1vZGVsLnByb3RvdHlwZS5lbnN1cmVJbmRleCA9IGZ1bmN0aW9uKG5hbWUsIGZuLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoKG9wdHMgPT09IHVuZGVmaW5lZCkgJiYgKHV0aWwuaXNQbGFpbk9iamVjdChmbikpKSB7XG4gICAgb3B0cyA9IGZuO1xuICAgIGZuID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHNlbGYuX2NyZWF0ZUluZGV4KG5hbWUsIGZuLCBvcHRzKVxuICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBzZWxmLl9nZXRNb2RlbCgpLl9zZXRFcnJvcihlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xufVxuXG5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUluZGV4ID0gZnVuY3Rpb24obmFtZSwgZm4sIG9wdHMpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwoKTtcbiAgdmFyIHRhYmxlTmFtZSA9IHRoaXMuZ2V0VGFibGVOYW1lKCk7XG4gIHZhciByID0gbW9kZWwuX3RoaW5reS5yO1xuXG4gIGlmIChvcHRzID09PSB1bmRlZmluZWQgJiYgdXRpbC5pc1BsYWluT2JqZWN0KGZuKSkge1xuICAgIG9wdHMgPSBmbjtcbiAgICBmbiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gdGhpcy50YWJsZVJlYWR5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gci5icmFuY2goXG4gICAgICAgIHIudGFibGUodGFibGVOYW1lKS5pbmRleExpc3QoKS5jb250YWlucyhuYW1lKSxcbiAgICAgICAgci50YWJsZSh0YWJsZU5hbWUpLmluZGV4V2FpdChuYW1lKSxcbiAgICAgICAgci5icmFuY2goXG4gICAgICAgICAgci50YWJsZSh0YWJsZU5hbWUpLmluZm8oKSgncHJpbWFyeV9rZXknKS5lcShuYW1lKSxcbiAgICAgICAgICByLnRhYmxlKHRhYmxlTmFtZSkuaW5kZXhXYWl0KG5hbWUpLFxuICAgICAgICAgIHIudGFibGUodGFibGVOYW1lKS5pbmRleENyZWF0ZShuYW1lLCBmbiwgb3B0cykuZG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gci50YWJsZSh0YWJsZU5hbWUpLmluZGV4V2FpdChuYW1lKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApXG4gICAgICAucnVuKClcbiAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UubWF0Y2goL15JbmRleC8pKSB7XG4gICAgICAgICAgLy8gVE9ETzogVGhpcyByZWdleCBzZWVtcyBhIGJpdCB0b28gZ2VuZXJvdXMgc2luY2UgbWVzc2FnZXMgc3VjaFxuICAgICAgICAgIC8vIGFzIFwiSW5kZXggYGlkYCB3YXMgbm90IGZvdW5kIG9uIHRhYmxlLi4uXCIgd2lsbCBiZSBhY2NlcHRlZC5cbiAgICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHRoaXMgaXMgT0sgb3Igbm90LlxuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KVxuICAudGhlbihmdW5jdGlvbigpIHtcbiAgICBtb2RlbC5faW5kZXhlc1tuYW1lXSA9IHRydWU7XG4gIH0pO1xuXG4gIHRoaXMuX3dhaXRGb3IocHJvbWlzZSk7XG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLypcbiAqIGpvaW5lZE1vZGVsOiB0aGUgam9pbmVkIG1vZGVsXG4gKiBmaWVsZERvYzogdGhlIGZpZWxkIHdoZXJlIHRoZSBqb2luZWQgZG9jdW1lbnQgd2lsbCBiZSBrZXB0XG4gKiBsZWZ0S2V5OiB0aGUga2V5IGluIHRoZSBtb2RlbCB1c2VkIGZvciB0aGUgam9pblxuICogcmlnaHRLZXk6IHRoZSBrZXkgaW4gdGhlIGpvaW5lZCBtb2RlbCB1c2VkIGZvciB0aGUgam9pblxuICpcbiAqIFRoZSBmb3JlaWduIGtleSBpcyBzdG9yZXMgaW4gdGhlIGpvaW5lZE1vZGVsXG4gKlxuICogUG9zdC5oYXNPbmUoQXV0aG9yLCBcImF1dGhvclwiLCBcImlkXCIsIFwicG9zdElkXCJcbiAqICAgICAgICAgICAgICAgIF4tIHBvc3QuaWRcbiAqXG4gKiBvcHRpb25zIGNhbiBiZTpcbiAqIC0gaW5pdDogQm9vbGVhbiAoY3JlYXRlIGFuIGluZGV4IG9yIG5vdClcbiAqIC0gdGltZUZvcm1hdDogJ3JhdycvJ25hdGl2ZSdcbiAqIC0gZW5mb3JjZV9leHRyYTogJ3N0cmljdCcvJ3JlbW92ZScvJ25vbmUnXG4gKiAtIGVuZm9yY2VfbWlzc2luZzogQm9vbGVhblxuICogLSBlbmZvcmNlX3R5cGU6ICdzdHJpY3QnLydsb29zZScvJ25vbmUnXG4gKiAtIHZhbGlkYXRlOiAnb25jcmVhdGUnLydvbnNhdmUnXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5oYXNPbmUgPSBmdW5jdGlvbihqb2luZWRNb2RlbCwgZmllbGREb2MsIGxlZnRLZXksIHJpZ2h0S2V5LCBvcHRpb25zKSB7XG4gIHZhciBzZWxmICA9IHRoaXM7XG5cbiAgaWYgKChqb2luZWRNb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBvZiBgaGFzT25lYCBtdXN0IGJlIGEgTW9kZWxcIilcbiAgfVxuICBpZiAoZmllbGREb2MgaW4gc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmllbGQgYFwiK2ZpZWxkRG9jK1wiYCBpcyBhbHJlYWR5IHVzZWQgYnkgYW5vdGhlciByZWxhdGlvbi5cIik7XG4gIH1cbiAgaWYgKGZpZWxkRG9jID09PSBcIl9hcHBseVwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpZWxkIGBfYXBwbHlgIGlzIHJlc2VydmVkIGJ5IHRoaW5reS4gUGxlYXNlIHVzZSBhbm90aGVyIG9uZS5cIik7XG4gIH1cbiAgc2VsZi5fZ2V0TW9kZWwoKS5fam9pbnNbZmllbGREb2NdID0ge1xuICAgIG1vZGVsOiBqb2luZWRNb2RlbCxcbiAgICBsZWZ0S2V5OiBsZWZ0S2V5LFxuICAgIHJpZ2h0S2V5OiByaWdodEtleSxcbiAgICB0eXBlOiAnaGFzT25lJ1xuICB9XG4gIGpvaW5lZE1vZGVsLl9nZXRNb2RlbCgpLl9sb2NhbEtleXNbcmlnaHRLZXldID0gdHJ1ZTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMuaW5pdCAhPT0gZmFsc2UpIHtcbiAgICB2YXIgbmV3SW5kZXggPSBqb2luZWRNb2RlbC5fY3JlYXRlSW5kZXgocmlnaHRLZXkpXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBqb2luZWRNb2RlbC5fZ2V0TW9kZWwoKS5fc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgc2VsZi5fZ2V0TW9kZWwoKS5fc2V0RXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIHNlbGYuX3dhaXRGb3IobmV3SW5kZXgpO1xuICB9XG59XG5cbi8qXG4gKiBqb2luZWRNb2RlbDogdGhlIGpvaW5lZCBtb2RlbFxuICogZmllbGREb2M6IHRoZSBmaWVsZCB3aGVyZSB0aGUgam9pbmVkIGRvY3VtZW50IHdpbGwgYmUga2VwdFxuICogbGVmdEtleTogdGhlIGtleSBpbiB0aGUgbW9kZWwgdXNlZCBmb3IgdGhlIGpvaW5cbiAqIHJpZ2h0S2V5OiB0aGUga2V5IGluIHRoZSBqb2luZWQgbW9kZWwgdXNlZCBmb3IgdGhlIGpvaW5cbiAqXG4gKiBUaGUgZm9yZWlnbiBrZXkgaXMgc3RvcmUgaW4gdGhlIG1vZGVsIGNhbGxpbmcgYmVsb25nc1RvXG4gKlxuICogUG9zdC5iZWxvbmdzVG8oQXV0aG9yLCBcImF1dGhvclwiLCBcImF1dGhvcklkXCIsIFwiaWRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBeLSBhdXRob3IuaWRcbiAqL1xuTW9kZWwucHJvdG90eXBlLmJlbG9uZ3NUbyA9IGZ1bmN0aW9uKGpvaW5lZE1vZGVsLCBmaWVsZERvYywgbGVmdEtleSwgcmlnaHRLZXksIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgID0gdGhpcztcblxuICBpZiAoKGpvaW5lZE1vZGVsIGluc3RhbmNlb2YgTW9kZWwpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG9mIGBiZWxvbmdzVG9gIG11c3QgYmUgYSBNb2RlbFwiKVxuICB9XG4gIGlmIChmaWVsZERvYyBpbiBzZWxmLl9nZXRNb2RlbCgpLl9qb2lucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaWVsZCBgXCIrZmllbGREb2MrXCJgIGlzIGFscmVhZHkgdXNlZCBieSBhbm90aGVyIHJlbGF0aW9uLlwiKTtcbiAgfVxuICBpZiAoZmllbGREb2MgPT09IFwiX2FwcGx5XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmllbGQgYF9hcHBseWAgaXMgcmVzZXJ2ZWQgYnkgdGhpbmt5LiBQbGVhc2UgdXNlIGFub3RoZXIgb25lLlwiKTtcbiAgfVxuXG4gIHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zW2ZpZWxkRG9jXSA9IHtcbiAgICBtb2RlbDogam9pbmVkTW9kZWwsXG4gICAgbGVmdEtleTogbGVmdEtleSxcbiAgICByaWdodEtleTogcmlnaHRLZXksXG4gICAgdHlwZTogJ2JlbG9uZ3NUbydcbiAgfTtcbiAgc2VsZi5fZ2V0TW9kZWwoKS5fbG9jYWxLZXlzW2xlZnRLZXldID0gdHJ1ZTtcblxuICBqb2luZWRNb2RlbC5fZ2V0TW9kZWwoKS5fcmV2ZXJzZUpvaW5zW2ZpZWxkRG9jXSA9IHtcbiAgICBtb2RlbDogc2VsZixcbiAgICBsZWZ0S2V5OiBsZWZ0S2V5LFxuICAgIHJpZ2h0S2V5OiByaWdodEtleSxcbiAgICB0eXBlOiAnYmVsb25nc1RvJyxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5pbml0ICE9PSBmYWxzZSkge1xuICAgIC8qXG4gICAgdmFyIG5ld0luZGV4ID0gc2VsZi5fY3JlYXRlSW5kZXgobGVmdEtleSlcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGpvaW5lZE1vZGVsLl9nZXRNb2RlbCgpLl9zZXRFcnJvcihlcnJvcik7XG4gICAgICBzZWxmLl9nZXRNb2RlbCgpLl9zZXRFcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgam9pbmVkTW9kZWwuX3dhaXRGb3IobmV3SW5kZXgpO1xuICAgICovXG4gICAgdmFyIG5ld0luZGV4ID0gam9pbmVkTW9kZWwuX2NyZWF0ZUluZGV4KHJpZ2h0S2V5KVxuICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgam9pbmVkTW9kZWwuX2dldE1vZGVsKCkuX3NldEVycm9yKGVycm9yKTtcbiAgICAgIHNlbGYuX2dldE1vZGVsKCkuX3NldEVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICBzZWxmLl93YWl0Rm9yKG5ld0luZGV4KTtcblxuICB9XG59XG5cblxuLypcbiAqIGpvaW5lZE1vZGVsOiB0aGUgam9pbmVkIG1vZGVsXG4gKiBmaWVsZERvYzogdGhlIGZpZWxkIHdoZXJlIHRoZSBqb2luZWQgZG9jdW1lbnQgd2lsbCBiZSBrZXB0XG4gKiBsZWZ0S2V5OiB0aGUga2V5IGluIHRoZSBtb2RlbCB1c2VkIGZvciB0aGUgam9pblxuICogcmlnaHRLZXk6IHRoZSBrZXkgaW4gdGhlIGpvaW5lZCBtb2RlbCB1c2VkIGZvciB0aGUgam9pblxuICpcbiAqIEEgcG9zdCBoYXMgb25lIGF1dGhvciwgYW5kIGFuIGF1dGhvciBjYW4gd3JpdGUgbXVsdGlwbGUgcG9zdHNcbiAqIEF1dGhvci5oYXNNYW55KFBvc3QsIFwicG9zdHNcIiwgXCJpZFwiLCBcImF1dGhvcklkXCJcbiAqICAgICAgICAgICAgICAgICBeLSBhdXRob3IuaWRcbiAqL1xuTW9kZWwucHJvdG90eXBlLmhhc01hbnkgPSBmdW5jdGlvbihqb2luZWRNb2RlbCwgZmllbGREb2MsIGxlZnRLZXksIHJpZ2h0S2V5LCBvcHRpb25zKSB7XG4gIHZhciBzZWxmICA9IHRoaXM7XG5cbiAgaWYgKChqb2luZWRNb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBvZiBgaGFzTWFueWAgbXVzdCBiZSBhIE1vZGVsXCIpXG4gIH1cbiAgaWYgKGZpZWxkRG9jIGluIHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpZWxkIGBcIitmaWVsZERvYytcImAgaXMgYWxyZWFkeSB1c2VkIGJ5IGFub3RoZXIgcmVsYXRpb24uXCIpO1xuICB9XG4gIGlmIChmaWVsZERvYyA9PT0gXCJfYXBwbHlcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaWVsZCBgX2FwcGx5YCBpcyByZXNlcnZlZCBieSB0aGlua3kuIFBsZWFzZSB1c2UgYW5vdGhlciBvbmUuXCIpO1xuICB9XG5cbiAgdGhpcy5fZ2V0TW9kZWwoKS5fam9pbnNbZmllbGREb2NdID0ge1xuICAgIG1vZGVsOiBqb2luZWRNb2RlbCxcbiAgICBsZWZ0S2V5OiBsZWZ0S2V5LFxuICAgIHJpZ2h0S2V5OiByaWdodEtleSxcbiAgICB0eXBlOiAnaGFzTWFueSdcbiAgfTtcbiAgam9pbmVkTW9kZWwuX2dldE1vZGVsKCkuX2xvY2FsS2V5c1tyaWdodEtleV0gPSB0cnVlO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5pbml0ICE9PSBmYWxzZSkge1xuICAgIHZhciBuZXdJbmRleCA9IGpvaW5lZE1vZGVsLl9jcmVhdGVJbmRleChyaWdodEtleSlcbiAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHNlbGYuX2dldE1vZGVsKCkuX3NldEVycm9yKGVycm9yKTtcbiAgICAgIGpvaW5lZE1vZGVsLl9nZXRNb2RlbCgpLl9zZXRFcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgc2VsZi5fd2FpdEZvcihuZXdJbmRleCk7XG4gIH1cbn1cblxuXG4vKlxuICogam9pbmVkTW9kZWw6IHRoZSBqb2luZWQgbW9kZWxcbiAqIGZpZWxkRG9jOiB0aGUgZmllbGQgd2hlcmUgdGhlIGpvaW5lZCBkb2N1bWVudCB3aWxsIGJlIGtlcHRcbiAqIGxlZnRLZXk6IHRoZSBrZXkgaW4gdGhlIG1vZGVsIHVzZWQgZm9yIHRoZSBqb2luXG4gKiByaWdodEtleTogdGhlIGtleSBpbiB0aGUgam9pbmVkIG1vZGVsIHVzZWQgZm9yIHRoZSBqb2luXG4gKlxuICogUGF0aWVudC5oYXNBbmRCZWxvbmdzVG9NYW55KERvY3RvciwgXCJkb2N0b3JzXCIsIFwiaWRcIiwgXCJpZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgIHBhdGllbnQuaWQtXiAgXi1kb2N0b3IuaWRcbiAqXG4gKiBJdCBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgYSB0YWJsZSA8bW9kZWxOYW1lPl88am9pbmVkTW9kZWw+IG9yIDxqb2luZWRNb2RlbD5fPG1vZGVsTmFtZT4gKGFscGhhYmV0aWMgb3JkZXIpXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5oYXNBbmRCZWxvbmdzVG9NYW55ID0gZnVuY3Rpb24oam9pbmVkTW9kZWwsIGZpZWxkRG9jLCBsZWZ0S2V5LCByaWdodEtleSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsaW5rLCBxdWVyeTtcbiAgdmFyIHRoaW5reSA9IHRoaXMuX2dldE1vZGVsKCkuX3RoaW5reTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKChqb2luZWRNb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBvZiBgaGFzQW5kQmVsb25nc1RvTWFueWAgbXVzdCBiZSBhIE1vZGVsXCIpXG4gIH1cbiAgaWYgKGZpZWxkRG9jIGluIHNlbGYuX2dldE1vZGVsKCkuX2pvaW5zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpZWxkIGBcIitmaWVsZERvYytcImAgaXMgYWxyZWFkeSB1c2VkIGJ5IGFub3RoZXIgcmVsYXRpb24uXCIpO1xuICB9XG4gIGlmIChmaWVsZERvYyA9PT0gXCJfYXBwbHlcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaWVsZCBgX2FwcGx5YCBpcyByZXNlcnZlZCBieSB0aGlua3kuIFBsZWFzZSB1c2UgYW5vdGhlciBvbmUuXCIpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2dldE1vZGVsKCkuX25hbWUgPCBqb2luZWRNb2RlbC5fZ2V0TW9kZWwoKS5fbmFtZSkge1xuICAgIGxpbmsgPSB0aGlzLl9nZXRNb2RlbCgpLl9uYW1lK1wiX1wiK2pvaW5lZE1vZGVsLl9nZXRNb2RlbCgpLl9uYW1lO1xuICB9XG4gIGVsc2Uge1xuICAgIGxpbmsgPSBqb2luZWRNb2RlbC5fZ2V0TW9kZWwoKS5fbmFtZStcIl9cIit0aGlzLl9nZXRNb2RlbCgpLl9uYW1lO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50eXBlID09PSAnc3RyaW5nJykge1xuICAgIGxpbmsgPSBsaW5rK1wiX1wiK29wdGlvbnMudHlwZTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy50eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy50eXBlIHNob3VsZCBiZSBhIHN0cmluZyBvciB1bmRlZmluZWQuJylcbiAgfVxuXG4gIHZhciBsaW5rTW9kZWw7XG4gIGlmICh0aGlua3kubW9kZWxzW2xpbmtdID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBDcmVhdGUgYSBtb2RlbCwgY2xhaW0gdGhlIG5hbWVzcGFjZSBhbmQgY3JlYXRlIHRoZSB0YWJsZVxuICAgIC8vIHBhc3NlcyB0YWJsZSBvcHRpb25zIHRvIHRoZSB1bmRlcmx5aW5nIG1vZGVsIChlLmcuIHJlcGxpY2FzLCBzaGFyZHMpXG4gICAgbGlua01vZGVsID0gdGhpbmt5LmNyZWF0ZU1vZGVsKGxpbmssIHt9LCB7IHRhYmxlOiBvcHRpb25zLnRhYmxlIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGxpbmtNb2RlbCA9IHRoaW5reS5tb2RlbHNbbGlua107XG4gIH1cblxuXG4gIHRoaXMuX2dldE1vZGVsKCkuX2pvaW5zW2ZpZWxkRG9jXSA9IHtcbiAgICBtb2RlbDogam9pbmVkTW9kZWwsXG4gICAgbGVmdEtleTogbGVmdEtleSxcbiAgICByaWdodEtleTogcmlnaHRLZXksXG4gICAgdHlwZTogJ2hhc0FuZEJlbG9uZ3NUb01hbnknLFxuICAgIGxpbms6IGxpbmssXG4gICAgbGlua01vZGVsOiBsaW5rTW9kZWxcbiAgfVxuXG4gIGpvaW5lZE1vZGVsLl9nZXRNb2RlbCgpLl9yZXZlcnNlSm9pbnNbc2VsZi5nZXRUYWJsZU5hbWUoKV0gPSB7XG4gICAgbGVmdEtleTogbGVmdEtleSxcbiAgICByaWdodEtleTogcmlnaHRLZXksXG4gICAgdHlwZTogJ2hhc0FuZEJlbG9uZ3NUb01hbnknLFxuICAgIGxpbms6IGxpbmssXG4gICAgbGlua01vZGVsOiBsaW5rTW9kZWxcbiAgfVxuXG4gIGlmIChvcHRpb25zLmluaXQgIT09IGZhbHNlKSB7XG4gICAgdmFyIHIgPSBzZWxmLl9nZXRNb2RlbCgpLl90aGlua3kucjtcblxuICAgIHZhciBxdWVyeTtcbiAgICBpZiAoKHRoaXMuZ2V0VGFibGVOYW1lKCkgPT09IGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKVxuICAgICAgJiYgKGxlZnRLZXkgPT09IHJpZ2h0S2V5KSkge1xuICAgICAgLy8gVGhlIHJlbGF0aW9uIGlzIGJ1aWx0IGZvciB0aGUgc2FtZSBtb2RlbCwgdXNpbmcgdGhlIHNhbWUga2V5XG4gICAgICAvLyBDcmVhdGUgYSBtdWx0aSBpbmRleFxuICAgICAgcXVlcnkgPSByLmJyYW5jaChcbiAgICAgICAgci50YWJsZShsaW5rKS5pbmRleExpc3QoKS5jb250YWlucyhsZWZ0S2V5K1wiX1wiK3JpZ2h0S2V5KSxcbiAgICAgICAgci50YWJsZShsaW5rKS5pbmRleFdhaXQobGVmdEtleStcIl9cIityaWdodEtleSksXG4gICAgICAgIHIudGFibGUobGluaykuaW5kZXhDcmVhdGUobGVmdEtleStcIl9cIityaWdodEtleSwgZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGRvYyhsZWZ0S2V5K1wiX1wiK3JpZ2h0S2V5KVxuICAgICAgICB9LCB7bXVsdGk6IHRydWV9KS5kbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gci50YWJsZShsaW5rKS5pbmRleFdhaXQobGVmdEtleStcIl9cIityaWdodEtleSlcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBxdWVyeSA9IHIuYnJhbmNoKFxuICAgICAgICByLnRhYmxlKGxpbmspLmluZGV4TGlzdCgpLmNvbnRhaW5zKHNlbGYuZ2V0VGFibGVOYW1lKCkrJ18nK2xlZnRLZXkpLFxuICAgICAgICByLnRhYmxlKGxpbmspLmluZGV4V2FpdChzZWxmLmdldFRhYmxlTmFtZSgpKydfJytsZWZ0S2V5KSxcbiAgICAgICAgci50YWJsZShsaW5rKS5pbmRleENyZWF0ZShzZWxmLmdldFRhYmxlTmFtZSgpKydfJytsZWZ0S2V5KS5kbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gci50YWJsZShsaW5rKS5pbmRleFdhaXQoc2VsZi5nZXRUYWJsZU5hbWUoKSsnXycrbGVmdEtleSlcbiAgICAgICAgfSlcbiAgICAgICkuZG8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByLmJyYW5jaChcbiAgICAgICAgICByLnRhYmxlKGxpbmspLmluZGV4TGlzdCgpLmNvbnRhaW5zKGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKydfJytyaWdodEtleSksXG4gICAgICAgICAgci50YWJsZShsaW5rKS5pbmRleFdhaXQoam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkrJ18nK3JpZ2h0S2V5KSxcbiAgICAgICAgICByLnRhYmxlKGxpbmspLmluZGV4Q3JlYXRlKGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKydfJytyaWdodEtleSkuZG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gci50YWJsZShsaW5rKS5pbmRleFdhaXQoam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkrJ18nK3JpZ2h0S2V5KVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgICB2YXIgbGlua1Byb21pc2UgPSBsaW5rTW9kZWwucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1ZXJ5LnJ1bigpXG4gICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fZ2V0TW9kZWwoKS5faW5kZXhlc1tsZWZ0S2V5XSA9IHRydWU7XG4gICAgICAgIGpvaW5lZE1vZGVsLl9nZXRNb2RlbCgpLl9pbmRleGVzW3JpZ2h0S2V5XSA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLm1hdGNoKC9eSW5kZXggYC8pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLm1hdGNoKC9eVGFibGUgYC4qYCBhbHJlYWR5IGV4aXN0cy8pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX2dldE1vZGVsKCkuX3NldEVycm9yKGVycm9yKTtcbiAgICAgICAgam9pbmVkTW9kZWwuX2dldE1vZGVsKCkuX3NldEVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fY3JlYXRlSW5kZXgobGVmdEtleSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBzZWxmLl9nZXRNb2RlbCgpLl9zZXRFcnJvcihlcnJvcik7XG4gICAgICAgIGpvaW5lZE1vZGVsLl9nZXRNb2RlbCgpLl9zZXRFcnJvcihlcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgam9pbmVkTW9kZWwuX2NyZWF0ZUluZGV4KHJpZ2h0S2V5KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIHNlbGYuX2dldE1vZGVsKCkuX3NldEVycm9yKGVycm9yKTtcbiAgICAgICAgam9pbmVkTW9kZWwuX2dldE1vZGVsKCkuX3NldEVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgam9pbmVkTW9kZWwuX3dhaXRGb3IobGlua1Byb21pc2UpO1xuICAgIHNlbGYuX3dhaXRGb3IobGlua1Byb21pc2UpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtzZWxmLnJlYWR5KCksIGpvaW5lZE1vZGVsLnJlYWR5KCldKTtcbiAgfVxufTtcblxuKGZ1bmN0aW9uKCkge1xuICAvLyBJbXBvcnQgcmV0aGlua2RiZGFzaCBtZXRob2RzXG4gIHZhciBUZXJtID0gcmVxdWlyZSgncmV0aGlua2RiZGFzaCcpKHtwb29sOiBmYWxzZX0pLmV4cHIoMSkuX19wcm90b19fO1xuICB1dGlsLmxvb3BLZXlzKFRlcm0sIGZ1bmN0aW9uKFRlcm0sIGtleSkge1xuICAgIGlmICghVGVybS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm47XG4gICAgaWYgKGtleSA9PT0gJ3J1bicgfHwga2V5WzBdID09PSAnXycpIHJldHVybjtcblxuICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ29yZGVyQnknOlxuICAgICAgICAgIE1vZGVsLnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodGhpcyk7XG4gICAgICAgICAgICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICYmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgJiYgKHRoaXMuX2dldE1vZGVsKCkuX2luZGV4ZXNbYXJndW1lbnRzWzBdXSA9PT0gdHJ1ZSkpIHtcblxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlba2V5XSh7aW5kZXg6IGFyZ3VtZW50c1swXX0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5W2tleV0uYXBwbHkocXVlcnksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZpbHRlcic6XG4gICAgICAgICAgTW9kZWwucHJvdG90eXBlW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgIGlmICgoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgJiYgKHV0aWwuaXNQbGFpbk9iamVjdChhcmd1bWVudHNbMF0pKSkge1xuXG4gICAgICAgICAgICAgIC8vIE9wdGltaXplIGEgZmlsdGVyIHdpdGggYW4gb2JqZWN0XG4gICAgICAgICAgICAgIC8vIFdlIHJlcGxhY2UgdGhlIGZpcnN0IGtleSB0aGF0IG1hdGNoIGFuIGluZGV4IG5hbWVcbiAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZpbHRlcikuc29ydCgpOyAvLyBMZXhpY29ncmFwaGljYWwgb3JkZXJcbiAgICAgICAgICAgICAgZm9yKHZhciBpPTAgOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBrZXlzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dldE1vZGVsKCkuX2luZGV4ZXNbaW5kZXhdID09PSB0cnVlKSB7IC8vIEluZGV4IGZvdW5kXG4gICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmdldEFsbChmaWx0ZXJbaW5kZXhdLCB7aW5kZXg6IGluZGV4fSk7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgZmlsdGVyW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5W2tleV0uYXBwbHkocXVlcnksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IG9mIGBnZXRgIGludG8gYF9nZXRgXG4gICAgICAgICAgTW9kZWwucHJvdG90eXBlWydfZ2V0J10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlbJ19nZXQnXS5hcHBseShxdWVyeSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgTW9kZWwucHJvdG90eXBlW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnlba2V5XS5hcHBseShxdWVyeSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KShrZXkpO1xuICB9KTtcbn0pKCk7XG5cbk1vZGVsLnByb3RvdHlwZS5nZXRKb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzKTtcbiAgcmV0dXJuIHF1ZXJ5LmdldEpvaW4uYXBwbHkocXVlcnksIGFyZ3VtZW50cylcbn1cblxuTW9kZWwucHJvdG90eXBlLnJlbW92ZVJlbGF0aW9ucyA9IGZ1bmN0aW9uKHJlbGF0aW9uc1RvUmVtb3ZlKSB7XG4gIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzKTtcbiAgcmV0dXJuIHF1ZXJ5LnJlbW92ZVJlbGF0aW9ucyhyZWxhdGlvbnNUb1JlbW92ZSk7XG59XG5cblxuTW9kZWwucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMpO1xuICByZXR1cm4gcXVlcnkucnVuKG9wdGlvbnMpO1xufVxuTW9kZWwucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzKTtcbiAgcmV0dXJuIHF1ZXJ5LmV4ZWN1dGUob3B0aW9ucyk7XG59XG5cbk1vZGVsLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oZG9jcywgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gc2VsZi5fZ2V0TW9kZWwoKS5fdGhpbmt5LnI7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkb2NzKTtcblxuICBpZiAoIWlzQXJyYXkpIHtcbiAgICBkb2NzID0gW2RvY3NdO1xuICB9XG5cbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihtYWluUmVzb2x2ZSwgbWFpblJlamVjdCkge1xuICAgIHZhciB0b1NhdmUgPSBkb2NzLmxlbmd0aDtcblxuICAgIHZhciByZXNvbHZlcyA9IFtdO1xuICAgIHZhciByZWplY3RzID0gW107XG4gICAgdmFyIGV4ZWN1dGVJbnNlcnQgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB0b1NhdmUtLTtcbiAgICAgIHJlc29sdmVzLnB1c2gocmVzb2x2ZSk7XG4gICAgICByZWplY3RzLnB1c2gocmVqZWN0KTtcblxuICAgICAgaWYgKHRvU2F2ZSA9PT0gMCkge1xuICAgICAgICB2YXIgY29waWVzID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGRvY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb3BpZXMucHVzaChkb2NzW2ldLl9tYWtlU2F2YWJsZUNvcHkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9vcHRpb25zO1xuICAgICAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgX29wdGlvbnMgPSB1dGlsLmRlZXBDb3B5KG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF9vcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgX29wdGlvbnMucmV0dXJuQ2hhbmdlcyA9ICdhbHdheXMnO1xuICAgICAgICByLnRhYmxlKHNlbGYuZ2V0VGFibGVOYW1lKCkpLmluc2VydChjb3BpZXMsIF9vcHRpb25zKS5ydW4oKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgICBpZiAocmVzdWx0cy5lcnJvcnMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHJlc3VsdHMuY2hhbmdlcyBjdXJyZW50bHkgZG9lcyBub3QgZW5mb3JjZSB0aGUgc2FtZSBvcmRlciBhcyBkb2NzXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzLmNoYW5nZXMpKSB7XG4gICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHJlc3VsdHMuY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRvY3NbaV0uX21lcmdlKHJlc3VsdHMuY2hhbmdlc1tpXS5uZXdfdmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jc1tpXS5fZ2V0TW9kZWwoKS5uZWVkVG9HZW5lcmF0ZUZpZWxkcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgZG9jc1tpXS5fZ2VuZXJhdGVEZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvY3NbaV0uX3NldE9sZFZhbHVlKHV0aWwuZGVlcENvcHkocmVzdWx0cy5jaGFuZ2VzW2ldLm9sZF92YWwpKTtcbiAgICAgICAgICAgICAgICBkb2NzW2ldLnNldFNhdmVkKCk7XG4gICAgICAgICAgICAgICAgZG9jc1tpXS5lbWl0KCdzYXZlZCcsIGRvY3NbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHJlc29sdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVzW2ldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9UT0RPIEV4cGFuZCBlcnJvciB3aXRoIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHJlamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVqZWN0c1tpXShuZXcgRXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGJhdGNoIGluc2VydC4gT3JpZ2luYWwgcmVzdWx0czpcXG5cIitKU09OLnN0cmluZ2lmeShyZXN1bHRzLCBudWxsLCAyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgdmFyIGZvdW5kTm9uVmFsaWREb2MgPSBmYWxzZTtcbiAgICBmb3IodmFyIGk9MDsgaTxkb2NzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZm91bmROb25WYWxpZERvYyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZG9jc1tpXSBpbnN0YW5jZW9mIERvY3VtZW50ID09PSBmYWxzZSkge1xuICAgICAgICBkb2NzW2ldID0gbmV3IHNlbGYoZG9jc1tpXSk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHV0aWwudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb21pc2UgPSBkb2NzW2ldLnZhbGlkYXRlKCk7XG4gICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSlcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgZm91bmROb25WYWxpZERvYyA9IHRydWU7XG4gICAgICAgIG1haW5SZWplY3QobmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJPbmUgb2YgdGhlIGRvY3VtZW50cyBpcyBub3QgdmFsaWQuIE9yaWdpbmFsIGVycm9yOlxcblwiK2Vycm9yLm1lc3NhZ2UpKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kTm9uVmFsaWREb2MgPT09IGZhbHNlKSB7XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGRvY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3NbaV0uX2JhdGNoU2F2ZShleGVjdXRlSW5zZXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbWFpblJlc29sdmUoZG9jcyk7XG4gICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgbWFpblJlamVjdChlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBtYWluUmVqZWN0KG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiT25lIG9mIHRoZSBkb2N1bWVudHMgaXMgbm90IHZhbGlkLiBPcmlnaW5hbCBlcnJvcjpcXG5cIitlcnJvci5tZXNzYWdlKSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcblxuICBpZiAoIWlzQXJyYXkpIHtcbiAgICByZXR1cm4gcC5nZXQoMCk7XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuXG5Nb2RlbC5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24oa2V5LCBmbikge1xuICB0aGlzLl9tZXRob2RzW2tleV0gPSBmbjtcbn1cbk1vZGVsLnByb3RvdHlwZS5kZWZpbmVTdGF0aWMgPSBmdW5jdGlvbihrZXksIGZuKSB7XG4gIHRoaXMuX3N0YXRpY01ldGhvZHNba2V5XSA9IGZuO1xuXG4gIHRoaXNba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5cblxuTW9kZWwucHJvdG90eXBlLl9wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIHVuZ3JvdXApIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgdmFyIHByb21pc2U7XG5cbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAodW5ncm91cCkge1xuICAgICAgZm9yKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IodmFyIGo9MDsgajxkYXRhW2ldLnJlZHVjdGlvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHV0aWwudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV3RG9jID0gbmV3IHNlbGYoZGF0YVtpXS5yZWR1Y3Rpb25bal0pO1xuICAgICAgICAgICAgbmV3RG9jLnNldFNhdmVkKHRydWUpO1xuICAgICAgICAgICAgbmV3RG9jLl9lbWl0UmV0cmlldmUoKTtcbiAgICAgICAgICAgIGRhdGFbaV0ucmVkdWN0aW9uW2pdID0gbmV3RG9jO1xuICAgICAgICAgIH0sIHJlamVjdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHV0aWwudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkYXRhW2ldID0gbmV3IHNlbGYoZGF0YVtpXSlcbiAgICAgICAgICBkYXRhW2ldLnNldFNhdmVkKHRydWUpO1xuXG4gICAgICAgICAgc2VsZi5lbWl0KCdyZXRyaWV2ZWQnLCBkYXRhW2ldKTtcblxuICAgICAgICAgIChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAvLyBPcmRlciBtYXR0ZXJzIGhlcmUsIHdlIHdhbnQgdGhlIGhvb2tzIHRvIGJlIGV4ZWN1dGVkICpiZWZvcmUqIGNhbGxpbmcgdmFsaWRhdGVcbiAgICAgICAgICAgIHByb21pc2UgPSB1dGlsLmhvb2soe1xuICAgICAgICAgICAgICBwb3N0SG9va3M6IGRhdGFbaV0uX2dldE1vZGVsKCkuX3Bvc3QucmV0cmlldmUsXG4gICAgICAgICAgICAgIGRvYzogZGF0YVtpXSxcbiAgICAgICAgICAgICAgYXN5bmM6IGRhdGFbaV0uX2dldE1vZGVsKCkuX2FzeW5jLnJldHJpZXZlLFxuICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBkYXRhW2ldLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgICAgICAgICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IGRhdGFbaV0udmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKGkpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB2YXIgbmV3RXJyb3IgPSBuZXcgRXJyb3IoXCJUaGUgcmVzdWx0cyBjb3VsZCBub3QgYmUgY29udmVydGVkIHRvIGluc3RhbmNlcyBvZiBgXCIrc2VsZi5nZXRUYWJsZU5hbWUoKStcImBcXG5EZXRhaWxlZCBlcnJvcjogXCIrZXJyb3IubWVzc2FnZSk7XG5cbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGdldCBhIEdST1VQRURfREFUQSwgd2UgY29udmVydCBkb2N1bWVudHMgaW4gZWFjaCBncm91cFxuICAgICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChkYXRhKSAmJiAoZGF0YS4kcmVxbF90eXBlJCA9PT0gXCJHUk9VUEVEX0RBVEFcIikpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB1dGlsLnRyeUNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciByZWR1Y3Rpb24sIG5ld0RvYztcbiAgICAgICAgICBmb3IodmFyIGk9MDsgaTxkYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgIHJlZHVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmRhdGFbaV1bMV0pKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8ZGF0YS5kYXRhW2ldWzFdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oaikge1xuICAgICAgICAgICAgICAgICAgICBuZXdEb2MgPSBuZXcgc2VsZihkYXRhLmRhdGFbaV1bMV1bal0pO1xuICAgICAgICAgICAgICAgICAgICBuZXdEb2Muc2V0U2F2ZWQodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3RG9jLl9lbWl0UmV0cmlldmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdXRpbC5ob29rKHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3N0SG9va3M6IG5ld0RvYy5fZ2V0TW9kZWwoKS5fcG9zdC5yZXRyaWV2ZSxcbiAgICAgICAgICAgICAgICAgICAgICBkb2M6IG5ld0RvYyxcbiAgICAgICAgICAgICAgICAgICAgICBhc3luYzogbmV3RG9jLl9nZXRNb2RlbCgpLl9hc3luYy5yZXRyaWV2ZSxcbiAgICAgICAgICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ld0RvYy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IG5ld0RvYy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlZHVjdGlvbi5wdXNoKG5ld0RvYylcbiAgICAgICAgICAgICAgICAgIH0pKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBncm91cDogZGF0YS5kYXRhW2ldWzBdLFxuICAgICAgICAgICAgICAgICAgcmVkdWN0aW9uOiByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0RvYyA9IG5ldyBzZWxmKGRhdGEuZGF0YVtpXVsxXSk7XG4gICAgICAgICAgICAgICAgbmV3RG9jLnNldFNhdmVkKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgbmV3RG9jLl9lbWl0UmV0cmlldmUoKTtcblxuICAgICAgICAgICAgICAgIHByb21pc2UgPSB1dGlsLmhvb2soe1xuICAgICAgICAgICAgICAgICAgcG9zdEhvb2tzOiBuZXdEb2MuX2dldE1vZGVsKCkuX3Bvc3QucmV0cmlldmUsXG4gICAgICAgICAgICAgICAgICBkb2M6IG5ld0RvYyxcbiAgICAgICAgICAgICAgICAgIGFzeW5jOiBuZXdEb2MuX2dldE1vZGVsKCkuX2FzeW5jLnJldHJpZXZlLFxuICAgICAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ld0RvYy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IG5ld0RvYy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGdyb3VwOiBkYXRhLmRhdGFbaV1bMF0sXG4gICAgICAgICAgICAgICAgICByZWR1Y3Rpb246IG5ld0RvY1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgICAgIH0pLmVycm9yKHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHsgLy8gbWFrZURvY3VtZW50IGlzIHRydWUsIGJ1dCB3ZSBnb3QgYG51bGxgXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNhbm5vdCBidWlsZCBhIG5ldyBpbnN0YW5jZSBvZiBgXCIrc2VsZi5nZXRUYWJsZU5hbWUoKStcImAgd2l0aCBgbnVsbGAuXCIpKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHV0aWwudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbmV3RG9jID0gbmV3IHNlbGYoZGF0YSk7XG4gICAgICAgICAgICBuZXdEb2Muc2V0U2F2ZWQodHJ1ZSk7XG5cbiAgICAgICAgICAgIG5ld0RvYy5fZW1pdFJldHJpZXZlKCk7XG5cbiAgICAgICAgICAgIHByb21pc2UgPSB1dGlsLmhvb2soe1xuICAgICAgICAgICAgICBwb3N0SG9va3M6IG5ld0RvYy5fZ2V0TW9kZWwoKS5fcG9zdC5yZXRyaWV2ZSxcbiAgICAgICAgICAgICAgZG9jOiBuZXdEb2MsXG4gICAgICAgICAgICAgIGFzeW5jOiBuZXdEb2MuX2dldE1vZGVsKCkuX2FzeW5jLnJldHJpZXZlLFxuICAgICAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXdEb2MudmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXdEb2MpO1xuICAgICAgICAgICAgICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKG5ld0RvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KS5lcnJvcihyZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHByb21pc2UgPSBuZXdEb2MudmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld0RvYylcbiAgICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXdEb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBwO1xufVxuXG4vKlxuICogSW1wbGVtZW50IGFuIGludGVyZmFjZSBzaW1pbGFyIHRvIGV2ZW50cy5FdmVudEVtaXR0ZXJcbiAqL1xuTW9kZWwucHJvdG90eXBlLmRvY0FkZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRLZXksIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnNbZXZlbnRLZXldID09IG51bGwpIHtcbiAgICBsaXN0ZW5lcnNbZXZlbnRLZXldID0gW107XG4gIH1cbiAgbGlzdGVuZXJzW2V2ZW50S2V5XS5wdXNoKHtcbiAgICBvbmNlOiBmYWxzZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5Nb2RlbC5wcm90b3R5cGUuZG9jT24gPSBNb2RlbC5wcm90b3R5cGUuZG9jQWRkTGlzdGVuZXI7XG5cbk1vZGVsLnByb3RvdHlwZS5kb2NPbmNlID0gZnVuY3Rpb24oZXZlbnRLZXksIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnNbZXZlbnRLZXldID09IG51bGwpIHtcbiAgICBsaXN0ZW5lcnNbZXZlbnRLZXldID0gW107XG4gIH1cbiAgbGlzdGVuZXJzW2V2ZW50S2V5XS5wdXNoKHtcbiAgICBvbmNlOiB0cnVlLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuTW9kZWwucHJvdG90eXBlLmRvY0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50S2V5LCByYXcpIHtcbiAgaWYgKGV2ZW50S2V5ID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TW9kZWwoKS5fbGlzdGVuZXJzXG4gIH1cblxuICByYXcgPSByYXcgfHwgdHJ1ZTtcbiAgaWYgKHJhdyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnNbZXZlbnRLZXldO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnNbZXZlbnRLZXldLm1hcChmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIGZuLmxpc3RlbmVyO1xuICAgIH0pO1xuICB9XG59XG5cbk1vZGVsLnByb3RvdHlwZS5kb2NTZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuX2dldE1vZGVsKCkuX21heExpc3RlbmVycyA9IG47XG59XG5cbk1vZGVsLnByb3RvdHlwZS5kb2NSZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2LCBsaXN0ZW5lcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnNbZXZdKSkge1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuX2dldE1vZGVsKCkuX2xpc3RlbmVyc1tldl0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnNbZXZdW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnNbZXZdLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbk1vZGVsLnByb3RvdHlwZS5kb2NSZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihldikge1xuICBpZiAoZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSB0aGlzLl9nZXRNb2RlbCgpLl9saXN0ZW5lcnNbZXZdXG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5fZ2V0TW9kZWwoKS5fbGlzdGVuZXJzID0ge307XG4gIH1cbn1cblxuTW9kZWwucHJvdG90eXBlLnByZSA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgdG8gYHByZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGlmIChmbi5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IHRvIGBwcmVgIG11c3QgYmUgYSBmdW5jdGlvbiB3aXRoIGF0IG1vc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9wcmVbZXZdKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcmUtaG9vayBhdmFpbGFibGUgZm9yIHRoZSBldmVudCBgXCIrZXYrXCJgLlwiKVxuICB9XG4gIHRoaXMuX2dldE1vZGVsKCkuX2FzeW5jW2V2XSA9IHRoaXMuX2dldE1vZGVsKCkuX2FzeW5jW2V2XSB8fCAoZm4ubGVuZ3RoID09PSAxKVxuICB0aGlzLl9nZXRNb2RlbCgpLl9wcmVbZXZdLnB1c2goZm4pO1xufVxuXG5Nb2RlbC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgdG8gYHByZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGlmIChmbi5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGFyZ3VtZW50IHRvIGBwcmVgIG11c3QgYmUgYSBmdW5jdGlvbiB3aXRoIGF0IG1vc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9wb3N0W2V2XSkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcG9zdC1ob29rIGF2YWlsYWJsZSBmb3IgdGhlIGV2ZW50IGBcIitlditcImAuXCIpXG4gIH1cbiAgdGhpcy5fZ2V0TW9kZWwoKS5fYXN5bmNbZXZdID0gdGhpcy5fZ2V0TW9kZWwoKS5fYXN5bmNbZXZdIHx8IChmbi5sZW5ndGggPT09IDEpXG4gIHRoaXMuX2dldE1vZGVsKCkuX3Bvc3RbZXZdLnB1c2goZm4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuIiwidmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKF9fZGlybmFtZSsnL3V0aWwuanMnKTtcbnZhciBFcnJvcnMgPSByZXF1aXJlKF9fZGlybmFtZSsnL2Vycm9ycy5qcycpO1xudmFyIHNjaGVtYVV0aWwgPSByZXF1aXJlKF9fZGlybmFtZSsnL3NjaGVtYS5qcycpO1xudmFyIEZlZWQgPSByZXF1aXJlKF9fZGlybmFtZSsnL2ZlZWQuanMnKTtcblxuXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciBhIFF1ZXJ5LiBBIFF1ZXJ5IGJhc2ljYWxseSB3cmFwcyBhIFJlUUwgcXVlcmllcyB0byBrZWVwIHRyYWNrXG4gKiBvZiB0aGUgbW9kZWwgcmV0dXJuZWQgYW5kIGlmIGEgcG9zdC1xdWVyeSB2YWxpZGF0aW9uIGlzIHJlcXVpcmVkLlxuICogQHBhcmFtIHtGdW5jdGlvbj19IG1vZGVsIE1vZGVsIG9mIHRoZSBkb2N1bWVudHMgcmV0dXJuZWRcbiAqIEBwYXJhbSB7UmVRTFF1ZXJ5PX0gY3VycmVudCBSZVFMIHF1ZXJ5IChyZXRoaW5rZGJkYXNoKVxuICogQHBhcmFtIHtib29sZWFuPX0gcG9zdFZhbGlkYXRpb24gd2hldGhlciBwb3N0IHF1ZXJ5IHZhbGlkYXRpb24gc2hvdWxkIGJlIHBlcmZvcm1lZFxuICovXG5mdW5jdGlvbiBRdWVyeShtb2RlbCwgcXVlcnksIG9wdGlvbnMsIGVycm9yKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9tb2RlbCA9IG1vZGVsOyAvLyBjb25zdHJ1Y3RvciBvZiB0aGUgbW9kZWwgd2Ugc2hvdWxkIHVzZSBmb3IgdGhlIHJlc3VsdHMuXG4gIGlmIChtb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fciA9IG1vZGVsLl9nZXRNb2RlbCgpLl90aGlua3kucjtcbiAgICB1dGlsLmxvb3BLZXlzKG1vZGVsLl9nZXRNb2RlbCgpLl9zdGF0aWNNZXRob2RzLCBmdW5jdGlvbihzdGF0aWNNZXRob2RzLCBrZXkpIHtcbiAgICAgIChmdW5jdGlvbihfa2V5KSB7XG4gICAgICAgIHNlbGZbX2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGljTWV0aG9kc1tfa2V5XS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSkoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChxdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fcXVlcnkgPSBxdWVyeTtcbiAgIH1cbiAgZWxzZSBpZiAobW9kZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIGluaXRpYWxpemUgdGhlIHF1ZXJ5IHRvIGByLnRhYmxlKDx0YWJsZU5hbWU+KWAuXG4gICAgdGhpcy5fcXVlcnkgPSB0aGlzLl9yLnRhYmxlKG1vZGVsLmdldFRhYmxlTmFtZSgpKTtcbiAgfVxuXG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBpZiAob3B0aW9ucy5wb3N0VmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fcG9zdFZhbGlkYXRpb24gPSBvcHRpb25zLnBvc3RWYWxpZGF0aW9uID09PSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51bmdyb3VwKSB7XG4gICAgICB0aGlzLl91bmdyb3VwID0gb3B0aW9ucy51bmdyb3VwID09PSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3VuZ3JvdXAgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIGxldCB0aGUgdXNlciByZXdvcmsgdGhlIHJlc3VsdCBhZnRlciB1bmdyb3VwXG4gICAgdGhpcy5fdW5ncm91cCA9IGZhbHNlO1xuICB9XG4gIGlmIChlcnJvcikge1xuICAgIC8vIE5vdGUgYFF1ZXJ5LnByb3RvdHlwZS5lcnJvcmAgaXMgZGVmaW5lZCBiZWNhdXNlIG9mIGByLmVycm9yYCwgc28gd2Ugc2hvdWxkbid0XG4gICAgLy8gZGVmaW5lZCB0aGlzLmVycm9yLlxuICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gIH1cbiAgdGhpcy5fcG9pbnRXcml0ZSA9IGZhbHNlO1xufVxuXG5RdWVyeS5wcm90b3R5cGUuc2V0UG9zdFZhbGlkYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcG9zdFZhbGlkYXRpb24gPSB0cnVlO1xufVxuXG5RdWVyeS5wcm90b3R5cGUuc2V0UG9pbnRXcml0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wb2ludFdyaXRlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgUXVlcnkgYW5kIGV4cGVjdCB0aGUgcmVzdWx0cyB0byBiZSBvYmplY3QocykgdGhhdCBjYW4gYmUgY29udmVydGVkXG4gKiB0byBpbnN0YW5jZXMgb2YgdGhlIG1vZGVsLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgZHJpdmVyJ3MgbWV0aG9kIGBydW5gXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHF1ZXJ5IGFuZFxuICogdGhlIGluc3RhbmNlcyBvZiB0aGUgbW9kZWxzIHdpbGwgYmUgY3JlYXRlZCAoaW5jbHVkZSB0aGUgcG90ZW50aWFsXG4gKiBhc3luY2hyb25vdXMgaG9va3MpLlxuICovXG5RdWVyeS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXhlY3V0ZShvcHRpb25zLCB0cnVlKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbn1cblxuXG4vKipcbiAqIEV4ZWN1dGUgYSBRdWVyeVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgZHJpdmVyJ3MgbWV0aG9kIGBydW5gXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHNcbiAqIG9mIHRoZSBxdWVyeS5cbiAqL1xuUXVlcnkucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB0aGlzLl9leGVjdXRlKG9wdGlvbnMsIGZhbHNlKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbn1cblxuLyoqXG4qIEJpbmQgUXVlcnkucHJvdG90eXBlLnJ1bigpIGZvciBsYXRlciB1c2VcbiogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgZHJpdmVyJ3MgbWV0aG9kIGBydW5gXG4qIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFja1xuKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmV0dXJuIGEgYHRoaXNgIGJvdW5kIFF1ZXJ5LnByb3RvdHlwZS5ydW4oKVxuKi9cblxuUXVlcnkucHJvdG90eXBlLmJpbmRSdW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjdXJyaWVkQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggUXVlcnkucHJvdG90eXBlLnJ1biwgWyB0aGlzIF0uY29uY2F0KCBjdXJyaWVkQXJncyApICk7XG59XG5cbi8qKlxuICogQmluZCBRdWVyeS5wcm90b3R5cGUuZXhlY3V0ZSgpIGZvciBsYXRlciB1c2VcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGRyaXZlcidzIG1ldGhvZCBgcnVuYFxuICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmV0dXJuIGEgYHRoaXNgIGJvdW5kIFF1ZXJ5LnByb3RvdHlwZS5leGVjdXRlKClcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuYmluZEV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjdXJyaWVkQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggUXVlcnkucHJvdG90eXBlLmV4ZWN1dGUsIFsgdGhpcyBdLmNvbmNhdCggY3VycmllZEFyZ3MgKSApO1xufVxuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB0byBleGVjdXRlIGEgcXVlcnkuIENhbGxlZCBieSBgcnVuYCBhbmQgYGV4ZWN1dGVgLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBkcml2ZXIncyBtZXRob2QgYHJ1bmBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyc2UgV2hldGhlciB0aGUgcmVzdWx0cyBzaG91bGQgYmUgY29udmVydGVkIGFzIGluc3RhbmNlKHMpIG9mIHRoZSBtb2RlbFxuICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRzXG4gKiBvZiB0aGUgcXVlcnkuXG4gKiBAcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbihvcHRpb25zLCBwYXJzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgZnVsbE9wdGlvbnMgPSB7Z3JvdXBGb3JtYXQ6ICdyYXcnfVxuICB1dGlsLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbnMsIGtleSkge1xuICAgIGZ1bGxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV1cbiAgfSk7XG4gIGlmIChwYXJzZSA9PT0gdHJ1ZSkge1xuICAgIGZ1bGxPcHRpb25zLmN1cnNvciA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNlbGYuX21vZGVsLl9lcnJvciAhPT0gbnVsbCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChzZWxmLl9tb2RlbC5fZXJyb3IpO1xuICB9XG4gIHJldHVybiBzZWxmLl9tb2RlbC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuX2V4ZWN1dGVDYWxsYmFjayhmdWxsT3B0aW9ucywgcGFyc2UsIG9wdGlvbnMuZ3JvdXBGb3JtYXQpO1xuICB9KTtcbn1cblxuUXVlcnkucHJvdG90eXBlLl9leGVjdXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihmdWxsT3B0aW9ucywgcGFyc2UsIGdyb3VwRm9ybWF0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuX2Vycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVGhlIHBhcnRpYWwgdmFsdWUgaXMgbm90IHZhbGlkLCBzbyB0aGUgd3JpdGUgd2FzIG5vdCBleGVjdXRlZC4gVGhlIG9yaWdpbmFsIGVycm9yIHdhczpcXG5cIitzZWxmLl9lcnJvci5tZXNzYWdlKSk7XG4gIH1cblxuICByZXR1cm4gc2VsZi5fcXVlcnkucnVuKGZ1bGxPcHRpb25zKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwgJiYgcGFyc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuRG9jdW1lbnROb3RGb3VuZCgpO1xuICAgIH1cblxuICAgIC8vIEV4cGVjdCBhIHdyaXRlIHJlc3VsdCBmcm9tIFJldGhpbmtEQlxuICAgIGlmIChzZWxmLl9wb3N0VmFsaWRhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHNlbGYuX3ZhbGlkYXRlUXVlcnlSZXN1bHQocmVzdWx0KTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC5nZXRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcmVzdWx0VHlwZSA9IHJlc3VsdC5nZXRUeXBlKCk7XG4gICAgICBpZiAocmVzdWx0VHlwZSA9PT0gJ0ZlZWQnIHx8XG4gICAgICAgIHJlc3VsdFR5cGUgPT09ICdPcmRlckJ5TGltaXRGZWVkJyB8fFxuICAgICAgICByZXN1bHRUeXBlID09PSAnVW5pb25lZEZlZWQnXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZlZWQgPSBuZXcgRmVlZChyZXN1bHQsIHNlbGYuX21vZGVsKTtcbiAgICAgICAgcmV0dXJuIGZlZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHRUeXBlID09PSAnQXRvbUZlZWQnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubmV4dCgpLnRoZW4oZnVuY3Rpb24oaW5pdGlhbCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWwubmV3X3ZhbCB8fCB7fTtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fbW9kZWwuX3BhcnNlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgZG9jLl9zZXRGZWVkKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyc2UgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBzZWxmLl9tb2RlbC5fcGFyc2UocmVzdWx0LCBzZWxmLl91bmdyb3VwKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBGb3JtYXQgIT09ICdyYXcnKSB7XG4gICAgICByZXR1cm4gUXVlcnkucHJvdG90eXBlLl9jb252ZXJ0R3JvdXBlZERhdGEocmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoRXJyb3JzLmNyZWF0ZShlcnIpKTtcbiAgfSlcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fdmFsaWRhdGVVbmdyb3VwUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0KSB7XG59XG5cblF1ZXJ5LnByb3RvdHlwZS5fdmFsaWRhdGVRdWVyeVJlc3VsdCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChyZXN1bHQuZXJyb3JzID4gMCkge1xuICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcnMuSW52YWxpZFdyaXRlKFwiQW4gZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIHdyaXRlXCIsIHJlc3VsdCkpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQuY2hhbmdlcykpIHtcbiAgICBpZiAoc2VsZi5faXNQb2ludFdyaXRlKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8cmVzdWx0LmNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAoZnVuY3Rpb24oaSkge1xuICAgICAgaWYgKHJlc3VsdC5jaGFuZ2VzW2ldLm5ld192YWwgIT09IG51bGwpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLl9tb2RlbC5fcGFyc2UocmVzdWx0LmNoYW5nZXNbaV0ubmV3X3ZhbCkpO1xuICAgICAgfVxuICAgIH0pKGkpXG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmIChzZWxmLl9pc1BvaW50V3JpdGUoKSkge1xuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBwb2ludCB3cml0ZSByZXR1cm5lZCBtdWx0aXBsZSB2YWx1ZXMnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuRG9jdW1lbnROb3RGb3VuZCkge1xuICAgICAgLy8gU2hvdWxkIHdlIHNlbmQgYmFjayBudWxsP1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZXZlcnRQcm9taXNlcyA9IFtdO1xuICAgICAgdmFyIHByaW1hcnlLZXlzID0gW107XG4gICAgICB2YXIga2V5c1RvVmFsdWVzID0ge307XG4gICAgICB2YXIgciA9IHNlbGYuX21vZGVsLl90aGlua3kucjtcbiAgICAgIGZvcih2YXIgcD0wOyBwPHJlc3VsdC5jaGFuZ2VzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHByaW1hcnkga2V5IG9mIHRoZSBkb2N1bWVudCBzYXZlZCBpbiB0aGUgZGF0YWJhc2VcbiAgICAgICAgdmFyIHByaW1hcnlLZXkgPSB1dGlsLmV4dHJhY3RQcmltYXJ5S2V5KFxuICAgICAgICAgICAgcmVzdWx0LmNoYW5nZXNbcF0ub2xkX3ZhbCxcbiAgICAgICAgICAgIHJlc3VsdC5jaGFuZ2VzW3BdLm5ld192YWwsXG4gICAgICAgICAgICBzZWxmLl9tb2RlbC5fcGspXG4gICAgICAgIGlmIChwcmltYXJ5S2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJpbWFyeUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGtleXNUb1ZhbHVlc1twcmltYXJ5S2V5XSA9IHJlc3VsdC5jaGFuZ2VzW3BdLm9sZF92YWw7XG4gICAgICAgICAgcHJpbWFyeUtleXMucHVzaChwcmltYXJ5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIGRvY3VtZW50cyB3aXRoIG5vbi1zdHJpbmcgdHlwZSBwcmltYXJ5IGtleXNcbiAgICAgICAgICAvLyBvbmUgYnkgb25lLlxuICAgICAgICAgIHJldmVydFByb21pc2VzLnB1c2goci50YWJsZShzZWxmLl9tb2RlbC5nZXRUYWJsZU5hbWUoKSlcbiAgICAgICAgICAgIC5nZXQocHJpbWFyeUtleSlcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlc3VsdC5jaGFuZ2VzW3BdLm9sZF92YWwpXG4gICAgICAgICAgICAucnVuKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGxhY2UgYWxsIGRvY3VtZW50cyB3aXRoIHN0cmluZy10eXBlIHByaW1hcnkga2V5c1xuICAgICAgLy8gaW4gYSBzaW5nbGUgcmVwbGFjZSgpIG9wZXJhdGlvbi5cbiAgICAgIGlmIChwcmltYXJ5S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV2ZXJ0UHJvbWlzZXMucHVzaChcbiAgICAgICAgICByLnRhYmxlKHNlbGYuX21vZGVsLmdldFRhYmxlTmFtZSgpKS5nZXRBbGwoci5hcmdzKHByaW1hcnlLZXlzKSkucmVwbGFjZShmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiByLmV4cHIoa2V5c1RvVmFsdWVzKShkb2Moc2VsZi5fbW9kZWwuX3BrKSk7XG4gICAgICAgICAgfSkucnVuKClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJldmVydFByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgd3JpdGUgZmFpbGVkLCBhbmQgdGhlIGNoYW5nZXMgd2VyZSByZXZlcnRlZC5cIik7XG4gICAgICB9KS5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgd3JpdGUgZmFpbGVkLCBhbmQgdGhlIGF0dGVtcHQgdG8gcmV2ZXJ0IHRoZSBjaGFuZ2VzIGZhaWxlZCB3aXRoIHRoZSBlcnJvcjpcXG5cIitlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IEdST1VQRURfREFUQSByZXN1bHRzIHRvIFtncm91cDogPGdyb3VwPiwgcmVkdWN0aW9uOiA8cmVkdWN0aW9uPl1cbiAqIFRoaXMgZG9lcyB0aGUgc2FtZSBhcyB0aGUgZHJpdmVyLiBUaGUgcmVkdWN0aW9uIGlzIG5vdCBjb252ZXJ0ZWQgdG9cbiAqIGluc3RhbmNlcyBvZiB0aGUgbW9kZWwuXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fY29udmVydEdyb3VwZWREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGRhdGEpICYmIChkYXRhLiRyZXFsX3R5cGUkID09PSBcIkdST1VQRURfREFUQVwiKSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgcmVkdWN0aW9uO1xuICAgIGZvcih2YXIgaT0wOyBpPGRhdGEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBncm91cDogZGF0YS5kYXRhW2ldWzBdLFxuICAgICAgICByZWR1Y3Rpb246IGRhdGEuZGF0YVtpXVsxXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuXG4vKipcbiAqIFBlcmZvcm0gYSBqb2luIGdpdmVuIHRoZSByZWxhdGlvbnMgb24gdGhpcy5fbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0PX0gbW9kZWxUb0dldCBleHBsaWNpdCBqb2luZWQgZG9jdW1lbnRzIHRvIHJldHJpZXZlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFsbCBJbnRlcm5hbCBhcmd1bWVudCwgaWYgYG1vZGVsVG9HZXRgIGlzIHVuZGVmaW5lZCwgYGdldEFsbGAgd2lsbFxuICogYmUgc2V0IHRvIGB0cnVlYCBhbmQgYGdldEpvaW5gIHdpbGwgYmUgZ3JlZWR5IGFuZCBrZWVwIHJlY3Vyc2luZyBhcyBsb25nIGFzIGl0IGRvZXMgbm90XG4gKiBoaXQgYSBjaXJjdWxhciByZWZlcmVuY2VcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZ290TW9kZWwgSW50ZXJuYWwgYXJndW1lbnQsIHRoZSBtb2RlbCB3ZSBhcmUgYWxyZWFkeSBmZXRjaGluZy5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICovXG5RdWVyeS5wcm90b3R5cGUuZ2V0Sm9pbiA9IGZ1bmN0aW9uKG1vZGVsVG9HZXQsIGdldEFsbCwgZ290TW9kZWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYuX21vZGVsLl9nZXRNb2RlbCgpLl90aGlua3kucjtcblxuICB2YXIgbW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgdmFyIGpvaW5zID0gdGhpcy5fbW9kZWwuX2dldE1vZGVsKCkuX2pvaW5zO1xuXG4gIHZhciBnZXRBbGwgPSBtb2RlbFRvR2V0ID09PSB1bmRlZmluZWQ7XG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3QobW9kZWxUb0dldCkgPT09IGZhbHNlKSB7XG4gICAgbW9kZWxUb0dldCA9IHt9O1xuICB9XG4gIHZhciBpbm5lclF1ZXJ5O1xuXG4gIGdvdE1vZGVsID0gZ290TW9kZWwgfHwge307XG4gIGdvdE1vZGVsW21vZGVsLmdldFRhYmxlTmFtZSgpXSA9IHRydWU7XG5cbiAgdXRpbC5sb29wS2V5cyhqb2lucywgZnVuY3Rpb24oam9pbnMsIGtleSkge1xuICAgIGlmICh1dGlsLnJlY3Vyc2Uoa2V5LCBqb2lucywgbW9kZWxUb0dldCwgZ2V0QWxsLCBnb3RNb2RlbCkpIHtcbiAgICAgIHN3aXRjaCAoam9pbnNba2V5XS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2hhc09uZSc6XG4gICAgICAgIGNhc2UgJ2JlbG9uZ3NUbyc6XG4gICAgICAgICAgc2VsZi5fcXVlcnkgPSBzZWxmLl9xdWVyeS5tZXJnZShmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiByLmJyYW5jaChcbiAgICAgICAgICAgICAgZG9jLmhhc0ZpZWxkcyhqb2luc1trZXldLmxlZnRLZXkpLFxuICAgICAgICAgICAgICByLnRhYmxlKGpvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkpLmdldEFsbChkb2Moam9pbnNba2V5XS5sZWZ0S2V5KSwge2luZGV4OiBqb2luc1trZXldLnJpZ2h0S2V5fSkuY29lcmNlVG8oXCJBUlJBWVwiKS5kbyhmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpbm5lclF1ZXJ5ID0gbmV3IFF1ZXJ5KGpvaW5zW2tleV0ubW9kZWwsIHJlc3VsdC5udGgoMCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKChtb2RlbFRvR2V0W2tleV0gIT0gbnVsbCkgJiYgKHR5cGVvZiBtb2RlbFRvR2V0W2tleV0uX2FwcGx5ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgaW5uZXJRdWVyeSA9IG1vZGVsVG9HZXRba2V5XS5fYXBwbHkoaW5uZXJRdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlubmVyUXVlcnkgPSBpbm5lclF1ZXJ5LmdldEpvaW4obW9kZWxUb0dldFtrZXldLCBnZXRBbGwsIGdvdE1vZGVsKS5fcXVlcnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuYnJhbmNoKFxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvdW50KCkuZXEoMSksXG4gICAgICAgICAgICAgICAgICByLm9iamVjdChrZXksIGlubmVyUXVlcnkpLFxuICAgICAgICAgICAgICAgICAgci5icmFuY2goXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3VudCgpLmVxKDApLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgci5lcnJvcihyLmV4cHIoXCJNb3JlIHRoYW4gb25lIGVsZW1lbnQgZm91bmQgZm9yIFwiKS5hZGQoZG9jLmNvZXJjZVRvKFwiU1RSSU5HXCIpKS5hZGQoci5leHByKFwiZm9yIHRoZSBmaWVsZCBcIikuYWRkKGtleSkpKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaGFzTWFueSc6XG4gICAgICAgICAgc2VsZi5fcXVlcnkgPSBzZWxmLl9xdWVyeS5tZXJnZShmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIGlubmVyUXVlcnkgPSBuZXcgUXVlcnkoam9pbnNba2V5XS5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgci50YWJsZShqb2luc1trZXldLm1vZGVsLmdldFRhYmxlTmFtZSgpKVxuICAgICAgICAgICAgICAgICAgICAgIC5nZXRBbGwoZG9jKGpvaW5zW2tleV0ubGVmdEtleSksIHtpbmRleDogam9pbnNba2V5XS5yaWdodEtleX0pKVxuXG4gICAgICAgICAgICBpZiAoKG1vZGVsVG9HZXRba2V5XSAhPSBudWxsKSAmJiAodHlwZW9mIG1vZGVsVG9HZXRba2V5XS5fYXBwbHkgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgIGlubmVyUXVlcnkgPSBtb2RlbFRvR2V0W2tleV0uX2FwcGx5KGlubmVyUXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5uZXJRdWVyeSA9IGlubmVyUXVlcnkuZ2V0Sm9pbihtb2RlbFRvR2V0W2tleV0sIGdldEFsbCwgZ290TW9kZWwpO1xuICAgICAgICAgICAgaWYgKChtb2RlbFRvR2V0W2tleV0gPT0gbnVsbCkgfHwgKG1vZGVsVG9HZXRba2V5XS5fYXJyYXkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICBpbm5lclF1ZXJ5ID0gaW5uZXJRdWVyeS5jb2VyY2VUbyhcIkFSUkFZXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5uZXJRdWVyeSA9IGlubmVyUXVlcnkuX3F1ZXJ5O1xuXG4gICAgICAgICAgICByZXR1cm4gci5icmFuY2goXG4gICAgICAgICAgICAgIGRvYy5oYXNGaWVsZHMoam9pbnNba2V5XS5sZWZ0S2V5KSxcbiAgICAgICAgICAgICAgci5vYmplY3Qoa2V5LCBpbm5lclF1ZXJ5KSxcbiAgICAgICAgICAgICAge31cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoYXNBbmRCZWxvbmdzVG9NYW55JzpcbiAgICAgICAgICBzZWxmLl9xdWVyeSA9IHNlbGYuX3F1ZXJ5Lm1lcmdlKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgaWYgKChtb2RlbC5nZXRUYWJsZU5hbWUoKSA9PT0gam9pbnNba2V5XS5tb2RlbC5nZXRUYWJsZU5hbWUoKSkgJiYgKGpvaW5zW2tleV0ubGVmdEtleSA9PT0gam9pbnNba2V5XS5yaWdodEtleSkpIHtcbiAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgbW9kZWwgaXMgbGlua2VkIHdpdGggaXRzZWxmIG9uIHRoZSBzYW1lIGtleVxuXG4gICAgICAgICAgICAgIGlubmVyUXVlcnkgPSByLnRhYmxlKGpvaW5zW2tleV0ubGluaykuZ2V0QWxsKGRvYyhqb2luc1trZXldLmxlZnRLZXkpLCB7aW5kZXg6IGpvaW5zW2tleV0ubGVmdEtleStcIl9cIitqb2luc1trZXldLmxlZnRLZXl9KS5jb25jYXRNYXAoZnVuY3Rpb24obGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRhYmxlKGpvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkpLmdldEFsbChcbiAgICAgICAgICAgICAgICAgIHIuYnJhbmNoKFxuICAgICAgICAgICAgICAgICAgICBkb2Moam9pbnNba2V5XS5sZWZ0S2V5KS5lcShsaW5rKGpvaW5zW2tleV0ubGVmdEtleStcIl9cIitqb2luc1trZXldLmxlZnRLZXkpLm50aCgwKSksXG4gICAgICAgICAgICAgICAgICAgIGxpbmsoam9pbnNba2V5XS5sZWZ0S2V5K1wiX1wiK2pvaW5zW2tleV0ubGVmdEtleSkubnRoKDEpLFxuICAgICAgICAgICAgICAgICAgICBsaW5rKGpvaW5zW2tleV0ubGVmdEtleStcIl9cIitqb2luc1trZXldLmxlZnRLZXkpLm50aCgwKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICwge2luZGV4OiBqb2luc1trZXldLnJpZ2h0S2V5fSlcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKChtb2RlbFRvR2V0W2tleV0gIT0gbnVsbCkgJiYgKHR5cGVvZiBtb2RlbFRvR2V0W2tleV0uX2FwcGx5ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIGlubmVyUXVlcnkgPSBtb2RlbFRvR2V0W2tleV0uX2FwcGx5KGlubmVyUXVlcnkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKChtb2RlbFRvR2V0W2tleV0gPT0gbnVsbCkgfHwgKG1vZGVsVG9HZXRba2V5XS5fYXJyYXkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlubmVyUXVlcnkgPSBpbm5lclF1ZXJ5LmNvZXJjZVRvKFwiQVJSQVlcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gci5icmFuY2goXG4gICAgICAgICAgICAgICAgZG9jLmhhc0ZpZWxkcyhqb2luc1trZXldLmxlZnRLZXkpLFxuICAgICAgICAgICAgICAgIHIub2JqZWN0KGtleSwgbmV3IFF1ZXJ5KGpvaW5zW2tleV0ubW9kZWwsIGlubmVyUXVlcnkpLmdldEpvaW4obW9kZWxUb0dldFtrZXldLCBnZXRBbGwsIGdvdE1vZGVsKS5fcXVlcnkpLFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpbm5lclF1ZXJ5ID0gci50YWJsZShqb2luc1trZXldLmxpbmspLmdldEFsbChkb2Moam9pbnNba2V5XS5sZWZ0S2V5KSwge2luZGV4OiBtb2RlbC5nZXRUYWJsZU5hbWUoKStcIl9cIitqb2luc1trZXldLmxlZnRLZXl9KS5jb25jYXRNYXAoZnVuY3Rpb24obGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRhYmxlKGpvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkpLmdldEFsbChsaW5rKGpvaW5zW2tleV0ubW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNba2V5XS5yaWdodEtleSksIHtpbmRleDogam9pbnNba2V5XS5yaWdodEtleX0pXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICgobW9kZWxUb0dldFtrZXldICE9IG51bGwpICYmICh0eXBlb2YgbW9kZWxUb0dldFtrZXldLl9hcHBseSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBpbm5lclF1ZXJ5ID0gbW9kZWxUb0dldFtrZXldLl9hcHBseShpbm5lclF1ZXJ5KVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKChtb2RlbFRvR2V0W2tleV0gPT0gbnVsbCkgfHwgKG1vZGVsVG9HZXRba2V5XS5fYXJyYXkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlubmVyUXVlcnkgPSBpbm5lclF1ZXJ5LmNvZXJjZVRvKFwiQVJSQVlcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gci5icmFuY2goXG4gICAgICAgICAgICAgICAgZG9jLmhhc0ZpZWxkcyhqb2luc1trZXldLmxlZnRLZXkpLFxuICAgICAgICAgICAgICAgIHIub2JqZWN0KGtleSxcbiAgICAgICAgICAgICAgICAgIG5ldyBRdWVyeShqb2luc1trZXldLm1vZGVsLCBpbm5lclF1ZXJ5KS5nZXRKb2luKG1vZGVsVG9HZXRba2V5XSwgZ2V0QWxsLCBnb3RNb2RlbCkuX3F1ZXJ5KSxcbiAgICAgICAgICAgICAgICB7fVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuLyoqXG4gKiBBZGQgYSByZWxhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBvZiB0aGUgam9pbmVkIGRvY3VtZW50KHMpXG4gKiBAcGFyYW0ge09iamVjdH0gam9pbmVkRG9jdW1lbnQgQW4gb2JqZWN0IHdpdGggdGhlIHByaW1hcnkga2V5IGRlZmluZWQgb3IgdGhlIHJlbGF0ZWQga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICpcbiAqIGhhc09uZSwgcHJpbWFyeSBrZXkgcmVxdWlyZWRcbiAqIFVzZXIuZ2V0KDEpLmFkZFJlbGF0aW9uKFwiYWNjb3VudFwiLCB7aWQ6IDIsIHNvbGQ6IDIxMzJ9KVxuICogVGhlIHByb21pc2UgcmVzb2x2ZWQgdGhlIGRvY3VtZW50IG9uIHdoaWNoIGFkZFJlbGF0aW9uIGlzIGNhbGxlZFxuICpcbiAqIGhhc01hbnksIHByaW1hcnkga2V5IHJlcXVpcmVkXG4gKiBVc2VyLmdldCgxKS5hZGRSZWxhdGlvbihcImFjY291bnRzXCIsIHtpZDogMiwgc29sZDogMjEzMn0pXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlZCB0aGUgdXBkYXRlZCBqb2luZWQgZG9jdW1lbnRcbiAqXG4gKiBiZWxvbmdzVG8sIHJpZ2h0IGpvaW5lZCBrZXkgT1IgcHJpbWFyeSBrZXkgcmVxdWlyZWRcbiAqIFVzZXIuZ2V0KDEpLmFkZFJlbGF0aW9uKFwiYWNjb3VudFwiLCB7aWQ6IDIsIHNvbGQ6IDIxMzJ9KVxuICogVGhlIHByb21pc2UgcmVzb2x2ZWQgdGhlIGRvY3VtZW50IG9uIHdoaWNoIGFkZFJlbGF0aW9uIGlzIGNhbGxlZFxuICpcbiAqIGhhc0FuZEJlbG9uZ3NUb01hbnksIHJpZ2h0IGpvaW5lZCBrZXkgcmVxdWlyZWRcbiAqIFVzZXIuZ2V0KDEpLmFkZFJlbGF0aW9uKFwiYWNjb3VudHNcIiwge2lkOiAyLCBzb2xkOiAyMTMyfSlcbiAqIFRoZSBwcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5hZGRSZWxhdGlvbiA9IGZ1bmN0aW9uKGZpZWxkLCBqb2luZWREb2N1bWVudCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBtb2RlbCA9IHNlbGYuX21vZGVsO1xuICB2YXIgam9pbnMgPSBzZWxmLl9tb2RlbC5fZ2V0TW9kZWwoKS5fam9pbnM7XG4gIHZhciBqb2luZWRNb2RlbCA9IGpvaW5zW2ZpZWxkXS5tb2RlbDtcbiAgdmFyIHIgPSBzZWxmLl9tb2RlbC5fdGhpbmt5LnI7XG5cbiAgc3dpdGNoIChqb2luc1tmaWVsZF0udHlwZSkge1xuICAgIGNhc2UgJ2hhc09uZSc6XG4gICAgY2FzZSAnaGFzTWFueSc6XG4gICAgICBpZiAoam9pbmVkRG9jdW1lbnRbam9pbmVkTW9kZWwuX3BrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkobW9kZWwsIHNlbGYsIHt9LFxuICAgICAgICAgICAgbmV3IEVycm9yKCdQcmltYXJ5IGtleSBmb3IgdGhlIGpvaW5lZCBkb2N1bWVudCBub3QgZm91bmQgZm9yIGEgYGhhc09uZS9oYXNNYW55YCByZWxhdGlvbi4nKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZVZhbHVlID0ge307XG4gICAgICB1cGRhdGVWYWx1ZVtqb2luc1tmaWVsZF0ucmlnaHRLZXldID0gc2VsZi5fcXVlcnkoam9pbnNbZmllbGRdLmxlZnRLZXkpO1xuICAgICAgcmV0dXJuIGpvaW5lZE1vZGVsLmdldChqb2luZWREb2N1bWVudFtqb2luZWRNb2RlbC5fcGtdKS51cGRhdGUodXBkYXRlVmFsdWUsIHtub25BdG9taWM6IHRydWV9KS5ydW4oKVxuICAgIGNhc2UgJ2JlbG9uZ3NUbyc6XG4gICAgICB2YXIgdXBkYXRlVmFsdWUgPSB7fTtcbiAgICAgIGlmIChqb2luZWREb2N1bWVudFtqb2luc1tmaWVsZF0ucmlnaHRLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpvaW5lZERvY3VtZW50W2pvaW5lZE1vZGVsLl9wa10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUXVlcnkobW9kZWwsIHNlbGYsIHt9LFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ1RoZSBwcmltYXJ5IGtleSBvciB0aGUgam9pbmVkIGtleSBtdXN0IGJlIGRlZmluZWQgaW4gdGhlIGpvaW5lZCBkb2N1bWVudCBmb3IgYSBgYmVsb25nc1RvYCByZWxhdGlvbi4nKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlVmFsdWVbam9pbnNbZmllbGRdLmxlZnRLZXldID0gam9pbmVkTW9kZWwuZ2V0KGpvaW5lZERvY3VtZW50W2pvaW5lZE1vZGVsLl9wa10pLmJyYWNrZXQoam9pbnNbZmllbGRdLnJpZ2h0S2V5KS5fcXVlcnk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdXBkYXRlVmFsdWVbam9pbnNbZmllbGRdLmxlZnRLZXldID0gam9pbmVkRG9jdW1lbnRbam9pbnNbZmllbGRdLnJpZ2h0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnVwZGF0ZSh1cGRhdGVWYWx1ZSwge25vbkF0b21pYzogdHJ1ZX0pLnJ1bigpO1xuICAgIGNhc2UgJ2hhc0FuZEJlbG9uZ3NUb01hbnknOlxuICAgICAgdmFyIGxpbmtNb2RlbCA9IGpvaW5zW2ZpZWxkXS5saW5rTW9kZWw7XG4gICAgICB2YXIgbGlua1ZhbHVlO1xuICAgICAgdmFyIGxpbms7XG4gICAgICBpZiAoam9pbmVkRG9jdW1lbnRbam9pbnNbZmllbGRdLnJpZ2h0S2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChqb2luZWREb2N1bWVudFtqb2luZWRNb2RlbC5fcGtdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KG1vZGVsLCBzZWxmLCB7fSxcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdUaGUgcHJpbWFyeSBrZXkgb3IgdGhlIGpvaW5lZCBrZXkgbXVzdCBiZSBkZWZpbmVkIGluIHRoZSBqb2luZWQgZG9jdW1lbnQgZm9yIGEgYGhhc0FuZEJlbG9uZ3NUb01hbnlgIHJlbGF0aW9uLicpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rID0gam9pbmVkTW9kZWwuZ2V0KGpvaW5lZERvY3VtZW50W2pvaW5lZE1vZGVsLl9wa10pLmJyYWNrZXQoam9pbnNbZmllbGRdLnJpZ2h0S2V5KS5fcXVlcnlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsaW5rID0gci5leHByKGpvaW5lZERvY3VtZW50W2pvaW5zW2ZpZWxkXS5yaWdodEtleV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG1vZGVsLmdldFRhYmxlTmFtZSgpID09PSBqb2luZWRNb2RlbC5nZXRUYWJsZU5hbWUoKSlcbiAgICAgICAgICAmJiAoam9pbnNbZmllbGRdLmxlZnRLZXkgPT09IGpvaW5zW2ZpZWxkXS5yaWdodEtleSkpIHtcbiAgICAgICAgbGlua1ZhbHVlID0gc2VsZi5fcXVlcnkoam9pbnNbZmllbGRdLmxlZnRLZXkpLmRvKGZ1bmN0aW9uKGxlZnRLZXkpIHtcbiAgICAgICAgICByZXR1cm4gbGluay5kbyhmdW5jdGlvbihyaWdodEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHIuYnJhbmNoKFxuICAgICAgICAgICAgICAgIHJpZ2h0S2V5Lmx0KGxlZnRLZXkpLFxuICAgICAgICAgICAgICAgIHIub2JqZWN0KFxuICAgICAgICAgICAgICAgICAgJ2lkJywgcmlnaHRLZXkuYWRkKCdfJykuYWRkKGxlZnRLZXkpLFxuICAgICAgICAgICAgICAgICAgam9pbnNbZmllbGRdLmxlZnRLZXkrXCJfXCIram9pbnNbZmllbGRdLmxlZnRLZXksIFtsZWZ0S2V5LCByaWdodEtleV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHIub2JqZWN0KFxuICAgICAgICAgICAgICAgICAgJ2lkJywgbGVmdEtleS5hZGQoJ18nKS5hZGQocmlnaHRLZXkpLFxuICAgICAgICAgICAgICAgICAgam9pbnNbZmllbGRdLmxlZnRLZXkrXCJfXCIram9pbnNbZmllbGRdLmxlZnRLZXksIFtsZWZ0S2V5LCByaWdodEtleV1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxpbmtWYWx1ZSA9IHNlbGYuX3F1ZXJ5KGpvaW5zW2ZpZWxkXS5sZWZ0S2V5KS5kbyhmdW5jdGlvbihsZWZ0S2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmsuZG8oZnVuY3Rpb24ocmlnaHRLZXkpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbC5nZXRUYWJsZU5hbWUoKSA8IGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByLm9iamVjdChcbiAgICAgICAgICAgICAgICAnaWQnLCBsZWZ0S2V5LmFkZCgnXycpLmFkZChyaWdodEtleSksXG4gICAgICAgICAgICAgICAgbW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNbZmllbGRdLmxlZnRLZXksIGxlZnRLZXksXG4gICAgICAgICAgICAgICAgam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNbZmllbGRdLnJpZ2h0S2V5LHJpZ2h0S2V5IFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbC5nZXRUYWJsZU5hbWUoKSA+IGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByLm9iamVjdChcbiAgICAgICAgICAgICAgICAnaWQnLCByaWdodEtleS5hZGQoJ18nKS5hZGQobGVmdEtleSksXG4gICAgICAgICAgICAgICAgbW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNbZmllbGRdLmxlZnRLZXksIGxlZnRLZXksXG4gICAgICAgICAgICAgICAgam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNbZmllbGRdLnJpZ2h0S2V5LHJpZ2h0S2V5IFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIuYnJhbmNoKFxuICAgICAgICAgICAgICAgIHJpZ2h0S2V5Lmx0KGxlZnRLZXkpLFxuICAgICAgICAgICAgICAgIHIub2JqZWN0KFxuICAgICAgICAgICAgICAgICAgJ2lkJywgbGVmdEtleS5hZGQoJ18nKS5hZGQocmlnaHRLZXkpLFxuICAgICAgICAgICAgICAgICAgbW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNbZmllbGRdLmxlZnRLZXksIGxlZnRLZXksXG4gICAgICAgICAgICAgICAgICBqb2luZWRNb2RlbC5nZXRUYWJsZU5hbWUoKStcIl9cIitqb2luc1tmaWVsZF0ucmlnaHRLZXkscmlnaHRLZXkgXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByLm9iamVjdChcbiAgICAgICAgICAgICAgICAgICdpZCcsIHJpZ2h0S2V5LmFkZCgnXycpLmFkZChsZWZ0S2V5KSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsLmdldFRhYmxlTmFtZSgpK1wiX1wiK2pvaW5zW2ZpZWxkXS5sZWZ0S2V5LCBsZWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkrXCJfXCIram9pbnNbZmllbGRdLnJpZ2h0S2V5LHJpZ2h0S2V5IFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmtNb2RlbC5pbnNlcnQobGlua1ZhbHVlLCB7Y29uZmxpY3Q6IFwicmVwbGFjZVwiLCByZXR1cm5DaGFuZ2VzOiAnYWx3YXlzJ30pLmRvKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gci5icmFuY2goXG4gICAgICAgICAgICByZXN1bHQoJ2Vycm9ycycpLmVxKDApLFxuICAgICAgICAgICAgdHJ1ZSwgLy8gbm90IHJlbGV2YW50IHZhbHVlXG4gICAgICAgICAgICByLmVycm9yKHJlc3VsdCgnZXJyb3JzJykpXG4gICAgICAgIClcbiAgICAgIH0pLmV4ZWN1dGUoKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IFF1ZXJ5KG1vZGVsLCBzZWxmLCB7fSxcbiAgICAgICAgICBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBmaWVsZCBgJytmaWVsZCsnYCBkb2VzIG5vdCBzdG9yZSBqb2luZWQgZG9jdW1lbnRzLicpXG4gICAgICApLnJ1bigpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIHByb3ZpZGVkIHJlbGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG9mIHRoZSBqb2luZWQgZG9jdW1lbnQocykgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge0FycmF5fSBqb2luZWREb2N1bWVudCBUaGUgZG9jdW1lbnQgd2l0aCB3aG8gdGhlIHJlbGF0aW9uIHNob3VsZCBiZSByZW1vdmVkXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG4vL1RPRE8gU3VwcG9ydCBhbiBhcnJheSBvZiBqb2luZWREb2N1bWVudHM/XG5RdWVyeS5wcm90b3R5cGUucmVtb3ZlUmVsYXRpb24gPSBmdW5jdGlvbihmaWVsZCwgam9pbmVkRG9jdW1lbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbW9kZWwgPSBzZWxmLl9tb2RlbDtcbiAgdmFyIGpvaW5zID0gc2VsZi5fbW9kZWwuX2dldE1vZGVsKCkuX2pvaW5zO1xuICB2YXIgam9pbmVkTW9kZWwgPSBqb2luc1tmaWVsZF0ubW9kZWw7XG4gIHZhciByID0gc2VsZi5fbW9kZWwuX3RoaW5reS5yO1xuXG4gIHZhciBxdWVyeTtcbiAgc3dpdGNoIChqb2luc1tmaWVsZF0udHlwZSkge1xuICAgIGNhc2UgJ2hhc09uZSc6XG4gICAgICBxdWVyeSA9IGpvaW5lZE1vZGVsLmdldEFsbChzZWxmLl9xdWVyeShqb2luc1tmaWVsZF0ubGVmdEtleSksIHtpbmRleDogam9pbnNbZmllbGRdLnJpZ2h0S2V5fSkucmVwbGFjZShmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdy53aXRob3V0KGpvaW5zW2ZpZWxkXS5yaWdodEtleSlcbiAgICAgIH0pO1xuICAgICAgcXVlcnkuc2V0UG9zdFZhbGlkYXRpb24oKTtcbiAgICAgIHF1ZXJ5LnNldFBvaW50V3JpdGUoKTtcbiAgICAgIHJldHVybiBxdWVyeTtcbiAgICBjYXNlICdoYXNNYW55JzpcbiAgICAgIGlmIChqb2luZWREb2N1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJ5ID0gam9pbmVkTW9kZWwuZ2V0QWxsKHNlbGYuX3F1ZXJ5KGpvaW5zW2ZpZWxkXS5sZWZ0S2V5KSwge2luZGV4OiBqb2luc1tmaWVsZF0ucmlnaHRLZXl9KS5yZXBsYWNlKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgIHJldHVybiByb3cud2l0aG91dChqb2luc1tmaWVsZF0ucmlnaHRLZXkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcXVlcnkgPSBqb2luZWRNb2RlbC5nZXRBbGwoci5leHByKGpvaW5lZERvY3VtZW50KShqb2luZWRNb2RlbC5fcGspKS5yZXBsYWNlKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgIHJldHVybiByb3cud2l0aG91dChqb2luc1tmaWVsZF0ucmlnaHRLZXkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBxdWVyeS5zZXRQb3N0VmFsaWRhdGlvbigpO1xuICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIGNhc2UgJ2JlbG9uZ3NUbyc6XG4gICAgICBxdWVyeSA9IHNlbGYucmVwbGFjZShmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdy53aXRob3V0KGpvaW5zW2ZpZWxkXS5sZWZ0S2V5KVxuICAgICAgfSlcbiAgICAgIHF1ZXJ5LnNldFBvc3RWYWxpZGF0aW9uKCk7XG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgY2FzZSAnaGFzQW5kQmVsb25nc1RvTWFueSc6XG4gICAgICB2YXIgbGlua01vZGVsID0gam9pbnNbZmllbGRdLmxpbmtNb2RlbDtcbiAgICAgIGlmIChqb2luZWREb2N1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJ5ID0gc2VsZi5fcXVlcnkoam9pbnNbZmllbGRdLmxlZnRLZXkpLmRvKGZ1bmN0aW9uKGxlZnRLZXkpIHtcbiAgICAgICAgICAvLyByYW5nZSBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LCBzbyBrZXlzIGlzIGFuIG9iamVjdCBhbmQgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBlbXB0eSBzZXF1ZW5jZXNcbiAgICAgICAgICBpZiAoKG1vZGVsLmdldFRhYmxlTmFtZSgpID09PSBqb2luZWRNb2RlbC5nZXRUYWJsZU5hbWUoKSlcbiAgICAgICAgICAgICAgJiYgKGpvaW5zW2ZpZWxkXS5sZWZ0S2V5ID09PSBqb2luc1tmaWVsZF0ucmlnaHRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlua01vZGVsLmdldEFsbChsZWZ0S2V5LCB7aW5kZXg6IGpvaW5zW2ZpZWxkXS5sZWZ0S2V5KydfJytqb2luc1tmaWVsZF0ubGVmdEtleX0pLmRlbGV0ZSgpLl9xdWVyeVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWwuZ2V0QWxsKGxlZnRLZXksIHtpbmRleDogbW9kZWwuZ2V0VGFibGVOYW1lKCkrJ18nK2pvaW5zW2ZpZWxkXS5sZWZ0S2V5fSkuZGVsZXRlKCkuX3F1ZXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9KS5kbyhmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gci5icmFuY2goXG4gICAgICAgICAgICAgIHJlc3VsdCgnZXJyb3JzJykuZXEoMCksXG4gICAgICAgICAgICAgIHRydWUsIC8vIG5vdCByZWxldmFudCB2YWx1ZVxuICAgICAgICAgICAgICByLmVycm9yKHJlc3VsdCgnZXJyb3JzJykpXG4gICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoam9pbmVkRG9jdW1lbnRbam9pbnNbZmllbGRdLnJpZ2h0S2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGpvaW5lZERvY3VtZW50W2pvaW5lZE1vZGVsLl9wa10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShtb2RlbCwgc2VsZiwge30sXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCdUaGUgcHJpbWFyeSBrZXkgb3IgdGhlIGpvaW5lZCBrZXkgbXVzdCBiZSBkZWZpbmVkIGluIHRoZSBqb2luZWQgZG9jdW1lbnQgZm9yIGEgYGhhc0FuZEJlbG9uZ3NUb01hbnlgIHJlbGF0aW9uLicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgobW9kZWwuZ2V0VGFibGVOYW1lKCkgPT09IGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKVxuICAgICAgICAgICAgICAmJiAoam9pbnNbZmllbGRdLmxlZnRLZXkgPT09IGpvaW5zW2ZpZWxkXS5yaWdodEtleSkpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gc2VsZi5fcXVlcnkoam9pbnNbZmllbGRdLmxlZnRLZXkpLmRvKGZ1bmN0aW9uKGxlZnRLZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGpvaW5lZE1vZGVsLmdldChqb2luZWREb2N1bWVudFtqb2luZWRNb2RlbC5fcGtdKS5icmFja2V0KGpvaW5zW2ZpZWxkXS5yaWdodEtleSkuZG8oZnVuY3Rpb24ocmlnaHRLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuZ2V0VGFibGVOYW1lKCkgPCBqb2luZWRNb2RlbC5nZXRUYWJsZU5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtNb2RlbC5nZXRBbGwobGVmdEtleS5hZGQoJ18nKS5hZGQocmlnaHRLZXkpKS5kZWxldGUoKS5fcXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsLmdldFRhYmxlTmFtZSgpID4gam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWwuZ2V0QWxsKHJpZ2h0S2V5LmFkZCgnXycpLmFkZChsZWZ0S2V5KSkuZGVsZXRlKCkuX3F1ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByLmJyYW5jaChcbiAgICAgICAgICAgICAgICAgICAgbGVmdEtleS5sdChyaWdodEtleSksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtNb2RlbC5nZXRBbGwobGVmdEtleS5hZGQoJ18nKS5hZGQocmlnaHRLZXkpKS5kZWxldGUoKS5fcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtNb2RlbC5nZXRBbGwocmlnaHRLZXkuYWRkKCdfJykuYWRkKGxlZnRLZXkpKS5kZWxldGUoKS5fcXVlcnlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWVyeSA9IHNlbGYuX3F1ZXJ5KGpvaW5zW2ZpZWxkXS5sZWZ0S2V5KS5kbyhmdW5jdGlvbihsZWZ0S2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBqb2luZWRNb2RlbC5nZXQoam9pbmVkRG9jdW1lbnRbam9pbmVkTW9kZWwuX3BrXSkuYnJhY2tldChqb2luc1tmaWVsZF0ucmlnaHRLZXkpLmRvKGZ1bmN0aW9uKHJpZ2h0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmdldFRhYmxlTmFtZSgpIDwgam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWwuZ2V0QWxsKGxlZnRLZXkuYWRkKCdfJykuYWRkKHJpZ2h0S2V5KSkuZGVsZXRlKCkuX3F1ZXJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsLmdldFRhYmxlTmFtZSgpID4gam9pbmVkTW9kZWwuZ2V0VGFibGVOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWwuZ2V0QWxsKHJpZ2h0S2V5LmFkZCgnXycpLmFkZChsZWZ0S2V5KSkuZGVsZXRlKCkuX3F1ZXJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHIuYnJhbmNoKFxuICAgICAgICAgICAgICAgICAgICBsZWZ0S2V5Lmx0KHJpZ2h0S2V5KSxcbiAgICAgICAgICAgICAgICAgICAgbGlua01vZGVsLmdldEFsbChsZWZ0S2V5LmFkZCgnXycpLmFkZChyaWdodEtleSkpLmRlbGV0ZSgpLl9xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgbGlua01vZGVsLmdldEFsbChyaWdodEtleS5hZGQoJ18nKS5hZGQobGVmdEtleSkpLmRlbGV0ZSgpLl9xdWVyeVxuICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHF1ZXJ5ID0gc2VsZi5fcXVlcnkoam9pbnNbZmllbGRdLmxlZnRLZXkpLmRvKGZ1bmN0aW9uKGxlZnRLZXkpIHtcbiAgICAgICAgICAgIHZhciByaWdodEtleSA9IHIuZXhwcihqb2luZWREb2N1bWVudFtqb2luc1tmaWVsZF0ucmlnaHRLZXldKTtcbiAgICAgICAgICAgIGlmIChtb2RlbC5nZXRUYWJsZU5hbWUoKSA8IGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWwuZ2V0QWxsKGxlZnRLZXkuYWRkKCdfJykuYWRkKHJpZ2h0S2V5KSkuZGVsZXRlKCkuX3F1ZXJ5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbC5nZXRUYWJsZU5hbWUoKSA+IGpvaW5lZE1vZGVsLmdldFRhYmxlTmFtZSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaW5rTW9kZWwuZ2V0QWxsKHJpZ2h0S2V5LmFkZCgnXycpLmFkZChsZWZ0S2V5KSkuZGVsZXRlKCkuX3F1ZXJ5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIuYnJhbmNoKFxuICAgICAgICAgICAgICAgIGxlZnRLZXkubHQocmlnaHRLZXkpLFxuICAgICAgICAgICAgICAgIGxpbmtNb2RlbC5nZXRBbGwobGVmdEtleS5hZGQoJ18nKS5hZGQocmlnaHRLZXkpKS5kZWxldGUoKS5fcXVlcnksXG4gICAgICAgICAgICAgICAgbGlua01vZGVsLmdldEFsbChyaWdodEtleS5hZGQoJ18nKS5hZGQobGVmdEtleSkpLmRlbGV0ZSgpLl9xdWVyeVxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgUXVlcnkobW9kZWwsIHNlbGYsIHt9LFxuICAgICAgICAgIG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGZpZWxkIGAnK2ZpZWxkKydgIGRvZXMgbm90IHN0b3JlIGpvaW5lZCBkb2N1bWVudHMuJylcbiAgICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogSW1wb3J0IGFsbCB0aGUgbWV0aG9kcyBmcm9tIHJldGhpbmtkYmRhc2gsIGV4cGVjdCB0aGUgcHJpdmF0ZSBvbmUgKHRoZSBvbmVcbiAqIHN0YXJ0aW5nIHdpdGggYW4gdW5kZXJzY29yZSkuXG4gKiBTb21lIG1ldGhvZCBhcmUgc2xpZ2h0bHkgY2hhbmdlZDogYGdldGAsIGB1cGRhdGVgLCBgcmVwbGFjZWAuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIFRlcm0gPSByZXF1aXJlKCdyZXRoaW5rZGJkYXNoJykoe3Bvb2w6IGZhbHNlfSkuZXhwcigxKS5fX3Byb3RvX187XG4gIHV0aWwubG9vcEtleXMoVGVybSwgZnVuY3Rpb24oVGVybSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJ3J1bicgfHwga2V5WzBdID09PSAnXycpIHJldHVybjtcbiAgICAvLyBOb3RlOiBXZSBzdXBwb3NlIHRoYXQgbm8gbWV0aG9kIGhhcyBhbiBlbXB0eSBuYW1lXG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgIC8vIGBnZXRgIGluIHRoaW5reSByZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBkb2N1bWVudCBpcyBub3QgZm91bmQuXG4gICAgICAgIC8vIFRoZSBkcml2ZXIgY3VycmVudGx5IGp1c3QgcmV0dXJucyBgbnVsbGAuXG4gICAgICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBRdWVyeS5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLl9tb2RlbCwgdGhpcy5fcXVlcnlba2V5XS5hcHBseSh0aGlzLl9xdWVyeSwgYXJndW1lbnRzKSkuZGVmYXVsdCh0aGlzLl9yLmVycm9yKG5ldyBFcnJvcnMuRG9jdW1lbnROb3RGb3VuZCgpLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKGtleSk7XG4gICAgICAgIC8vIENvcHkgaXQgaW4gYF9nZXRgIHdpdGhvdXQgYGRlZmF1bHRgLlxuICAgICAgICAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgUXVlcnkucHJvdG90eXBlWydfZ2V0J10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBxdWVyeSB0byBsZXQgcGVvcGxlIGZvcmsgaXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5fbW9kZWwsIHRoaXMuX3F1ZXJ5W2tleV0uYXBwbHkodGhpcy5fcXVlcnksIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoa2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgIC8vIGB1cGRhdGVgIGFuZCBgcmVwbGFjZWAgY2FuIGJlIHVzZWQuIEEgcGFydGlhbCB2YWxpZGF0aW9uIGlzIHBlcmZvcm1lZCBiZWZvcmVcbiAgICAgICAgLy8gc2VuZGluZyB0aGUgcXVlcnksIGFuZCBhIGZ1bGwgdmFsaWRhdGlvbiBpcyBwZXJmb3JtZWQgYWZ0ZXIgdGhlIHF1ZXJ5LiBJZiB0aGVcbiAgICAgICAgLy8gdmFsaWRhdGlvbiBmYWlscywgdGhlIGRvY3VtZW50KHMpIHdpbGwgYmUgcmV2ZXJ0ZWQuXG4gICAgICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBRdWVyeS5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMucmV0dXJuQ2hhbmdlcyA9ICdhbHdheXMnO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHV0aWwudHJ5Q2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hVXRpbC52YWxpZGF0ZSh2YWx1ZSwgc2VsZi5fbW9kZWwuX3NjaGVtYSwgJycsIHtlbmZvcmNlX21pc3Npbmc6IGZhbHNlfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLl9tb2RlbCwgdGhpcy5fcXVlcnlba2V5XS5jYWxsKHRoaXMuX3F1ZXJ5LCB2YWx1ZSwgb3B0aW9ucyksIHtwb3N0VmFsaWRhdGlvbjogdHJ1ZX0sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKGtleSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjaGFuZ2VzJzpcbiAgICAgICAgKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIFF1ZXJ5LnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGBnZXQoKS5jaGFuZ2VzKClgIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBkZWZhdWx0KHIuZXJycm9yKC4uLikpXG4gICAgICAgICAgICAvLyBUT0RPOiBEbyBub3QgaGFyZGNvZGUgdGhpcz9cbiAgICAgICAgICAgIGlmICgodHlwZW9mIHRoaXMuX3F1ZXJ5ID09PSAnZnVuY3Rpb24nKSAmJiAodGhpcy5fcXVlcnkuX3F1ZXJ5WzBdID09PSA5MikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcXVlcnkuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkuX3F1ZXJ5WzFdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLl9tb2RlbCwgdGhpcy5fcXVlcnlba2V5XS5hcHBseSh0aGlzLl9xdWVyeSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KShrZXkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndGhlbic6XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICBjYXNlICdjYXRjaCc6XG4gICAgICBjYXNlICdmaW5hbGx5JzpcbiAgICAgICAgKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIFF1ZXJ5LnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucnVuKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVtrZXldLmFwcGx5KHByb21pc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KShrZXkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndW5ncm91cCc6XG4gICAgICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBRdWVyeS5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLl9tb2RlbCwgdGhpcy5fcXVlcnlba2V5XS5hcHBseSh0aGlzLl9xdWVyeSwgYXJndW1lbnRzKSwge3VuZ3JvdXA6IHRydWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKGtleSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgUXVlcnkucHJvdG90eXBlW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBxdWVyeSB0byBsZXQgcGVvcGxlIGZvcmsgaXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5fbW9kZWwsIHRoaXMuX3F1ZXJ5W2tleV0uYXBwbHkodGhpcy5fcXVlcnksIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoa2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH0pO1xufSkoKTtcblxuUXVlcnkucHJvdG90eXBlLl9pc1BvaW50V3JpdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BvaW50V3JpdGUgfHwgKEFycmF5LmlzQXJyYXkodGhpcy5fcXVlcnkuX3F1ZXJ5KSAmJlxuICAgICAgKHRoaXMuX3F1ZXJ5Ll9xdWVyeS5sZW5ndGggPiAxKSAmJlxuICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLl9xdWVyeS5fcXVlcnlbMV0pICYmXG4gICAgICAodGhpcy5fcXVlcnkuX3F1ZXJ5WzFdLmxlbmd0aCA+IDApICYmXG4gICAgICBBcnJheS5pc0FycmF5KHRoaXMuX3F1ZXJ5Ll9xdWVyeVsxXVswXSkgJiZcbiAgICAgICh0aGlzLl9xdWVyeS5fcXVlcnlbMV1bMF0ubGVuZ3RoID4gMSkgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5fcXVlcnkuX3F1ZXJ5WzFdWzBdWzFdKSAmJlxuICAgICAgKHRoaXMuX3F1ZXJ5Ll9xdWVyeVsxXVswXVsxXS5sZW5ndGggPiAwKSAmJlxuICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLl9xdWVyeS5fcXVlcnlbMV1bMF1bMV1bMF0pICYmXG4gICAgICAodGhpcy5fcXVlcnkuX3F1ZXJ5WzFdWzBdWzFdWzBdWzBdID09PSAxNikpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgcXVlcnkgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUXVlcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9xdWVyeS50b1N0cmluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIiwidmFyIGFycmF5UHJlZml4ID0gXCJfX2FycmF5XCJcbm1vZHVsZS5leHBvcnRzLmFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXg7XG5cbnZhciB1dGlsID0gcmVxdWlyZShfX2Rpcm5hbWUrJy91dGlsLmpzJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoX19kaXJuYW1lKycvdHlwZS9pbmRleC5qcycpO1xudmFyIEVycm9ycyA9IHJlcXVpcmUoX19kaXJuYW1lKycvZXJyb3JzLmpzJyk7XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVWaXJ0dWFsKGRvYywgZGVmYXVsdEZpZWxkLCBvcmlnaW5hbERvYywgdmlydHVhbCkge1xuICB2YXIgcGF0aCA9IGRlZmF1bHRGaWVsZC5wYXRoO1xuICB2YXIgdmFsdWUgPSBkZWZhdWx0RmllbGQudmFsdWU7XG4gIHZhciBmaWVsZCA9IGRvYztcblxuICB2YXIga2VlcEdvaW5nID0gdHJ1ZTtcbiAgdmFyIHZpcnR1YWxWYWx1ZSA9IHZpcnR1YWw7XG5cbiAgZm9yKHZhciBqPTA7IGo8cGF0aC5sZW5ndGgtMTsgaisrKSB7XG4gICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdCh2aXJ0dWFsVmFsdWUpKSB7XG4gICAgICB2aXJ0dWFsVmFsdWUgPSB2aXJ0dWFsVmFsdWVbcGF0aFtqXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmlydHVhbFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChwYXRoW2pdID09PSBhcnJheVByZWZpeCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGNhdWdodCBieSB2YWxpZGF0ZSwgZXhjZXB0IGlmIHRoZXJlIGlzIGFuIGBlbmZvcmNlX3R5cGU6IFwibm9uZVwiYC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvcih2YXIgaz0wOyBrPGZpZWxkLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKHZpcnR1YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlydHVhbFZhbHVlID0gdmlydHVhbFtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2VuZXJhdGVWaXJ0dWFsKGZpZWxkW2tdLCB7cGF0aDogZGVmYXVsdEZpZWxkLnBhdGguc2xpY2UoaisxKSwgdmFsdWU6IGRlZmF1bHRGaWVsZC52YWx1ZX0sIHRoaXMsIHZpcnR1YWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtlZXBHb2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGZpZWxkIGNhbm5vdCBiZSB1bmRlZmluZWQgKGRvYyBpcyBub3QgdW5kZWZpbmVkIG9uIHRoZSBmaXJzdCBpdGVyYXRpb24sIGFuZCB3ZSdsbCByZXR1cm4gaWYgaXQgYmVjb21lcyB1bmRlZmluZWRcbiAgICAgIGZpZWxkID0gZmllbGRbcGF0aFtqXV07XG4gICAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBXZSBkbyBub3QgcG9wdWxhdGUgcGFyZW50IG9mIGRlZmF1bHQgZmllbGRzIGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoa2VlcEdvaW5nKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3QodmlydHVhbFZhbHVlKSAmJiAodmlydHVhbFZhbHVlW1twYXRoW3BhdGgubGVuZ3RoLTFdXV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgZmllbGRbcGF0aFtwYXRoLmxlbmd0aC0xXV0gPSB2aXJ0dWFsVmFsdWVbW3BhdGhbcGF0aC5sZW5ndGgtMV1dXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZS5fcXVlcnkpKSB7XG4gICAgICBmaWVsZFtwYXRoW3BhdGgubGVuZ3RoLTFdXSA9IHZhbHVlLmNhbGwoZG9jKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmaWVsZFtwYXRoW3BhdGgubGVuZ3RoLTFdXSA9IHV0aWwuZGVlcENvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWVsZFtwYXRoW3BhdGgubGVuZ3RoLTFdXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZG9jO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZVZpcnR1YWwgPSBnZW5lcmF0ZVZpcnR1YWw7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRGVmYXVsdChkb2MsIGRlZmF1bHRGaWVsZCwgb3JpZ2luYWxEb2MpIHtcbiAgdmFyIHBhdGggPSBkZWZhdWx0RmllbGQucGF0aDtcbiAgdmFyIHZhbHVlID0gZGVmYXVsdEZpZWxkLnZhbHVlO1xuICB2YXIgZmllbGQgPSBkb2M7XG5cbiAgdmFyIGtlZXBHb2luZyA9IHRydWU7XG4gIGZvcih2YXIgaj0wOyBqPHBhdGgubGVuZ3RoLTE7IGorKykge1xuICAgIGlmIChwYXRoW2pdID09PSBhcnJheVByZWZpeCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGNhdWdodCBieSB2YWxpZGF0ZSwgZXhjZXB0IGlmIHRoZXJlIGlzIGFuIGBlbmZvcmNlX3R5cGU6IFwibm9uZVwiYC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvcih2YXIgaz0wOyBrPGZpZWxkLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgZ2VuZXJhdGVEZWZhdWx0KGZpZWxkW2tdLCB7cGF0aDogZGVmYXVsdEZpZWxkLnBhdGguc2xpY2UoaisxKSwgdmFsdWU6IGRlZmF1bHRGaWVsZC52YWx1ZX0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmaWVsZCA9IGZpZWxkW3BhdGhbal1dO1xuICAgICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHBvcHVsYXRlIHBhcmVudCBvZiBkZWZhdWx0IGZpZWxkcyBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGtlZXBHb2luZyAmJiB1dGlsLmlzUGxhaW5PYmplY3QoZmllbGQpICYmIGZpZWxkW3BhdGhbcGF0aC5sZW5ndGgtMV1dID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZS5fcXVlcnkpKSB7XG4gICAgICBmaWVsZFtwYXRoW3BhdGgubGVuZ3RoLTFdXSA9IHZhbHVlLmNhbGwoZG9jKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmaWVsZFtwYXRoW3BhdGgubGVuZ3RoLTFdXSA9IHV0aWwuZGVlcENvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZpZWxkW3BhdGhbcGF0aC5sZW5ndGgtMV1dID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkb2M7XG59XG5cbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRlRGVmYXVsdCA9IGdlbmVyYXRlRGVmYXVsdDtcblxuZnVuY3Rpb24gcGFyc2Uoc2NoZW1hLCBwcmVmaXgsIG9wdGlvbnMsIG1vZGVsKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKChwcmVmaXggPT09ICcnKSAmJiAodHlwZS5pc09iamVjdChzY2hlbWEpID09PSBmYWxzZSkgJiYgKHV0aWwuaXNQbGFpbk9iamVjdChzY2hlbWEpID09PSBmYWxzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSBzY2hlbWEgbXVzdCBiZSBhIHBsYWluIG9iamVjdC5cIilcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGEgc2NoZW1hIGFuZCBhZGQgdGhlIGZpZWxkIF9lbnVtIGlmIG5lZWRlZFxuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHNjaGVtYSkpIHtcbiAgICBpZiAoc2NoZW1hLl90eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB1dGlsLm1lcmdlT3B0aW9ucyhvcHRpb25zLCBzY2hlbWEub3B0aW9ucyk7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgc3dpdGNoKHNjaGVtYS5fdHlwZSkge1xuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICByZXN1bHQgPSB0eXBlLnN0cmluZygpLm9wdGlvbnMob3B0aW9ucykudmFsaWRhdG9yKHNjaGVtYS52YWxpZGF0b3IpLmVudW0oc2NoZW1hLmVudW0pO1xuICAgICAgICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7IHJlc3VsdC5kZWZhdWx0KHNjaGVtYS5kZWZhdWx0KTsgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbiA9PT0gXCJudW1iZXJcIikgeyByZXN1bHQubWluKHNjaGVtYS5taW4pOyB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4ID09PSBcIm51bWJlclwiKSB7IHJlc3VsdC5tYXgoc2NoZW1hLm1heCk7IH1cbiAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgcmVzdWx0Lmxlbmd0aChzY2hlbWEubGVuZ3RoKTsgfVxuICAgICAgICAgIGlmIChzY2hlbWEuYWxwaGFudW0gPT09IHRydWUpIHsgcmVzdWx0LmFscGhhbnVtKCk7IH1cbiAgICAgICAgICBpZiAoc2NoZW1hLmxvd2VyY2FzZSA9PT0gdHJ1ZSkgeyByZXN1bHQubG93ZXJjYXNlKCk7IH1cbiAgICAgICAgICBpZiAoc2NoZW1hLnVwcGVyY2FzZSA9PT0gdHJ1ZSkgeyByZXN1bHQudXBwZXJjYXNlKCk7IH1cbiAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5yZWdleCA9PT0gXCJzdHJpbmdcIikgeyByZXN1bHQucmVnZXgocmVnZXgsIHNjaGVtYS5mbGFncyk7IH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICByZXN1bHQgPSB0eXBlLm51bWJlcigpLm9wdGlvbnMob3B0aW9ucykudmFsaWRhdG9yKHNjaGVtYS52YWxpZGF0b3IpO1xuICAgICAgICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7IHJlc3VsdC5kZWZhdWx0KHNjaGVtYS5kZWZhdWx0KTsgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbiA9PT0gXCJudW1iZXJcIikgeyByZXN1bHQubWluKHNjaGVtYS5taW4pOyB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4ID09PSBcIm51bWJlclwiKSB7IHJlc3VsdC5tYXgoc2NoZW1hLm1heCk7IH1cbiAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgcmVzdWx0Lmxlbmd0aChzY2hlbWEubGVuZ3RoKTsgfVxuICAgICAgICAgIGlmIChzY2hlbWEuaW50ZWdlciA9PT0gdHJ1ZSkgeyByZXN1bHQuaW50ZWdlcigpOyB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgIHJlc3VsdCA9IHR5cGUuYm9vbGVhbigpLm9wdGlvbnMob3B0aW9ucykudmFsaWRhdG9yKHNjaGVtYS52YWxpZGF0b3IpO1xuICAgICAgICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7IHJlc3VsdC5kZWZhdWx0KHNjaGVtYS5kZWZhdWx0KTsgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgRGF0ZTpcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHlwZS5kYXRlKCkub3B0aW9ucyhvcHRpb25zKS52YWxpZGF0b3Ioc2NoZW1hLnZhbGlkYXRvcik7XG4gICAgICAgICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHsgcmVzdWx0LmRlZmF1bHQoc2NoZW1hLmRlZmF1bHQpOyB9XG4gICAgICAgICAgaWYgKHNjaGVtYS5taW4gaW5zdGFuY2VvZiBEYXRlKSB7IHJlc3VsdC5taW4oc2NoZW1hLm1pbik7IH1cbiAgICAgICAgICBpZiAoc2NoZW1hLm1heCBpbnN0YW5jZW9mIERhdGUpIHsgcmVzdWx0Lm1heChzY2hlbWEubWF4KTsgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgQnVmZmVyOlxuICAgICAgICAgIHJlc3VsdCA9IHR5cGUuYnVmZmVyKCkub3B0aW9ucyhvcHRpb25zKS52YWxpZGF0b3Ioc2NoZW1hLnZhbGlkYXRvcik7XG4gICAgICAgICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHsgcmVzdWx0LmRlZmF1bHQoc2NoZW1hLmRlZmF1bHQpOyB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICByZXN1bHQgPSB0eXBlLm9iamVjdCgpLm9wdGlvbnMob3B0aW9ucykudmFsaWRhdG9yKHNjaGVtYS52YWxpZGF0b3IpO1xuICAgICAgICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7IHJlc3VsdC5kZWZhdWx0KHNjaGVtYS5kZWZhdWx0KTsgfVxuICAgICAgICAgIHV0aWwubG9vcEtleXMoc2NoZW1hLnNjaGVtYSwgZnVuY3Rpb24oX3NjaGVtYSwga2V5KSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0S2V5KGtleSwgcGFyc2UoX3NjaGVtYVtrZXldLCBwcmVmaXgrXCJbXCIra2V5K1wiXVwiLCBvcHRpb25zKSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAocHJlZml4ID09PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0Ll9zZXRNb2RlbChtb2RlbClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHlwZS5hcnJheSgpLm9wdGlvbnMob3B0aW9ucykudmFsaWRhdG9yKHNjaGVtYS52YWxpZGF0b3IpO1xuICAgICAgICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7IHJlc3VsdC5kZWZhdWx0KHNjaGVtYS5kZWZhdWx0KTsgfVxuICAgICAgICAgIGlmIChzY2hlbWEuc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zY2hlbWEocGFyc2Uoc2NoZW1hLnNjaGVtYSwgcHJlZml4K1wiWzBdXCIsIG9wdGlvbnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWluID09PSBcIm51bWJlclwiKSB7IHJlc3VsdC5taW4oc2NoZW1hLm1pbik7IH1cbiAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXggPT09IFwibnVtYmVyXCIpIHsgcmVzdWx0Lm1heChzY2hlbWEubWF4KTsgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyByZXN1bHQubGVuZ3RoKHNjaGVtYS5sZW5ndGgpOyB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICAgIHJlc3VsdCA9IHR5cGUucG9pbnQoKS5vcHRpb25zKG9wdGlvbnMpLnZhbGlkYXRvcihzY2hlbWEudmFsaWRhdG9yKTtcbiAgICAgICAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkgeyByZXN1bHQuZGVmYXVsdChzY2hlbWEuZGVmYXVsdCk7IH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlICd2aXJ0dWFsJzpcbiAgICAgICAgICByZXN1bHQgPSB0eXBlLnZpcnR1YWwoKTtcbiAgICAgICAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkgeyByZXN1bHQuZGVmYXVsdChzY2hlbWEuZGVmYXVsdCk7IH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIGRlZmF1bHQ6IC8vIFVua25vd24gdHlwZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVGhlIGZpZWxkIGBfdHlwZWAgbXVzdCBiZSBgU3RyaW5nYC9gTnVtYmVyYC9gQm9vbGVhbmAvYERhdGVgL2BCdWZmZXJgL2BPYmplY3RgL2BBcnJheWAvYCd2aXJ0dWFsJ2AvYCdQb2ludCdgIGZvciBcIitwcmVmaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLmlzU3RyaW5nKHNjaGVtYSlcbiAgICAgICAgfHwgdHlwZS5pc051bWJlcihzY2hlbWEpXG4gICAgICAgIHx8IHR5cGUuaXNCb29sZWFuKHNjaGVtYSlcbiAgICAgICAgfHwgdHlwZS5pc0RhdGUoc2NoZW1hKVxuICAgICAgICB8fCB0eXBlLmlzQnVmZmVyKHNjaGVtYSlcbiAgICAgICAgfHwgdHlwZS5pc1BvaW50KHNjaGVtYSlcbiAgICAgICAgfHwgdHlwZS5pc09iamVjdChzY2hlbWEpXG4gICAgICAgIHx8IHR5cGUuaXNBcnJheShzY2hlbWEpXG4gICAgICAgIHx8IHR5cGUuaXNBbnkoc2NoZW1hKVxuICAgICAgICB8fCB0eXBlLmlzVmlydHVhbChzY2hlbWEpKXsgLy8gVW5rbm93biB0eXBlXG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmVcbiAgICAgIGlmICh0eXBlLmlzT2JqZWN0KHNjaGVtYSkpIHtcbiAgICAgICAgcGFyc2Uoc2NoZW1hLl9zY2hlbWEsIHByZWZpeCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlLmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICBpZiAoc2NoZW1hLl9zY2hlbWEgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2NoZW1hLl9zY2hlbWEgPSBwYXJzZSh0eXBlLmFueSgpLCBwcmVmaXgsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNjaGVtYS5fc2NoZW1hID0gcGFyc2Uoc2NoZW1hLl9zY2hlbWEsIHByZWZpeCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2Ugd2FudCB0byBjb3B5IHRoZSBtb2RlbCBvYmplY3QgaGVyZVxuICAgICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChzY2hlbWEuX29wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgICBzY2hlbWEub3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChzY2hlbWEuX29wdGlvbnMuZW5mb3JjZV9leHRyYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHx8IChzY2hlbWEuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgfHwgKHNjaGVtYS5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB7fTtcbiAgICAgICAgbmV3T3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSAoc2NoZW1hLl9vcHRpb25zLmVuZm9yY2VfbWlzc2luZyAhPSBudWxsKSA/IHNjaGVtYS5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgOiBvcHRpb25zLmVuZm9yY2VfbWlzc2luZztcbiAgICAgICAgbmV3T3B0aW9ucy5lbmZvcmNlX2V4dHJhID0gKHNjaGVtYS5fb3B0aW9ucy5lbmZvcmNlX2V4dHJhICE9IG51bGwpID8gc2NoZW1hLl9vcHRpb25zLmVuZm9yY2VfZXh0cmEgOiBvcHRpb25zLmVuZm9yY2VfZXh0cmE7XG4gICAgICAgIG5ld09wdGlvbnMuZW5mb3JjZV90eXBlID0gKHNjaGVtYS5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgIT0gbnVsbCkgPyBzY2hlbWEuX29wdGlvbnMuZW5mb3JjZV90eXBlIDogb3B0aW9ucy5lbmZvcmNlX3R5cGU7XG4gICAgICAgIHNjaGVtYS5vcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgPSB0eXBlLm9iamVjdCgpLm9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB1dGlsLmxvb3BLZXlzKHNjaGVtYSwgZnVuY3Rpb24oX3NjaGVtYSwga2V5KSB7XG4gICAgICAgIHJlc3VsdC5zZXRLZXkoa2V5LCBwYXJzZShfc2NoZW1hW2tleV0sIHByZWZpeCtcIltcIitrZXkrXCJdXCIsIG9wdGlvbnMpKTtcbiAgICAgIH0pXG4gICAgICBpZiAocHJlZml4ID09PSAnJykge1xuICAgICAgICByZXN1bHQuX3NldE1vZGVsKG1vZGVsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcmVzdWx0ID0gdHlwZS5hcnJheSgpLm9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKHNjaGVtYS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIkFuIGFycmF5IGluIGEgc2NoZW1hIGNhbiBoYXZlIGF0IG1vc3Qgb25lIGVsZW1lbnQuIEZvdW5kIFwiK3NjaGVtYS5sZW5ndGgrXCIgZWxlbWVudHMgaW4gXCIrcHJlZml4KVxuICAgIH1cblxuICAgIGlmIChzY2hlbWEubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnNjaGVtYShwYXJzZShzY2hlbWFbMF0sIHByZWZpeCtcIlswXVwiLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgfVxuICBlbHNlIGlmIChzY2hlbWEgPT09IFN0cmluZykge1xuICAgIHJldHVybiB0eXBlLnN0cmluZygpLm9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgZWxzZSBpZiAoc2NoZW1hID09PSBOdW1iZXIpIHtcbiAgICByZXR1cm4gdHlwZS5udW1iZXIoKS5vcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIGVsc2UgaWYgKHNjaGVtYSA9PT0gQm9vbGVhbikge1xuICAgIHJldHVybiB0eXBlLmJvb2xlYW4oKS5vcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIGVsc2UgaWYgKHNjaGVtYSA9PT0gRGF0ZSkge1xuICAgIHJldHVybiB0eXBlLmRhdGUoKS5vcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIGVsc2UgaWYgKHNjaGVtYSA9PT0gQnVmZmVyKSB7XG4gICAgcmV0dXJuIHR5cGUuYnVmZmVyKCkub3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICBlbHNlIGlmIChzY2hlbWEgPT09IE9iamVjdCkge1xuICAgIHJldHVybiB0eXBlLm9iamVjdCgpLm9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgZWxzZSBpZiAoc2NoZW1hID09PSBBcnJheSkge1xuICAgIHJldHVybiB0eXBlLmFycmF5KCkub3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICBlbHNlIGlmIChzY2hlbWEgPT09ICdQb2ludCcpIHtcbiAgICByZXR1cm4gdHlwZS5wb2ludCgpLm9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgZWxzZSBpZiAoc2NoZW1hID09PSAndmlydHVhbCcpIHtcbiAgICByZXR1cm4gdHlwZS52aXJ0dWFsKCkub3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSB2YWx1ZSBtdXN0IGJlIGBTdHJpbmdgL2BOdW1iZXJgL2BCb29sZWFuYC9gRGF0ZWAvYEJ1ZmZlcmAvYE9iamVjdGAvYEFycmF5YC9gJ3ZpcnR1YWwnYC9gJ1BvaW50J2AgZm9yIFwiK3ByZWZpeCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbi8vIFRoZSBzY2hlbWEgZG9lc24ndCBjb250YWluIGpvaW5lZCBkb2NzXG5mdW5jdGlvbiB2YWxpZGF0ZShkb2MsIHNjaGVtYSwgcHJlZml4LCBvcHRpb25zKSB7XG4gIHNjaGVtYS52YWxpZGF0ZShkb2MsIHByZWZpeCwgb3B0aW9ucyk7XG59XG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuXG5mdW5jdGlvbiBnZXRUeXBlKHNjaGVtYSkge1xuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHNjaGVtYSkgJiYgKHNjaGVtYS5fdHlwZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHJldHVybiBzY2hlbWEuX3R5cGU7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVudW0oZG9jLCBzY2hlbWEsIHByZWZpeCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgJiYgKHNjaGVtYS5fZW51bVtkb2NdICE9PSB0cnVlKSkge1xuICAgIHZhciB2YWxpZFZhbHVlcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5fZW51bSk7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSBmaWVsZCBcIitwcmVmaXgrXCIgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiBcIlxuXG4gICAgZm9yKHZhciBpPTA7IGk8dmFsaWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID09PSAxMCkgeyBicmVhazsgfVxuICAgICAgaWYgKChpID09PSB2YWxpZFZhbHVlcy5sZW5ndGgtMSkgfHwgKGkgPT09IDkpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlK3ZhbGlkVmFsdWVzW2ldXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UrdmFsaWRWYWx1ZXNbaV0rXCIsIFwiXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxpZFZhbHVlcy5sZW5ndGggPiAxMCkge1xuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UrXCIuLi5cIlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlK1wiLlwiXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbi8vIENoZWNrIHRoYXQgc2NoZW1hIGlzIGEgdmFsaWQgb2JqZWN0IGZpcnN0XG5mdW5jdGlvbiB2YWxpZGF0ZUN1c3RvbWl6ZWRWYWxpZGF0b3IoZG9jLCBzY2hlbWEsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIHNjaGVtYS52YWxpZGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2NoZW1hLnZhbGlkYXRvcihkb2MpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbGlkYXRvciBmb3IgdGhlIGZpZWxkIFwiK3ByZWZpeCtcIiByZXR1cm5lZCBgZmFsc2VgLlwiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcoZG9jLCBzY2hlbWEsIHByZWZpeCwgb3B0aW9ucykge1xuICBpZiAodmFsaWRhdGVOb3ROdWxsVW5kZWZpbmVkKGRvYywgcHJlZml4LCBcInN0cmluZ1wiLCBvcHRpb25zKSkgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2YgZG9jICE9PSBcInN0cmluZ1wiKSB7IC8vIGRvYyBpcyBub3QgbnVsbC91bmRlZmluZWRcbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgIHN0cmljdFR5cGUocHJlZml4LCBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwibG9vc2VcIikge1xuICAgICAgbG9vc2VUeXBlKHByZWZpeCwgXCJzdHJpbmdcIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChzY2hlbWEpKSB7XG4gICAgdmFsaWRhdGVDdXN0b21pemVkVmFsaWRhdG9yKGRvYywgc2NoZW1hLCBwcmVmaXgpO1xuICAgIHZhbGlkYXRlRW51bShkb2MsIHNjaGVtYSwgcHJlZml4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihkb2MsIHNjaGVtYSwgcHJlZml4LCBvcHRpb25zKSB7XG4gIGlmICh2YWxpZGF0ZU5vdE51bGxVbmRlZmluZWQoZG9jLCBwcmVmaXgsIFwibnVtYmVyXCIsIG9wdGlvbnMpKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBkb2MgIT09IFwibnVtYmVyXCIpIHsgLy8gZG9jIGlzIG5vdCBudWxsL3VuZGVmaW5lZFxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgc3RyaWN0VHlwZShwcmVmaXgsIFwibnVtYmVyXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJsb29zZVwiKSB7XG4gICAgICBsb29zZVR5cGUocHJlZml4LCBcIm51bWJlclwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHNjaGVtYSkpIHtcbiAgICB2YWxpZGF0ZUN1c3RvbWl6ZWRWYWxpZGF0b3IoZG9jLCBzY2hlbWEsIHByZWZpeCk7XG4gICAgdmFsaWRhdGVFbnVtKGRvYywgc2NoZW1hLCBwcmVmaXgpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuKGRvYywgc2NoZW1hLCBwcmVmaXgsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbGlkYXRlTm90TnVsbFVuZGVmaW5lZChkb2MsIHByZWZpeCwgXCJib29sZWFuXCIsIG9wdGlvbnMpKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBkb2MgIT09IFwiYm9vbGVhblwiKSB7IC8vIGRvYyBpcyBub3QgbnVsbC91bmRlZmluZWRcbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgIHN0cmljdFR5cGUocHJlZml4LCBcImJvb2xlYW5cIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlID09PSBcImxvb3NlXCIpIHtcbiAgICAgIGxvb3NlVHlwZShwcmVmaXgsIFwiYm9vbGVhblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHNjaGVtYSkpIHtcbiAgICB2YWxpZGF0ZUN1c3RvbWl6ZWRWYWxpZGF0b3IoZG9jLCBzY2hlbWEsIHByZWZpeCk7XG4gICAgdmFsaWRhdGVFbnVtKGRvYywgc2NoZW1hLCBwcmVmaXgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZShkb2MsIHNjaGVtYSwgcHJlZml4LCBvcHRpb25zKSB7XG4gIGlmICh2YWxpZGF0ZU5vdE51bGxVbmRlZmluZWQoZG9jLCBwcmVmaXgsIFwiZGF0ZVwiLCBvcHRpb25zKSkgcmV0dXJuO1xuXG4gIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGRvYykgJiYgKGRvY1tcIiRyZXFsX3R5cGUkXCJdID09PSBcIlRJTUVcIikpIHtcbiAgICAgIGlmIChkb2MuZXBvY2hfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBzZXVkb1R5cGVFcnJvcihcImRhdGVcIiwgXCJlcG9jaF90aW1lXCIsIHByZWZpeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkb2MudGltZXpvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwc2V1ZG9UeXBlRXJyb3IoXCJkYXRlXCIsIFwidGltZXpvbmVcIiwgcHJlZml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpICYmIChBcnJheS5pc0FycmF5KGRvYy5fcXVlcnkpKSkge1xuICAgICAgLy8gVE9JTVBST1ZFIC0tIHdlIGN1cnJlbnRseSBqdXN0IGNoZWNrIGlmIGl0J3MgYSB0ZXJtIGZyb20gdGhlIGRyaXZlclxuICAgICAgLy8gV2Ugc3VwcG9zZSBmb3Igbm93IHRoYXQgdGhpcyBpcyBlbm91Z2ggYW5kIHdlIGRvbid0IHRocm93IGFuIGVycm9yXG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGRvYyk7XG4gICAgICBpZiAoZGF0ZS5nZXRUaW1lKCkgIT09IGRhdGUuZ2V0VGltZSgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICAgIHN0cmljdFR5cGUocHJlZml4LCBcImRhdGUgb3IgYSB2YWxpZCBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgbG9vc2VUeXBlKHByZWZpeCwgXCJkYXRlIG9yIGEgdmFsaWQgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChkb2MgaW5zdGFuY2VvZiBEYXRlKSA9PT0gZmFsc2UpICB7XG4gICAgICBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgc3RyaWN0VHlwZShwcmVmaXgsIFwiZGF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBsb29zZVR5cGUocHJlZml4LCBcImRhdGVcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChzY2hlbWEpKSB7XG4gICAgdmFsaWRhdGVDdXN0b21pemVkVmFsaWRhdG9yKGRvYywgc2NoZW1hLCBwcmVmaXgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnQoZG9jLCBzY2hlbWEsIHByZWZpeCwgb3B0aW9ucykge1xuICBpZiAodmFsaWRhdGVOb3ROdWxsVW5kZWZpbmVkKGRvYywgcHJlZml4LCBcInBvaW50XCIsIG9wdGlvbnMpKSByZXR1cm47XG5cbiAgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlICE9PSBcIm5vbmVcIikge1xuICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3QoZG9jKSAmJiAoZG9jW1wiJHJlcWxfdHlwZSRcIl0gPT09IFwiR0VPTUVUUllcIikpIHtcbiAgICAgIGlmIChkb2MudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBzZXVkb1R5cGVFcnJvcihcIlBvaW50XCIsIFwidHlwZVwiLCBwcmVmaXgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZG9jLnR5cGUgIT09IFwiUG9pbnRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSBmaWVsZCBgdHlwZWAgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGAnUG9pbnQnYC5cIilcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGRvYy5jb29yZGluYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBzZXVkb1R5cGVFcnJvcihcImRhdGVcIiwgXCJjb29yZGluYXRlc1wiLCBwcmVmaXgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKCFBcnJheS5pc0FycmF5KGRvYy5jb29yZGluYXRlcykpIHx8IChkb2MuY29vcmRpbmF0ZXMubGVuZ3RoICE9PSAyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSBmaWVsZCBgY29vcmRpbmF0ZXNgIGZvciBcIitwcmVmaXgrXCIgbXVzdCBiZSBhbiBBcnJheSBvZiB0d28gbnVtYmVycy5cIilcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGRvYykgJiYgKGRvYy50eXBlID09PSBcIlBvaW50XCIpICYmIChBcnJheS5pc0FycmF5KGRvYy5jb29yZGluYXRlcykpICYmIChkb2MuY29vcmRpbmF0ZXMubGVuZ3RoID09PSAyKSkgeyAvLyBHZW9qc29uXG4gICAgICAvLyBHZW9qc29uIGZvcm1hdFxuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykgJiYgKEFycmF5LmlzQXJyYXkoZG9jLl9xdWVyeSkpKSB7XG4gICAgICAvLyBUT0lNUFJPdkUgLS0gd2UgY3VycmVudGx5IGp1c3QgY2hlY2sgaWYgaXQncyBhIHRlcm0gZnJvbSB0aGUgZHJpdmVyXG4gICAgICAvLyBXZSBzdXBwb3NlIGZvciBub3cgdGhhdCB0aGlzIGlzIGVub3VnaCBhbmQgd2UgZG9uJ3QgdGhyb3cgYW4gZXJyb3JcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGRvYykpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZG9jKS5zb3J0KCk7XG4gICAgICBpZiAoKChrZXlzLmxlbmd0aCAhPT0gMikgfHwga2V5c1swXSAhPT0gJ2xhdGl0dWRlJykgfHwgKGtleXNbMV0gIT09ICdsb25naXR1ZGUnKSB8fCAodHlwZW9mIGRvYy5sYXRpdHVkZSAhPT0gXCJudW1iZXJcIikgfHwgKHR5cGVvZiBkb2MubG9uZ2l0dWRlICE9PSBcIm51bWJlclwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSB2YWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYSBSZVFMIFBvaW50IChgci5wb2ludCg8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPilgKSwgYW4gb2JqZWN0IGB7bG9uZ2l0dWRlOiA8bnVtYmVyPiwgbGF0aXR1ZGU6IDxudW1iZXI+fWAsIG9yIGFuIGFycmF5IFs8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPl0uXCIpXG4gICAgICB9XG4gICAgICBlbHNlIGlmICgodHlwZW9mIGRvYy5sYXRpdHVkZSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZG9jLmxhdGl0dWRlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJUaGUgdmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGEgUmVRTCBQb2ludCAoYHIucG9pbnQoPGxvbmdpdHVkZT4sIDxsYXRpdHVkZT4pYCksIGFuIG9iamVjdCBge2xvbmdpdHVkZTogPG51bWJlcj4sIGxhdGl0dWRlOiA8bnVtYmVyPn1gLCBvciBhbiBhcnJheSBbPGxvbmdpdHVkZT4sIDxsYXRpdHVkZT5dLlwiKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICAgIGlmICgoZG9jLmxlbmd0aCAhPT0gMikgfHwgKHR5cGVvZiBkb2NbMF0gIT09IFwibnVtYmVyXCIpIHx8ICh0eXBlb2YgZG9jWzFdICE9PSBcIm51bWJlclwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSB2YWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYSBSZVFMIFBvaW50IChgci5wb2ludCg8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPilgKSwgYW4gb2JqZWN0IGB7bG9uZ2l0dWRlOiA8bnVtYmVyPiwgbGF0aXR1ZGU6IDxudW1iZXI+fWAsIG9yIGFuIGFycmF5IFs8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPl0uXCIpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qoc2NoZW1hKSkge1xuICAgIHZhbGlkYXRlQ3VzdG9taXplZFZhbGlkYXRvcihkb2MsIHNjaGVtYSwgcHJlZml4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUJ1ZmZlcihkb2MsIHNjaGVtYSwgcHJlZml4LCBvcHRpb25zKSB7XG4gIGlmICh2YWxpZGF0ZU5vdE51bGxVbmRlZmluZWQoZG9jLCBwcmVmaXgsIFwiYnVmZmVyXCIsIG9wdGlvbnMpKSByZXR1cm47XG5cbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChkb2MpICYmIChkb2NbXCIkcmVxbF90eXBlJFwiXSA9PT0gXCJCSU5BUllcIikpIHtcbiAgICBpZiAoZG9jLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHNldWRvVHlwZUVycm9yKFwiYmluYXJ5XCIsIFwiZGF0YVwiLCBwcmVmaXgpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmICgodHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykgJiYgKEFycmF5LmlzQXJyYXkoZG9jLl9xdWVyeSkpKSB7XG4gICAgLy8gVE9JTVBST3ZFIC0tIHdlIGN1cnJlbnRseSBqdXN0IGNoZWNrIGlmIGl0J3MgYSB0ZXJtIGZyb20gdGhlIGRyaXZlclxuICAgIC8vIFdlIHN1cHBvc2UgZm9yIG5vdyB0aGF0IHRoaXMgaXMgZW5vdWdoIGFuZCB3ZSBkb24ndCB0aHJvdyBhbiBlcnJvclxuICB9XG4gIGVsc2UgaWYgKChkb2MgaW5zdGFuY2VvZiBCdWZmZXIpID09PSBmYWxzZSkgIHtcbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgIHN0cmljdFR5cGUocHJlZml4LCBcImJ1ZmZlclwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBsb29zZVR5cGUocHJlZml4LCBcImJ1ZmZlclwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHNjaGVtYSkpIHtcbiAgICB2YWxpZGF0ZUN1c3RvbWl6ZWRWYWxpZGF0b3IoZG9jLCBzY2hlbWEsIHByZWZpeCk7XG4gIH1cbn1cbiIsInZhciByZXRoaW5rZGJkYXNoID0gcmVxdWlyZSgncmV0aGlua2RiZGFzaCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9tb2RlbC5qcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKF9fZGlybmFtZSsnL3V0aWwuanMnKTtcbnZhciB0eXBlID0gcmVxdWlyZShfX2Rpcm5hbWUrJy90eXBlL2luZGV4LmpzJyk7XG52YXIgUXVlcnkgPSByZXF1aXJlKF9fZGlybmFtZSsnL3F1ZXJ5LmpzJyk7XG52YXIgRXJyb3JzID0gcmVxdWlyZShfX2Rpcm5hbWUrJy9lcnJvcnMuanMnKTtcblxuLyoqXG4gKiBNYWluIG1ldGhvZCwgY3JlYXRlIHRoZSBkZWZhdWx0IGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIGZvciB0aGUgZHJpdmVyIGFuZCB0aGUgZnV0dXJlIG1vZGVscyBjcmVhdGVkLlxuICogIC0gYG1heGAge251bWJlcn0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGluIHRoZSBwb29sLCBkZWZhdWx0IDEwMDBcbiAqICAtIGBidWZmZXJgIHtudW1iZXJ9IFRoZSBtaW5pbXVtIG51bWJlciBvZiBjb25uZWN0aW9ucyBhdmFpbGFibGUgaW4gdGhlIHBvb2wsIGRlZmF1bHQgNTBcbiAqICAtIGB0aW1lb3V0RXJyb3JgIHtudW1iZXJ9IFRoZSB3YWl0IHRpbWUgYmVmb3JlIHJlY29ubmVjdGluZyBpbiBjYXNlIG9mIGFuIGVycm9yIChpbiBtcyksIGRlZmF1bHQgMTAwMFxuICogIC0gYHRpbWVvdXRHYmAge251bWJlcn0gSG93IGxvbmcgdGhlIHBvb2wga2VlcCBhIGNvbm5lY3Rpb24gdGhhdCBoYXNuJ3QgYmVlbiB1c2VkIChpbiBtcyksIGRlZmF1bHQgNjAqNjAqMTAwMFxuICogIC0gYGVuZm9yY2VfbWlzc2luZ2Age2Jvb2xlYW59LCBkZWZhdWx0IGBmYWxzZWBcbiAqICAtIGBlbmZvcmNlX2V4dHJhYCB7XCJzdHJpY3RcInxcInJlbW92ZVwifFwibm9uZVwifSwgZGVmYXVsdCBgXCJub25lXCJgXG4gKiAgLSBgZW5mb3JjZV90eXBlYCB7XCJzdHJpY3RcInxcImxvb3NlXCJ8XCJub25lXCJ9LCBkZWZhdWx0IGBcImxvb3NlXCJgXG4gKiAgLSBgdGltZUZvcm1hdGAge1wicmF3XCJ8XCJuYXRpdmVcIn1cbiAqICAtIGBjcmVhdGVEYXRhYmFzZWAge2Jvb2xlYW59IFdoZXRoZXIgdGhpbmt5IHNob3VsZCBjcmVhdGUgdGhlIGRhdGFiYXNlIG9yIG5vdC5cbiAqL1xuZnVuY3Rpb24gVGhpbmt5KGNvbmZpZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGIgPSBjb25maWcuZGIgfHwgJ3Rlc3QnOyAvLyBXZSBuZWVkIHRoZSBkZWZhdWx0IGRiIHRvIGNyZWF0ZSBpdC5cbiAgc2VsZi5fY29uZmlnID0gY29uZmlnO1xuXG4gIHNlbGYuX29wdGlvbnMgPSB7fTtcbiAgLy8gT3B0aW9uIHBhc3NlZCB0byBlYWNoIG1vZGVsIHdlIGFyZSBnb2luZyB0byBjcmVhdGUuXG4gIHNlbGYuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID1cbiAgICAoY29uZmlnLmVuZm9yY2VfbWlzc2luZyAhPSBudWxsKSA/IGNvbmZpZy5lbmZvcmNlX21pc3NpbmcgOiBmYWxzZTtcbiAgc2VsZi5fb3B0aW9ucy5lbmZvcmNlX2V4dHJhID1cbiAgICAoY29uZmlnLmVuZm9yY2VfZXh0cmEgIT0gbnVsbCkgPyBjb25maWcuZW5mb3JjZV9leHRyYSA6IFwibm9uZVwiO1xuICBzZWxmLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9XG4gICAgKGNvbmZpZy5lbmZvcmNlX3R5cGUgIT0gbnVsbCkgPyBjb25maWcuZW5mb3JjZV90eXBlIDogJ2xvb3NlJztcblxuICAvLyBGb3JtYXQgb2YgdGltZSBvYmplY3RzIHJldHVybmVkIGJ5IHRoZSBkYXRhYmFzZSwgYnkgZGVmYXVsdCB3ZSBjb252ZXJ0XG4gIC8vIHRoZW0gdG8gSmF2YVNjcmlwdCBEYXRlcy5cbiAgc2VsZi5fb3B0aW9ucy50aW1lRm9ybWF0ID1cbiAgICAoY29uZmlnLnRpbWVGb3JtYXQgIT0gbnVsbCkgPyBjb25maWcudGltZUZvcm1hdCA6ICduYXRpdmUnO1xuICAvLyBPcHRpb24gcGFzc2VkIHRvIGVhY2ggbW9kZWwgd2UgYXJlIGdvaW5nIHRvIGNyZWF0ZS5cbiAgc2VsZi5fb3B0aW9ucy52YWxpZGF0ZSA9XG4gICAgKGNvbmZpZy52YWxpZGF0ZSAhPSBudWxsKSA/IGNvbmZpZy52YWxpZGF0ZSA6ICdvbnNhdmUnO1xuXG4gIGlmIChjb25maWcuciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5yID0gcmV0aGlua2RiZGFzaChjb25maWcpO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlbGYuciA9IGNvbmZpZy5yO1xuICB9XG4gIHNlbGYudHlwZSA9IHR5cGU7XG4gIHNlbGYuUXVlcnkgPSBRdWVyeTtcbiAgc2VsZi5tb2RlbHMgPSB7fTtcblxuICAvLyBFeHBvcnQgZXJyb3JzXG4gIHNlbGYuRXJyb3JzID0gRXJyb3JzO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGRhdGFiYXNlLlxuICBzZWxmLmRiUmVhZHkoKS50aGVuKCkuZXJyb3IoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBJbml0aWFsaXplIG91ciBkYXRhYmFzZS5cbiAqIEByZXR1cm4ge1Byb21pc2U9fSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgZGF0YWJhc2UgaXMgcmVhZHkuXG4gKi9cblRoaW5reS5wcm90b3R5cGUuZGJSZWFkeSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLl9kYlJlYWR5UHJvbWlzZSkgcmV0dXJuIHRoaXMuX2RiUmVhZHlQcm9taXNlO1xuICB2YXIgciA9IHNlbGYucjtcbiAgaWYgKHNlbGYuX2NvbmZpZy5jcmVhdGVEYXRhYmFzZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgdGhpcy5fZGJSZWFkeVByb21pc2UgPSByLmRiQ3JlYXRlKHNlbGYuX2NvbmZpZy5kYilcbiAgLnJ1bigpXG4gIC5lcnJvcihmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIFRoZSBgZG9gIGlzIG5vdCBhdG9taWMsIHdlIGEgY29uY3VycmVudCBxdWVyeSBjb3VsZCBjcmVhdGUgdGhlIGRhdGFiYXNlXG4gICAgLy8gYmV0d2VlbiB0aGUgdGltZSBgZGJMaXN0YCBpcyByYW4gYW5kIGBkYkNyZWF0ZWAgaXMuXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UubWF0Y2goL15EYXRhYmFzZSBgLipgIGFscmVhZHkgZXhpc3RzIGluLykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyB3ZW50IHdyb25nIGhlcmUsIHdlIGRvIG5vdCByZWNvdmVyIGFuZCB0aHJvdy5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG5cbiAgcmV0dXJuIHNlbGYuX2RiUmVhZHlQcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGN1cnJlbnQgb3B0aW9uIHVzZWQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBnbG9iYWwgb3B0aW9ucyBvZiB0aGUgbGlicmFyeVxuICovXG5UaGlua3kucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBtb2RlbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWJsZSB1c2VkIGJlaGluZCB0aGlzIG1vZGVsLlxuICogQHBhcmFtIHtvYmplY3R8VHlwZX0gc2NoZW1hIFRoZSBzY2hlbWEgb2YgdGhpcyBtb2RlbC5cbiAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGlzIG1vZGVsLiBUaGUgZmllbGRzIGNhbiBiZTpcbiAqICAtIGBpbml0YCB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdGFibGUgc2hvdWxkIGJlIGNyZWF0ZWQgb3Igbm90LiBUaGUgdmFsdWVcbiAqICBgZmFsc2VgIGlzIHVzZWQgdG8gc3BlZWQgdXAgdGVzdGluZywgYW5kIHNob3VsZCBwcm9iYWJseSBiZSBgdHJ1ZWAgaW5cbiAqICBvdGhlciB1c2UgY2FzZXMuXG4gKiAgLSBgdGltZUZvcm1hdGAge1wicmF3XCJ8XCJuYXRpdmVcIn0gRm9ybWF0IG9mIFJlUUwgZGF0ZXMuXG4gKiAgLSBgZW5mb3JjZV9taXNzaW5nYCB7Ym9vbGVhbn0sIGRlZmF1bHQgYGZhbHNlYC5cbiAqICAtIGBlbmZvcmNlX2V4dHJhYCB7XCJzdHJpY3RcInxcInJlbW92ZVwifFwibm9uZVwifSwgZGVmYXVsdCBgXCJub25lXCJgLlxuICogIC0gYGVuZm9yY2VfdHlwZWAge1wic3RyaWN0XCJ8XCJsb29zZVwifFwibm9uZVwifSwgZGVmYXVsdCBgXCJsb29zZVwiYC5cbiAqICAtIGB2YWxpZGF0ZWAge1wib25jcmVhdGVcInxcIm9uc2F2ZVwifSwgZGVmYXVsdCBcIm9uc2F2ZVwiLlxuICovXG5UaGlua3kucHJvdG90eXBlLmNyZWF0ZU1vZGVsID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBNYWtlIGEgZGVlcCBjb3B5IG9mIHRoZSBvcHRpb25zIGFzIHRoZSBtb2RlbCBtYXkgb3ZlcndyaXRlIHRoZW0uXG4gIHZhciBmdWxsT3B0aW9ucyA9IHV0aWwuZGVlcENvcHkodGhpcy5fb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB1dGlsLmxvb3BLZXlzKG9wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbnMsIGtleSkge1xuICAgIGZ1bGxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH0pO1xuXG4gIC8vIFR3byBtb2RlbHMgY2Fubm90IHNoYXJlIHRoZSBzYW1lIG5hbWUuXG4gIGlmIChzZWxmLm1vZGVsc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlZGVmaW5lIGEgTW9kZWxcIik7XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIGNvbnN0cnVjdG9yIHJldHVybmVkLiBUaGlzIHdpbGwgYWxzbyB2YWxpZGF0ZSB0aGUgc2NoZW1hLlxuICB2YXIgbW9kZWwgPSBNb2RlbC5uZXcobmFtZSwgc2NoZW1hLCBmdWxsT3B0aW9ucywgc2VsZik7XG5cbiAgLy8gS2VlcCBhIHJlZmVyZW5jZSBvZiB0aGlzIG1vZGVsLlxuICBzZWxmLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuICByZXR1cm4gbW9kZWw7XG59XG5cblxuLyoqXG4gKiBNZXRob2QgdG8gY2xlYW4gYWxsIHRoZSByZWZlcmVuY2VzIHRvIHRoZSBtb2RlbHMuIFRoaXMgaXMgdXNlZCB0byBzcGVlZCB1cFxuICogdGVzdGluZyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG90aGVyIHVzZSBjYXNlcy5cbiAqL1xuVGhpbmt5LnByb3RvdHlwZS5fY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5tb2RlbHMgPSB7fTtcbn1cblxuXG4vLyBFeHBvcnQgdGhlIG1vZHVsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIHJldHVybiBuZXcgVGhpbmt5KGNvbmZpZyk7XG59XG5cbi8vIEV4cG9zZSB0aGlua3kgdHlwZXMgZGlyZWN0bHkgZnJvbSBtb2R1bGVcbm1vZHVsZS5leHBvcnRzLnR5cGUgPSB0eXBlO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKF9fZGlybmFtZSsnLy4uL3V0aWwuanMnKTtcbnZhciBzY2hlbWEgPSAgICAgIHJlcXVpcmUoX19kaXJuYW1lKycvLi4vc2NoZW1hLmpzJyk7XG5cbmZ1bmN0aW9uIFR5cGVBbnkoKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3ZhbGlkYXRvciA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fb3B0aW9ucyA9IHt9O1xufVxuXG5UeXBlQW55LnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZm5PclZhbHVlKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSBmbk9yVmFsdWU7XG59XG5UeXBlQW55LnByb3RvdHlwZS52YWxpZGF0b3IgPSBmdW5jdGlvbihmbikge1xuICB0aGlzLl92YWxpZGF0b3IgPSBmbjtcbn1cblR5cGVBbnkucHJvdG90eXBlLl9nZXREZWZhdWx0RmllbGRzID0gZnVuY3Rpb24ocHJlZml4LCBkZWZhdWx0RmllbGRzLCB2aXJ0dWFsRmllbGRzKSB7XG59XG5cbi8vIER1bW15IG1ldGhvZHMsIGp1c3QgdG8gYWxsb3cgdXNlcnMgdG8gZWFzaWx5IHN3aXRjaCBmcm9tIGEgdmFsaWQgdHlwZSB0byBhbnlcblR5cGVBbnkucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzO1xufVxuVHlwZUFueS5wcm90b3R5cGUub3B0aW9uYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5UeXBlQW55LnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblR5cGVBbnkucHJvdG90eXBlLmFsbG93TnVsbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblR5cGVBbnkucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblR5cGVBbnkucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblR5cGVBbnkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblR5cGVBbnkucHJvdG90eXBlLnNjaGVtYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblR5cGVBbnkucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVBbnk7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoX19kaXJuYW1lKycvLi4vdXRpbC5qcycpO1xudmFyIHNjaGVtYSA9ICAgICAgcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi9zY2hlbWEuanMnKTtcbnZhciBhcnJheVByZWZpeCA9IHNjaGVtYS5hcnJheVByZWZpeDtcbnZhciBFcnJvcnMgPSByZXF1aXJlKF9fZGlybmFtZSsnLy4uL2Vycm9ycy5qcycpO1xuXG5mdW5jdGlvbiBUeXBlQXJyYXkoKSB7XG4gIHRoaXMuX21pbiA9IC0xO1xuICB0aGlzLl9tYXggPSAtMTtcbiAgdGhpcy5fbGVuZ3RoID0gLTE7XG4gIHRoaXMuX3NjaGVtYSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdmFsaWRhdG9yID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vcHRpb25zID0ge307XG59XG5cblxuVHlwZUFycmF5LnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gIG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9IG9wdGlvbnMuZW5mb3JjZV90eXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX2V4dHJhICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9leHRyYSA9IG9wdGlvbnMuZW5mb3JjZV9leHRyYVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlQXJyYXkucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVBcnJheS5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlQXJyYXkucHJvdG90eXBlLmFsbG93TnVsbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gJ3N0cmljdCcpIHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gJ2xvb3NlJ1xuICAgIH1cbiAgICAvLyBlbHNlIGEgbm8tb3AsIHN0cmljdCAtPiBzdHJpY3RcbiAgfVxuICBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgLy8gVGhlIHZhbHVlIGlzIGxvb3NlIG9yIHVuZGVmaW5lZFxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnbG9vc2UnXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgbG9vc2UsIHNvIGlmIHdlIGNhbGwgYWxsb3dOdWxsKGZhbHNlKSwgaXQgYmVjb21lcyBzdHJpY3RcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gJ3N0cmljdCdcbiAgICB9XG4gIH1cbiAgLy8gZWxzZSBubyBvcCwgdHlwZS5hbnkoKSBpcyB0aGUgc2FtZSBhcyB0eXBlLmFueSgpLmFsbG93TnVsbCg8Ym9vbD4pXG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVBcnJheS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24obWluKSB7XG4gIGlmIChtaW4gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJUaGUgdmFsdWUgZm9yIGBtaW5gIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG4gIHRoaXMuX21pbiA9IG1pbjtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZUFycmF5LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihtYXgpIHtcbiAgaWYgKG1heCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSB2YWx1ZSBmb3IgYG1heGAgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIH1cbiAgdGhpcy5fbWF4ID0gbWF4O1xuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVGhlIHZhbHVlIGZvciBgbGVuZ3RoYCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgfVxuICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVBcnJheS5wcm90b3R5cGUuc2NoZW1hID0gZnVuY3Rpb24oc2NoZW1hKSB7XG4gIHRoaXMuX3NjaGVtYSA9IHNjaGVtYTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZUFycmF5LnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZm5PclZhbHVlKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSBmbk9yVmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVBcnJheS5wcm90b3R5cGUudmFsaWRhdG9yID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5fdmFsaWRhdG9yID0gZm47XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVBcnJheS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSwgcHJlZml4LCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxvY2FsT3B0aW9ucyA9IHV0aWwubWVyZ2VPcHRpb25zKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGlmICh1dGlsLnZhbGlkYXRlSWZVbmRlZmluZWQoYXJyYXksIHByZWZpeCwgXCJhcnJheVwiLCBsb2NhbE9wdGlvbnMpKSByZXR1cm47XG5cbiAgaWYgKCh0eXBlb2Ygc2VsZi5fdmFsaWRhdG9yID09PSBcImZ1bmN0aW9uXCIpICYmIChzZWxmLl92YWxpZGF0b3IoYXJyYXkpID09PSBmYWxzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbGlkYXRvciBmb3IgdGhlIGZpZWxkIFwiK3ByZWZpeCtcIiByZXR1cm5lZCBgZmFsc2VgLlwiKTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIGFycmF5ID09PSAnZnVuY3Rpb24nKSAmJiAoYXJyYXkuX3F1ZXJ5ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgLy8gV2UgZG8gbm90IGNoZWNrIFJlUUwgdGVybXNcbiAgfVxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICBpZiAobG9jYWxPcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgdXRpbC5zdHJpY3RUeXBlKHByZWZpeCwgXCJhcnJheVwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGxvY2FsT3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwibG9vc2VcIikgJiYgKGFycmF5ICE9PSBudWxsKSkge1xuICAgICAgdXRpbC5sb29zZVR5cGUocHJlZml4LCBcImFycmF5XCIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoKHRoaXMuX21pbiAhPT0gLTEpICYmICh0aGlzLl9taW4gPiBhcnJheS5sZW5ndGgpKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGhhdmUgYXQgbGVhc3QgXCIrdGhpcy5fbWluK1wiIGVsZW1lbnRzLlwiKVxuICAgIH1cbiAgICBpZiAoKHRoaXMuX21heCAhPT0gLTEpICYmICh0aGlzLl9tYXggPCBhcnJheS5sZW5ndGgpKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGhhdmUgYXQgbW9zdCBcIit0aGlzLl9tYXgrXCIgZWxlbWVudHMuXCIpXG4gICAgfVxuICAgIGlmICgodGhpcy5fbGVuZ3RoICE9PSAtMSkgJiYgKHRoaXMuX2xlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbHVlIGZvciBcIitwcmVmaXgrXCIgbXVzdCBiZSBhbiBhcnJheSB3aXRoIFwiK3RoaXMuX2xlbmd0aCtcIiBlbGVtZW50cy5cIilcbiAgICB9XG5cbiAgICBmb3IodmFyIGk9MDsgaTxhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycmF5W2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJUaGUgZWxlbWVudCBpbiB0aGUgYXJyYXkgXCIrcHJlZml4K1wiIChwb3NpdGlvbiBcIitpK1wiKSBjYW5ub3QgYmUgYHVuZGVmaW5lZGAuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3NjaGVtYS52YWxpZGF0ZShhcnJheVtpXSwgcHJlZml4K1wiW1wiK2krXCJdXCIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblR5cGVBcnJheS5wcm90b3R5cGUuX2dldERlZmF1bHRGaWVsZHMgPSBmdW5jdGlvbihwcmVmaXgsIGRlZmF1bHRGaWVsZHMsIHZpcnR1YWxGaWVsZHMpIHtcbiAgaWYgKHRoaXMuX2RlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlZmF1bHRGaWVsZHMucHVzaCh7XG4gICAgICBwYXRoOiBwcmVmaXgsXG4gICAgICB2YWx1ZTogdGhpcy5fZGVmYXVsdCxcbiAgICB9KTtcbiAgfVxuICBpZiAodGhpcy5fc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9zY2hlbWEuX2dldERlZmF1bHRGaWVsZHMocHJlZml4LmNvbmNhdChhcnJheVByZWZpeCksIGRlZmF1bHRGaWVsZHMsIHZpcnR1YWxGaWVsZHMpO1xuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlQXJyYXk7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoX19kaXJuYW1lKycvLi4vdXRpbC5qcycpO1xudmFyIEVycm9ycyA9IHJlcXVpcmUoX19kaXJuYW1lKycvLi4vZXJyb3JzLmpzJyk7XG5cbmZ1bmN0aW9uIFR5cGVCb29sZWFuKCkge1xuICB0aGlzLl9kZWZhdWx0ID0gdW5kZWZpbmVkO1xuICB0aGlzLl92YWxpZGF0b3IgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX29wdGlvbnMgPSB7fTtcbn1cblxuXG5UeXBlQm9vbGVhbi5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfbWlzc2luZyAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9ICBvcHRpb25zLmVuZm9yY2VfbWlzc2luZ1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSBvcHRpb25zLmVuZm9yY2VfdHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV9leHRyYSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfZXh0cmEgPSBvcHRpb25zLmVuZm9yY2VfZXh0cmFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZUJvb2xlYW4ucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVCb29sZWFuLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVCb29sZWFuLnByb3RvdHlwZS5hbGxvd051bGwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09ICdzdHJpY3QnKSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdsb29zZSdcbiAgICB9XG4gICAgLy8gZWxzZSBhIG5vLW9wLCBzdHJpY3QgLT4gc3RyaWN0XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgIT09ICdub25lJykge1xuICAgIC8vIFRoZSB2YWx1ZSBpcyBsb29zZSBvciB1bmRlZmluZWRcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gJ2xvb3NlJ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGxvb3NlLCBzbyBpZiB3ZSBjYWxsIGFsbG93TnVsbChmYWxzZSksIGl0IGJlY29tZXMgc3RyaWN0XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdzdHJpY3QnXG4gICAgfVxuICB9XG4gIC8vIGVsc2Ugbm8gb3AsIHR5cGUuYW55KCkgaXMgdGhlIHNhbWUgYXMgdHlwZS5hbnkoKS5hbGxvd051bGwoPGJvb2w+KVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5cblR5cGVCb29sZWFuLnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZm5PclZhbHVlKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSBmbk9yVmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVCb29sZWFuLnByb3RvdHlwZS52YWxpZGF0b3IgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSBmbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlQm9vbGVhbi5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihib29sLCBwcmVmaXgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHV0aWwubWVyZ2VPcHRpb25zKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGlmICh1dGlsLnZhbGlkYXRlSWZVbmRlZmluZWQoYm9vbCwgcHJlZml4LCBcImJvb2xlYW5cIiwgb3B0aW9ucykpIHJldHVybjtcblxuICBpZiAoKHR5cGVvZiB0aGlzLl92YWxpZGF0b3IgPT09IFwiZnVuY3Rpb25cIikgJiYgKHRoaXMuX3ZhbGlkYXRvcihib29sKSA9PT0gZmFsc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWxpZGF0b3IgZm9yIHRoZSBmaWVsZCBcIitwcmVmaXgrXCIgcmV0dXJuZWQgYGZhbHNlYC5cIik7XG4gIH1cblxuICBpZiAodHlwZW9mIGJvb2wgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlID09PSBcInN0cmljdFwiKSB7XG4gICAgICB1dGlsLnN0cmljdFR5cGUocHJlZml4LCBcImJvb2xlYW5cIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJsb29zZVwiKSAmJiAoYm9vbCAhPT0gbnVsbCkpIHtcbiAgICAgIHV0aWwubG9vc2VUeXBlKHByZWZpeCwgXCJib29sZWFuXCIpO1xuICAgIH1cbiAgfVxufVxuXG5cblR5cGVCb29sZWFuLnByb3RvdHlwZS5fZ2V0RGVmYXVsdEZpZWxkcyA9IGZ1bmN0aW9uKHByZWZpeCwgZGVmYXVsdEZpZWxkcywgdmlydHVhbEZpZWxkcykge1xuICBpZiAodGhpcy5fZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmYXVsdEZpZWxkcy5wdXNoKHtcbiAgICAgIHBhdGg6IHByZWZpeCxcbiAgICAgIHZhbHVlOiB0aGlzLl9kZWZhdWx0LFxuICAgIH0pO1xuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlQm9vbGVhbjtcbiIsInZhciB1dGlsID0gcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi91dGlsLmpzJyk7XG52YXIgRXJyb3JzID0gcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi9lcnJvcnMuanMnKTtcblxuZnVuY3Rpb24gVHlwZUJ1ZmZlcigpIHtcbiAgdGhpcy5fZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICB0aGlzLl92YWxpZGF0b3IgPSB1bmRlZmluZWQ7XG59XG5cblxuVHlwZUJ1ZmZlci5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfbWlzc2luZyAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9ICBvcHRpb25zLmVuZm9yY2VfbWlzc2luZ1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSBvcHRpb25zLmVuZm9yY2VfdHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV9leHRyYSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfZXh0cmEgPSBvcHRpb25zLmVuZm9yY2VfZXh0cmFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZUJ1ZmZlci5wcm90b3R5cGUub3B0aW9uYWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZUJ1ZmZlci5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlQnVmZmVyLnByb3RvdHlwZS5hbGxvd051bGwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09ICdzdHJpY3QnKSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdsb29zZSdcbiAgICB9XG4gICAgLy8gZWxzZSBhIG5vLW9wLCBzdHJpY3QgLT4gc3RyaWN0XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgIT09ICdub25lJykge1xuICAgIC8vIFRoZSB2YWx1ZSBpcyBsb29zZSBvciB1bmRlZmluZWRcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gJ2xvb3NlJ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGxvb3NlLCBzbyBpZiB3ZSBjYWxsIGFsbG93TnVsbChmYWxzZSksIGl0IGJlY29tZXMgc3RyaWN0XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdzdHJpY3QnXG4gICAgfVxuICB9XG4gIC8vIGVsc2Ugbm8gb3AsIHR5cGUuYW55KCkgaXMgdGhlIHNhbWUgYXMgdHlwZS5hbnkoKS5hbGxvd051bGwoPGJvb2w+KVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlQnVmZmVyLnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZm5PclZhbHVlKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSBmbk9yVmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVCdWZmZXIucHJvdG90eXBlLnZhbGlkYXRvciA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRoaXMuX3ZhbGlkYXRvciA9IGZuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVCdWZmZXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oYnVmZmVyLCBwcmVmaXgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHV0aWwubWVyZ2VPcHRpb25zKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGlmICh1dGlsLnZhbGlkYXRlSWZVbmRlZmluZWQoYnVmZmVyLCBwcmVmaXgsIFwiYnVmZmVyXCIsIG9wdGlvbnMpKSByZXR1cm47XG5cbiAgaWYgKCh0eXBlb2YgdGhpcy5fdmFsaWRhdG9yID09PSBcImZ1bmN0aW9uXCIpICYmICh0aGlzLl92YWxpZGF0b3IoYnVmZmVyKSA9PT0gZmFsc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWxpZGF0b3IgZm9yIHRoZSBmaWVsZCBcIitwcmVmaXgrXCIgcmV0dXJuZWQgYGZhbHNlYC5cIik7XG4gIH1cblxuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGJ1ZmZlcikgJiYgKGJ1ZmZlcltcIiRyZXFsX3R5cGUkXCJdID09PSBcIkJJTkFSWVwiKSkge1xuICAgIGlmIChidWZmZXIuZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1dGlsLnBzZXVkb1R5cGVFcnJvcihcImJpbmFyeVwiLCBcImRhdGFcIiwgcHJlZml4KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoKHR5cGVvZiBidWZmZXIgPT09ICdmdW5jdGlvbicpICYmIChidWZmZXIuX3F1ZXJ5ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgLy8gVE9JTVBST3ZFIC0tIHdlIGN1cnJlbnRseSBqdXN0IGNoZWNrIGlmIGl0J3MgYSB0ZXJtIGZyb20gdGhlIGRyaXZlclxuICAgIC8vIFdlIHN1cHBvc2UgZm9yIG5vdyB0aGF0IHRoaXMgaXMgZW5vdWdoIGFuZCB3ZSBkb24ndCB0aHJvdyBhbiBlcnJvclxuICB9XG4gIGVsc2UgaWYgKChidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpID09PSBmYWxzZSkgIHsgLy8gV2UgZG9uJ3QgaGF2ZSBhIGJ1ZmZlclxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgdXRpbC5zdHJpY3RUeXBlKHByZWZpeCwgXCJidWZmZXJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJsb29zZVwiKSAmJiAoYnVmZmVyICE9PSBudWxsKSkge1xuICAgICAgdXRpbC5sb29zZVR5cGUocHJlZml4LCBcImJ1ZmZlclwiKTtcbiAgICB9XG4gIH1cbn1cblxuXG5UeXBlQnVmZmVyLnByb3RvdHlwZS5fZ2V0RGVmYXVsdEZpZWxkcyA9IGZ1bmN0aW9uKHByZWZpeCwgZGVmYXVsdEZpZWxkcywgdmlydHVhbEZpZWxkcykge1xuICBpZiAodGhpcy5fZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmYXVsdEZpZWxkcy5wdXNoKHtcbiAgICAgIHBhdGg6IHByZWZpeCxcbiAgICAgIHZhbHVlOiB0aGlzLl9kZWZhdWx0LFxuICAgIH0pO1xuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlQnVmZmVyO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKF9fZGlybmFtZSsnLy4uL3V0aWwuanMnKTtcbnZhciBFcnJvcnMgPSByZXF1aXJlKF9fZGlybmFtZSsnLy4uL2Vycm9ycy5qcycpO1xuXG5mdW5jdGlvbiBUeXBlRGF0ZSgpIHtcbiAgdGhpcy5fbWluID0gdW5kZWZpbmVkO1xuICB0aGlzLl9tYXggPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3ZhbGlkYXRvciA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fb3B0aW9ucyA9IHt9O1xufVxuXG5cblR5cGVEYXRlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gIG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9IG9wdGlvbnMuZW5mb3JjZV90eXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX2V4dHJhICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9leHRyYSA9IG9wdGlvbnMuZW5mb3JjZV9leHRyYVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlRGF0ZS5wcm90b3R5cGUub3B0aW9uYWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZURhdGUucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZURhdGUucHJvdG90eXBlLmFsbG93TnVsbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gJ3N0cmljdCcpIHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gJ2xvb3NlJ1xuICAgIH1cbiAgICAvLyBlbHNlIGEgbm8tb3AsIHN0cmljdCAtPiBzdHJpY3RcbiAgfVxuICBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgLy8gVGhlIHZhbHVlIGlzIGxvb3NlIG9yIHVuZGVmaW5lZFxuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnbG9vc2UnXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgbG9vc2UsIHNvIGlmIHdlIGNhbGwgYWxsb3dOdWxsKGZhbHNlKSwgaXQgYmVjb21lcyBzdHJpY3RcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gJ3N0cmljdCdcbiAgICB9XG4gIH1cbiAgLy8gZWxzZSBubyBvcCwgdHlwZS5hbnkoKSBpcyB0aGUgc2FtZSBhcyB0eXBlLmFueSgpLmFsbG93TnVsbCg8Ym9vbD4pXG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVEYXRlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihtaW4pIHtcbiAgdGhpcy5fbWluID0gbWluO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlRGF0ZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24obWF4KSB7XG4gIHRoaXMuX21heCA9IG1heDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZURhdGUucHJvdG90eXBlLmRlZmF1bHQgPSBmdW5jdGlvbihmbk9yVmFsdWUpIHtcbiAgdGhpcy5fZGVmYXVsdCA9IGZuT3JWYWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZURhdGUucHJvdG90eXBlLnZhbGlkYXRvciA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRoaXMuX3ZhbGlkYXRvciA9IGZuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVEYXRlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKGRhdGUsIHByZWZpeCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gdXRpbC5tZXJnZU9wdGlvbnModGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgaWYgKHV0aWwudmFsaWRhdGVJZlVuZGVmaW5lZChkYXRlLCBwcmVmaXgsIFwiZGF0ZVwiLCBvcHRpb25zKSkgcmV0dXJuO1xuXG4gIGlmICgodHlwZW9mIHRoaXMuX3ZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSAmJiAodGhpcy5fdmFsaWRhdG9yKGRhdGUpID09PSBmYWxzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbGlkYXRvciBmb3IgdGhlIGZpZWxkIFwiK3ByZWZpeCtcIiByZXR1cm5lZCBgZmFsc2VgLlwiKTtcbiAgfVxuXG4gIHZhciBqc0RhdGU7XG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3QoZGF0ZSkgJiYgKGRhdGVbXCIkcmVxbF90eXBlJFwiXSA9PT0gXCJUSU1FXCIpKSB7XG4gICAgaWYgKGRhdGUuZXBvY2hfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB1dGlsLnBzZXVkb1R5cGVFcnJvcihcImRhdGVcIiwgXCJlcG9jaF90aW1lXCIsIHByZWZpeCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGUudGltZXpvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXRpbC5wc2V1ZG9UeXBlRXJyb3IoXCJkYXRlXCIsIFwidGltZXpvbmVcIiwgcHJlZml4KTtcbiAgICB9XG5cbiAgICBqc0RhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgICBqc0RhdGUuc2V0VVRDU2Vjb25kcyhkYXRlLmVwb2NoX3RpbWUpXG4gIH1cbiAgZWxzZSBpZiAoKHR5cGVvZiBkYXRlID09PSAnZnVuY3Rpb24nKSAmJiAoZGF0ZS5fcXVlcnkgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAvLyBUT0lNUFJPVkUgLS0gd2UgY3VycmVudGx5IGp1c3QgY2hlY2sgaWYgaXQncyBhIHRlcm0gZnJvbSB0aGUgZHJpdmVyXG4gICAgLy8gV2Ugc3VwcG9zZSBmb3Igbm93IHRoYXQgdGhpcyBpcyBlbm91Z2ggYW5kIHdlIGRvbid0IHRocm93IGFuIGVycm9yXG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgIHZhciBudW1lcmljRGF0ZSA9IHBhcnNlSW50KGRhdGUsIDEwKTtcbiAgICBpZighaXNOYU4obnVtZXJpY0RhdGUpKXtcbiAgICAgIGRhdGUgPSBudW1lcmljRGF0ZTtcbiAgICB9XG4gICAganNEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgaWYgKGpzRGF0ZS5nZXRUaW1lKCkgIT09IGpzRGF0ZS5nZXRUaW1lKCkpIHtcbiAgICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICB1dGlsLnN0cmljdFR5cGUocHJlZml4LCBcImRhdGUgb3IgYSB2YWxpZCBzdHJpbmdcIik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgdXRpbC5sb29zZVR5cGUocHJlZml4LCBcImRhdGUgb3IgYSB2YWxpZCBzdHJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKChkYXRlIGluc3RhbmNlb2YgRGF0ZSkgPT09IGZhbHNlKSB7IC8vIFdlIGhhdmUgYSBub24gdmFsaWQgZGF0ZVxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgdXRpbC5zdHJpY3RUeXBlKHByZWZpeCwgXCJkYXRlXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwibG9vc2VcIikgJiYgKGRhdGUgIT09IG51bGwpKSB7XG4gICAgICB1dGlsLmxvb3NlVHlwZShwcmVmaXgsIFwiZGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAganNEYXRlID0gZGF0ZTtcbiAgfVxuXG4gIC8vIFdlIGNoZWNrIGZvciBtaW4vbWF4IG9ubHkgaWYgd2UgY291bGQgY3JlYXRlIGEgamF2YXNjcmlwdCBkYXRlIGZyb20gdGhlIHZhbHVlXG4gIGlmIChqc0RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICgodGhpcy5fbWluIGluc3RhbmNlb2YgRGF0ZSkgJiYgKHRoaXMuX21pbiA+IGpzRGF0ZSkpe1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYWZ0ZXIgXCIrdGhpcy5fbWluK1wiLlwiKVxuICAgIH1cbiAgICBpZiAoKHRoaXMuX21heCBpbnN0YW5jZW9mIERhdGUpICYmICh0aGlzLl9tYXggPCBqc0RhdGUpKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGJlZm9yZSBcIit0aGlzLl9tYXgrXCIuXCIpXG4gICAgfVxuICB9XG59XG5cblxuVHlwZURhdGUucHJvdG90eXBlLl9nZXREZWZhdWx0RmllbGRzID0gZnVuY3Rpb24ocHJlZml4LCBkZWZhdWx0RmllbGRzLCB2aXJ0dWFsRmllbGRzKSB7XG4gIGlmICh0aGlzLl9kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWZhdWx0RmllbGRzLnB1c2goe1xuICAgICAgcGF0aDogcHJlZml4LFxuICAgICAgdmFsdWU6IHRoaXMuX2RlZmF1bHQsXG4gICAgfSk7XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVEYXRlO1xuIiwidmFyIHNjaGVtYSA9ICAgICAgcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi9zY2hlbWEuanMnKTtcbnZhciB1dGlsID0gICAgICAgIHJlcXVpcmUoX19kaXJuYW1lKycvLi4vdXRpbC5qcycpO1xudmFyIFR5cGVBbnkgPSAgICAgcmVxdWlyZShfX2Rpcm5hbWUrJy9hbnkuanMnKTtcbnZhciBUeXBlQXJyYXkgPSAgIHJlcXVpcmUoX19kaXJuYW1lKycvYXJyYXkuanMnKTtcbnZhciBUeXBlQm9vbGVhbiA9IHJlcXVpcmUoX19kaXJuYW1lKycvYm9vbGVhbi5qcycpO1xudmFyIFR5cGVCdWZmZXIgPSAgcmVxdWlyZShfX2Rpcm5hbWUrJy9idWZmZXIuanMnKTtcbnZhciBUeXBlRGF0ZSA9ICAgIHJlcXVpcmUoX19kaXJuYW1lKycvZGF0ZS5qcycpO1xudmFyIFR5cGVOdW1iZXIgPSAgcmVxdWlyZShfX2Rpcm5hbWUrJy9udW1iZXIuanMnKTtcbnZhciBUeXBlT2JqZWN0ID0gIHJlcXVpcmUoX19kaXJuYW1lKycvb2JqZWN0LmpzJyk7XG52YXIgVHlwZVBvaW50ID0gICByZXF1aXJlKF9fZGlybmFtZSsnL3BvaW50LmpzJyk7XG52YXIgVHlwZVN0cmluZyA9ICByZXF1aXJlKF9fZGlybmFtZSsnL3N0cmluZy5qcycpO1xudmFyIFR5cGVWaXJ0dWFsID0gcmVxdWlyZShfX2Rpcm5hbWUrJy92aXJ0dWFsLmpzJyk7XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVHlwZSB0aGF0IGxldCB1c2VycyBjcmVhdGUgc3ViLXR5cGVzLlxuICogQHJldHVybiB7VHlwZX1cbiAqL1xuZnVuY3Rpb24gVHlwZSgpIHsgfVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFR5cGVBbnkgb2JqZWN0XG4gKiBAcmV0dXJuIHtUeXBlQW55fVxuICovXG5cblR5cGUucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFR5cGVBbnkoKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUeXBlU3RyaW5nIG9iamVjdC5cbiAqIEByZXR1cm4ge1R5cGVTdHJpbmd9XG4gKi9cblR5cGUucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFR5cGVTdHJpbmcoKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUeXBlTnVtYmVyIG9iamVjdC5cbiAqIEByZXR1cm4ge1R5cGVOdW1iZXJ9XG4gKi9cblR5cGUucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFR5cGVOdW1iZXIoKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUeXBlQm9vbGVhbiBvYmplY3QuXG4gKiBAcmV0dXJuIHtUeXBlQm9vbGVhbn1cbiAqL1xuVHlwZS5wcm90b3R5cGUuYm9vbGVhbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFR5cGVCb29sZWFuKCk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVHlwZURhdGUgb2JqZWN0LlxuICogQHJldHVybiB7VHlwZURhdGV9XG4gKi9cblR5cGUucHJvdG90eXBlLmRhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRGF0ZSgpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFR5cGVCdWZmZXIgb2JqZWN0LlxuICogQHJldHVybiB7VHlwZUJ1ZmZlcn1cbiAqL1xuVHlwZS5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUJ1ZmZlcigpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFR5cGVQb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtUeXBlUG9pbnR9XG4gKi9cblR5cGUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVHlwZVBvaW50KCk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVHlwZU9iamVjdCBvYmplY3QuXG4gKiBAcmV0dXJuIHtUeXBlT2JqZWN0fVxuICovXG5UeXBlLnByb3RvdHlwZS5vYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlT2JqZWN0KCk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVHlwZUFycmF5IG9iamVjdC5cbiAqIEByZXR1cm4ge1R5cGVBcnJheX1cbiAqL1xuVHlwZS5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlQXJyYXkoKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUeXBlVmlydHVhbCBvYmplY3QuXG4gKiBAcmV0dXJuIHtUeXBlVmlydHVhbH1cbiAqL1xuVHlwZS5wcm90b3R5cGUudmlydHVhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFR5cGVWaXJ0dWFsKCk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVHlwZVN0cmluZyBvYmplY3QgdG8gdXNlIGFzIGFuIGlkLlxuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZS5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlU3RyaW5nKCkub3B0aW9uYWwoKTtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIFR5cGVTdHJpbmcgb2JqZWN0IG9yIG5vdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrIGFnYWluc3QgVHlwZVN0cmluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblR5cGUucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBUeXBlU3RyaW5nO1xufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgVHlwZU51bWJlciBvYmplY3Qgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgYWdhaW5zdCBUeXBlTnVtYmVyLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVHlwZS5wcm90b3R5cGUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFR5cGVOdW1iZXI7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBUeXBlQm9vbGVhbiBvYmplY3Qgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgYWdhaW5zdCBUeXBlQm9vbGVhbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblR5cGUucHJvdG90eXBlLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgVHlwZUJvb2xlYW47XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBUeXBlRGF0ZSBvYmplY3Qgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgYWdhaW5zdCBUeXBlRGF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblR5cGUucHJvdG90eXBlLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgVHlwZURhdGU7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBUeXBlQnVmZmVyIG9iamVjdCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjaGVjayBhZ2FpbnN0IFR5cGVCdWZmZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UeXBlLnByb3RvdHlwZS5pc0J1ZmZlciA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgVHlwZUJ1ZmZlcjtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIFR5cGVQb2ludCBvYmplY3Qgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgYWdhaW5zdCBUeXBlUG9pbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UeXBlLnByb3RvdHlwZS5pc1BvaW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBUeXBlUG9pbnQ7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBUeXBlT2JqZWN0IG9iamVjdCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjaGVjayBhZ2FpbnN0IFR5cGVPYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UeXBlLnByb3RvdHlwZS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgVHlwZU9iamVjdDtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIFR5cGVBcnJheSBvYmplY3Qgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgYWdhaW5zdCBUeXBlQXJyYXkuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UeXBlLnByb3RvdHlwZS5pc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBUeXBlQXJyYXk7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBUeXBlVmlydHVhbCBvYmplY3Qgb3Igbm90XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgYWdhaW5zdCBUeXBlVmlydHVhbC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblR5cGUucHJvdG90eXBlLmlzVmlydHVhbCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgVHlwZVZpcnR1YWw7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBUeXBlQW55IG9iamVjdCBvciBub3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjaGVjayBhZ2FpbnN0IFR5cGVBbnkuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UeXBlLnByb3RvdHlwZS5pc0FueSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgVHlwZUFueTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCk7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoX19kaXJuYW1lKycvLi4vdXRpbC5qcycpO1xudmFyIEVycm9ycyA9IHJlcXVpcmUoX19kaXJuYW1lKycvLi4vZXJyb3JzLmpzJyk7XG5cbmZ1bmN0aW9uIFR5cGVOdW1iZXIoKSB7XG4gIHRoaXMuX21pbiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbWF4ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9pbnRlZ2VyID0gZmFsc2U7XG4gIHRoaXMuX2RlZmF1bHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3ZhbGlkYXRvciA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fb3B0aW9ucyA9IHt9O1xufVxuXG5cblR5cGVOdW1iZXIucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSAgb3B0aW9ucy5lbmZvcmNlX21pc3NpbmdcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gb3B0aW9ucy5lbmZvcmNlX3R5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfZXh0cmEgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX2V4dHJhID0gb3B0aW9ucy5lbmZvcmNlX2V4dHJhXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVOdW1iZXIucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVOdW1iZXIucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZU51bWJlci5wcm90b3R5cGUuYWxsb3dOdWxsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID09PSAnc3RyaWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnbG9vc2UnXG4gICAgfVxuICAgIC8vIGVsc2UgYSBuby1vcCwgc3RyaWN0IC0+IHN0cmljdFxuICB9XG4gIGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlICE9PSAnbm9uZScpIHtcbiAgICAvLyBUaGUgdmFsdWUgaXMgbG9vc2Ugb3IgdW5kZWZpbmVkXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdsb29zZSdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBsb29zZSwgc28gaWYgd2UgY2FsbCBhbGxvd051bGwoZmFsc2UpLCBpdCBiZWNvbWVzIHN0cmljdFxuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnc3RyaWN0J1xuICAgIH1cbiAgfVxuICAvLyBlbHNlIG5vIG9wLCB0eXBlLmFueSgpIGlzIHRoZSBzYW1lIGFzIHR5cGUuYW55KCkuYWxsb3dOdWxsKDxib29sPilcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuXG5UeXBlTnVtYmVyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihtaW4pIHtcbiAgaWYgKCh0eXBlb2YobWluKSAhPT0gJ251bWJlcicpIHx8IChpc0Zpbml0ZShtaW4pID09IGZhbHNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVGhlIHZhbHVlIGZvciBgbWluYCBtdXN0IGJlIGEgZmluaXRlIG51bWJlclwiKTtcbiAgfVxuICB0aGlzLl9taW4gPSBtaW47XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVOdW1iZXIucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKG1heCkge1xuICBpZiAoKHR5cGVvZihtYXgpICE9PSAnbnVtYmVyJykgfHwgKGlzRmluaXRlKG1heCkgPT0gZmFsc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJUaGUgdmFsdWUgZm9yIGBtYXhgIG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyXCIpO1xuICB9XG4gIHRoaXMuX21heCA9IG1heDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZU51bWJlci5wcm90b3R5cGUuaW50ZWdlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9pbnRlZ2VyID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZU51bWJlci5wcm90b3R5cGUuZGVmYXVsdCA9IGZ1bmN0aW9uKGZuT3JWYWx1ZSkge1xuICB0aGlzLl9kZWZhdWx0ID0gZm5PclZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlTnVtYmVyLnByb3RvdHlwZS52YWxpZGF0b3IgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSBmbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlTnVtYmVyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKG51bWJlciwgcHJlZml4LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB1dGlsLm1lcmdlT3B0aW9ucyh0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcblxuICBpZiAodXRpbC52YWxpZGF0ZUlmVW5kZWZpbmVkKG51bWJlciwgcHJlZml4LCBcIm51bWJlclwiLCBvcHRpb25zKSkgcmV0dXJuO1xuXG4gIGlmICgodHlwZW9mIHRoaXMuX3ZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSAmJiAodGhpcy5fdmFsaWRhdG9yKG51bWJlcikgPT09IGZhbHNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsaWRhdG9yIGZvciB0aGUgZmllbGQgXCIrcHJlZml4K1wiIHJldHVybmVkIGBmYWxzZWAuXCIpO1xuICB9XG5cbiAgaWYodHlwZW9mIG51bWJlciA9PT0gJ3N0cmluZycpe1xuICAgIHZhciBudW1lcmljU3RyaW5nID0gcGFyc2VGbG9hdChudW1iZXIpO1xuICAgIGlmKCFpc05hTihudW1lcmljU3RyaW5nKSl7XG4gICAgICBudW1iZXIgPSBudW1lcmljU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmICgodHlwZW9mIG51bWJlciA9PT0gJ2Z1bmN0aW9uJykgJiYgKG51bWJlci5fcXVlcnkgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAvLyBXZSBkbyBub3QgY2hlY2sgUmVRTCB0ZXJtc1xuICB9XG4gIGVsc2UgaWYgKCh0eXBlb2YgbnVtYmVyICE9PSBcIm51bWJlclwiKSB8fCAoaXNGaW5pdGUobnVtYmVyKSA9PT0gZmFsc2UpKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlID09PSBcInN0cmljdFwiKSB7XG4gICAgICB1dGlsLnN0cmljdFR5cGUocHJlZml4LCBcImZpbml0ZSBudW1iZXJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJsb29zZVwiKSAmJiAobnVtYmVyICE9PSBudWxsKSkge1xuICAgICAgdXRpbC5sb29zZVR5cGUocHJlZml4LCBcImZpbml0ZSBudW1iZXJcIik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICgodGhpcy5fbWluICE9PSB1bmRlZmluZWQpICYmICh0aGlzLl9taW4gPiBudW1iZXIpKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBcIit0aGlzLl9taW4rXCIuXCIpXG4gICAgfVxuICAgIGlmICgodGhpcy5fbWF4ICE9PSB1bmRlZmluZWQpICYmICh0aGlzLl9tYXggPCBudW1iZXIpKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBcIit0aGlzLl9tYXgrXCIuXCIpXG4gICAgfVxuICAgIGlmICgodGhpcy5faW50ZWdlciA9PT0gdHJ1ZSkgJiYgKG51bWJlciAlIDEgIT09IDApKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGFuIGludGVnZXIuXCIpXG4gICAgfVxuICB9XG59XG5cblxuVHlwZU51bWJlci5wcm90b3R5cGUuX2dldERlZmF1bHRGaWVsZHMgPSBmdW5jdGlvbihwcmVmaXgsIGRlZmF1bHRGaWVsZHMsIHZpcnR1YWxGaWVsZHMpIHtcbiAgaWYgKHRoaXMuX2RlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlZmF1bHRGaWVsZHMucHVzaCh7XG4gICAgICBwYXRoOiBwcmVmaXgsXG4gICAgICB2YWx1ZTogdGhpcy5fZGVmYXVsdCxcbiAgICB9KTtcbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZU51bWJlcjtcbiIsInZhciB1dGlsID0gcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi91dGlsLmpzJyk7XG52YXIgRXJyb3JzID0gcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi9lcnJvcnMuanMnKTtcblxuZnVuY3Rpb24gVHlwZU9iamVjdCgpIHtcbiAgdGhpcy5fZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdmFsaWRhdG9yID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vcHRpb25zID0ge307XG4gIHRoaXMuX3NjaGVtYSA9IHt9O1xufVxuXG5cblR5cGVPYmplY3QucHJvdG90eXBlLl9zZXRNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVPYmplY3QucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSAgb3B0aW9ucy5lbmZvcmNlX21pc3NpbmdcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gb3B0aW9ucy5lbmZvcmNlX3R5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfZXh0cmEgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX2V4dHJhID0gb3B0aW9ucy5lbmZvcmNlX2V4dHJhXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVPYmplY3QucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVPYmplY3QucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZU9iamVjdC5wcm90b3R5cGUuYWxsb3dOdWxsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID09PSAnc3RyaWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnbG9vc2UnXG4gICAgfVxuICAgIC8vIGVsc2UgYSBuby1vcCwgc3RyaWN0IC0+IHN0cmljdFxuICB9XG4gIGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlICE9PSAnbm9uZScpIHtcbiAgICAvLyBUaGUgdmFsdWUgaXMgbG9vc2Ugb3IgdW5kZWZpbmVkXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdsb29zZSdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBsb29zZSwgc28gaWYgd2UgY2FsbCBhbGxvd051bGwoZmFsc2UpLCBpdCBiZWNvbWVzIHN0cmljdFxuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnc3RyaWN0J1xuICAgIH1cbiAgfVxuICAvLyBlbHNlIG5vIG9wLCB0eXBlLmFueSgpIGlzIHRoZSBzYW1lIGFzIHR5cGUuYW55KCkuYWxsb3dOdWxsKDxib29sPilcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZU9iamVjdC5wcm90b3R5cGUuYWxsb3dFeHRyYSA9IGZ1bmN0aW9uKGFsbG93ZWQpIHtcbiAgaWYgKGFsbG93ZWQgPT09IHRydWUpIHtcbiAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfZXh0cmEgPSAnbm9uZSc7XG4gIH1cbiAgZWxzZSBpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfZXh0cmEgPSAnc3RyaWN0JztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlT2JqZWN0LnByb3RvdHlwZS5yZW1vdmVFeHRyYSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfZXh0cmEgPSAncmVtb3ZlJztcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZU9iamVjdC5wcm90b3R5cGUuc2NoZW1hID0gZnVuY3Rpb24oc2NoZW1hKSB7XG4gIC8vIFVzZXJzIHNob3VsZG4ndCB1c2UgdGhlIGRlcHJlY2F0ZWQgc3ludGF4IHdpdGggdGhlIGNoYWluYWJsZSBvbmVcbiAgLy8gV2UgZG8gbm90IHBhcnNlIHRoZSBzY2hlbWEgYXMgd2UgZG9uJ3QgaGF2ZSB0aGUgY3VycmVudCBwcmVmaXgsIG9wdGlvbnMgZXRjLlxuICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVPYmplY3QucHJvdG90eXBlLnNldEtleSA9IGZ1bmN0aW9uKGtleSwgc2NoZW1hKSB7XG4gIHRoaXMuX3NjaGVtYVtrZXldID0gc2NoZW1hO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlT2JqZWN0LnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZm5PclZhbHVlKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSBmbk9yVmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVPYmplY3QucHJvdG90eXBlLnZhbGlkYXRvciA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRoaXMuX3ZhbGlkYXRvciA9IGZuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVPYmplY3QucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24ob2JqZWN0LCBwcmVmaXgsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9jYWxPcHRpb25zID0gdXRpbC5tZXJnZU9wdGlvbnModGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgaWYgKHV0aWwudmFsaWRhdGVJZlVuZGVmaW5lZChvYmplY3QsIHByZWZpeCwgXCJvYmplY3RcIiwgbG9jYWxPcHRpb25zKSkgcmV0dXJuO1xuXG4gIGlmICgodHlwZW9mIHNlbGYuX3ZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSAmJiAoc2VsZi5fdmFsaWRhdG9yKG9iamVjdCkgPT09IGZhbHNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsaWRhdG9yIGZvciB0aGUgZmllbGQgXCIrcHJlZml4K1wiIHJldHVybmVkIGBmYWxzZWAuXCIpO1xuICB9XG5cbiAgaWYgKCh0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nKSAmJiAob2JqZWN0Ll9xdWVyeSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIC8vIFdlIGRvIG5vdCBjaGVjayBSZVFMIHRlcm1zXG4gIH1cbiAgZWxzZSBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgaWYgKGxvY2FsT3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgIHV0aWwuc3RyaWN0VHlwZShwcmVmaXgsIFwib2JqZWN0XCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgobG9jYWxPcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJsb29zZVwiKSAmJiAob2JqZWN0ICE9PSBudWxsKSkge1xuICAgICAgdXRpbC5sb29zZVR5cGUocHJlZml4LCBcIm9iamVjdFwiKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdXRpbC5sb29wS2V5cyhzZWxmLl9zY2hlbWEsIGZ1bmN0aW9uKHNjaGVtYSwga2V5KSB7XG4gICAgICBzY2hlbWFba2V5XS52YWxpZGF0ZShvYmplY3Rba2V5XSwgcHJlZml4K1wiW1wiK2tleStcIl1cIiwgb3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBXZSBjbGVhbiBleHRyYSBmaWVsZHMgaW4gdmFsaWRhdGUsIGZvciBhIHVzZSBjYXNlLCBzZWU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25ldW1pbm8vdGhpbmt5L3B1bGwvMTIzI2lzc3VlY29tbWVudC01NjI1NDY4MlxuICAgIGlmIChsb2NhbE9wdGlvbnMuZW5mb3JjZV9leHRyYSA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgdXRpbC5sb29wS2V5cyhvYmplY3QsIGZ1bmN0aW9uKG9iamVjdCwga2V5KSB7XG4gICAgICAgIGlmICgoc2VsZi5fbW9kZWwgPT09IHVuZGVmaW5lZCB8fCBzZWxmLl9tb2RlbC5fam9pbnMuaGFzT3duUHJvcGVydHkoa2V5KSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAmJiAoc2VsZi5fc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2NhbE9wdGlvbnMuZW5mb3JjZV9leHRyYSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgdXRpbC5sb29wS2V5cyhvYmplY3QsIGZ1bmN0aW9uKG9iamVjdCwga2V5KSB7XG4gICAgICAgIGlmICgoc2VsZi5fbW9kZWwgPT09IHVuZGVmaW5lZCB8fCBzZWxmLl9tb2RlbC5fam9pbnMuaGFzT3duUHJvcGVydHkoa2V5KSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAmJiAoc2VsZi5fc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICB1dGlsLmV4dHJhRmllbGQocHJlZml4LCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuXG5UeXBlT2JqZWN0LnByb3RvdHlwZS5fZ2V0RGVmYXVsdEZpZWxkcyA9IGZ1bmN0aW9uKHByZWZpeCwgZGVmYXVsdEZpZWxkcywgdmlydHVhbEZpZWxkcykge1xuICBpZiAodGhpcy5fZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmYXVsdEZpZWxkcy5wdXNoKHtcbiAgICAgIHBhdGg6IHByZWZpeCxcbiAgICAgIHZhbHVlOiB0aGlzLl9kZWZhdWx0LFxuICAgIH0pO1xuICB9XG4gIGlmICh0aGlzLl9zY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgIHV0aWwubG9vcEtleXModGhpcy5fc2NoZW1hLCBmdW5jdGlvbihfc2NoZW1hLCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgX3NjaGVtYVtrZXldLl9nZXREZWZhdWx0RmllbGRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKF9zY2hlbWEpO1xuICAgICAgICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhfc2NoZW1hW2tleV0pO1xuICAgICAgfVxuICAgICAgX3NjaGVtYVtrZXldLl9nZXREZWZhdWx0RmllbGRzKHByZWZpeC5jb25jYXQoa2V5KSwgZGVmYXVsdEZpZWxkcywgdmlydHVhbEZpZWxkcyk7XG4gICAgfSlcbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZU9iamVjdDtcbiIsInZhciB1dGlsID0gcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi91dGlsLmpzJyk7XG52YXIgRXJyb3JzID0gcmVxdWlyZShfX2Rpcm5hbWUrJy8uLi9lcnJvcnMuanMnKTtcblxuZnVuY3Rpb24gVHlwZVBvaW50KCkge1xuICB0aGlzLl9kZWZhdWx0ID0gdW5kZWZpbmVkO1xuICB0aGlzLl92YWxpZGF0b3IgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX29wdGlvbnMgPSB7fTtcbn1cblxuXG5UeXBlUG9pbnQucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSAgb3B0aW9ucy5lbmZvcmNlX21pc3NpbmdcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV90eXBlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID0gb3B0aW9ucy5lbmZvcmNlX3R5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfZXh0cmEgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX2V4dHJhID0gb3B0aW9ucy5lbmZvcmNlX2V4dHJhXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVQb2ludC5wcm90b3R5cGUub3B0aW9uYWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX21pc3NpbmcgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZVBvaW50LnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVQb2ludC5wcm90b3R5cGUuYWxsb3dOdWxsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID09PSAnc3RyaWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnbG9vc2UnXG4gICAgfVxuICAgIC8vIGVsc2UgYSBuby1vcCwgc3RyaWN0IC0+IHN0cmljdFxuICB9XG4gIGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlICE9PSAnbm9uZScpIHtcbiAgICAvLyBUaGUgdmFsdWUgaXMgbG9vc2Ugb3IgdW5kZWZpbmVkXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdsb29zZSdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBsb29zZSwgc28gaWYgd2UgY2FsbCBhbGxvd051bGwoZmFsc2UpLCBpdCBiZWNvbWVzIHN0cmljdFxuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnc3RyaWN0J1xuICAgIH1cbiAgfVxuICAvLyBlbHNlIG5vIG9wLCB0eXBlLmFueSgpIGlzIHRoZSBzYW1lIGFzIHR5cGUuYW55KCkuYWxsb3dOdWxsKDxib29sPilcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuVHlwZVBvaW50LnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZm5PclZhbHVlKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSBmbk9yVmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cblR5cGVQb2ludC5wcm90b3R5cGUudmFsaWRhdG9yID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICB0aGlzLl92YWxpZGF0b3IgPSBmbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5UeXBlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24ocG9pbnQsIHByZWZpeCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gdXRpbC5tZXJnZU9wdGlvbnModGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgaWYgKHV0aWwudmFsaWRhdGVJZlVuZGVmaW5lZChwb2ludCwgcHJlZml4LCBcInBvaW50XCIsIG9wdGlvbnMpKSByZXR1cm47XG5cbiAgaWYgKCh0eXBlb2YgdGhpcy5fdmFsaWRhdG9yID09PSBcImZ1bmN0aW9uXCIpICYmICh0aGlzLl92YWxpZGF0b3IocG9pbnQpID09PSBmYWxzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbGlkYXRvciBmb3IgdGhlIGZpZWxkIFwiK3ByZWZpeCtcIiByZXR1cm5lZCBgZmFsc2VgLlwiKTtcbiAgfVxuXG4gIGlmICh1dGlsLmlzUGxhaW5PYmplY3QocG9pbnQpICYmIChwb2ludFtcIiRyZXFsX3R5cGUkXCJdID09PSBcIkdFT01FVFJZXCIpKSB7XG4gICAgaWYgKHBvaW50LnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXRpbC5wc2V1ZG9UeXBlRXJyb3IoXCJQb2ludFwiLCBcInR5cGVcIiwgcHJlZml4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocG9pbnQudHlwZSAhPT0gXCJQb2ludFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSBmaWVsZCBgdHlwZWAgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGAnUG9pbnQnYC5cIilcbiAgICB9XG4gICAgZWxzZSBpZiAocG9pbnQuY29vcmRpbmF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXRpbC5wc2V1ZG9UeXBlRXJyb3IoXCJkYXRlXCIsIFwiY29vcmRpbmF0ZXNcIiwgcHJlZml4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKCFBcnJheS5pc0FycmF5KHBvaW50LmNvb3JkaW5hdGVzKSkgfHwgKHBvaW50LmNvb3JkaW5hdGVzLmxlbmd0aCAhPT0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVGhlIGZpZWxkIGBjb29yZGluYXRlc2AgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGFuIEFycmF5IG9mIHR3byBudW1iZXJzLlwiKVxuICAgIH1cbiAgfVxuICBlbHNlIGlmICh1dGlsLmlzUGxhaW5PYmplY3QocG9pbnQpICYmIChwb2ludC50eXBlID09PSBcIlBvaW50XCIpICYmIChBcnJheS5pc0FycmF5KHBvaW50LmNvb3JkaW5hdGVzKSkgJiYgKHBvaW50LmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMikpIHsgLy8gR2VvanNvblxuICAgIC8vIEdlb2pzb24gZm9ybWF0XG4gIH1cbiAgZWxzZSBpZiAoKHR5cGVvZiBwb2ludCA9PT0gJ2Z1bmN0aW9uJykgJiYgKHBvaW50Ll9xdWVyeSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIC8vIFRPSU1QUk92RSAtLSB3ZSBjdXJyZW50bHkganVzdCBjaGVjayBpZiBpdCdzIGEgdGVybSBmcm9tIHRoZSBkcml2ZXJcbiAgICAvLyBXZSBzdXBwb3NlIGZvciBub3cgdGhhdCB0aGlzIGlzIGVub3VnaCBhbmQgd2UgZG9uJ3QgdGhyb3cgYW4gZXJyb3JcbiAgfVxuICBlbHNlIGlmICh1dGlsLmlzUGxhaW5PYmplY3QocG9pbnQpKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwb2ludCkuc29ydCgpO1xuICAgIGlmICgoKGtleXMubGVuZ3RoICE9PSAyKSB8fCBrZXlzWzBdICE9PSAnbGF0aXR1ZGUnKSB8fCAoa2V5c1sxXSAhPT0gJ2xvbmdpdHVkZScpIHx8ICh0eXBlb2YgcG9pbnQubGF0aXR1ZGUgIT09IFwibnVtYmVyXCIpIHx8ICh0eXBlb2YgcG9pbnQubG9uZ2l0dWRlICE9PSBcIm51bWJlclwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJUaGUgdmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGEgUmVRTCBQb2ludCAoYHIucG9pbnQoPGxvbmdpdHVkZT4sIDxsYXRpdHVkZT4pYCksIGFuIG9iamVjdCBge2xvbmdpdHVkZTogPG51bWJlcj4sIGxhdGl0dWRlOiA8bnVtYmVyPn1gLCBvciBhbiBhcnJheSBbPGxvbmdpdHVkZT4sIDxsYXRpdHVkZT5dLlwiKVxuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZW9mIHBvaW50LmxhdGl0dWRlICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBwb2ludC5sYXRpdHVkZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSB2YWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYSBSZVFMIFBvaW50IChgci5wb2ludCg8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPilgKSwgYW4gb2JqZWN0IGB7bG9uZ2l0dWRlOiA8bnVtYmVyPiwgbGF0aXR1ZGU6IDxudW1iZXI+fWAsIG9yIGFuIGFycmF5IFs8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPl0uXCIpXG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocG9pbnQpKSB7XG4gICAgaWYgKChwb2ludC5sZW5ndGggIT09IDIpIHx8ICh0eXBlb2YgcG9pbnRbMF0gIT09IFwibnVtYmVyXCIpIHx8ICh0eXBlb2YgcG9pbnRbMV0gIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSB2YWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYSBSZVFMIFBvaW50IChgci5wb2ludCg8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPilgKSwgYW4gb2JqZWN0IGB7bG9uZ2l0dWRlOiA8bnVtYmVyPiwgbGF0aXR1ZGU6IDxudW1iZXI+fWAsIG9yIGFuIGFycmF5IFs8bG9uZ2l0dWRlPiwgPGxhdGl0dWRlPl0uXCIpXG4gICAgfVxuICB9XG4gIGVsc2UgeyAvLyBXZSBkb24ndCBoYXZlIGEgcG9pbnRcbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgIHV0aWwuc3RyaWN0VHlwZShwcmVmaXgsIFwiUG9pbnRcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJsb29zZVwiKSAmJiAocG9pbnQgIT09IG51bGwpKSB7XG4gICAgICB1dGlsLmxvb3NlVHlwZShwcmVmaXgsIFwiUG9pbnRcIik7XG4gICAgfVxuICB9XG59XG5cblxuVHlwZVBvaW50LnByb3RvdHlwZS5fZ2V0RGVmYXVsdEZpZWxkcyA9IGZ1bmN0aW9uKHByZWZpeCwgZGVmYXVsdEZpZWxkcywgdmlydHVhbEZpZWxkcykge1xuICBpZiAodGhpcy5fZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmYXVsdEZpZWxkcy5wdXNoKHtcbiAgICAgIHBhdGg6IHByZWZpeCxcbiAgICAgIHZhbHVlOiB0aGlzLl9kZWZhdWx0LFxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZVBvaW50O1xuIiwidmFyIHV0aWwgPSAgICAgICByZXF1aXJlKF9fZGlybmFtZSsnLy4uL3V0aWwuanMnKTtcbnZhciB2YWxpZGF0b3IgPSAgcmVxdWlyZShcInZhbGlkYXRvclwiKTtcbnZhciBFcnJvcnMgPSByZXF1aXJlKF9fZGlybmFtZSsnLy4uL2Vycm9ycy5qcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUeXBlU3RyaW5nIG9iamVjdFxuICovXG5mdW5jdGlvbiBUeXBlU3RyaW5nKCkge1xuICAvKipcbiAgICogTWluaW11bSBsZW5ndGggb2YgdGhlIHN0cmluZywgbmVnYXRpdmUgaWYgbm8gbWluaW11bSBsZW5ndGggaXMgcmVxdWlyZWQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9taW4gPSAtMTtcbiAgLyoqXG4gICAqIE1heGltdW0gbGVuZ3RoIG9mIHRoZSBzdHJpbmcsIG5lZ2F0aXZlIGlmIG5vIG1heGltdW0gbGVuZ3RoIGlzIHJlcXVpcmVkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fbWF4ID0gLTE7XG4gIC8qKlxuICAgKiBMZW5ndGggb2YgdGhlIHN0cmluZywgbmVnYXRpdmUgaWYgbm8gbGVuZ3RoIGlzIHJlcXVpcmVkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fbGVuZ3RoID0gLTE7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdHJpbmcgbXVzdCBiZSBhbHBoYW51bWVyaWMgb3Igbm90LiBXZSB1c2VkIHRoZSBucG0gdmFsaWRhdG9yXG4gICAqIHBhY2thZ2UsIGFuZCBhcyAyMDE0LzEyLzE0LCBpdCBjaGVjayBhZ2FpbnN0IHRoZSByZWdleCBbYS16QS1aMC05XVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuX2FscGhhbnVtID0gZmFsc2U7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgc3RyaW5nIG11c3QgYmUgdXBwZXJjYXNlIG9yIG5vdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLl91cHBlcmNhc2UgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuX2xvd2VyY2FzZSA9IGZhbHNlO1xuICAvKlxuICAgKiBUaGUgcmVnZXggYWdhaW5zdCB3aGljaCB0aGUgc3RyaW5nIG11c3QgY29uZm9ybS4gVW5kZWZpbmVkIGlmIHRoZSBzdHJpbmdcbiAgICogZG9lcyBub3QgaGF2ZSB0byBjb25mb3JtIHRvIGEgUmVnRXhwLlxuICAgKiBAdHlwZSB7UmVnRXhwPX1cbiAgICovXG4gIHRoaXMuX3JlZ2V4ID0gdW5kZWZpbmVkO1xuICAvKipcbiAgICogVGhlIHZhbGlkYXRvciBjYWxsZWQgd2l0aCB0aGUgc3RyaW5nIG11c3QgcmV0dXJuIHt0cnVlfSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLFxuICAgKiB7ZmFsc2V9IGlmIHRoZSBzdHJpbmcgaXMgbm90LlxuICAgKiBAdHlwZSB7ZnVuY3Rpb24oc3RyaW5nKT19XG4gICAqL1xuICB0aGlzLl9lbnVtID0gdW5kZWZpbmVkO1xuICAvKipcbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgZmllbGQgb3IgYSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICogQHR5cGUge2Z1bmN0aW9ufHN0cmluZ31cbiAgICovXG4gIHRoaXMuX2RlZmF1bHQgPSB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgc3RyaW5nIG11c3QgYmUgYSB1dWlkIG9yIG5vdC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX3V1aWQgPSB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciB0aGlzIHR5cGUgXCJlbmZvcmNlX21pc3NpbmdcIiwgXCJlbmZvcmNlX3R5cGVcIiwgXCJlbmZvcmNlX2V4dHJhXCJcbiAgICogQHR5cGUge09iamVjdD19XG4gICAqL1xuICB0aGlzLl92YWxpZGF0b3IgPSB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIGFjY2VwdGFibGUgdmFsdWVzIGZvciB0aGUgc3RyaW5nLiBVbmRlZmluZWQgaWYgdGhpc1xuICAgKiBpcyBub3QgYSByZXF1aXJlbWVudC5cbiAgICogQHR5cGUge09iamVjdD19XG4gICAqL1xuICB0aGlzLl9vcHRpb25zID0ge307XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIG9wdGlvbnMgZm9yIHRoaXMgZmllbGQuXG4gKiBAcGFyYW0geyFvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoaXMgZmllbGQuIFRoZSB2YWxpZCBmaWVsZHMgYXJlOlxuICogIC0gYGVuZm9yY2VfbWlzc2luZ2Age2Jvb2xlYW59LCBkZWZhdWx0IGBmYWxzZWBcbiAqICAtIGBlbmZvcmNlX2V4dHJhYCB7XCJzdHJpY3RcInxcInJlbW92ZVwifFwibm9uZVwifSwgZGVmYXVsdCBgXCJub25lXCJgXG4gKiAgLSBgZW5mb3JjZV90eXBlYCB7XCJzdHJpY3RcInxcImxvb3NlXCJ8XCJub25lXCJ9LCBkZWZhdWx0IGBcImxvb3NlXCJgXG4gKiBAcmV0dXJuIHtUeXBlU3RyaW5nfVxuICovXG5UeXBlU3RyaW5nLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gIG9wdGlvbnMuZW5mb3JjZV9taXNzaW5nXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfdHlwZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9IG9wdGlvbnMuZW5mb3JjZV90eXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlX2V4dHJhICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9leHRyYSA9IG9wdGlvbnMuZW5mb3JjZV9leHRyYVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgcHJvcGVydHkgYXMgb3B0aW9uYWwgKGVuZm9yY2VfbWlzc2luZyA9IGZhbHNlKS5cbiAqIExlYXZlcyBvdGhlciBleGlzdGluZyBvcHRpb25zIHVuY2hhbmdlZC5cbiAqIEByZXR1cm4ge1R5cGVTdHJpbmd9XG4gKi9cblR5cGVTdHJpbmcucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29wdGlvbnMuZW5mb3JjZV9taXNzaW5nID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSBwcm9wZXJ0eSBhcyByZXF1aXJlZCAoZW5mb3JjZV9taXNzaW5nID0gdHJ1ZSkuXG4gKiBMZWF2ZXMgb3RoZXIgZXhpc3Rpbmcgb3B0aW9ucyB1bmNoYW5nZWQuXG4gKiBAcmV0dXJuIHtUeXBlU3RyaW5nfVxuICovXG5UeXBlU3RyaW5nLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSBwcm9wZXJ0eSBhcyBub3Qgc3RyaWN0IChudWxsIGFsbG93ZWQsIGVuZm9yY2VfbWlzc2luZyA9IHRydWUpLlxuICogTGVhdmVzIG90aGVyIGV4aXN0aW5nIG9wdGlvbnMgdW5jaGFuZ2VkLlxuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZVN0cmluZy5wcm90b3R5cGUuYWxsb3dOdWxsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlID09PSAnc3RyaWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnbG9vc2UnXG4gICAgfVxuICAgIC8vIGVsc2UgYSBuby1vcCwgc3RyaWN0IC0+IHN0cmljdFxuICB9XG4gIGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuZW5mb3JjZV90eXBlICE9PSAnbm9uZScpIHtcbiAgICAvLyBUaGUgdmFsdWUgaXMgbG9vc2Ugb3IgdW5kZWZpbmVkXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmVuZm9yY2VfdHlwZSA9ICdsb29zZSdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBsb29zZSwgc28gaWYgd2UgY2FsbCBhbGxvd051bGwoZmFsc2UpLCBpdCBiZWNvbWVzIHN0cmljdFxuICAgICAgdGhpcy5fb3B0aW9ucy5lbmZvcmNlX3R5cGUgPSAnc3RyaWN0J1xuICAgIH1cbiAgfVxuICAvLyBlbHNlIG5vIG9wLCB0eXBlLmFueSgpIGlzIHRoZSBzYW1lIGFzIHR5cGUuYW55KCkuYWxsb3dOdWxsKDxib29sPilcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gbGVuZ3RoIGFsbG93ZWQgZm9yIGEgc3RyaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBNaW5pbXVtIGxlbmd0aCBmb3IgdGhlIHN0cmluZ1xuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZVN0cmluZy5wcm90b3R5cGUubWluID0gZnVuY3Rpb24obWluKSB7XG4gIGlmIChtaW4gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJUaGUgdmFsdWUgZm9yIGBtaW5gIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG4gIHRoaXMuX21pbiA9IG1pbjtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gbGVuZ3RoIGFsbG93ZWQgZm9yIGEgc3RyaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBNaW5pbXVtIGxlbmd0aCBmb3IgdGhlIHN0cmluZ1xuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZVN0cmluZy5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24obWF4KSB7XG4gIGlmIChtYXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJUaGUgdmFsdWUgZm9yIGBtYXhgIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG4gIHRoaXMuX21heCA9IG1heDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIGxlbmd0aCBhbGxvd2VkIGZvciBhIHN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gTWluaW11bSBsZW5ndGggZm9yIHRoZSBzdHJpbmdcbiAqIEByZXR1cm4ge1R5cGVTdHJpbmd9XG4gKi9cblR5cGVTdHJpbmcucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVGhlIHZhbHVlIGZvciBgbGVuZ3RoYCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgfVxuICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSByZWdleCB0aGF0IHRoZSBzdHJpbmcgbXVzdCBtYXRjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdleCBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWdleFxuICogQHBhcmFtIHtzdHJpbmd9IGZsYWdzIFRoZSBmbGFncyB1c2VkIHdoZW4gY2FsbGluZyBuZXcgUmVnRXhwKC4uLilcbiAqIEByZXR1cm4ge1R5cGVTdHJpbmd9XG4gKi9cblR5cGVTdHJpbmcucHJvdG90eXBlLnJlZ2V4ID0gZnVuY3Rpb24ocmVnZXgsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZmxhZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLl9yZWdleCA9IG5ldyBSZWdFeHAocmVnZXgsIGZsYWdzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLl9yZWdleCA9IG5ldyBSZWdFeHAocmVnZXgpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSBzdHJpbmcgdG8gYmUgYWxwaGFudW1lcmljLlxuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZVN0cmluZy5wcm90b3R5cGUuYWxwaGFudW0gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYWxwaGFudW0gPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgc3RyaW5nIHRvIGJlIGFuIGVtYWlsLlxuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZVN0cmluZy5wcm90b3R5cGUuZW1haWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZW1haWwgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgc3RyaW5nIHRvIGJlIGxvd2VyY2FzZS5cbiAqIEByZXR1cm4ge1R5cGVTdHJpbmd9XG4gKi9cblR5cGVTdHJpbmcucHJvdG90eXBlLmxvd2VyY2FzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9sb3dlcmNhc2UgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgc3RyaW5nIHRvIGJlIHVwcGVyY2FzZS5cbiAqIEByZXR1cm4ge1R5cGVTdHJpbmd9XG4gKi9cblR5cGVTdHJpbmcucHJvdG90eXBlLnVwcGVyY2FzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cHBlcmNhc2UgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBzdHJpbmcsIG9yIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2VuZXJhdGVcbiAqIHRoZSBkZWZhdWx0IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gZm5PclZhbHVlXG4gKiBAcmV0dXJuIHtUeXBlU3RyaW5nfVxuICovXG5UeXBlU3RyaW5nLnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24oZm5PclZhbHVlKSB7XG4gIHRoaXMuX2RlZmF1bHQgPSBmbk9yVmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3RyaW5nIHRvIGJlIGEgdXVpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtUeXBlU3RyaW5nfVxuICovXG5UeXBlU3RyaW5nLnByb3RvdHlwZS51dWlkID0gZnVuY3Rpb24odmVyc2lvbikge1xuICBpZiAoaXNOYU4odmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlRoZSB2YWx1ZSBmb3IgYHZlcnNpb25gIG11c3QgYmUgYSBudW1iZXIuXCIpO1xuICB9XG4gIGlmICh2ZXJzaW9uIDwgMyB8fCB2ZXJzaW9uID4gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVGhlIHZhbHVlIGZvciBgdmVyc2lvbmAgbXVzdCBiZSBlaXRoZXIgMywgNCBvciA1XCIpO1xuICB9XG4gIHRoaXMuX3V1aWQgPSB2ZXJzaW9uO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFNldCBhIGN1c3RvbSB2YWxpZGF0b3IgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBzdHJpbmcuIFRoZSB2YWxpZGF0b3JcbiAqIHNob3VsZCByZXR1cm4gYSBib29sZWFuIHdoZXRoZXIgdGhlIGZpZWxkIGlzIHZhbGlkIG9yIG5vdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtUeXBlU3RyaW5nfVxuICovXG5UeXBlU3RyaW5nLnByb3RvdHlwZS52YWxpZGF0b3IgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSBmbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgdmFsaWQgdmFsdWVzIGZvciB0aGlzIGZpZWxkLiBUaGUgYXJndW1lbnRzIG11c3QgYmUgc3RyaW5nc1xuICogb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfEFycmF5LjxzdHJpbmc+fSBmblxuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZVN0cmluZy5wcm90b3R5cGUuZW51bSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpICYmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpKSB7XG4gICAgdGhpcy5fZW51bSA9IHt9O1xuICAgIGZvcih2YXIgaT0wOyBpPGFyZ3VtZW50c1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZW51bVthcmd1bWVudHNbMF1baV1dID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHx8IChhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICB0aGlzLl9lbnVtID0ge307XG4gICAgZm9yKHZhciBpPTA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lbnVtW2FyZ3VtZW50c1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBzdHJpbmcgZ2l2ZW4gb3B0aW9uYWwgb3B0aW9ucywgYW5kIHRocm93IGFuIGVycm9yIGluIGNhc2VcbiAqIHRoZSBmaWVsZCBpcyBub3QgdmFsaWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggbGVhZGluZyB0byBgc3RyYC5cbiAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIHRvIG92ZXJ3cml0ZSB0aGUgb25lIGRlZmluZWQgZm9yIHRoZSBmaWVsZC5cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5UeXBlU3RyaW5nLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKHN0ciwgcHJlZml4LCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyA9IHV0aWwubWVyZ2VPcHRpb25zKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIGlmICh1dGlsLnZhbGlkYXRlSWZVbmRlZmluZWQoc3RyLCBwcmVmaXgsIFwic3RyaW5nXCIsIF9vcHRpb25zKSkgcmV0dXJuO1xuXG4gIGlmICgodHlwZW9mIHRoaXMuX3ZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSAmJiAodGhpcy5fdmFsaWRhdG9yKHN0cikgPT09IGZhbHNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsaWRhdG9yIGZvciB0aGUgZmllbGQgXCIrcHJlZml4K1wiIHJldHVybmVkIGBmYWxzZWAuXCIpO1xuICB9XG5cblxuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdmdW5jdGlvbicpICYmIChzdHIuX3F1ZXJ5ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgLy8gV2UgZG8gbm90IGNoZWNrIFJlUUwgdGVybXNcbiAgfVxuICBlbHNlIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKF9vcHRpb25zLmVuZm9yY2VfdHlwZSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgdXRpbC5zdHJpY3RUeXBlKHByZWZpeCwgXCJzdHJpbmdcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChfb3B0aW9ucy5lbmZvcmNlX3R5cGUgPT09IFwibG9vc2VcIikgJiYgKHN0ciAhPT0gbnVsbCkpIHtcbiAgICAgIHV0aWwubG9vc2VUeXBlKHByZWZpeCwgXCJzdHJpbmdcIik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICgodGhpcy5fbWluICE9PSAtMSkgJiYgKHRoaXMuX21pbiA+IHN0ci5sZW5ndGgpKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IG5vdCBiZSBzaG9ydGVyIHRoYW4gXCIrdGhpcy5fbWluK1wiLlwiKVxuICAgIH1cbiAgICBpZiAoKHRoaXMuX21heCAhPT0gLTEpICYmICh0aGlzLl9tYXggPCBzdHIubGVuZ3RoKSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbHVlIGZvciBcIitwcmVmaXgrXCIgbXVzdCBub3QgYmUgbG9uZ2VyIHRoYW4gXCIrdGhpcy5fbWF4K1wiLlwiKVxuICAgIH1cbiAgICBpZiAoKHRoaXMuX2xlbmd0aCAhPT0gLTEpICYmICh0aGlzLl9sZW5ndGggIT09IHN0ci5sZW5ndGgpKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGEgc3RyaW5nIHdpdGggXCIrdGhpcy5fbGVuZ3RoK1wiIGNoYXJhY3RlcnMuXCIpXG4gICAgfVxuICAgIGlmICgodGhpcy5fcmVnZXggaW5zdGFuY2VvZiBSZWdFeHApICYmICh0aGlzLl9yZWdleC50ZXN0KHN0cikgPT09IGZhbHNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgbWF0Y2ggdGhlIHJlZ2V4LlwiKVxuICAgIH1cbiAgICBpZiAoKHRoaXMuX2FscGhhbnVtID09PSB0cnVlKSAmJiAodmFsaWRhdG9yLmlzQWxwaGFudW1lcmljKHN0cikgPT09IGZhbHNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYW4gYWxwaGFudW1lcmljIHN0cmluZy5cIilcbiAgICB9XG4gICAgaWYgKCh0aGlzLl9lbWFpbCA9PT0gdHJ1ZSkgJiYgKHZhbGlkYXRvci5pc0VtYWlsKHN0cikgPT09IGZhbHNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYSB2YWxpZCBlbWFpbC5cIilcbiAgICB9XG4gICAgaWYgKCh0aGlzLl9sb3dlcmNhc2UgPT09IHRydWUpICYmICh2YWxpZGF0b3IuaXNMb3dlcmNhc2Uoc3RyKSA9PT0gZmFsc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbHVlIGZvciBcIitwcmVmaXgrXCIgbXVzdCBiZSBhIGxvd2VyY2FzZSBzdHJpbmcuXCIpXG4gICAgfVxuICAgIGlmICgodGhpcy5fdXBwZXJjYXNlID09PSB0cnVlKSAmJiAodmFsaWRhdG9yLmlzVXBwZXJjYXNlKHN0cikgPT09IGZhbHNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYSB1cHBlcmNhc2Ugc3RyaW5nLlwiKVxuICAgIH1cbiAgICBpZiAoKHRoaXMuX3V1aWQgIT09IHVuZGVmaW5lZCkgJiYgKHZhbGlkYXRvci5pc1VVSUQoc3RyLCB0aGlzLl91dWlkKSA9PT0gZmFsc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIlZhbHVlIGZvciBcIitwcmVmaXgrXCIgbXVzdCBiZSBhIHV1aWQgc3RyaW5nLlwiKVxuICAgIH1cbiAgICBpZiAoKHRoaXMuX2VudW0gIT09IHVuZGVmaW5lZCkgJiYgKHRoaXMuX2VudW1bc3RyXSAhPT0gdHJ1ZSkpIHtcbiAgICAgIHZhciB2YWxpZFZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMuX2VudW0pO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSBmaWVsZCBcIitwcmVmaXgrXCIgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiBcIlxuXG4gICAgICBmb3IodmFyIGk9MDsgaTx2YWxpZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gMTApIHsgYnJlYWs7IH1cbiAgICAgICAgaWYgKChpID09PSB2YWxpZFZhbHVlcy5sZW5ndGgtMSkgfHwgKGkgPT09IDkpKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UrdmFsaWRWYWx1ZXNbaV1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSt2YWxpZFZhbHVlc1tpXStcIiwgXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbGlkVmFsdWVzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlK1wiLi4uXCJcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZStcIi5cIlxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIExvb2sgZm9yIGEgZGVmYXVsdCB2YWx1ZSBvciBkZWZhdWx0IGZ1bmN0aW9uLCBhbmQgYXBwZW5kIGFuIG9iamVjdCB0byBgZGVmYXVsdEZpZWxkc2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggbGVhZGluZyB0byBgc3RyYC5cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGRlZmF1bHRGaWVsZHMgVGhlIGRlZmF1bHQgZmllbGRzIHRvIGdlbmVyYXRlXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSB2aXJ0dWFsRmllbGRzIFRoZSB2aXJ0dWFsIGZpZWxkcyB0byBnZW5lcmF0ZVxuICogQHJldHVybiB7VHlwZVN0cmluZ31cbiAqL1xuVHlwZVN0cmluZy5wcm90b3R5cGUuX2dldERlZmF1bHRGaWVsZHMgPSBmdW5jdGlvbihwcmVmaXgsIGRlZmF1bHRGaWVsZHMsIHZpcnR1YWxGaWVsZHMpIHtcbiAgaWYgKHRoaXMuX2RlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlZmF1bHRGaWVsZHMucHVzaCh7XG4gICAgICBwYXRoOiBwcmVmaXgsXG4gICAgICB2YWx1ZTogdGhpcy5fZGVmYXVsdCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVTdHJpbmc7XG4iLCJmdW5jdGlvbiBUeXBlVmlydHVhbCgpIHtcbiAgdGhpcy5fZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdmFsaWRhdG9yID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vcHRpb25zID0ge307XG59XG5cblxuVHlwZVZpcnR1YWwucHJvdG90eXBlLmRlZmF1bHQgPSBmdW5jdGlvbihmbk9yVmFsdWUpIHtcbiAgdGhpcy5fZGVmYXVsdCA9IGZuT3JWYWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLy8gRHVtbXkgZnVuY3Rpb25zXG5UeXBlVmlydHVhbC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHt9XG5cblxuVHlwZVZpcnR1YWwucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbigpIHt9XG5cblxuVHlwZVZpcnR1YWwucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24oKSB7fVxuXG5cblR5cGVWaXJ0dWFsLnByb3RvdHlwZS5yZXF1aXJlZCA9IGZ1bmN0aW9uKCkge31cblxuXG5UeXBlVmlydHVhbC5wcm90b3R5cGUuYWxsb3dOdWxsID0gZnVuY3Rpb24oKSB7fVxuXG5cblR5cGVWaXJ0dWFsLnByb3RvdHlwZS5fZ2V0RGVmYXVsdEZpZWxkcyA9IGZ1bmN0aW9uKHByZWZpeCwgZGVmYXVsdEZpZWxkcywgdmlydHVhbEZpZWxkcykge1xuICAvLyBXZSBrZWVwIHRyYWNrIG9mIHZpcnR1YWwgZmllbGRzIGV2ZW4gaWYgdGhlcmUgaXMgbm8gZGVmYXVsdCB2YWx1ZVxuICB2aXJ0dWFsRmllbGRzLnB1c2goe1xuICAgIHBhdGg6IHByZWZpeCxcbiAgICB2YWx1ZTogdGhpcy5fZGVmYXVsdCxcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZVZpcnR1YWw7XG4iLCJ2YXIgdXRpbCA9IHt9O1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBFcnJvcnMgPSByZXF1aXJlKF9fZGlybmFtZSsnL2Vycm9ycy5qcycpO1xuXG4vKipcbiAqIFJhbmRvbSB1c2VmdWwgbWV0aG9kcyB1c2VkIGV2ZXJ5d2hlcmUuXG4gKi9cblxuXG4vKipcbiAqIElzIGBvYmpgIGEgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbnV0aWwuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5cblxuLyoqXG4gKiBNYWtlIGEgXCJkZWVwIGNvcHlcIi5cbiAqIFRoZSBwcm90b3R5cGUgY2hhaW4gaXMgbm90IGNvcGllZC5cbiAqL1xuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgLy8gaXNQbGFpbk9iamVjdChidWZmZXIpIHJldHVybnMgdHJ1ZS5cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPT09IHRydWUpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgICBsb29wS2V5cyh2YWx1ZSwgZnVuY3Rpb24oX3ZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChfdmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBDb3B5KF92YWx1ZVtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmVzdWx0ID0gW11cbiAgICBmb3IodmFyIGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goZGVlcENvcHkodmFsdWVbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbnV0aWwuZGVlcENvcHkgPSBkZWVwQ29weTtcblxuXG4vKipcbiAqIFdyYXAgdHJ5L2NhdGNoIGZvciB2OFxuICovXG5mdW5jdGlvbiB0cnlDYXRjaCh0b1RyeSwgaGFuZGxlRXJyb3IpIHtcbiAgdHJ5e1xuICAgIHRvVHJ5KClcbiAgfVxuICBjYXRjaChlcnIpIHtcbiAgICBoYW5kbGVFcnJvcihlcnIpXG4gIH1cbn1cbnV0aWwudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcblxuXG4vKipcbiAqIFJldHVybiBhIHByb21pc2UgaWYgYSBob29rIGlzIGFzeW5jaHJvbm91c1xuICogTm90ZTogSWYgbm8gaG9vayBpcyBhc3luY2hyb25vdXMsIGBmbmAgY2FuIHN0aWxsIGJlIGFzeW5jaHJvbm91cyBpbiB3aGljaFxuICogY2FzZSB3ZSByZXR1cm4gYSBwcm9taXNlIG9yIHVuZGVmaW5lZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMsIHRoZSBhcmd1bWVudHMgYXJlOlxuICogLSBwcmVIb29rcyB7QXJyYXl9IHRoZSBtZXRob2RzIHRvIGV4ZWN1dGUgYmVmb3JlIHRoZSBtYWluIG9uZVxuICogLSBwb3N0SG9va3Mge0FycmF5fSB0aGUgbWV0aG9kcyB0byBleGVjdXRlIGFmdGVyIHRoZSBtYWluIG9uZVxuICogLSBhc3luYyB7Ym9vbGVhbn0gd2hldGhlciB0aGlzIHRoaXMgaG9vayBpcyBhc3luY2hyb25vdXMgb3Igbm90XG4gKiAtIGRvYyB7RG9jdW1lbnR9IHRoZSBkb2N1bWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgaG9va3NcbiAqIC0gZm4ge0Z1bmN0aW9ufSB0aGUgbWFpbiBmdW5jdGlvblxuICogLSBmbkFyZ3Mge0FycmF5fSBhcmd1bWVudHMgZm9yIGBmbmBcbiAqIEByZXR1cm4ge1Byb21pc2U9fVxuICovXG5mdW5jdGlvbiBob29rKG9wdGlvbnMpIHtcbiAgdmFyIHByZUhvb2tzID0gb3B0aW9ucy5wcmVIb29rcztcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJlSG9va3MpID09PSBmYWxzZSkge1xuICAgIHByZUhvb2tzID0gW107XG4gIH1cbiAgdmFyIHBvc3RIb29rcyA9IG9wdGlvbnMucG9zdEhvb2tzO1xuICBpZiAoQXJyYXkuaXNBcnJheShwb3N0SG9va3MpID09PSBmYWxzZSkge1xuICAgIHBvc3RIb29rcyA9IFtdO1xuICB9XG4gIHZhciBkb2MgPSBvcHRpb25zLmRvYzsgLy8gV2UgbmVlZCB0aGUgZG9jIHRvIHNldCB0aGUgY29udGV4dCBvZiB0aGUgaG9va3NcbiAgdmFyIGFzeW5jID0gb3B0aW9ucy5hc3luYyB8fCBmYWxzZTtcbiAgdmFyIGZuID0gb3B0aW9ucy5mbjsgLy8gVGhlIGZ1bmN0aW9uIHRoYXQgd2UgYXJlIGhvb2tcbiAgdmFyIGZuQXJncyA9IG9wdGlvbnMuZm5BcmdzO1xuXG4gIGlmIChhc3luYyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF9hc3luY0hvb2soe1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICByZWplY3Q6IHJlamVjdCxcbiAgICAgICAgcHJlSG9va3M6IHByZUhvb2tzLFxuICAgICAgICBwb3N0SG9va3M6IHBvc3RIb29rcyxcbiAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgIGZuOiBmbixcbiAgICAgICAgZm5BcmdzOiBmbkFyZ3NcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIF9zeW5jSG9vayh7XG4gICAgcHJlSG9va3M6IHByZUhvb2tzLFxuICAgIHBvc3RIb29rczogcG9zdEhvb2tzLFxuICAgIGRvYzogZG9jLFxuICAgIGZuOiBmbixcbiAgICBmbkFyZ3M6IGZuQXJnc1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9zeW5jSG9vayhhcmdzKSB7XG4gIHZhciBwcmVIb29rcyA9IGFyZ3MucHJlSG9va3M7XG4gIHZhciBwb3N0SG9va3MgPSBhcmdzLnBvc3RIb29rcztcbiAgdmFyIGZuID0gYXJncy5mbjtcbiAgdmFyIGRvYyA9IGFyZ3MuZG9jO1xuICB2YXIgZm5BcmdzID0gYXJncy5mbkFyZ3M7XG5cbiAgZm9yKHZhciBpPTA7IGk8cHJlSG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBwcmVIb29rc1tpXS5jYWxsKGRvYyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KGRvYywgZm5BcmdzKTtcbiAgZm9yKHZhciBqPTA7IGo8cG9zdEhvb2tzLmxlbmd0aDsgaisrKSB7XG4gICAgcG9zdEhvb2tzW2pdLmNhbGwoZG9jKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2FzeW5jSG9vayhhcmdzKSB7XG4gIC8vIE9uZSBvZiB0aGUgaG9vaywgb3IgdGhlIGZ1bmN0aW9uIGlzIGFzeW5jaHJvbm91cywgc28gd2Ugd2lsbFxuICAvLyBhbHdheXMgcmV0dXJuIGEgcHJvbWlzZVxuICAvLyBXZSBvbmx5IG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcmVzdWx0IHJldHVybi9yZXNvbHZlZCBmb3IgZm5cblxuICB2YXIgcHJlSG9va3MgPSBhcmdzLnByZUhvb2tzO1xuICB2YXIgcG9zdEhvb2tzID0gYXJncy5wb3N0SG9va3M7XG4gIHZhciBmbiA9IGFyZ3MuZm47XG4gIHZhciBmbkFyZ3MgPSBhcmdzLmZuQXJncztcbiAgdmFyIGRvYyA9IGFyZ3MuZG9jO1xuICB2YXIgcmVzb2x2ZSA9IGFyZ3MucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IGFyZ3MucmVqZWN0O1xuICB2YXIgYXJncyA9IGFyZ3MuYXJncztcblxuICB2YXIgcmVzdWx0O1xuXG4gIHZhciBuZXh0UG9zdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgZXhlY3V0ZU1haW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXN1bHQgPSBmbi5hcHBseShkb2MsIGZuQXJncyk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzO1xuICAgICAgICBleGVjdXRlSG9va3MoMCwgcG9zdEhvb2tzLCBkb2MsIHJlamVjdCwgbmV4dFBvc3QpO1xuICAgICAgfSkuZXJyb3IocmVqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4ZWN1dGVIb29rcygwLCBwb3N0SG9va3MsIGRvYywgcmVqZWN0LCBuZXh0UG9zdCk7XG4gIH1cblxuICB2YXIgbmV4dFByZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeUNhdGNoKGV4ZWN1dGVNYWluLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGV4ZWN1dGVIb29rcygwLCBwcmVIb29rcywgZG9jLCByZWplY3QsIG5leHRQcmUpO1xufVxudXRpbC5ob29rID0gaG9vaztcblxuZnVuY3Rpb24gZXhlY3V0ZUhvb2tzKGhvb2tJbmRleCwgaG9va3MsIGRvYywgcmVqZWN0LCBuZXh0KSB7XG4gIGlmIChob29rSW5kZXggPCBob29rcy5sZW5ndGgpIHtcbiAgICBpZiAoaG9va3NbaG9va0luZGV4XS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGhvb2tzW2hvb2tJbmRleF0uY2FsbChkb2MsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIGV4ZWN1dGVIb29rcyhob29rSW5kZXgrMSwgaG9va3MsIGRvYywgcmVqZWN0LCBuZXh0KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaG9va3NbaG9va0luZGV4XS5jYWxsKGRvYyk7XG4gICAgICBleGVjdXRlSG9va3MoaG9va0luZGV4KzEsIGhvb2tzLCBkb2MsIHJlamVjdCwgbmV4dClcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgbmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3BLZXlzKG9iaiwgZm4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGZvcih2YXIgaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IGZuKG9iaiwga2V5c1tpXSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxudXRpbC5sb29wS2V5cyA9IGxvb3BLZXlzO1xuXG5mdW5jdGlvbiBjaGFuZ2VQcm90byhvYmplY3QsIG5ld1Byb3RvKSB7XG4gIG9iamVjdC5fX3Byb3RvX18gPSBuZXdQcm90bztcbn1cbnV0aWwuY2hhbmdlUHJvdG8gPSBjaGFuZ2VQcm90bztcblxuZnVuY3Rpb24gcmVjdXJzZShrZXksIGpvaW5zLCBtb2RlbFRvLCBhbGwsIGRvbmUpIHtcbiAgcmV0dXJuICh1dGlsLmlzUGxhaW5PYmplY3QobW9kZWxUbykgJiYgbW9kZWxUby5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgIHx8ICgoYWxsID09PSB0cnVlKSAmJiAoZG9uZVtqb2luc1trZXldLm1vZGVsLmdldFRhYmxlTmFtZSgpXSAhPT0gdHJ1ZSkpXG59XG51dGlsLnJlY3Vyc2UgPSByZWN1cnNlO1xuXG5mdW5jdGlvbiBiaW5kRW1pdHRlcihzZWxmKSB7XG4gIHV0aWwubG9vcEtleXMoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZW1pdHRlciwga2V5KSB7XG4gICAgdmFyIGZuID0gZW1pdHRlcltrZXldO1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGZba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnV0aWwuYmluZEVtaXR0ZXIgPSBiaW5kRW1pdHRlcjtcblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChuZXdPcHRpb25zKSkge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgbG9jYWxPcHRpb25zID0ge307XG4gICAgbG9jYWxPcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9IChuZXdPcHRpb25zLmVuZm9yY2VfbWlzc2luZyAhPSBudWxsKSA/IG5ld09wdGlvbnMuZW5mb3JjZV9taXNzaW5nIDogb3B0aW9ucy5lbmZvcmNlX21pc3Npbmc7XG4gICAgbG9jYWxPcHRpb25zLmVuZm9yY2VfdHlwZSA9IChuZXdPcHRpb25zLmVuZm9yY2VfdHlwZSAhPSBudWxsKSA/IG5ld09wdGlvbnMuZW5mb3JjZV90eXBlIDogb3B0aW9ucy5lbmZvcmNlX3R5cGU7XG4gICAgbG9jYWxPcHRpb25zLmVuZm9yY2VfZXh0cmEgPSAobmV3T3B0aW9ucy5lbmZvcmNlX2V4dHJhICE9IG51bGwpID8gbmV3T3B0aW9ucy5lbmZvcmNlX2V4dHJhIDogb3B0aW9ucy5lbmZvcmNlX2V4dHJhO1xuICAgIHJldHVybiBsb2NhbE9wdGlvbnM7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG51dGlsLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcblxuZnVuY3Rpb24gZXh0cmFjdFByaW1hcnlLZXkob2xkVmFsdWUsIG5ld1ZhbHVlLCBwcmltYXJ5S2V5KSB7XG4gIHZhciBwcmltYXJ5S2V5O1xuICBpZiAob2xkVmFsdWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gb2xkVmFsdWVbcHJpbWFyeUtleV07XG4gIH1cbiAgaWYgKG5ld1ZhbHVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ld1ZhbHVlW3ByaW1hcnlLZXldO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG51dGlsLmV4dHJhY3RQcmltYXJ5S2V5ID0gZXh0cmFjdFByaW1hcnlLZXk7XG5cblxuZnVuY3Rpb24gdW5kZWZpbmVkRmllbGQocHJlZml4KSB7XG4gIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGRlZmluZWQuXCIpXG59XG51dGlsLnVuZGVmaW5lZEZpZWxkID0gdW5kZWZpbmVkRmllbGQ7XG5cblxudmFyIHZvd2VscyA9IHthOiB0cnVlLCBlOiB0cnVlLCBpOiB0cnVlLCBvOiB0cnVlLCB1OiB0cnVlfTtcbmZ1bmN0aW9uIHN0cmljdFR5cGUocHJlZml4LCBleHBlY3RlZCkge1xuICBpZiAoKGV4cGVjdGVkLmxlbmd0aCA+IDApICYmICh2b3dlbHNbZXhwZWN0ZWRbMF1dKSkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGFuIFwiK2V4cGVjdGVkK1wiLlwiKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGEgXCIrZXhwZWN0ZWQrXCIuXCIpXG59XG51dGlsLnN0cmljdFR5cGUgPSBzdHJpY3RUeXBlO1xuXG5cbmZ1bmN0aW9uIGV4dHJhRmllbGQocHJlZml4LCBrZXkpIHtcbiAgaWYgKHByZWZpeCA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIkV4dHJhIGZpZWxkIGBcIitrZXkrXCJgIG5vdCBhbGxvd2VkLlwiKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiRXh0cmEgZmllbGQgYFwiK2tleStcImAgaW4gXCIrcHJlZml4K1wiIG5vdCBhbGxvd2VkLlwiKVxufVxudXRpbC5leHRyYUZpZWxkID0gZXh0cmFGaWVsZDtcblxuXG5mdW5jdGlvbiBsb29zZVR5cGUocHJlZml4LCBleHBlY3RlZCkge1xuICBpZiAoKGV4cGVjdGVkLmxlbmd0aCA+IDApICYmICh2b3dlbHNbZXhwZWN0ZWRbMF1dKSkge1xuICAgIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVmFsdWUgZm9yIFwiK3ByZWZpeCtcIiBtdXN0IGJlIGFuIFwiK2V4cGVjdGVkK1wiIG9yIG51bGwuXCIpXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IoXCJWYWx1ZSBmb3IgXCIrcHJlZml4K1wiIG11c3QgYmUgYSBcIitleHBlY3RlZCtcIiBvciBudWxsLlwiKVxufVxudXRpbC5sb29zZVR5cGUgPSBsb29zZVR5cGU7XG5cblxuZnVuY3Rpb24gcHNldWRvVHlwZUVycm9yKHR5cGUsIG1pc3NpbmdGaWVsZCwgcHJlZml4KSB7XG4gIHRocm93IG5ldyBFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiVGhlIHJhdyBcIit0eXBlK1wiIG9iamVjdCBmb3IgXCIrcHJlZml4K1wiIGlzIG1pc3NpbmcgdGhlIHJlcXVpcmVkIGZpZWxkIFwiK21pc3NpbmdGaWVsZCtcIi5cIilcbn1cbnV0aWwucHNldWRvVHlwZUVycm9yID0gcHNldWRvVHlwZUVycm9yO1xuXG5cbi8vIFJldHVybiB0cnVlIGlmIGRvYyBpcyB1bmRlZmluZWQsIGVsc2UgZmFsc2VcbmZ1bmN0aW9uIHZhbGlkYXRlSWZVbmRlZmluZWQodmFsdWUsIHByZWZpeCwgdHlwZSwgb3B0aW9ucykge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLmVuZm9yY2VfbWlzc2luZyA9PT0gdHJ1ZSkge1xuICAgICAgdW5kZWZpbmVkRmllbGQocHJlZml4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudXRpbC52YWxpZGF0ZUlmVW5kZWZpbmVkID0gdmFsaWRhdGVJZlVuZGVmaW5lZDtcblxuZnVuY3Rpb24gdG9BcnJheShhcmdzKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xufVxudXRpbC50b0FycmF5ID0gdG9BcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuIiwiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQ2hyaXMgTydIYXJhIDxjb2hhcmE4N0BnbWFpbC5jb20+XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuKGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0pKCd2YWxpZGF0b3InLCBmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YWxpZGF0b3IgPSB7IHZlcnNpb246ICczLjM0LjAnIH07XG5cbiAgICB2YXIgZW1haWxBZGRyZXNzID0gLygoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkvO1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IC8oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFwuXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXXxcXHMpKi87XG5cbiAgICB2YXIgZW1haWwgPSBuZXcgUmVnRXhwKCdeJyArIGVtYWlsQWRkcmVzcy5zb3VyY2UgKyAnJCcsICdpJyk7XG4gICAgdmFyIGVtYWlsV2l0aERpc3BsYXlOYW1lID0gbmV3IFJlZ0V4cCgnXicgKyBkaXNwbGF5TmFtZS5zb3VyY2UgKyAnPCcgKyBlbWFpbEFkZHJlc3Muc291cmNlICsgJz4kJywgJ2knKTtcblxuICAgIHZhciBjcmVkaXRDYXJkID0gL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9KSQvO1xuXG4gICAgdmFyIGlzaW4gPSAvXltBLVpdezJ9WzAtOUEtWl17OX1bMC05XSQvO1xuXG4gICAgdmFyIGlzYm4xME1heWJlID0gL14oPzpbMC05XXs5fVh8WzAtOV17MTB9KSQvXG4gICAgICAsIGlzYm4xM01heWJlID0gL14oPzpbMC05XXsxM30pJC87XG5cbiAgICB2YXIgaXB2NE1heWJlID0gL14oXFxkP1xcZD9cXGQpXFwuKFxcZD9cXGQ/XFxkKVxcLihcXGQ/XFxkP1xcZClcXC4oXFxkP1xcZD9cXGQpJC9cbiAgICAgICwgaXB2NkJsb2NrID0gL15bMC05QS1GXXsxLDR9JC9pO1xuXG4gICAgdmFyIHV1aWQgPSB7XG4gICAgICAgICczJzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS0zWzAtOUEtRl17M30tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pXG4gICAgICAsICc0JzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS00WzAtOUEtRl17M30tWzg5QUJdWzAtOUEtRl17M30tWzAtOUEtRl17MTJ9JC9pXG4gICAgICAsICc1JzogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS01WzAtOUEtRl17M30tWzg5QUJdWzAtOUEtRl17M30tWzAtOUEtRl17MTJ9JC9pXG4gICAgICAsIGFsbDogL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2lcbiAgICB9O1xuXG4gICAgdmFyIGFscGhhID0gL15bYS16QS1aXSskL1xuICAgICAgLCBhbHBoYW51bWVyaWMgPSAvXlthLXpBLVowLTldKyQvXG4gICAgICAsIG51bWVyaWMgPSAvXlstK10/WzAtOV0rJC9cbiAgICAgICwgaW50ID0gL14oPzpbLStdPyg/OjB8WzEtOV1bMC05XSopKSQvXG4gICAgICAsIGZsb2F0ID0gL14oPzpbLStdPyg/OlswLTldKykpPyg/OlxcLlswLTldKik/KD86W2VFXVtcXCtcXC1dPyg/OlswLTldKykpPyQvXG4gICAgICAsIGhleGFkZWNpbWFsID0gL15bMC05YS1mQS1GXSskL1xuICAgICAgLCBoZXhjb2xvciA9IC9eIz8oWzAtOWEtZkEtRl17M318WzAtOWEtZkEtRl17Nn0pJC87XG5cbiAgICB2YXIgYXNjaWkgPSAvXltcXHgwMC1cXHg3Rl0rJC9cbiAgICAgICwgbXVsdGlieXRlID0gL1teXFx4MDAtXFx4N0ZdL1xuICAgICAgLCBmdWxsV2lkdGggPSAvW15cXHUwMDIwLVxcdTAwN0VcXHVGRjYxLVxcdUZGOUZcXHVGRkEwLVxcdUZGRENcXHVGRkU4LVxcdUZGRUUwLTlhLXpBLVpdL1xuICAgICAgLCBoYWxmV2lkdGggPSAvW1xcdTAwMjAtXFx1MDA3RVxcdUZGNjEtXFx1RkY5RlxcdUZGQTAtXFx1RkZEQ1xcdUZGRTgtXFx1RkZFRTAtOWEtekEtWl0vO1xuXG4gICAgdmFyIHN1cnJvZ2F0ZVBhaXIgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS87XG5cbiAgICB2YXIgYmFzZTY0ID0gL14oPzpbQS1aYS16MC05K1xcL117NH0pKig/OltBLVphLXowLTkrXFwvXXsyfT09fFtBLVphLXowLTkrXFwvXXszfT18W0EtWmEtejAtOStcXC9dezR9KSQvO1xuXG4gICAgdmFyIHBob25lcyA9IHtcbiAgICAgICd6aC1DTic6IC9eKFxcKz8wPzg2XFwtPyk/MVszNDU3ODldXFxkezl9JC8sXG4gICAgICAnZW4tWkEnOiAvXihcXCs/Mjd8MClcXGR7OX0kLyxcbiAgICAgICdlbi1BVSc6IC9eKFxcKz82MXwwKTRcXGR7OH0kLyxcbiAgICAgICdlbi1ISyc6IC9eKFxcKz84NTJcXC0/KT9bNTY5XVxcZHszfVxcLT9cXGR7NH0kLyxcbiAgICAgICdmci1GUic6IC9eKFxcKz8zM3wwKVs2N11cXGR7OH0kLyxcbiAgICAgICdwdC1QVCc6IC9eKFxcKzM1MSk/OVsxMjM2XVxcZHs3fSQvLFxuICAgICAgJ2VsLUdSJyA6IC9eKFxcKzMwKT8oKDJcXGR7OX0pfCg2OVxcZHs4fSkpJC9cbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmV4dGVuZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgICB2YWxpZGF0b3JbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzWzBdID0gdmFsaWRhdG9yLnRvU3RyaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHZhbGlkYXRvciwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vUmlnaHQgYmVmb3JlIGV4cG9ydGluZyB0aGUgdmFsaWRhdG9yIG9iamVjdCwgcGFzcyBlYWNoIG9mIHRoZSBidWlsdGluc1xuICAgIC8vdGhyb3VnaCBleHRlbmQoKSBzbyB0aGF0IHRoZWlyIGZpcnN0IGFyZ3VtZW50IGlzIGNvZXJjZWQgdG8gYSBzdHJpbmdcbiAgICB2YWxpZGF0b3IuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yW25hbWVdICE9PSAnZnVuY3Rpb24nIHx8IG5hbWUgPT09ICd0b1N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9PT0gJ3RvRGF0ZScgfHwgbmFtZSA9PT0gJ2V4dGVuZCcgfHwgbmFtZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0b3IuZXh0ZW5kKG5hbWUsIHZhbGlkYXRvcltuYW1lXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLnRvU3RyaW5nID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0ICE9PSBudWxsICYmIGlucHV0LnRvU3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCAoaXNOYU4oaW5wdXQpICYmICFpbnB1dC5sZW5ndGgpKSB7XG4gICAgICAgICAgICBpbnB1dCA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ICs9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLnRvRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZSA9IERhdGUucGFyc2UoZGF0ZSk7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZSkgPyBuZXcgRGF0ZShkYXRlKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci50b0Zsb2F0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IudG9JbnQgPSBmdW5jdGlvbiAoc3RyLCByYWRpeCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCByYWRpeCB8fCAxMCk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci50b0Jvb2xlYW4gPSBmdW5jdGlvbiAoc3RyLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ciA9PT0gJzEnIHx8IHN0ciA9PT0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIgIT09ICcwJyAmJiBzdHIgIT09ICdmYWxzZScgJiYgc3RyICE9PSAnJztcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmVxdWFscyA9IGZ1bmN0aW9uIChzdHIsIGNvbXBhcmlzb24pIHtcbiAgICAgICAgcmV0dXJuIHN0ciA9PT0gdmFsaWRhdG9yLnRvU3RyaW5nKGNvbXBhcmlzb24pO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuY29udGFpbnMgPSBmdW5jdGlvbiAoc3RyLCBlbGVtKSB7XG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZih2YWxpZGF0b3IudG9TdHJpbmcoZWxlbSkpID49IDA7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5tYXRjaGVzID0gZnVuY3Rpb24gKHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF0dGVybikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRfZW1haWxfb3B0aW9ucyA9IHtcbiAgICAgICAgYWxsb3dfZGlzcGxheV9uYW1lOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNFbWFpbCA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGRlZmF1bHRfZW1haWxfb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGVtYWlsLnRlc3Qoc3RyKSB8fCAob3B0aW9ucy5hbGxvd19kaXNwbGF5X25hbWUgPT09IHRydWUgJiYgZW1haWxXaXRoRGlzcGxheU5hbWUudGVzdChzdHIpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRfdXJsX29wdGlvbnMgPSB7XG4gICAgICAgIHByb3RvY29sczogWyAnaHR0cCcsICdodHRwcycsICdmdHAnIF1cbiAgICAgICwgcmVxdWlyZV90bGQ6IHRydWVcbiAgICAgICwgcmVxdWlyZV9wcm90b2NvbDogZmFsc2VcbiAgICAgICwgYWxsb3dfdW5kZXJzY29yZXM6IGZhbHNlXG4gICAgICAsIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2VcbiAgICAgICwgYWxsb3dfcHJvdG9jb2xfcmVsYXRpdmVfdXJsczogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzVVJMID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXVybCB8fCB1cmwubGVuZ3RoID49IDIwODMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLmluZGV4T2YoJ21haWx0bzonKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWZhdWx0X3VybF9vcHRpb25zKTtcbiAgICAgICAgdmFyIHByb3RvY29sLCB1c2VyLCBwYXNzLCBhdXRoLCBob3N0LCBob3N0bmFtZSwgcG9ydCxcbiAgICAgICAgICAgIHBvcnRfc3RyLCBwYXRoLCBxdWVyeSwgaGFzaCwgc3BsaXQ7XG4gICAgICAgIHNwbGl0ID0gdXJsLnNwbGl0KCc6Ly8nKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHByb3RvY29sID0gc3BsaXQuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlX3Byb3RvY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gIGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dfcHJvdG9jb2xfcmVsYXRpdmVfdXJscyAmJiB1cmwuc3Vic3RyKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICAgICAgICBzcGxpdFswXSA9IHVybC5zdWJzdHIoMik7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gc3BsaXQuam9pbignOi8vJyk7XG4gICAgICAgIHNwbGl0ID0gdXJsLnNwbGl0KCcjJyk7XG4gICAgICAgIHVybCA9IHNwbGl0LnNoaWZ0KCk7XG4gICAgICAgIGhhc2ggPSBzcGxpdC5qb2luKCcjJyk7XG4gICAgICAgIGlmIChoYXNoICYmIC9cXHMvLnRlc3QoaGFzaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdCA9IHVybC5zcGxpdCgnPycpO1xuICAgICAgICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuICAgICAgICBxdWVyeSA9IHNwbGl0LmpvaW4oJz8nKTtcbiAgICAgICAgaWYgKHF1ZXJ5ICYmIC9cXHMvLnRlc3QocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzcGxpdCA9IHVybC5zcGxpdCgnLycpO1xuICAgICAgICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xuICAgICAgICBwYXRoID0gc3BsaXQuam9pbignLycpO1xuICAgICAgICBpZiAocGF0aCAmJiAvXFxzLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXQgPSB1cmwuc3BsaXQoJ0AnKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGF1dGggPSBzcGxpdC5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGF1dGguaW5kZXhPZignOicpID49IDApIHtcbiAgICAgICAgICAgICAgICBhdXRoID0gYXV0aC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIHVzZXIgPSBhdXRoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCEvXlxcUyskLy50ZXN0KHVzZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFzcyA9IGF1dGguam9pbignOicpO1xuICAgICAgICAgICAgICAgIGlmICghL15cXFMqJC8udGVzdCh1c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhvc3RuYW1lID0gc3BsaXQuam9pbignQCcpO1xuICAgICAgICBzcGxpdCA9IGhvc3RuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgIGhvc3QgPSBzcGxpdC5zaGlmdCgpO1xuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3J0X3N0ciA9IHNwbGl0LmpvaW4oJzonKTtcbiAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChwb3J0X3N0ciwgMTApO1xuICAgICAgICAgICAgaWYgKCEvXlswLTldKyQvLnRlc3QocG9ydF9zdHIpIHx8IHBvcnQgPD0gMCB8fCBwb3J0ID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWxpZGF0b3IuaXNJUChob3N0KSAmJiAhdmFsaWRhdG9yLmlzRlFETihob3N0LCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgIGhvc3QgIT09ICdsb2NhbGhvc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaG9zdF93aGl0ZWxpc3QgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhvc3Rfd2hpdGVsaXN0LmluZGV4T2YoaG9zdCkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaG9zdF9ibGFja2xpc3QgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhvc3RfYmxhY2tsaXN0LmluZGV4T2YoaG9zdCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0lQID0gZnVuY3Rpb24gKHN0ciwgdmVyc2lvbikge1xuICAgICAgICB2ZXJzaW9uID0gdmFsaWRhdG9yLnRvU3RyaW5nKHZlcnNpb24pO1xuICAgICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0b3IuaXNJUChzdHIsIDQpIHx8IHZhbGlkYXRvci5pc0lQKHN0ciwgNik7XG4gICAgICAgIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzQnKSB7XG4gICAgICAgICAgICBpZiAoIWlwdjRNYXliZS50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbM10gPD0gMjU1O1xuICAgICAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICc2Jykge1xuICAgICAgICAgICAgdmFyIGJsb2NrcyA9IHN0ci5zcGxpdCgnOicpO1xuICAgICAgICAgICAgdmFyIGZvdW5kT21pc3Npb25CbG9jayA9IGZhbHNlOyAvLyBtYXJrZXIgdG8gaW5kaWNhdGUgOjpcblxuICAgICAgICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPiA4KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaW5pdGlhbCBvciBmaW5hbCA6OlxuICAgICAgICAgICAgaWYgKHN0ciA9PT0gJzo6Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAnOjonKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYmxvY2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgZm91bmRPbWlzc2lvbkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gMikgPT09ICc6OicpIHtcbiAgICAgICAgICAgICAgICBibG9ja3MucG9wKCk7XG4gICAgICAgICAgICAgICAgYmxvY2tzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBmb3IgYSA6OiB3aGljaCBjYW4gbm90IGJlIGF0IHRoZSBzdHJpbmcgc3RhcnQvZW5kXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhvc2UgY2FzZXMgaGF2ZSBiZWVuIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tzW2ldID09PSAnJyAmJiBpID4gMCAmJiBpIDwgYmxvY2tzLmxlbmd0aCAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtdWx0aXBsZSA6OiBpbiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXB2NkJsb2NrLnRlc3QoYmxvY2tzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm91bmRPbWlzc2lvbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPj0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPT09IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdF9mcWRuX29wdGlvbnMgPSB7XG4gICAgICAgIHJlcXVpcmVfdGxkOiB0cnVlXG4gICAgICAsIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZVxuICAgICAgLCBhbGxvd190cmFpbGluZ19kb3Q6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0ZRRE4gPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWZhdWx0X2ZxZG5fb3B0aW9ucyk7XG5cbiAgICAgICAgLyogUmVtb3ZlIHRoZSBvcHRpb25hbCB0cmFpbGluZyBkb3QgYmVmb3JlIGNoZWNraW5nIHZhbGlkaXR5ICovXG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93X3RyYWlsaW5nX2RvdCAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXF1aXJlX3RsZCkge1xuICAgICAgICAgICAgdmFyIHRsZCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0cy5sZW5ndGggfHwgIS9eKFthLXpcXHUwMGExLVxcdWZmZmZdezIsfXx4blthLXowLTktXXsyLH0pJC9pLnRlc3QodGxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBwYXJ0LCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd191bmRlcnNjb3Jlcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ19fJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEvXlthLXpcXHUwMGExLVxcdWZmZmYwLTktXSskL2kudGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0WzBdID09PSAnLScgfHwgcGFydFtwYXJ0Lmxlbmd0aCAtIDFdID09PSAnLScgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFydC5pbmRleE9mKCctLS0nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNBbHBoYSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGFscGhhLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzQWxwaGFudW1lcmljID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gYWxwaGFudW1lcmljLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzTnVtZXJpYyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG51bWVyaWMudGVzdChzdHIpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNIZXhhZGVjaW1hbCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzSGV4Q29sb3IgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBoZXhjb2xvci50ZXN0KHN0cik7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0xvd2VyY2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ciA9PT0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc1VwcGVyY2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ciA9PT0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0ludCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGludC50ZXN0KHN0cik7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0Zsb2F0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyICE9PSAnJyAmJiBmbG9hdC50ZXN0KHN0cik7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0RpdmlzaWJsZUJ5ID0gZnVuY3Rpb24gKHN0ciwgbnVtKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3IudG9GbG9hdChzdHIpICUgdmFsaWRhdG9yLnRvSW50KG51bSkgPT09IDA7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc051bGwgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgc3Vycm9nYXRlUGFpcnMgPSBzdHIubWF0Y2goL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZykgfHwgW107XG4gICAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoIC0gc3Vycm9nYXRlUGFpcnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0J5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSBtaW4gJiYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnIHx8IHN0ci5sZW5ndGggPD0gbWF4KTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzVVVJRCA9IGZ1bmN0aW9uIChzdHIsIHZlcnNpb24pIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB1dWlkW3ZlcnNpb24gPyB2ZXJzaW9uIDogJ2FsbCddO1xuICAgICAgICByZXR1cm4gcGF0dGVybiAmJiBwYXR0ZXJuLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzRGF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHN0cikpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNBZnRlciA9IGZ1bmN0aW9uIChzdHIsIGRhdGUpIHtcbiAgICAgICAgdmFyIGNvbXBhcmlzb24gPSB2YWxpZGF0b3IudG9EYXRlKGRhdGUgfHwgbmV3IERhdGUoKSlcbiAgICAgICAgICAsIG9yaWdpbmFsID0gdmFsaWRhdG9yLnRvRGF0ZShzdHIpO1xuICAgICAgICByZXR1cm4gISEob3JpZ2luYWwgJiYgY29tcGFyaXNvbiAmJiBvcmlnaW5hbCA+IGNvbXBhcmlzb24pO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNCZWZvcmUgPSBmdW5jdGlvbiAoc3RyLCBkYXRlKSB7XG4gICAgICAgIHZhciBjb21wYXJpc29uID0gdmFsaWRhdG9yLnRvRGF0ZShkYXRlIHx8IG5ldyBEYXRlKCkpXG4gICAgICAgICAgLCBvcmlnaW5hbCA9IHZhbGlkYXRvci50b0RhdGUoc3RyKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsICYmIGNvbXBhcmlzb24gJiYgb3JpZ2luYWwgPCBjb21wYXJpc29uO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNJbiA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0aW9ucykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHZhbGlkYXRvci50b1N0cmluZyhvcHRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHN0cikgPj0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmhhc093blByb3BlcnR5KHN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmRleE9mKHN0cikgPj0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0NyZWRpdENhcmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBzYW5pdGl6ZWQgPSBzdHIucmVwbGFjZSgvW14wLTldKy9nLCAnJyk7XG4gICAgICAgIGlmICghY3JlZGl0Q2FyZC50ZXN0KHNhbml0aXplZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VtID0gMCwgZGlnaXQsIHRtcE51bSwgc2hvdWxkRG91YmxlO1xuICAgICAgICBmb3IgKHZhciBpID0gc2FuaXRpemVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBkaWdpdCA9IHNhbml0aXplZC5zdWJzdHJpbmcoaSwgKGkgKyAxKSk7XG4gICAgICAgICAgICB0bXBOdW0gPSBwYXJzZUludChkaWdpdCwgMTApO1xuICAgICAgICAgICAgaWYgKHNob3VsZERvdWJsZSkge1xuICAgICAgICAgICAgICAgIHRtcE51bSAqPSAyO1xuICAgICAgICAgICAgICAgIGlmICh0bXBOdW0gPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9ICgodG1wTnVtICUgMTApICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1bSArPSB0bXBOdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGREb3VibGUgPSAhc2hvdWxkRG91YmxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhISgoc3VtICUgMTApID09PSAwID8gc2FuaXRpemVkIDogZmFsc2UpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNJU0lOID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIWlzaW4udGVzdChzdHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBjaGVja3N1bVN0ciA9IHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbihjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjaGFyYWN0ZXIsIDM2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3VtID0gMCwgZGlnaXQsIHRtcE51bSwgc2hvdWxkRG91YmxlID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoZWNrc3VtU3RyLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBkaWdpdCA9IGNoZWNrc3VtU3RyLnN1YnN0cmluZyhpLCAoaSArIDEpKTtcbiAgICAgICAgICAgIHRtcE51bSA9IHBhcnNlSW50KGRpZ2l0LCAxMCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRG91YmxlKSB7XG4gICAgICAgICAgICAgICAgdG1wTnVtICo9IDI7XG4gICAgICAgICAgICAgICAgaWYgKHRtcE51bSA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdG1wTnVtICsgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdG1wTnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3VtICs9IHRtcE51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZERvdWJsZSA9ICFzaG91bGREb3VibGU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwYXJzZUludChzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSAxKSwgMTApID09PSAoMTAwMDAgLSBzdW0pICUgMTA7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc0lTQk4gPSBmdW5jdGlvbiAoc3RyLCB2ZXJzaW9uKSB7XG4gICAgICAgIHZlcnNpb24gPSB2YWxpZGF0b3IudG9TdHJpbmcodmVyc2lvbik7XG4gICAgICAgIGlmICghdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRvci5pc0lTQk4oc3RyLCAxMCkgfHwgdmFsaWRhdG9yLmlzSVNCTihzdHIsIDEzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2FuaXRpemVkID0gc3RyLnJlcGxhY2UoL1tcXHMtXSsvZywgJycpXG4gICAgICAgICAgLCBjaGVja3N1bSA9IDAsIGk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAnMTAnKSB7XG4gICAgICAgICAgICBpZiAoIWlzYm4xME1heWJlLnRlc3Qoc2FuaXRpemVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bSArPSAoaSArIDEpICogc2FuaXRpemVkLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzYW5pdGl6ZWQuY2hhckF0KDkpID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bSArPSAxMCAqIDEwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bSArPSAxMCAqIHNhbml0aXplZC5jaGFyQXQoOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNoZWNrc3VtICUgMTEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhc2FuaXRpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgIGlmICh2ZXJzaW9uID09PSAnMTMnKSB7XG4gICAgICAgICAgICBpZiAoIWlzYm4xM01heWJlLnRlc3Qoc2FuaXRpemVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSBbIDEsIDMgXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gZmFjdG9yW2kgJSAyXSAqIHNhbml0aXplZC5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FuaXRpemVkLmNoYXJBdCgxMikgLSAoKDEwIC0gKGNoZWNrc3VtICUgMTApKSAlIDEwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXNhbml0aXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5pc01vYmlsZVBob25lID0gZnVuY3Rpb24oc3RyLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKGxvY2FsZSBpbiBwaG9uZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaG9uZXNbbG9jYWxlXS50ZXN0KHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdF9jdXJyZW5jeV9vcHRpb25zID0ge1xuICAgICAgICBzeW1ib2w6ICckJ1xuICAgICAgLCByZXF1aXJlX3N5bWJvbDogZmFsc2VcbiAgICAgICwgYWxsb3dfc3BhY2VfYWZ0ZXJfc3ltYm9sOiBmYWxzZVxuICAgICAgLCBzeW1ib2xfYWZ0ZXJfZGlnaXRzOiBmYWxzZVxuICAgICAgLCBhbGxvd19uZWdhdGl2ZXM6IHRydWVcbiAgICAgICwgcGFyZW5zX2Zvcl9uZWdhdGl2ZXM6IGZhbHNlXG4gICAgICAsIG5lZ2F0aXZlX3NpZ25fYmVmb3JlX2RpZ2l0czogZmFsc2VcbiAgICAgICwgbmVnYXRpdmVfc2lnbl9hZnRlcl9kaWdpdHM6IGZhbHNlXG4gICAgICAsIGFsbG93X25lZ2F0aXZlX3NpZ25fcGxhY2Vob2xkZXI6IGZhbHNlXG4gICAgICAsIHRob3VzYW5kc19zZXBhcmF0b3I6ICcsJ1xuICAgICAgLCBkZWNpbWFsX3NlcGFyYXRvcjogJy4nXG4gICAgICAsIGFsbG93X3NwYWNlX2FmdGVyX2RpZ2l0czogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzQ3VycmVuY3kgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWZhdWx0X2N1cnJlbmN5X29wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW5jeVJlZ2V4KG9wdGlvbnMpLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzSlNPTiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNNdWx0aWJ5dGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBtdWx0aWJ5dGUudGVzdChzdHIpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNBc2NpaSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGFzY2lpLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzRnVsbFdpZHRoID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gZnVsbFdpZHRoLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzSGFsZldpZHRoID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gaGFsZldpZHRoLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzVmFyaWFibGVXaWR0aCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGxXaWR0aC50ZXN0KHN0cikgJiYgaGFsZldpZHRoLnRlc3Qoc3RyKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmlzU3Vycm9nYXRlUGFpciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN1cnJvZ2F0ZVBhaXIudGVzdChzdHIpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNCYXNlNjQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQudGVzdChzdHIpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuaXNNb25nb0lkID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yLmlzSGV4YWRlY2ltYWwoc3RyKSAmJiBzdHIubGVuZ3RoID09PSAyNDtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLmx0cmltID0gZnVuY3Rpb24gKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjaGFycyA/IG5ldyBSZWdFeHAoJ15bJyArIGNoYXJzICsgJ10rJywgJ2cnKSA6IC9eXFxzKy9nO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocGF0dGVybiwgJycpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IucnRyaW0gPSBmdW5jdGlvbiAoc3RyLCBjaGFycykge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGNoYXJzID8gbmV3IFJlZ0V4cCgnWycgKyBjaGFycyArICddKyQnLCAnZycpIDogL1xccyskL2c7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShwYXR0ZXJuLCAnJyk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci50cmltID0gZnVuY3Rpb24gKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjaGFycyA/IG5ldyBSZWdFeHAoJ15bJyArIGNoYXJzICsgJ10rfFsnICsgY2hhcnMgKyAnXSskJywgJ2cnKSA6IC9eXFxzK3xcXHMrJC9nO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocGF0dGVybiwgJycpO1xuICAgIH07XG5cbiAgICB2YWxpZGF0b3IuZXNjYXBlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gKHN0ci5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiN4Mjc7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJyYjeDJGOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxgL2csICcmIzk2OycpKTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdG9yLnN0cmlwTG93ID0gZnVuY3Rpb24gKHN0ciwga2VlcF9uZXdfbGluZXMpIHtcbiAgICAgICAgdmFyIGNoYXJzID0ga2VlcF9uZXdfbGluZXMgPyAnXFxcXHgwMC1cXFxceDA5XFxcXHgwQlxcXFx4MENcXFxceDBFLVxcXFx4MUZcXFxceDdGJyA6ICdcXFxceDAwLVxcXFx4MUZcXFxceDdGJztcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvci5ibGFja2xpc3Qoc3RyLCBjaGFycyk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci53aGl0ZWxpc3QgPSBmdW5jdGlvbiAoc3RyLCBjaGFycykge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnW14nICsgY2hhcnMgKyAnXSsnLCAnZycpLCAnJyk7XG4gICAgfTtcblxuICAgIHZhbGlkYXRvci5ibGFja2xpc3QgPSBmdW5jdGlvbiAoc3RyLCBjaGFycykge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnWycgKyBjaGFycyArICddKycsICdnJyksICcnKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRfbm9ybWFsaXplX2VtYWlsX29wdGlvbnMgPSB7XG4gICAgICAgIGxvd2VyY2FzZTogdHJ1ZVxuICAgIH07XG5cbiAgICB2YWxpZGF0b3Iubm9ybWFsaXplRW1haWwgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGRlZmF1bHRfbm9ybWFsaXplX2VtYWlsX29wdGlvbnMpO1xuICAgICAgICBpZiAoIXZhbGlkYXRvci5pc0VtYWlsKGVtYWlsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0cyA9IGVtYWlsLnNwbGl0KCdAJywgMik7XG4gICAgICAgIHBhcnRzWzFdID0gcGFydHNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnZ21haWwuY29tJyB8fCBwYXJ0c1sxXSA9PT0gJ2dvb2dsZW1haWwuY29tJykge1xuICAgICAgICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLi9nLCAnJyk7XG4gICAgICAgICAgICBpZiAocGFydHNbMF1bMF0gPT09ICcrJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0uc3BsaXQoJysnKVswXTtcbiAgICAgICAgICAgIHBhcnRzWzFdID0gJ2dtYWlsLmNvbSc7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5sb3dlcmNhc2UpIHtcbiAgICAgICAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignQCcpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtZXJnZShvYmosIGRlZmF1bHRzKSB7XG4gICAgICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbmN5UmVnZXgob3B0aW9ucykge1xuICAgICAgICB2YXIgc3ltYm9sID0gJyhcXFxcJyArIG9wdGlvbnMuc3ltYm9sLnJlcGxhY2UoL1xcLi9nLCAnXFxcXC4nKSArICcpJyArIChvcHRpb25zLnJlcXVpcmVfc3ltYm9sID8gJycgOiAnPycpXG4gICAgICAgICAgICAsIG5lZ2F0aXZlID0gJy0/J1xuICAgICAgICAgICAgLCB3aG9sZV9kb2xsYXJfYW1vdW50X3dpdGhvdXRfc2VwID0gJ1sxLTldXFxcXGQqJ1xuICAgICAgICAgICAgLCB3aG9sZV9kb2xsYXJfYW1vdW50X3dpdGhfc2VwID0gJ1sxLTldXFxcXGR7MCwyfShcXFxcJyArIG9wdGlvbnMudGhvdXNhbmRzX3NlcGFyYXRvciArICdcXFxcZHszfSkqJ1xuICAgICAgICAgICAgLCB2YWxpZF93aG9sZV9kb2xsYXJfYW1vdW50cyA9IFsnMCcsIHdob2xlX2RvbGxhcl9hbW91bnRfd2l0aG91dF9zZXAsIHdob2xlX2RvbGxhcl9hbW91bnRfd2l0aF9zZXBdXG4gICAgICAgICAgICAsIHdob2xlX2RvbGxhcl9hbW91bnQgPSAnKCcgKyB2YWxpZF93aG9sZV9kb2xsYXJfYW1vdW50cy5qb2luKCd8JykgKyAnKT8nXG4gICAgICAgICAgICAsIGRlY2ltYWxfYW1vdW50ID0gJyhcXFxcJyArIG9wdGlvbnMuZGVjaW1hbF9zZXBhcmF0b3IgKyAnXFxcXGR7Mn0pPyc7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gd2hvbGVfZG9sbGFyX2Ftb3VudCArIGRlY2ltYWxfYW1vdW50O1xuICAgICAgICAvLyBkZWZhdWx0IGlzIG5lZ2F0aXZlIHNpZ24gYmVmb3JlIHN5bWJvbCwgYnV0IHRoZXJlIGFyZSB0d28gb3RoZXIgb3B0aW9ucyAoYmVzaWRlcyBwYXJlbnMpXG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93X25lZ2F0aXZlcyAmJiAhb3B0aW9ucy5wYXJlbnNfZm9yX25lZ2F0aXZlcykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmVnYXRpdmVfc2lnbl9hZnRlcl9kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IG5lZ2F0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5uZWdhdGl2ZV9zaWduX2JlZm9yZV9kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gbmVnYXRpdmUgKyBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNvdXRoIEFmcmljYW4gUmFuZCwgZm9yIGV4YW1wbGUsIHVzZXMgUiAxMjMgKHNwYWNlKSBhbmQgUi0xMjMgKG5vIHNwYWNlKVxuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd19uZWdhdGl2ZV9zaWduX3BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gJyggKD8hXFxcXC0pKT8nICsgcGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmFsbG93X3NwYWNlX2FmdGVyX3N5bWJvbCkge1xuICAgICAgICAgICAgcGF0dGVybiA9ICcgPycgKyBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dfc3BhY2VfYWZ0ZXJfZGlnaXRzKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9ICcoICg/ISQpKT8nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnN5bWJvbF9hZnRlcl9kaWdpdHMpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gc3ltYm9sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybiA9IHN5bWJvbCArIHBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dfbmVnYXRpdmVzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnNfZm9yX25lZ2F0aXZlcykge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAnKFxcXFwoJyArIHBhdHRlcm4gKyAnXFxcXCl8JyArIHBhdHRlcm4gKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKG9wdGlvbnMubmVnYXRpdmVfc2lnbl9iZWZvcmVfZGlnaXRzIHx8IG9wdGlvbnMubmVnYXRpdmVfc2lnbl9hZnRlcl9kaWdpdHMpKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IG5lZ2F0aXZlICsgcGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlcmUncyBhIGRvbGxhciBhbmQvb3IgZGVjaW1hbCBhbW91bnQsIGFuZCB0aGF0IGl0IGRvZXNuJ3Qgc3RhcnQgd2l0aCBhIHNwYWNlIG9yIGEgbmVnYXRpdmUgc2lnbiBmb2xsb3dlZCBieSBhIHNwYWNlXG4gICAgICAgICAgICAnKD8hLT8gKSg/PS4qXFxcXGQpJyArXG4gICAgICAgICAgICBwYXR0ZXJuICtcbiAgICAgICAgICAgICckJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhbGlkYXRvci5pbml0KCk7XG5cbiAgICByZXR1cm4gdmFsaWRhdG9yO1xuXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUGFnZSA9IGV4cG9ydHMuVGVtcGxhdGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfc3RyaW5naWZ5ID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5Jyk7XG5cbnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7XG5cbnZhciBfaXNvbW9ycGhpY0ZldGNoID0gcmVxdWlyZSgnaXNvbW9ycGhpYy1mZXRjaCcpO1xuXG52YXIgX2lzb21vcnBoaWNGZXRjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc29tb3JwaGljRmV0Y2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgZW50ZXJNb2R1bGUgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykuZW50ZXJNb2R1bGU7XG5cbiAgZW50ZXJNb2R1bGUgJiYgZW50ZXJNb2R1bGUobW9kdWxlKTtcbn0pKCk7XG5cbnZhciBBUElfQkFTRSA9ICdodHRwOi8vMC4wLjAuMDo5OTk5L2FwaSc7XG5cbnZhciBhcGkgPSBmdW5jdGlvbiBhcGkocGF0aCwgb3B0aW9ucykge1xuICByZXR1cm4gZmV0Y2gocGF0aCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgPiAyMDApIHtcbiAgICAgIHRocm93IHsgbXNnOiAnZXJyb3InIH07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0pO1xufTtcblxudmFyIEFQSSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQocGF0aCkge1xuICAgIHJldHVybiBhcGkoJycgKyBBUElfQkFTRSArIHBhdGgpO1xuICB9LFxuICBwb3N0OiBmdW5jdGlvbiBwb3N0KHBhdGgsIGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJlbC1saW5lXG4gICAgcmV0dXJuIGFwaSgnJyArIEFQSV9CQVNFICsgcGF0aCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBib2R5OiAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkoZGF0YSlcbiAgICB9KTtcbiAgfSxcbiAgcGF0Y2g6IGZ1bmN0aW9uIHBhdGNoKHBhdGgsIGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJlbC1saW5lXG4gICAgcmV0dXJuIGFwaSgnJyArIEFQSV9CQVNFICsgcGF0aCwge1xuICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKGRhdGEpXG4gICAgfSk7XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZShwYXRoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FiZWwtbGluZVxuICAgIHJldHVybiBhcGkoJycgKyBBUElfQkFTRSArIHBhdGgsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURSdcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIFRlbXBsYXRlID0gZXhwb3J0cy5UZW1wbGF0ZSA9IHtcbiAgZ2V0QWxsOiBmdW5jdGlvbiBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIEFQSS5nZXQoJy90ZW1wbGF0ZXMnKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoaWQpIHtcbiAgICByZXR1cm4gQVBJLmdldCgnL3RlbXBsYXRlcy8nICsgaWQpO1xuICB9LFxuICBnZXRCeTogZnVuY3Rpb24gZ2V0QnkoYnksIHZhbHVlKSB7XG4gICAgcmV0dXJuIEFQSS5nZXQoJy90ZW1wbGF0ZXMvJyArIGJ5ICsgJy8nICsgdmFsdWUpO1xuICB9LFxuICBkZWxldGVBbGw6IGZ1bmN0aW9uIGRlbGV0ZUFsbCgpIHtcbiAgICByZXR1cm4gQVBJLmRlbGV0ZSgnL3RlbXBsYXRlcycpO1xuICB9LFxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShkYXRhKSB7XG4gICAgcmV0dXJuIEFQSS5wb3N0KCcvdGVtcGxhdGVzJywgZGF0YSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgICByZXR1cm4gQVBJLnBhdGNoKCcvdGVtcGxhdGVzJywgZGF0YSk7XG4gIH1cbn07XG5cbnZhciBQYWdlID0gZXhwb3J0cy5QYWdlID0ge1xuICBnZXRBbGw6IGZ1bmN0aW9uIGdldEFsbCgpIHtcbiAgICByZXR1cm4gQVBJLmdldCgnL3BhZ2VzJyk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0KGlkKSB7XG4gICAgcmV0dXJuIEFQSS5nZXQoJy9wYWdlcy8nICsgaWQpO1xuICB9LFxuICBnZXRCeTogZnVuY3Rpb24gZ2V0QnkoYnksIHZhbHVlKSB7XG4gICAgcmV0dXJuIEFQSS5nZXQoJy9wYWdlcy8nICsgYnkgKyAnLycgKyB2YWx1ZSk7XG4gIH0sXG4gIGRlbGV0ZUFsbDogZnVuY3Rpb24gZGVsZXRlQWxsKCkge1xuICAgIHJldHVybiBBUEkuZGVsZXRlKCcvcGFnZXMnKTtcbiAgfSxcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZGF0YSkge1xuICAgIHJldHVybiBBUEkucG9zdCgnL3BhZ2VzJywgZGF0YSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgICByZXR1cm4gQVBJLnBhdGNoKCcvcGFnZXMnLCBkYXRhKTtcbiAgfVxufTtcblxudmFyIF9kZWZhdWx0ID0gQVBJO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG47XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciByZWFjdEhvdExvYWRlciA9IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKS5kZWZhdWx0O1xuXG4gIHZhciBsZWF2ZU1vZHVsZSA9IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKS5sZWF2ZU1vZHVsZTtcblxuICBpZiAoIXJlYWN0SG90TG9hZGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoQVBJX0JBU0UsICdBUElfQkFTRScsICcvVXNlcnMvbTMwMDAvcmVwb3MvcmV0aGluay1kcmFmdGpzL2Zyb250ZW5kL3NyYy9hcGkvaW5kZXguanMnKTtcbiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoYXBpLCAnYXBpJywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2FwaS9pbmRleC5qcycpO1xuICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihBUEksICdBUEknLCAnL1VzZXJzL20zMDAwL3JlcG9zL3JldGhpbmstZHJhZnRqcy9mcm9udGVuZC9zcmMvYXBpL2luZGV4LmpzJyk7XG4gIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKFRlbXBsYXRlLCAnVGVtcGxhdGUnLCAnL1VzZXJzL20zMDAwL3JlcG9zL3JldGhpbmstZHJhZnRqcy9mcm9udGVuZC9zcmMvYXBpL2luZGV4LmpzJyk7XG4gIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKFBhZ2UsICdQYWdlJywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2FwaS9pbmRleC5qcycpO1xuICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihfZGVmYXVsdCwgJ2RlZmF1bHQnLCAnL1VzZXJzL20zMDAwL3JlcG9zL3JldGhpbmstZHJhZnRqcy9mcm9udGVuZC9zcmMvYXBpL2luZGV4LmpzJyk7XG4gIGxlYXZlTW9kdWxlKG1vZHVsZSk7XG59KSgpO1xuXG47IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3RIb3RMb2FkZXIgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJyk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX0JsYW5rID0gcmVxdWlyZSgnLi9CbGFuaycpO1xuXG52YXIgX0JsYW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JsYW5rKTtcblxudmFyIF9FZGl0Q29udGV4dCA9IHJlcXVpcmUoJy4vRWRpdENvbnRleHQnKTtcblxudmFyIF9QYWdlTGlzdCA9IHJlcXVpcmUoJy4vUGFnZUxpc3QnKTtcblxudmFyIF9QYWdlTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYWdlTGlzdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBlbnRlck1vZHVsZSA9IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKS5lbnRlck1vZHVsZTtcblxuICBlbnRlck1vZHVsZSAmJiBlbnRlck1vZHVsZShtb2R1bGUpO1xufSkoKTtcblxudmFyIEFwcCA9IGZ1bmN0aW9uIEFwcChwcm9wcykge1xuICByZXR1cm4gKC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgIF9FZGl0Q29udGV4dC5FZGl0Q29udGV4dC5Qcm92aWRlcixcbiAgICAgIHsgdmFsdWU6IHByb3BzLmVkaXQgfSxcbiAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9CbGFuazIuZGVmYXVsdCwgeyBpZDogJ2FzZCcgfSksXG4gICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUGFnZUxpc3QyLmRlZmF1bHQsIG51bGwpXG4gICAgKVxuICApO1xufTtcblxuQXBwLnByb3BUeXBlcyA9IHtcbiAgZWRpdDogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxudmFyIF9kZWZhdWx0ID0gKDAsIF9yZWFjdEhvdExvYWRlci5ob3QpKG1vZHVsZSkoQXBwKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG47XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciByZWFjdEhvdExvYWRlciA9IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKS5kZWZhdWx0O1xuXG4gIHZhciBsZWF2ZU1vZHVsZSA9IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKS5sZWF2ZU1vZHVsZTtcblxuICBpZiAoIXJlYWN0SG90TG9hZGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoQXBwLCAnQXBwJywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvQXBwLmpzJyk7XG4gIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKF9kZWZhdWx0LCAnZGVmYXVsdCcsICcvVXNlcnMvbTMwMDAvcmVwb3MvcmV0aGluay1kcmFmdGpzL2Zyb250ZW5kL3NyYy9jb21wb25lbnRzL0FwcC5qcycpO1xuICBsZWF2ZU1vZHVsZShtb2R1bGUpO1xufSkoKTtcblxuOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yZWdlbmVyYXRvciA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3InKTtcblxudmFyIF9yZWdlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWdlbmVyYXRvcik7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcicpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNUb0dlbmVyYXRvcjIpO1xuXG52YXIgX2tleXMgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMnKTtcblxudmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG52YXIgX2V4dGVuZHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKTtcblxudmFyIF9leHRlbmRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZHMyKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfZGVjLCBfY2xhc3MsIF9jbGFzczIsIF90ZW1wO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX3RlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG52YXIgX3RlbXBsYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RlbXBsYXRlKTtcblxudmFyIF9hcGkgPSByZXF1aXJlKCcuLi9hcGknKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudGVyTW9kdWxlID0gcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpLmVudGVyTW9kdWxlO1xuXG4gIGVudGVyTW9kdWxlICYmIGVudGVyTW9kdWxlKG1vZHVsZSk7XG59KSgpO1xuXG52YXIgYmxhbmsgPSB7XG4gIG5hbWU6ICdCbGFuaycsXG4gIHZhbHVlczogW3tcbiAgICBrZXk6ICdhYnN0cmFjdCcsXG4gICAgdmFsdWU6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2V0ZXR1ciBzYWRpcHNjaW5nIGVsaXRyLCBzZWQgZGlhbSBub251bXkgZWlybW9kIHRlbXBvciBpbnZpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1eWFtIGVyYXQsIHNlZCBkaWFtIHZvbHVwdHVhLiBBdCB2ZXJvIGVvcyBldCBhY2N1c2FtIGV0IGp1c3RvIGR1byBkb2xvcmVzIGV0IGVhIHJlYnVtLiBTdGV0IGNsaXRhIGthc2QgZ3ViZXJncmVuLCBubyBzZWEgdGFraW1hdGEgc2FuY3R1cyBlc3QgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQuIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZXRldHVyIHNhZGlwc2NpbmcgZWxpdHIsIHNlZCBkaWFtIG5vbnVteSBlaXJtb2QgdGVtcG9yIGludmlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXV5YW0gZXJhdCwgc2VkIGRpYW0gdm9sdXB0dWEuIEF0IHZlcm8gZW9zIGV0IGFjY3VzYW0gZXQganVzdG8gZHVvIGRvbG9yZXMgZXQgZWEgcmVidW0uIFN0ZXQgY2xpdGEga2FzZCBndWJlcmdyZW4sIG5vIHNlYSB0YWtpbWF0YSBzYW5jdHVzIGVzdCBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldC4nXG4gIH0sIHtcbiAgICBrZXk6ICd0aXRsZScsXG4gICAgdmFsdWU6ICdOZXcgQmxhbmsgVGVtcGxhdGUnXG4gIH0sIHtcbiAgICBrZXk6ICd0ZWwnLFxuICAgIHZhbHVlOiAnKzQ5IDMwIDEyMyA0NTYgNzgnXG4gIH1dXG59O1xuXG52YXIgQmxhbmsgPSAoX2RlYyA9ICgwLCBfdGVtcGxhdGUyLmRlZmF1bHQpKGJsYW5rLCB7IHJlY2VpdmVVcGRhdGVzOiBmYWxzZSB9KSwgX2RlYyhfY2xhc3MgPSAoX3RlbXAgPSBfY2xhc3MyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQmxhbmssIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJsYW5rKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEJsYW5rKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoQmxhbmsuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEJsYW5rKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShCbGFuaywgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB2YWx1ZXMgPSBfcHJvcHMudmFsdWVzLFxuICAgICAgICAgIHJlbW90ZSA9IF9wcm9wcy5yZW1vdGU7XG5cbiAgICAgIGNvbnNvbGUubG9nKHJlbW90ZSk7XG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBudWxsLFxuICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICB7IG9uTW91c2VEb3duOiBmdW5jdGlvbiBvbk1vdXNlRG93bigpIHtcbiAgICAgICAgICAgICAgX2FwaS5QYWdlLmNyZWF0ZSgoMCwgX2V4dGVuZHMzLmRlZmF1bHQpKHt9LCBibGFuaywge1xuICAgICAgICAgICAgICAgIHZhbHVlczogKDAsIF9rZXlzMi5kZWZhdWx0KSh2YWx1ZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlc1trZXldIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICdjcmVhdGUgcGFnZSdcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2gxJyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHZhbHVlcy50aXRsZVxuICAgICAgICApLFxuICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAncCcsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2YWx1ZXMuYWJzdHJhY3RcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3AnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdmFsdWVzLnRlbFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19fcmVhY3RzdGFuZGluX19yZWdlbmVyYXRlQnlFdmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX19yZWFjdHN0YW5kaW5fX3JlZ2VuZXJhdGVCeUV2YWwoa2V5LCBjb2RlKSB7XG4gICAgICB0aGlzW2tleV0gPSBldmFsKGNvZGUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnZ2V0SW5pdGlhbFByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IzLmRlZmF1bHQpKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yMi5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm9wcykge1xuICAgICAgICB2YXIgZGF0YSwgcGFyc2VkO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yMi5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb3BzJywgcHJvcHMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfYXBpLlRlbXBsYXRlLmNyZWF0ZShibGFuayk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmpzb24oKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB7XG4gICAgICAgICAgICAgICAgICB0ZXN0OiBwYXJzZWRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRJbml0aWFsUHJvcHMoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldEluaXRpYWxQcm9wcztcbiAgICB9KCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH1dKTtcbiAgcmV0dXJuIEJsYW5rO1xufShfcmVhY3QuQ29tcG9uZW50KSwgX2NsYXNzMi5wcm9wVHlwZXMgPSB7XG4gIHZhbHVlczogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZWRpdDogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxcbiAgcmVtb3RlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkXG59LCBfdGVtcCkpIHx8IF9jbGFzcyk7XG52YXIgX2RlZmF1bHQgPSBCbGFuaztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgcmVhY3RIb3RMb2FkZXIgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykuZGVmYXVsdDtcblxuICB2YXIgbGVhdmVNb2R1bGUgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykubGVhdmVNb2R1bGU7XG5cbiAgaWYgKCFyZWFjdEhvdExvYWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGJsYW5rLCAnYmxhbmsnLCAnL1VzZXJzL20zMDAwL3JlcG9zL3JldGhpbmstZHJhZnRqcy9mcm9udGVuZC9zcmMvY29tcG9uZW50cy9CbGFuay5qcycpO1xuICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihCbGFuaywgJ0JsYW5rJywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvQmxhbmsuanMnKTtcbiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoX2RlZmF1bHQsICdkZWZhdWx0JywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvQmxhbmsuanMnKTtcbiAgbGVhdmVNb2R1bGUobW9kdWxlKTtcbn0pKCk7XG5cbjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkVkaXRDb250ZXh0ID0gZXhwb3J0cy5lZGl0ID0gdW5kZWZpbmVkO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBlbnRlck1vZHVsZSA9IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKS5lbnRlck1vZHVsZTtcblxuICBlbnRlck1vZHVsZSAmJiBlbnRlck1vZHVsZShtb2R1bGUpO1xufSkoKTtcblxudmFyIGVkaXQgPSBleHBvcnRzLmVkaXQgPSBmdW5jdGlvbiBlZGl0KCkge1xuICB2YXIgaXNTZXJ2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB2YXIgc25hcHNob3QgPSBhcmd1bWVudHNbMV07XG5cbiAgdmFyIGluaXRpYWxBY3Rpb25zID0gW107XG4gIGlmIChzbmFwc2hvdCkge1xuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGluaXRpYWxBY3Rpb25zOiBpbml0aWFsQWN0aW9ucyxcbiAgICBpc1NlcnZlcjogaXNTZXJ2ZXIsXG4gICAgYWRkQWN0aW9uOiBmdW5jdGlvbiBhZGRBY3Rpb24oYWN0aW9uKSB7XG4gICAgICBpbml0aWFsQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgfSxcbiAgICBpbml0czoge31cbiAgfTtcbn07XG5cbnZhciBFZGl0Q29udGV4dCA9IGV4cG9ydHMuRWRpdENvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ29udGV4dChlZGl0KCkpO1xuO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgcmVhY3RIb3RMb2FkZXIgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykuZGVmYXVsdDtcblxuICB2YXIgbGVhdmVNb2R1bGUgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykubGVhdmVNb2R1bGU7XG5cbiAgaWYgKCFyZWFjdEhvdExvYWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGVkaXQsICdlZGl0JywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvRWRpdENvbnRleHQuanMnKTtcbiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoRWRpdENvbnRleHQsICdFZGl0Q29udGV4dCcsICcvVXNlcnMvbTMwMDAvcmVwb3MvcmV0aGluay1kcmFmdGpzL2Zyb250ZW5kL3NyYy9jb21wb25lbnRzL0VkaXRDb250ZXh0LmpzJyk7XG4gIGxlYXZlTW9kdWxlKG1vZHVsZSk7XG59KSgpO1xuXG47IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cbnZhciBfaW5oZXJpdHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG5cbnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2FwaSA9IHJlcXVpcmUoJy4uL2FwaScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgZW50ZXJNb2R1bGUgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykuZW50ZXJNb2R1bGU7XG5cbiAgZW50ZXJNb2R1bGUgJiYgZW50ZXJNb2R1bGUobW9kdWxlKTtcbn0pKCk7XG5cbnZhciBQYWdlTGlzdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFBhZ2VMaXN0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQYWdlTGlzdCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBQYWdlTGlzdCk7XG5cbiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChQYWdlTGlzdC5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoUGFnZUxpc3QpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgcGFnZXM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShQYWdlTGlzdCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIF9hcGkuUGFnZS5nZXRBbGwoKS50aGVuKGZ1bmN0aW9uIChwYWdlcykge1xuICAgICAgICByZXR1cm4gcGFnZXMuanNvbigpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocGFnZXMpIHtcbiAgICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgICBwYWdlczogcGFnZXMucGFnZXNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcGFnZXMgPSB0aGlzLnN0YXRlLnBhZ2VzO1xuXG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBudWxsLFxuICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnaHInLCBudWxsKSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3VsJyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhZ2VzLm1hcChmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICB7IGtleTogcGFnZS5pZCB9LFxuICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnaDInLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgcGFnZS50aXRsZSxcbiAgICAgICAgICAgICAgICAnICgnLFxuICAgICAgICAgICAgICAgIHBhZ2UudHlwZSB8fCBwYWdlLm5hbWUsXG4gICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfX3JlYWN0c3RhbmRpbl9fcmVnZW5lcmF0ZUJ5RXZhbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9fcmVhY3RzdGFuZGluX19yZWdlbmVyYXRlQnlFdmFsKGtleSwgY29kZSkge1xuICAgICAgdGhpc1trZXldID0gZXZhbChjb2RlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBhZ2VMaXN0O1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxudmFyIF9kZWZhdWx0ID0gUGFnZUxpc3Q7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbjtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlYWN0SG90TG9hZGVyID0gcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpLmRlZmF1bHQ7XG5cbiAgdmFyIGxlYXZlTW9kdWxlID0gcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpLmxlYXZlTW9kdWxlO1xuXG4gIGlmICghcmVhY3RIb3RMb2FkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihQYWdlTGlzdCwgJ1BhZ2VMaXN0JywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvUGFnZUxpc3QuanMnKTtcbiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoX2RlZmF1bHQsICdkZWZhdWx0JywgJy9Vc2Vycy9tMzAwMC9yZXBvcy9yZXRoaW5rLWRyYWZ0anMvZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvUGFnZUxpc3QuanMnKTtcbiAgbGVhdmVNb2R1bGUobW9kdWxlKTtcbn0pKCk7XG5cbjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5Jyk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkyKTtcblxudmFyIF9leHRlbmRzMyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG5cbnZhciBfZXh0ZW5kczQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmRzMyk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB0ZW1wbGF0ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9hcGkgPSByZXF1aXJlKCcuLi9hcGknKTtcblxudmFyIF9FZGl0Q29udGV4dCA9IHJlcXVpcmUoJy4vRWRpdENvbnRleHQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudGVyTW9kdWxlID0gcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpLmVudGVyTW9kdWxlO1xuXG4gIGVudGVyTW9kdWxlICYmIGVudGVyTW9kdWxlKG1vZHVsZSk7XG59KSgpO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShkYXRhLCBfcmVmKSB7XG4gIHZhciBfcmVmJHJlY2VpdmVVcGRhdGVzID0gX3JlZi5yZWNlaXZlVXBkYXRlcyxcbiAgICAgIHJlY2VpdmVVcGRhdGVzID0gX3JlZiRyZWNlaXZlVXBkYXRlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkcmVjZWl2ZVVwZGF0ZXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChXcmFwcGVkKSB7XG4gICAgdmFyIF9jbGFzcywgX3RlbXA7XG5cbiAgICB2YXIgbmFtZSA9IFdyYXBwZWQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZC5uYW1lO1xuICAgIHZhciBUZW1wbGF0ZSA9IChfdGVtcCA9IF9jbGFzcyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShUZW1wbGF0ZSwgX0NvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlKHByb3BzKSB7XG4gICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFRlbXBsYXRlKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChUZW1wbGF0ZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoVGVtcGxhdGUpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX2FwaS5UZW1wbGF0ZS51cGRhdGUoKDAsIF9leHRlbmRzNC5kZWZhdWx0KSh7fSwgZGF0YSwge1xuICAgICAgICAgICAgaWQ6IF90aGlzLnN0YXRlLmlkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZW1vdGUgPSBudWxsO1xuICAgICAgICBpZiAoV3JhcHBlZC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgICBpZiAoIXByb3BzLmVkaXQuaW5pdHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHByb3BzLmVkaXQuaW5pdHNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGluaXQ6IFdyYXBwZWQuZ2V0SW5pdGlhbFByb3BzKHByb3BzKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCdnZXRJbml0aWFsUHJvcHMgRXJyb3I6JywgZXJyKTtcbiAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHByb3BzLmVkaXQuaW5pdHNbbmFtZV0uZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuZWRpdC5pbml0c1tuYW1lXS5kYXRhKSB7XG4gICAgICAgICAgICAgIHJlbW90ZSA9IHByb3BzLmVkaXQuaW5pdHNbbmFtZV0uZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICBoYXNDaGFuZ2VzOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZXM6IGRhdGEudmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9leHRlbmRzNC5kZWZhdWx0KSh7fSwgYWNjLCAoMCwgX2RlZmluZVByb3BlcnR5My5kZWZhdWx0KSh7fSwgdi5rZXksIHYudmFsdWUpKTtcbiAgICAgICAgICB9LCB7fSksXG4gICAgICAgICAgcmVtb3RlOiByZW1vdGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShUZW1wbGF0ZSwgW3tcbiAgICAgICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgICB2YXIgZWRpdCA9IHRoaXMucHJvcHMuZWRpdDtcbiAgICAgICAgICAvLyBjb25zdCBhY3Rpb24gPSB0ZW1wbGF0ZUFwaS5jcmVhdGUoZGF0YSkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgLy8gICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAvLyAgIGlmICghcmVjZWl2ZVVwZGF0ZXMpIHJldHVybjtcbiAgICAgICAgICAvLyAgIGNvbnN0IHtcbiAgICAgICAgICAvLyAgICAgdGVtcGxhdGU6IHJlc1RlbXBsYXRlLFxuICAgICAgICAgIC8vICAgICBoYXNDaGFuZ2VzLFxuICAgICAgICAgIC8vICAgfSA9IGpzb247XG4gICAgICAgICAgLy8gICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAvLyAgICAgaWQ6IHJlc1RlbXBsYXRlLmlkLFxuICAgICAgICAgIC8vICAgICB2YWx1ZXM6IHJlc1RlbXBsYXRlLnZhbHVlcy5yZWR1Y2UoKGFjYywgdikgPT4gKHsgLi4uYWNjLCBbdi5rZXldOiB2LnZhbHVlIH0pLCB7fSksXG4gICAgICAgICAgLy8gICAgIGhhc0NoYW5nZXMsXG4gICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAvLyBlZGl0LmFkZEFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgdmFyIGhhc0NoYW5nZXMgPSB0aGlzLnN0YXRlLmhhc0NoYW5nZXM7XG5cbiAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBoYXNDaGFuZ2VzICYmIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgJ1RoZSByZW1vdGUgdmVyc2lvbiBvZiB0aGlzIHRlbXBsYXRlIGRvZXNuXFwndCBtYXRjaC4gWW91IGNhbiBzeW5jIHRoZSByZW1vdGUgd2l0aCB5b3VyIGxvY2FsIHZlcnNpb24uICcsXG4gICAgICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICB7IGhyZWY6ICcjJyB9LFxuICAgICAgICAgICAgICAgICdtb3JlIGluZm9ybWF0aW9uJ1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAnXFx4QTAnLFxuICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgICB7IG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZVVwZGF0ZSB9LFxuICAgICAgICAgICAgICAgICdVcGRhdGUgVGVtcGxhdGUnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkLCAoMCwgX2V4dGVuZHM0LmRlZmF1bHQpKHt9LCB0aGlzLnByb3BzLCB0aGlzLnN0YXRlKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19fcmVhY3RzdGFuZGluX19yZWdlbmVyYXRlQnlFdmFsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9fcmVhY3RzdGFuZGluX19yZWdlbmVyYXRlQnlFdmFsKGtleSwgY29kZSkge1xuICAgICAgICAgIHRoaXNba2V5XSA9IGV2YWwoY29kZSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHJldHVybiBUZW1wbGF0ZTtcbiAgICB9KF9yZWFjdC5Db21wb25lbnQpLCBfY2xhc3MucHJvcFR5cGVzID0ge1xuICAgICAgZWRpdDogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZFxuICAgIH0sIF90ZW1wKTtcblxuXG4gICAgVGVtcGxhdGUuZGlzcGxheU5hbWUgPSAnVGVtcGxhdGUoJyArIG5hbWUgKyAnKSc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBfRWRpdENvbnRleHQuRWRpdENvbnRleHQuQ29uc3VtZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGZ1bmN0aW9uIChlZGl0KSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRlbXBsYXRlLCAoMCwgX2V4dGVuZHM0LmRlZmF1bHQpKHt9LCBwcm9wcywgeyBlZGl0OiBlZGl0IH0pKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICB9O1xufVxuO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgcmVhY3RIb3RMb2FkZXIgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykuZGVmYXVsdDtcblxuICB2YXIgbGVhdmVNb2R1bGUgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykubGVhdmVNb2R1bGU7XG5cbiAgaWYgKCFyZWFjdEhvdExvYWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKHRlbXBsYXRlLCAndGVtcGxhdGUnLCAnL1VzZXJzL20zMDAwL3JlcG9zL3JldGhpbmstZHJhZnRqcy9mcm9udGVuZC9zcmMvY29tcG9uZW50cy90ZW1wbGF0ZS5qcycpO1xuICBsZWF2ZU1vZHVsZShtb2R1bGUpO1xufSkoKTtcblxuOyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aHRtbD5cXG4gIDxoZWFkPlxcbiAgICA8dGl0bGU+U1NSMzAwMCBBcHA8L3RpdGxlPlxcbiAgPC9oZWFkPlxcbiAgPGJvZHk+XFxuICAgIDxkaXYgaWQ9XFxcInJvb3RcXFwiPjwlPSBhcHAgJT48L2Rpdj5cXG4gICAgPHNjcmlwdD53aW5kb3cuU05BUFNIT1QgPSA8JT0gSlNPTi5zdHJpbmdpZnkoc25hcHNob3QpICU+Ozwvc2NyaXB0PlxcbiAgICA8JSBjaHVua3MuanMuZm9yRWFjaCgoY2h1bmspID0+IHsgJT48c2NyaXB0IHNyYz1cXFwiPCU9IGNodW5rICU+XFxcIj48L3NjcmlwdD48JSB9KTsgJT5cXG4gIDwvYm9keT5cXG48L2h0bWw+XCIiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlJyk7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxudmFyIF9rZXlzID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzJyk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3InKTtcblxudmFyIF9yZWdlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWdlbmVyYXRvcik7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcicpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNUb0dlbmVyYXRvcjIpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfc2VydmVyID0gcmVxdWlyZSgncmVhY3QtZG9tL3NlcnZlcicpO1xuXG52YXIgX2V4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XG5cbnZhciBfbG9kYXNoID0gcmVxdWlyZSgnbG9kYXNoLnRlbXBsYXRlJyk7XG5cbnZhciBfbG9kYXNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaCk7XG5cbnZhciBfcmV0aGlua0RyYWZ0SnMgPSByZXF1aXJlKCdyZXRoaW5rLWRyYWZ0LWpzJyk7XG5cbnZhciBfcmV0aGlua0RyYWZ0SnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmV0aGlua0RyYWZ0SnMpO1xuXG52YXIgX2luZGV4ID0gcmVxdWlyZSgnLi9pbmRleC5lanMnKTtcblxudmFyIF9pbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmRleCk7XG5cbnZhciBfQXBwID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9BcHAnKTtcblxudmFyIF9BcHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBwKTtcblxudmFyIF9FZGl0Q29udGV4dCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvRWRpdENvbnRleHQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudGVyTW9kdWxlID0gcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpLmVudGVyTW9kdWxlO1xuXG4gIGVudGVyTW9kdWxlICYmIGVudGVyTW9kdWxlKG1vZHVsZSk7XG59KSgpO1xuXG52YXIgY2xlYXJSZXF1aXJlID0gcmVxdWlyZSgnY2xlYXItcmVxdWlyZScpO1xuXG52YXIgdGVtcGxhdGUgPSAoMCwgX2xvZGFzaDIuZGVmYXVsdCkoX2luZGV4Mi5kZWZhdWx0KTtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoY2h1bmtzKSB7XG4gIHZhciByb3V0ZXIgPSBuZXcgX2V4cHJlc3MuUm91dGVyKCk7XG4gIHJvdXRlci51c2UoJy9mYXZpY29uLmljbycsIGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICAgIHJlcy5zdGF0dXMoMjAwKS5zZW5kKCdsb2wnKTtcbiAgfSk7XG4gIHJvdXRlci51c2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMy5kZWZhdWx0KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxLCByZXMsIG5leHQpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IyLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy9jb25zdCByZXRoaW5rID0gcmVxdWlyZSgncmV0aGluay1kcmFmdC1qcycpO1xuICAgICAgICAgICAgICAoMCwgX3JldGhpbmtEcmFmdEpzMi5kZWZhdWx0KSgpKHJlcSwgcmVzLCBuZXh0KTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIHVuZGVmaW5lZCk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyLCBfeDMpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpKTtcbiAgcm91dGVyLnVzZShmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgICB2YXIgZWRpdEluc3RhbmNlID0gKDAsIF9FZGl0Q29udGV4dC5lZGl0KSh0cnVlKTtcblxuICAgICgwLCBfc2VydmVyLnJlbmRlclRvU3RyaW5nKShfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfQXBwMi5kZWZhdWx0LCB7IGVkaXQ6IGVkaXRJbnN0YW5jZSB9KSk7XG4gICAgLy9jb25zb2xlLmxvZygnYXBwIHJlbmRlcmVkJywgZWRpdEluc3RhbmNlKTtcbiAgICB2YXIgYWxsID0gKDAsIF9rZXlzMi5kZWZhdWx0KShlZGl0SW5zdGFuY2UuaW5pdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZWRpdEluc3RhbmNlLmluaXRzW2tleV0uaW5pdDtcbiAgICB9KTtcbiAgICBfcHJvbWlzZTIuZGVmYXVsdC5hbGwoYWxsKS50aGVuKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICByZXMuc3RhdHVzKDIwMCkuc2VuZCh0ZW1wbGF0ZSh7XG4gICAgICAgIGNodW5rczogY2h1bmtzLFxuICAgICAgICBhcHA6ICgwLCBfc2VydmVyLnJlbmRlclRvU3RyaW5nKShfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfQXBwMi5kZWZhdWx0LCB7IGVkaXQ6IGVkaXRJbnN0YW5jZSB9KSksXG4gICAgICAgIHNuYXBzaG90OiBlZGl0SW5zdGFuY2VcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnc2VuZCByZXNwb25zZScpO1xuICB9KTtcbiAgcmV0dXJuIHJvdXRlcjtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgcmVhY3RIb3RMb2FkZXIgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykuZGVmYXVsdDtcblxuICB2YXIgbGVhdmVNb2R1bGUgPSByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykubGVhdmVNb2R1bGU7XG5cbiAgaWYgKCFyZWFjdEhvdExvYWRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKHRlbXBsYXRlLCAndGVtcGxhdGUnLCAnL1VzZXJzL20zMDAwL3JlcG9zL3JldGhpbmstZHJhZnRqcy9mcm9udGVuZC9zcmMvc2VydmVyTWlkZGxld2FyZS9pbmRleC5qcycpO1xuICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihfZGVmYXVsdCwgJ2RlZmF1bHQnLCAnL1VzZXJzL20zMDAwL3JlcG9zL3JldGhpbmstZHJhZnRqcy9mcm9udGVuZC9zcmMvc2VydmVyTWlkZGxld2FyZS9pbmRleC5qcycpO1xuICBsZWF2ZU1vZHVsZShtb2R1bGUpO1xufSkoKTtcblxuOyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3T0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDalpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDclpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoeURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDanFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcnRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hNQTs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBIiwic291cmNlUm9vdCI6IiJ9